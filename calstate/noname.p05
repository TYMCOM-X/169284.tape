BASE 0

!PROCEDURES
GLOBAL %NONAME
FIND %INITTTY,%HASH,%QUERY,%GETNUM,%GETOCT,%GETTOKEN,%LISTABLE
FIND %CHR.OUT,%OCTWD.OUT,%OCTOUT,%OUT,%NUMOUT,%SIXOUT,%MAKE.SIXBIT
FIND %CHOOSE,%DATOUT,%SHORT.OUT,%SPOUT
LOCAL %CHK.IO.ERR,%CHECK.CHG,%HEADING
LOCAL %DUL.LOOK,%DUL.OVERFLOW
LOCAL %OPEN.DUL,%OPEN.LUD,%MAKE.ROOM,%KNOW.ACCT
LOCAL %LUD.LOOK,%LUD.SEQ,%LIST.RECORD,%LUD.OVERFLOW
LOCAL %CHANGEIT,%INITNONAME

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)
LOCAL THISPPN,THISACCT,THISDIST,THISLIC
GLOBAL NUMBER,NAME.HASH,LOC.HASH,P,GETCMD:,CH.OUT
GLOBAL USER(2),LISTFLG,ALTTYP
LOCAL SAVORG(SIZE.BLK),OLDBLK,STATUS
LOCAL CH.LUD,CH.DUL,IO.ADR,CMD,LIST,MODE,ZONE
LOCAL D.INDEX,D.BLK(SIZE.BLK)
LOCAL L.INDEX,L.BLK(SIZE.BLK)
LOCAL LUD.SIZE,TEMP



!COMMANDS
DEF CMD.LIST AS 1
DEF CMD.CHANGE AS 2
DEF CMD.ENDIT AS 3
DEF CMD.HELP AS 4
DEF CMD.INSTR AS 5


!FLAGS IN LISTFLG
DEF USER.LST AS 1
DEF ACCT.LST AS 2
DEF CHANGE AS 4
DEF DIST.LST AS 3
DEF ALL.SET AS -1

!CHANGES TO BE MADE
DEF MIN.CHG AS CH.LIC
DEF MAX.CHG AS CH.MODE
DEF CH.LIC AS 4
DEF CH.MSG AS 5
DEF CH.INIT AS 6
DEF CH.ZONE AS 7
DEF CH.DET AS 8
DEF CH.MODE AS 9

!FLAGS IN STATUS
DEF NO.CHG AS 0
DEF OLD.OUT AS 1	!OLD BLK WAS WRITTEN OUT...WITHOUT THIS USER

! SIZE OF TABLES
DEF N.CMDS AS 5	!NUMBER OF PRIMARY COMMANDS
DEF N.LISTS AS 3 !NUMBER OF LIST COMMANDS
DEF N.MODES AS 4	!NUMBER OF MODES
DEF N.ZONES AS 17 	!NUMBER OF TIME ZONES

!TABLES
GLOBAL TABLE CMDS(1:N.CMDS)['LIST','CHANGE','QUIT','HELP','INSTRUCTIONS']
GLOBAL TABLE LISTS(1:N.LISTS)['USER','ACCOUNT','DISTRICT']
GLOBAL TABLE MODES(1:N.MODES)['PDP10','TYMEX','GE','SUDS']
GLOBAL TABLE ZONES(1:N.ZONES)[7(-1),'PACIFIC','MOUNTAIN','CENTRAL',&
	'EASTERN',5(-1),'PARIS']

!MACRO'S
DEF ACTSUP.BIT AS BYT(LUD(3),1,13)
DEF BIG AS (LISTFLG = ACCT.LST OR LISTFLG = DIST.LST)
DEF LITTLE AS NOT(BIG)
DEF COLON AS CHR.OUT($:)
DEF CHECK.NO.MORE.IN(A) AS [IF NCHV P=EOLIT THEN A; PCHV P]
DEF CHG.LEGAL AS MIN.CHG<=NUMBER<=MAX.CHG
DEF LUD.TEMP(A) AS LUD(TEMP.INDEX+A)
DEF CR AS CHR.OUT(CARRET)
DEF DASH AS CHR.OUT($-)
DEF ENTER.NAME AS '$ENTER USER NAME: '
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF LUD.WRIT AS [KEEP.CP; WB(CH.LUD,SIZE.BLK,L.BLK)]
DEF DAYLIG.BIT AS BYT(LUD(3),1,33)
DEF DETACH.BIT AS BYT(LUD(3),1,15)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF DISTOUT AS [SPOUT(DIST.BITS,6); NUMOUT(DIST.BITS)]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF GETNAME(A) AS [CHECK.NO.MORE.IN(A);GETTOKEN(2);MAKE.SIXBIT(TOKEN,USER,12)]
DEF INIT.BIT AS BYT(LUD(2),1,8)
DEF INIT.LONG.LIST AS [HEADING; SETCP(CH.LUD,FIXCP(1)); LUD.SEQ]
DEF KEEP.CP AS [TEMP _ CP(CH.LUD); TEMP-_SIZE.BLK; SETCP(CH.LUD,TEMP)]
DEF LEGAL AS (THISDIST = 0 OR (THISLIC = 1 AND SAMACCT) OR SAMUSR)
DEF MODE.BIT AS BYT(LUD(3),2,7)
DEF MOVE.DOWN AS [FOR TEMP _ 5 TO 7 LUD(TEMP+3) _ LUD(TEMP)]
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NAMOUT AS SIXOUT(@DUL(1),12)
DEF NOT.VALID AS [MSG('$NOT A VALID USER.$');CLOSE.ALL;GO GETCMD]
DEF OV.BLK AS HW(@LUD(0),1)
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF PROT.FAILURE AS [MSG('$NOT YOUR GLOBAL ACCOUNT$$');GO GETCMD]
DEF SAMACCT AS THISACCT = HW(@LUD(0),0)
DEF SAMUSR AS THISPPN = LUD(0)
DEF SIZE.INC AS SIZE.LUD.ENT _ SIZE.LUD.ENT + 3
DEF SIZE.DEC AS SIZE.LUD.ENT _ SIZE.LUD.ENT - 3
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF SUPMSG.BIT AS BYT(LUD(2),1,34)
DEF TYM.BIT AS BYT(LUD(3),1,14)
DEF TYPSPACE(A) AS [REPEAT A SP]
DEF USER.MISSING AS [PPN.OUT; OUT(' MISSING FROM DUL.$'); RETURN]
DEF VERSION AS 5
DEF WHAT AS [MSG('?$'); GO GETCMD]
DEF ZONE.BIT AS BYT(LUD(3),5,28)


!LABELS
LOCAL LUD.ERR:,CHK.ERR:
%NONAME
	!MAINLINE
LOCAL ENDLUD:
START: IOCS(2); INITNONAME
\\->START
GETCMD: STATUS _ NO.CHG; IO.ADR _ 0; CLOSE.ALL
	 CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
	CR; PUT($:); P _ GETLINE(TEL); GETTOKEN(0)
	IF CMD _ CHOOSE(N.CMDS,CMDS) = 0 THEN WHAT
	OPEN.LUD; OPEN.DUL

DO CMD OF 1:N.CMDS

CMD.LIST: CHECK.NO.MORE.IN([LISTABLE(N.LISTS,LISTS); COLON])
    GETTOKEN(0)
    WHILE LIST _ CHOOSE(N.LISTS,LISTS) = 0 THEN[CR;LISTABLE(N.LISTS,LISTS); COLON;&
	GETTOKEN(0)]
	IO.ADR _ ENDLUD
	DO LIST OF 1:N.LISTS

	USER.LST: LISTFLG _ USER.LST; GETNAME(MSG(ENTER.NAME))
	   IF LUD.LOOK(USER) = 0 THEN NOT.VALID
	   IF LEGAL THEN LIST.RECORD(ALL.SET) ELSE PROT.FAILURE

	ACCT.LST:  LISTFLG _ ACCT.LST
	    IF THISDIST = 0 THEN DO
		IF KNOW.ACCT=1 THEN [CHECK.NO.MORE.IN(MSG('$ACCOUNT: '));&
			GETOCT]
	    END  ELSE NUMBER _ THISACCT
	   INIT.LONG.LIST
	      LOOP DO
		IF LEGAL AND NUMBER =HW(@LUD(0),0) THEN LIST.RECORD(ALL.SET)
		LUD.SEQ
	   END

	DIST.LST: LISTFLG _ DIST.LST
	   IF THISDIST=0 THEN [CHECK.NO.MORE.IN(MSG('$DISTRICT: '));&
		GETNUM] ELSE NUMBER _ THISDIST
	   INIT.LONG.LIST
	   LOOP DO
		IF LEGAL AND NUMBER=DIST.BITS THEN LIST.RECORD(ALL.SET)
		LUD.SEQ
	   END
	END

CMD.CHANGE:GETNAME(MSG(ENTER.NAME))
	IF LUD.LOOK(USER) = 0 THEN NOT.VALID
	IF NOT(LEGAL) THEN PROT.FAILURE
	LISTFLG _ CHANGE; LIST.RECORD(ALL.SET)
LOOP DO
	STATUS _ NO.CHG
	MOVE SIZE.BLK FROM @LBLK(0) TO @SAVORG(0)	!SAVE OLD ENTRY
	MSG('$CHANGE WHICH ITEM - TYPE NUMBER:  ');GETNUM; CR
	IF CHG.LEGAL THEN DO
	  CHANGEIT(NUMBER)
	  IF CHECK.CHG(NUMBER)=1 THEN [LUD.WRIT;MSG('$CHANGE COMPLETED.$')]
	  [IF QUERY('ANOTHER') = 0 THEN GO ENDLUD ELSE &
	  [CLOSE.ALL; OPEN.LUD; OPEN.DUL; LUD.LOOK(USER)]]
	END ELSE MSG('ILLEGAL NUMBER.$')
END

CMD.ENDIT: CLOSE.ALL; MSG('$E.O.J.$'); EXIT

CMD.HELP: MSG('LEGAL COMMANDS ARE:$')
   LISTABLE(N.CMDS,CMDS); MSG('.$')

CMD.INSTR: MSG('$$$GENERAL INFORMATION$$')
MSG('	EACH TYMSHARE COMPUTER SYSTEM HAS A LOCAL USER DIRECTORY')
MSG('$CALLED THE LUD.  THIS USER DIRECTORY IS USED BY THE MONITOR')
MSG('$TO KEEP TRACK OF USERS ON THAT SYSTEM.')
MSG('$$	A USER MAY BE PROMPTED OR MAY TYPE AN ENTIRE COMMAND')
MSG('$WITH NO PROMPTING.  FOR EXAMPLE THE USER MAY TYPE:')
MSG('$		LIST USER ABCD')
MSG('$OR HE MAY TYPE 1 WORD AT A TIME AND THE PROGRAM WILL ASK FOR THE')
MSG('$NEXT.')
MSG('$$	NORMALLY THE PROGRAM WILL REPEAT A QUESTION IF AN INVALID')
MSG('$REPLY IS GIVEN.  AS IT IS POSSIBLE THE CALLER MAY BE FACED BY')
MSG('$A QUESTION HE DOES NOT KNOW THE ANSWER TO, HE CAN FORCE THE')
MSG('$PROGRAM BACK TO THE COMMAND DISPATCHER BY ENTERING A QUESTION')
MSG('$MARK AS A REPLY TO ANY YES OR NO QUESTION OR WHENEVER THE')
MSG('$PROGRAM IS REQUESTING A USER NAME.')
MSG('$$$HELP$$')
MSG('	THIS COMMAND OUTPUTS ALL VALID COMMANDS OF THE PROGRAM')
MSG('$TO THE TELETYPE.')
MSG('$$$INSTRUCTIONS$$')
MSG('	THIS COMMAND PROVIDES DETAILED INSTRUCTIONS FOR ALL COMMANDS.')
MSG('$$$LIST USER$$	THIS COMMAND IS USED TO OBTAIN INFORMATION')
MSG('$ABOUT A SPECIFIED USER.$A SAMPLE DIALOGUE:$$')
MSG(':LIST USER$$ENTER USER NAME: JONES')
MSG('$$1. USER NAME: JONES$2. DISTRICT: 63')
MSG('$3. GLOBAL ACCOUNT: 12345$UNIVERSAL USER NO.: 65432')
MSG('$4. LICENSE: ACT.SUP.$5. SUPRESS TYMSHARE MESSAGE AT LOGIN.')
MSG('$6. NO INIT FILE.$7. TIME ZONE NOT SET.')
MSG('$8. DETACH ON DISCONNECT.$9. TYMEX MODE.')
MSG('$10. STRUCTURE: DSKB$QUOTA IN: 10000$QUOTA OUT: 10000')
MSG('$$$LIST ACCOUNT$	THIS COMMAND WILL MAKE A LISTING OF ALL ENTRIES')
MSG('$IN A GLOBAL ACCOUNT, EITHER TO THE TELETYPE OR A FILE.')
MSG('$A SAMPLE DIALOGUE:')
MSG('$$:LIST ACCOUNT$$OUTPUT TO: TEL')
MSG('$$7-22-72  14:32$$GLOBAL ACCOUNT: 1234')
MSG('$$USER           DIST   UUN      LICENSE         MSG INIT FILE')
MSG('$                   ZONE     DISC            MODE   STR    Q-IN   Q-OUT')
MSG('$$JONES             3   234567        ACT.SUP.   SUP')
MSG('$JONES            NOT SET    LOG             TYMEX  DSKB   10000   10000')
MSG('$SMITHY            5   112234                   TYP')
MSG('$SMITHY           PACIF-D    DET             PDP10  DSKB   30000   30000')
MSG('$JOHNSON           3   445675                   TYP (USERNAME    )FILE')
MSG('$JOHNSON          CENTR-S    DET             GE      DSKB   50000   50000')
MSG('$$SOME EXPLANATION:')
MSG('$LICENSE - ACT.SUP. = ACCOUNT SUPERVISOR')
MSG('$          TYM. = TYMSHARE')
MSG('$MSG - WHAT IS DONE WITH TYMSHARE MESSAGE AT LOGIN.')
MSG('$	SUP=SUPRESS MESSAGE$	TYP=TYPE MESSAGE')
MSG('$ZONE - TIME ZONE$	D=DAYLIGHT SAVINGS$	S=STANDARD')
MSG('$DISC - WHAT IS DONE IF THE TELEPHONE LINE DISCONNECTS.')
MSG('$	LOG=LOGOUT JOB$	DET=DETACH JOB')
MSG('$MODE - THE MODE THE USER RUNS UNDER$$$LIST DISTRICT')
MSG('$	THIS COMMAND WILL MAKE A LISTING OF ALL ENTRIES IN A GLOBAL')
MSG('$ACCOUNT IN A DISTRICT.')
MSG('$	THE OUTPUT IS SIMILAR TO THAT OF LIST ACCOUNT.')
MSG('$$$CHANGE USER$	THE COMMAND IS USED TO:')
MSG('$DECREASE LICENSE, CHANGE WHAT IS DONE WITH THE TYMSHARE MESSAGE')
MSG('$AT LOGIN TIME, SET AN INIT FILE, CHANGE A USERS TIME ZONE,')
MSG('$CHANGE A USERS MODE, CHANGE WHAT IS DONE ON A DISCONNECT.')
MSG('$A SAMPLE DIALOGUE:')
MSG('$$:CHANGE JONES$$USER NAME: JONES')
MSG('$4. LICENSE: ACT.SUP.$5. SUPRESS TYMSHARE MESSAGE AT LOGIN.')
MSG('$6. NO INIT FILE.$7. TIME ZONE NOT SET.')
MSG('$8. DETACH ON DISCONNECT.$9. MODE: PDP10')
MSG('$$CHANGE WHICH ITEM - TYPE NUMBER: 5')
MSG('$$SUPRESS TYMSHARE MESSAGE AT LOGIN? NO')
MSG('$$5. DO NOT SUPRESS TYMSHARE MESSAGE AT LOGIN.')
MSG('$$OKAY? YES$CHANGE COMPLETED.$ANOTHER? NO')
MSG('$$$QUIT$$	THIS COMMAND IS USED TO EXIT ')
MSG('$FROM THE PROGRAM.  ALTMODES MAY BE USED TO RETURN TO COMMAND MODE.$$')

END
ENDLUD:  LISTFLG _ 0;  GO GETCMD

ALTTYP: IF STATUS = NO.CHG THEN [CLOSE.ALL; GO GETCMD]
	MOVE SIZE.BLK FROM @SAVORG(0) TO @LBLK(0)
	SETCP(CH.LUD,FIXCP(OLDBLK)); WB(CH.LUD,SIZE.BLK,L.BLK)
	CLOSE.ALL; GO GETCMD




%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
LOOP DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)<0 THEN LUD.OVERFLOW
	WHILE LUD(0)=0 THEN LUD.READ
	IF LUD(4) # 0 THEN RETURN
END
END LUD.SEQ


%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
OLDBLK _ LOC.HASH
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK(PPN)
	!LOOK UP PPN IN DUL
SETCP(CH.DUL,FIXCP((PPN MOD 101)+1)); DUL.READ
WHILE DUL(0)#PPN THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK); OLDBLK _ OV.BLK
LUD.READ
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%INITNONAME
	!INIT PROGRAM
INITTTY(GETCMD)
CMD _ 0
MSG('$USER VALIDATION PROGRAM - VERSION '); NUMOUT(VERSION);MSG('$$$')
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THISPPN _ EXU(OCT 47,OCT 1,OCT 24); OPEN.DUL
THISACCT _ HW(@THISPPN,0)
IF DUL.LOOK(THISPPN) = 0 THEN [OCTWD.OUT(THISPPN); MSG(' NOT IN DUL');&
	EXIT]
OPEN.LUD; LUD.SIZE _ N.LUD.BLKS
IF LUD.LOOK(@DUL(1)) = 0 THEN [SIXOUT(DUL(1),12); MSG(' NOT IN LUD')&
	;EXIT]
THISDIST _ DIST.BITS
THISLIC _ ACTSUP.BIT
ALTLOC _ ALTTYP; OFFALT
 RETURN
END INITNONAME



%LIST.RECORD(LISTNUM)
	!LIST RECORD POINTED TO BY L.INDEX...LIST ONLY
	!ITEMS THAT CAN BE CHANGED IF USER WANTS TO CHANGE...LIST ONLY
	!SELECTIVE ITEMS IF ALL DIST OR ALL ACCT. REQUESTED
LOCAL TEMP.INDEX,FLG,I
IF LISTNUM=ALL.SET THEN [LISTNUM_1; FLG_1] ELSE FLG _ 0
TEMP.INDEX _ 0
IF DUL.LOOK(LUD(0)) = 0 THEN USER.MISSING
LOOP DO

	DO LISTNUM OF 1:10
1: IF LITTLE THEN DO
	CR
	IF LISTFLG#CHANGE THEN MSG('1. ')
	MSG('USER NAME: ')
END
NAMOUT

2: IF LISTFLG#CHANGE THEN DO
	IF LITTLE THEN MSG('$2. DISTRICT: ')
	IF BIG AND ((THISDIST=0 AND LISTFLG=ACCT.LST) OR THISDIST#0) THEN DO
			DISTOUT
			TYPSPACE(3)
	END ELSE IF LITTLE THEN DISTOUT
   END

3: IF LISTFLG#CHANGE THEN DO
	IF LITTLE THEN [MSG('$3. GLOBAL ACCOUNT: '); OCTOUT(HW(@LUD(0),0))]
	IF BIG AND LISTFLG=DIST.LST THEN OCTOUT(HW(@LUD(0),0))
	IF LITTLE THEN MSG('$UNIVERSAL USER NO.: ')
	OCTOUT(HW(@LUD(0),1)); TYPSPACE(3)
END

4: IF LITTLE THEN MSG('$4. LICENSE: ')
	IF LISTFLG # CHANGE THEN DO
		IF TYM.BIT = 1 THEN OUT('TYM. ') ELSE OUT('     ')
	END
	IF ACTSUP.BIT = 1 THEN OUT('ACT.SUP.') ELSE OUT('        ')
	IF BIG THEN TYPSPACE(3)

5: IF LITTLE THEN DO
	MSG('$5. '); IF SUPMSG.BIT = 0 THEN MSG('DO NOT ')
	MSG('SUPRESS TYMSHARE MESSAGE AT LOGIN.')
END ELSE DO
	IF SUPMSG.BIT=0 THEN OUT('TYP') ELSE OUT('SUP')
	SP
	END

6: IF LITTLE THEN MSG('$6. ')
	IF INIT.BIT = 1 THEN DO
		IF LITTLE THEN MSG('INIT FILE: ')
		TEMP.INDEX_3
		IF LUD(6)#0 OR LUD(7)#0 THEN [CHR.OUT($();&
			 SIXOUT(@LUD(6),12); CHR.OUT($))]
		 SIXOUT(@LUD(5),6)
	END ELSE IF LITTLE THEN MSG('NO INIT FILE.')
   IF BIG THEN [CR; NAMOUT; TYPSPACE(5)]

7: IF LITTLE THEN DO
	MSG('$7. ')
	IF ZONE.BIT#0 THEN [MSG(ZONES(ZONE.BIT)); MSG(' TIME ZONE.')]&
		ELSE MSG('TIME ZONE NOT SET.')

	END  ELSE DO
		IF ZONES(ZONE.BIT)=-1 OR ZONE.BIT=0  THEN [OUT('NOT SET'); TYPSPACE(4); GO STRTAGN ]
		TEMP_CHPT(ZONES(ZONE.BIT),-1)
		SHORT.OUT(TEMP,5)
	END
	IF BIG THEN DASH
	IF DAYLIG.BIT = 1 THEN DO
		IF LITTLE THEN MSG('$SUBJECT TO DAYLIGHT SAVINGS.')
		IF BIG THEN CHR.OUT($D)
	END ELSE IF BIG THEN CHR.OUT($S)
	IF BIG THEN TYPSPACE(4)

8: IF LITTLE THEN DO
	MSG('$8. ')
	IF DETACH.BIT = 1 THEN MSG('DETACH') ELSE MSG('LOGOUT')
	MSG(' ON DISCONNECT.')
END ELSE DO
	IF DETACH.BIT = 1 THEN OUT('DET') ELSE OUT('LOG')
	TYPSPACE(13)
END

9: IF LITTLE THEN [MSG('$9. MODE: '); MSG(MODES(MODE.BIT+1))] ELSE &
	[TEMP_CHPT(MODES(MODE.BIT+1),-1); SHORT.OUT(TEMP,5); TYPSPACE(2)]

10: IF LISTFLG # CHANGE THEN DO
	IF LITTLE THEN MSG('$10. STRUCTURE: ')
	SIXOUT(@LUD.TEMP(5),4);SP
	IF LITTLE THEN MSG('$QUOTA IN: '); SPOUT(LUD.TEMP(6),6)
	 NUMOUT(LUD.TEMP(6));SP
	IF LITTLE THEN MSG('$QUOTA OUT: '); SPOUT(LUD.TEMP(7),6)

	NUMOUT(LUD.TEMP(7))
	END
END
STRTAGN:IF FLG = 0 THEN [CR; RETURN] ELSE [IF INC LISTNUM = 11 THEN [CR; RETURN]]
END
END LIST.RECORD



%CHANGEIT(WHICHONE)
	!CHANGE ITEM "WHICHONE" IN LUD
LOCAL SAVNAM(2)
	DO WHICHONE OF CH.LIC:CH.MODE

CH.LIC: IF QUERY('ACCOUNT SUPERVISOR') = 1 THEN DO
		IF ACTSUP.BIT = 0 THEN MSG('$CANNOT SET ACCOUNT SUPERVISOR BIT.'); &
			 RETURN
	END ELSE ACTSUP.BIT _ 0

CH.MSG: SUPMSG.BIT _ QUERY('SUPRESS TYMSHARE MESSAGE AT LOGIN')

CH.INIT: IF QUERY('DO YOU WANT TO SET AN INIT FILE') = 1 THEN DO
    IF INIT.BIT # 1 THEN [INIT.BIT _ 1;MAKE.ROOM;MOVE.DOWN;SIZE.INC]
	MOVE 2 FROM USER TO SAVNAM
	GETNAME(MSG('USER FILE BELONGS TO: ')); MOVE 2 FROM USER TO @LUD(6)
	MOVE 2 FROM SAVNAM TO USER; MSG('FILE NAME: ')
	    GETTOKEN(0); MAKE.SIXBIT(TOKEN,@LUD(5),6)
	END ELSE [IF INIT.BIT=1 THEN  [INIT.BIT _ 0;SIZE.DEC;&
	 MOVE (SIZE.BLK-(L.INDEX+SIZE.LUD.ENT)) FROM @LUD(8) TO @LUD(5);&
	MOVE 3 FROM ALL 0 TO L.BLK(126)]]

CH.ZONE:  LOOP DO
	MSG('ENTER TIME ZONE: '); GETTOKEN(0)
	IF ZONE_CHOOSE(N.ZONES,ZONES)#0 THEN [ZONE.BIT_ZONE;REPEAT 0]&
	ELSE [MSG('$VALID TIME ZONES ARE '); LISTABLE(N.ZONES,ZONES); CR;CR]
END
	DAYLIG.BIT _ QUERY('$SUBJECT TO DAYLIGHT SAVING')

CH.DET: DETACH.BIT _ QUERY('DETACH ON DISCONNECT')

CH.MODE: LOOP DO
	MSG('MODE: '); GETTOKEN(0)
	IF MODE_CHOOSE(N.MODES,MODES)#0 THEN [MODE.BIT_MODE-1; RETURN]
	MSG('$VALID MODES ARE '); LISTABLE(N.MODES,MODES); CR;CR
END
END
RETURN
END CHANGEIT



%MAKE.ROOM
	!MAKE ROOM FOR AN ADDITIONAL 3 WORD IN ENTRY...CREATE OVERFLOW
	!BLOCK IF NECESSARY
LOCAL TMP,I,SAVENT(20)
TMP _ SIZE.LUD.ENT
MOVE TMP FROM @LUD(0) TO SAVENT
MOVE SIZE.BLK-L.INDEX-TMP FROM @LUD(TMP) TO @LUD(0)
WHILE LUD(0)#0 THEN L.INDEX+_SIZE.LUD.ENT
MOVE TMP FROM SAVENT TO @LUD(0)
IF L.INDEX+SIZE.LUD.ENT+3<SIZE.BLK THEN RETURN
HW(@LUD(0),0) _ -1; OV.BLK _ LUD.SIZE+ _ 1
STATUS _ OLD.OUT; LUD.WRIT; SETCP(CH.LUD,(LUD.SIZE+1)*SIZE.BLK)
L.INDEX _ 0
MOVE SIZE.BLK FROM ALL 0 TO LBLK
MOVE TMP FROM SAVENT TO @LUD(0)
RETURN
END MAKE.ROOM


%HEADING
MSG('$OUTPUT TO: '); GETTOKEN(0)
CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
DATOUT
IF THISDIST = 0 THEN DO
	IF LISTFLG = ACCT.LST THEN [OUT('$GLOBAL ACCOUNT: ');&
					OCTOUT(NUMBER)]
	IF LISTFLG = DIST.LST THEN [OUT('$DISTRICT: ');NUMOUT(NUMBER)]
END ELSE [OUT('$GLOBAL ACCOUNT: '); OCTOUT(THISACCT)]
OUT('$$USER         ')
IF THISDIST#0 OR LISTFLG=ACCT.LST  THEN OUT('  DIST   ')
IF THISDIST = 0 AND LISTFLG=DIST.LST  THEN OUT('GAN    ')
OUT('UUN      LICENSE         MSG INIT FILE$')
OUT('                   ZONE     DISC            MODE   STR    Q-IN   Q-OUT$$')
RETURN
END HEADING


%KNOW.ACCT
	!SEE IF USER KNOWS ACCT. NO...OR ASK HIM NAME
IF QUERY('$DO YOU KNOW THE GLOBAL ACCOUNT NUMBER') = 1 THEN RETURN 1
MSG('$ENTER A USERS NAME FROM THE ACCOUNT: '); GETTOKEN(2)
MAKE.SIXBIT(TOKEN,USER,12)
IF LUD.LOOK(USER) = 0 THEN NOT.VALID ELSE NUMBER _ HW(@LUD(0),0)
RETURN 0
END KNOW.ACCT


%CHECK.CHG(NUMBER)
	!ASK IF USER IS SURE HE WANTS TO MAKE CHANGE
	!1=YES, 0=NO
LIST.RECORD(NUMBER)
TEMP _ QUERY('$OKAY'); RETURN TEMP
END CHECK.CHG


%OPEN.LUD
	!LOOK FOR LUD.SYS ON DSK
		IF CMD # CMD.CHANGE THEN &
	CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR)&
	ELSE CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+UPDATE+WORD,LUD.ERR)
	RETURN
LUD.ERR:CHK.IO.ERR
END OPEN.LUD


%OPEN.DUL
	!LOOK FOR DUL.SITE ON DSK
LOCAL DUL.ERR:
	CH.DUL_OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,DUL.ERR)
	RETURN
DUL.ERR:CHK.IO.ERR
END OPEN.DUL



END NONAME
