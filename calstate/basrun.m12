TITL(BASRUN,BASIC RUNSIDE MODULE)
        LOC     137
JOBVER: EXP  BASVER

        RELOC
        HISEG
INTERN EXECUT,RESTOR,RESTOS,IFIX
INTERN EXP3.0,DECCEI,DECFLO
INTERN  APPEND,SPACEB,RANSCR,FNMX0,CHRB,SINB,RANDER,PAGEAL,LEFTB
INTERN SETCOR,XCTON,WRPRER,SCNIMS,INSTRB,VALB,EXPB,LENB,DOREAD
INTERN SCNIMN,UXIT,PAGE,OPNFIL,MIDB,INTB,CHAHAN
INTERN TANB,MARGN,ENDIMG,STRB, MARGAL,CRLF,COTB,RESTON,RETURN
INTERN RIGHTB,RNDB,RNNUMO,IFLOAT,CHKIMG,CHAXIT,CHAERR,ATANB
INTERN SAVACS,DOINPT,RNSTRO,CLSFIL,FRETRN,MARERR,COSB,LOGB
INTERN REINER,SQRTB,FNMXER,IMGLIN,CLOGB,OUTST2,SCTH2,XRES2,INST2,EOF2
	SUBTTL RUN-TIME ROUTINES

        FTRND=-1
        FTMAT=-1
        FTSTR=-1
;RUN-TIME GOSUB ROUTINES

GOSBER:	MOVE	X1,@40
	MOVE	R,FCNLNK
	HRLM	R,@40		;SAVE PRECEDING CALL
	MOVE	R,40		;FETCH CURRENT CALL
	MOVEM	R,FCNLNK
	TRNN	X1,777777	;IF FCN, BEGINS AT CTRL WRD + 1
	HRRI	X1,1(R)
	TLNN	X1,777777	;CHECK RECURSIVE CALL
	JRST	(X1)

	PUSHJ	P,INLMES	;RECURSIVE CALL
	ASCIZ	/
? SUBROUTINE OR FUNCTION CALLS ITSELF/
GOSR2:	PUSH	P,[Z UXIT]	;PRINT LINE NUMBER AND END EXECUTION
GOSR3:	PUSHJ	P,INLMES
	ASCIZ	/ IN LINE /
	MOVE	T,SORCLN	;PRINT LINE NUMBER AND CONTINUE EXECUTION.
	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,PRTNUM
	POP	P,ODF
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3
GOSR6:	PUSHJ	P,INLMES
	ASCIZ	/
/
	OUTPUT 0,
	POPJ	P,

FORCOM:	MOVEI	X1,313		;RUNTIME COMPARE FIX-DONT USE IF CON
	SKIPGE	@40
	ADDI	X1,2
	DPB	X1,[POINT 9,@(P),8]   ;SET UP COMPARE FOR ENTIRE LOOP
	POPJ	P,

XCTON:	JUMPLE	N,XCTON1	;IS ON ARGUMENT <=0?
	FAD	N,FIXCON
	HRRZ	T,N		;GET INTEGER PART
	JUMPE	T,XCTON1
	ADDI	T,(A)		;GET THE "GOTO" ADDRESS
	CAMGE	T,(A)		;IS IT IN RANGE?
	JRST	@(T)		;YES, GOGO

XCTON1:	PUSHJ	P,INLMES
	ASCIZ /
? ON EVALUATED OUT OF RANGE/
	JRST	GOSR2

;HERE ON OVFLOW ERROR
OVTRAP:	PUSH	P,X1		;SAVE THIS REG IN CASE FALSE ALARM.
	HRRZ	X1,JOBTPC	;GET TRAP ADDRESS.
	CAML	X1,FLCOD	;TRAP IN USER PROG?
	CAMLE	X1,CECOD
	JRST	OVFIG2		;NO. FALSE TRAP.(NOT BY USER)
	MOVE	X1,JOBTPC	;GET TRAP FLAGS.
	TLNE	X1,(1B11)	;UNDERFLOW?
	JRST	UNTRAP		;YES
	TLNE	X1,(1B12)	;ZERO DIVIDE?
	JRST	DVTRAP		;YES.
	TLNN	X1,(1B3)
	JRST	OVFIG2		;NOT OVFLOW EITHER. IGNORE.
OVTR0:	PUSHJ	P,INLMES
	ASCIZ	/
% OVERFLOW/
	SKIPL	N		;NEG OVFLOW?
OVTR2:	HRLOI	N,377777	;LRG NUMBER
	SKIPG	N
	MOVE	N,MIFI		;LRG NEG NUMBER
OVTR1:	PUSHJ	P,GOSR3
OVFIG2:	MOVEI	X1,10
	CALLI	X1,16
	SETOM	LIBFLG
	POP	P,X1
	JRST	@JOBTPC

OVFLCM:	PUSH	P,X1
	JRST	OVFIG2

UNTRAP:	PUSHJ	P,INLMES
	ASCIZ	/
% UNDERFLOW/
	SETZI	N,		;RESULT IS ZERO.
	JRST	OVTR1

DVTRAP:	PUSHJ	P,INLMES
	ASCIZ	/
% DIVISION BY ZERO/
	JRST	OVTR2
;ANALYZE THE FILENAME ARGUMENT FOR CHAIN.

CHAHAN:	PUSHJ	P,STRPL1	;GET STR PLUS TERM DOLL SIGN
	JRST	CHAER1		;SO FILNAM WILL STOP.
	PUSHJ	P,FILNAM
	JUMP	NEWOL1
	CAME	T,VALPTR	;STOPPED IN RIGHT PLACE?
	JRST	CHAER1
	POP	P,Q
	MOVEI	X2,.+2
	JRST	RESACS
	SOS	MASAPP
	POPJ	P,
	EXTERN	IFNFLG		;IFNFLG DISTINGUISHES BETWEEN "RETURN"
				;AND END OF FNX PROCESSING.
RETURN:	SETZB	T,IFNFLG	;GOSUB RETURN, NOTHING ON PLIST.
	JRST	.+2
FRETRN:	SETOM	IFNFLG
	MOVE	R,FCNLNK
	JUMPE	R,BADRET	;CHECK RETURN TOO FAR
	MOVS	X1,(R)		;FETCH LINK BACK
	HRRZS	(R)		;MARK SUBR NOT IN USE
	MOVEI	R,(X1)
	MOVEM	R,FCNLNK
	POP	P,X2		;SAVE REAL RETURN LOCATION
	SUB	Q,T		;POP ANY ARGUMENTS OFF THE PUSH LIST
	SKIPN	IFNFLG
	JRST	(X2)		;RETURN
RESACS:	POP	P,T		;RESTORE AC'S, EXCEPT 0, X2, AND P.
	POP	P,T1
	POP	P,SORCLN
	POP	P,A
	POP	P,B
	POP	P,C
	POP	P,D
	POP	P,F
	POP	P,ODF
	POP	P,E
	POP	P,G
	POP	P,R
	POP	P,X1
	POP	P,L
	JRST	(X2)

SAVACS:	POP	P,X2
	PUSH	P,N
	HRRZ	N,P
	SUBI	N,PLIST
	CAILE	N,250
	JRST	MNYDEF
	POP	P,N
SAVCS1:	PUSH	P,L
	PUSH	P,X1
	PUSH	P,R
	PUSH	P,G
	PUSH	P,E
	PUSH	P,ODF
	PUSH	P,F
	PUSH	P,D
	PUSH	P,C
	PUSH	P,B
	PUSH	P,A
	PUSH	P,SORCLN
	PUSH	P,T1
	PUSH	P,T
	JRST	(X2)

MNYDEF:	PUSHJ	P,INLMES
	ASCIZ	/
? TOO MANY FN'S/
	JRST	GOSR2

BADRET:	PUSHJ	P,INLMES
	ASCIZ	/
? RETURN BEFORE GOSUB/
	JRST	GOSR2

IFN FTRND,<
;RUN-TIME RANDOMIZER
RANDER:	CALL	N,[SIXBIT /MSTIME/]
	CAME	N,RANTST
	JRST	RANDR2
	AOS	RANCNT
	MOVE	T1,RANCNT
	ADDI	N,117
	SOJG	T1,.-1
	JRST	.+3
RANDR2:	MOVEM	N,RANTST
	SETZM	RANCNT
	IMUL	N,N		;USE THE 31 LOW ORDER BITS OF MILLISECS IN DAY ^2
	TLZ	N,760000
	JRST	WRANB		;PRIME RANDOM FCN AND RETURN.
>;ASSEMBLE ABOVE IF INCLUDING RANDOM FACILITY


;R.A. OUTPUT ROUTINE.

RNSTRO:	SKIPG	STRLEN-1(LP)	;STR FILE?
	JRST	RNERR1		;NO. FAIL.
	HLRZ	B,STRLEN-1(LP)	;B=NO. WORDS/REC.
	MOVEI	X1,^D128
	IDIVI	X1,(B)
	MOVE	A,POINT-1(LP)	;X1=NO. RECS/BLK.
	MOVEI	T,(A)
	IDIVI	T,(X1)		;T = BLK NO. - 1.
	IMULI	T1,(B)		;T1 = NO. OF WRDS INTO BLK.
	JRST	RNNUM1

RNNUMO:	SKIPL	STRLEN-1(LP)	;NUM FILE?
	JRST	RNERR1		;NO. FAIL.
	MOVE	A,POINT-1(LP)
	MOVEI	T,1(A)		;T = BLK NO. - 1.
	IDIVI	T,^D128		;T1 = NO. OF WRDS INTO BLK.

RNNUM1:	AOJ	T,.+1
	CAMN	T,BLOCK-1(LP)	;CUR BLK?
	JRST	RNNUM4		;YES.
	SKIPN	MODBLK-1(LP)	;NO -- NEED TO OUTPUT
	JRST	RNNUM2		;CUR BLK?
	MOVE	X2,BLOCK-1(LP)	;YES.
	PUSHJ	P,OUTRAN
RNNUM2:	CAMG	A,LASREC-1(LP)	;IS NEW REC WITHIN FILE?
	JRST	RNNUM3		;YES.
	MOVE	A,LASREC-1(LP)
	IDIVI	A,(X1)
	CAIN	T,1(A)
	JRST	RNNUM3
RNNM25:	HLRZ	A,BA-1(LP)
	MOVEI	B,177		;CLEAR OUT NEW BLK.
	SETZM	3(A)
	AOJ	A,.+1
	SOJGE	B,.-2
	JRST	.+3
RNNUM3:	MOVE	X2,T		;OR GET NEW BLK.
	PUSHJ	P,INRAN
	MOVEM	T,BLOCK-1(LP)
RNNUM4:	MOVE	A,POINT-1(LP)
	CAMLE	A,LASREC-1(LP)
	MOVEM	A,LASREC-1(LP)
	HLRZ	A,BA-1(LP)
	ADDI	A,3(T1)
	SKIPL	STRLEN-1(LP)
	JRST	RNNUM5
	MOVEM	N,(A)		;OUTPUT NUM.
RNNOUT:	AOS	POINT-1(LP)
	SETOM	MODBLK-1(LP)
	POPJ	P,

RNNUM5:	TLNN	N,777777	;OUTPUT STR.
	JRST	RNNM12
	TLNE	N,377777
	JRST	RNNUM6
	MOVE	T,N
	MOVE	N,(T)
	TLNN	N,777777
	JRST	RNNM12
RNNUM6:	JUMPG	N,RNNUM9
	HLRE	T,N
	MOVM	T,T
	HRRZ	B,STRLEN-1(LP)
	CAMLE	T,B
	JRST	RNERR2
	MOVEM	T,(A)
	ADDI	A,1
	HRL	A,N
	SOJL	T,RNNOUT
	IDIVI	T,5
	ADDI	T,(A)
	BLT	A,(T)
	JRST	RNNOUT

RNNUM9:	MOVE	X1,N		;APP BLK.
	PUSHJ	P,LENAPB
	HRRZ	B,STRLEN-1(LP)
	CAMLE	N,B
	JRST	RNERR2
	MOVEM	N,(A)
	ADDI	A,1
	HRLI	A,440700	;A HAS NEW PNTR.
	HLRE	E,X1
	HRRZI	X1,(X1)
RNNM10:	HRR	X2,1(X1)
	HRLI	X2,440700	;X2 IS AN OLD PNTR.
	HLRE	T1,1(X1)
	JUMPE	T1,RNNM11
	ILDB	C,X2
	IDPB	C,A
	AOJL	T1,.-2
RNNM11:	SOJLE	E,RNNOUT
	AOJA	X1,RNNM10

RNNM12:	SETZM	(A)
	JRST	RNNOUT

;UTILITY ROUTINE TO INPUT A BLOCK FOR A R.A. FILE. THE DESIRED
;BLOCK NUMBER IS IN X2.

INRAN:	HRRM	X2,USETID-1(LP)
	XCT	USETID-1(LP)
	DPB	LP,[POINT 4,INNDSK,12]
	XCT	INNDSK
	POPJ	P,
	MOVEI	T,INLSYS
	JRST	ERRMSG


;UTILITY ROUTINE TO TRANSFER A BLOCK FROM A R.A. INPUT BUFFER TO THE 
;OUTPUT BUFFER FOR THAT CHANNEL. THE BLOCK NUMBER IS IN X2.

OUTRAN:	PUSH	P,X1
	HRRM	X2,USETOD-1(LP)
	XCT	USETOD-1(LP)
	HLRZ	X2,BA-1(LP)
	ADDI	X2,3
	HRLI	X2,(X2)
	MOVEI	X1,203
	ADDI	X1,(X2)
	HRRI	X2,(X1)
	BLT	X2,177(X1)
	MOVEI	X2,200
	HRRM	X2,-1(X1)
	DPB	LP,[POINT 4,OUTTDS,12]
	POP	P,X1
	XCT	OUTTDS
	POPJ	P,
	DPB	LP,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR


;RUNTIME ROUTINE FOR THE PAGE STATEMENT.
;PAGE SIZE IS IN AC N, IN FLOATING POINT.

PAGE:	CAMGE	N,ONE		;PAGE SIZE MUST BE 1.0
	JRST	PAGERR		;OR GREATER.
	PUSHJ	P,IFIX
PAGE0:	MOVEM	N,PAGLIM(LP)
	JUMPE	LP,PAGE1	;TTY IS ALWAYS IN "OUTPUT MODE".
	MOVE	T1,ACTBL-1(LP)	;FILE. IS IT WRITEABLE?
	CAIE	T1,3
	JRST	PAGE2
PAGE1:	PUSH	P,ODF
	SETZM	ODF
	JUMPE	LP,.+2
	SETOM	ODF
	SKIPN	HPOS(LP)	;NEED TO END CURRENT LINE?
	JRST	PAGE3		;NO.
	SETOM	PAGLIM(LP)
	MOVEI	C,15
	PUSHJ	P,OUCH
	MOVEI	C,12
	PUSHJ	P,OUCH
PAGE3:	MOVEI	C,14
	PUSHJ	P,OUCH
	SETOM	FIRSFL(LP)
	POP	P,ODF
PAGE2:	SETZM	PAGCNT(LP)
	SETZM	HPOS(LP)
	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	POPJ	P,


;RUNTIME ROUTINE FOR THE PAGE ALL STATEMENT.
;PAGE SIZE IS IN AC N, IN FLOATING POINT.

PAGEAL:	CAMGE	N,ONE		;PAGE SIZE MUST BE 1.0
	JRST	PAGERR		;OR GREATER.
	PUSHJ	P,IFIX
	MOVEI	LP,9
PAGEL1:	PUSHJ	P,PAGE0
	SOJG	LP,PAGEL1
	POPJ	P,

;RUNTIME ROUTINE FOR THE MARGIN STATEMENT.
;MARGIN SIZE IS IN AC N, IN FLOATING POINT.

MARGN:	CAML	N,ONE		;MARGIN MUST BE >=1 AND <=132.
	CAML	N,ONE33
	JRST	MARER1
	PUSHJ	P,IFIX
	MOVEM	N,MARWAI(LP)
	POPJ	P,

ONE33:	133.0
ONE28:	128.0
MINONE:	-1.0


;RUNTIME ROUTINE FOR THE MARGIN ALL STATEMENT.
;MARGIN SIZE IS IN AC N, IN FLOATING POINT.

MARGAL:	CAML	N,ONE		;MARGIN MUST BE >= 1 AND <= 132.
	CAML	N,ONE33
	JRST	MARER1
	PUSHJ	P,IFIX
	MOVEI	LP,9
	MOVEM	N,MARWAI(LP)
	SOJG	LP,.-1
	POPJ	P,


;SEMI-IFIX ROUTINE.
;IFIX EXPECTS A NON-NEGATIVE FLOATING POINT NUMBER IN AC N
;AND RETURNS A FIXED POINT INTEGER IN AC N.

IFIX:	PUSH	P,T
	PUSH	P,T1
	MOVE	T,N
	MULI	T,400
	SETZM	LIBFLG
	ASH	T1,-243(T)
	MOVE	N,T1
	POP	P,T1
	POP	P,T
	SKIPN	LIBFLG
	POPJ	P,
	HRLOI	N,377777
	POPJ	P,


;SEMI-IFLOAT ROUTINE.
;IFLOAT EXPECTS A NON-NEGATIVE FIXED POINT NUMBER IN AC N AND
;RETURNS A FLOATING POINT NUMBER IN AC N.

IFLOAT:	PUSH	P,T
	SETZ	T,
	LSHC	N,-^D8
	LSH	T,-^D9
	TLO	N,243000
	TLO	T,210000
	FADR	N,T
	POP	P,T
	POPJ	P,
	
;RUN-TIME ROUTINES FOR READ AND INPUT

DOREAD:	MOVE	R,[XWD NXREAD,PREAD]
	SETZM	INPFLA		;READ, NOT INPUT
	POPJ	P,		;SET UP TO READ

	EXTERN	PINPNM
DOINPT:	SKIPN	IFIFG
	SETZM	PINPUT		;FORCE NEW LINE
	MOVE	R,[XWD NXINPT,PINPUT]
	POP	P,INPFLA	;SAVE ERROR RETURN
	JRST	@INPFLA

;ROUTINE TO GET A DATA WORD

DATAER:	SKIPN	IFIFG
	JRST	DATAE1
	SKIPN	T,PINPNM-1(LP)
	JRST	NXINPT
	SKIPGE	REAINP-1(LP)
	SKIPN	EOFFLG-1(LP)	;SEE NOTE IN IF END# ROUTINE.
	JRST	.+3
	SETZ	X1,
	JRST	NXIN4
	PUSHJ	P,DELAWY
	JRST	DATR0
DATAE1:	SKIPN	T,(R)		;MORE ON SAME LINE?
	JRST	DATR1		;NO
	PUSHJ	P,NXCH		;PUT FIRST CHAR OF NEXT NUMBER IN C
	SKIPE	INPFLA		;CHECK TO SEE IF THIS IS REALLY
	JRST	DATR0		;THE "ONE OPTIONAL TRAILING COMMA"
	TLNE	C,F.TERM	;ALLOWED IN DATA STATEMENTS.
	JRST	DATR1
DATR0:	PUSHJ	P,EVANUM
	PUSHJ	P,SSKIP		;IT WASN'T A NUMBER, TRY NEXT
	PUSH	P,X1
	HRRZ	X1,40
	MOVEM	N,(X1)		;STORE THE DATA WORD.
	POP	P,X1
	SKIPE	IFIFG
	PUSHJ	P,DELAWY
	SKIPE	INPFLA		;END OF LINE TEST.
	TLNN	C,F.CR
	TLNE	C,F.TERM	
	SETZI	T,		
	SKIPN	IFIFG
	JRST	DATAE2
	MOVEM	T,PINPNM-1(LP)
	JRST	DATR01
DATAE2:	MOVEM	T,(R)
DATR01:	POP	P,X1
	SKIPN	T		;END OF A LINE?
	SKIPN	INPFLA		;YES, IS THIS INPUT?
	JRST	(X1)		;NO, RETURN
	MOVEM	X1,INPFLA	;YES, RESTART NEXT ERROR FROM HERE.
	JRST	(X1)

DATR1:	MOVS	X1,R		;DISPATCH ADDRS FOR MORE DATA
	JRST	(X1)

;ROUTINE TO GET A DATA STRING

INSTR:
IFN FTSTR,<
SDATAE:	SKIPN	IFIFG
	JRST	SDAT1
	SKIPN	T,PINPNM-1(LP)
	JRST	NXSINP
	SKIPGE	REAINP-1(LP)
	SKIPN	EOFFLG-1(LP)	;SEE NOTE IN IF END# ROUTINE.
	JRST	.+3
	MOVEI	X1,1
	JRST	NXIN4
	PUSHJ	P,DELAWY
	JRST	SDATR0
SDAT1:	MOVE	T,1(R)		;GET CURRENT LINE POINTER
	SKIPE	INPFLA		;INPUT,INSTRUCTION?
	MOVE	T,(R)		;YES, SHARE POINTER WITH NUMBER DATA
	SKIPN	T		;MORE ON CURRENT STRING DATA LINE?
	JRST	SDATR1		;NO. HUNT FOR NEXT DATA LINE
	PUSHJ	P,NXCH		;GET FIRST CHAR
	SKIPE	INPFLA		;CHECK TO SEE IF THIS IS REALLY
	JRST	SDATR0		;THE "ONE OPTIONAL TRAILING COMMA"
	TLNE	C,F.TERM	;ALLOWED IN DATA STATEMENTS.
	JRST	SDATR1
SDATR0:	PUSHJ	P,REDSTR	;READ THE STRING AND STORE IT
	PUSHJ	P,SSKIP		;BAD STRING
	SKIPE	IFIFG
	PUSHJ	P,DELAWY
	SKIPE	INPFLA		;END OF LINE TEST.
	TLNN	C,F.CR
	TLNE	C,F.TERM	
	SETZI	T,		
	SKIPN	IFIFG
	JRST	SDAT2
	MOVEM	T,PINPNM-1(LP)
	JRST	DATR01
SDAT2:	MOVEM	T,1(R)		;SAVE STRING DATA POINTER.
	SKIPE	INPFLA		;INPUT?
	MOVEM	T,(R)		;YES , SHARE POINTER
	JRST	DATR01

SDATR1:	MOVS	X1,R		;DISPATCH ADDRESS FOR STRING DATA..
	JRST	1(X1)
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

;GET AN ARRAY DATA WORD

ADT1ER:	PUSH	P,40		;DATAER NEEDS STORE LOC
	SETZM	40
	PUSHJ	P,DATAER
	POP	P,40
	JRST	AST1ER	;GO STORE THE WORD

ADT2ER:	PUSH	P,40
	SETZM	40
	PUSHJ	P,DATAER
	POP	P,40
	JRST	AST2ER

;GO TO NEXT LINE OF DATA

NXREAD:	TDZA	X1,X1		;GET NEXT DATA LINE FOR NUMBER ITEM
NSRSTR:	MOVEI	X1,1		;GET NEXT DATA LINE FOR STRING ITEM
	MOVE	T,DATLIN(X1)	;GET NXT DATA LINE NO
	AOBJP	T,NXRE2		;JUMP IF OUT OF DATA
	MOVEM	T,DATLIN(X1)
	HRRZ	T,(T)		;GET ADDRS OF SOURCE LINE
	HRLI	T,440700
	PUSHJ	P,NXCH
	PUSH	P,X1
	PUSHJ	P,QSA		;LOOK FOR "DATA"
	ASCIZ	/DATA/
	JRST	[POP P,X1
		JRST NXREAD+2]
	POP	P,X1
IFN FTSTR,<
	JUMPG	X1,SDATR0	;GO GET STRING?
>
	JRST	DATR0		;NO, GO GET NUMBER
;REQUEST NEXT LINE OF INPUT

NXVINP:	SETOI	X1,		;GET LINE AND RETURN TO "MATIN"
	JRST	NXIN1
NXINPT:	TDZA	X1,X1		;GET A LINE OF INPUT; NUMBER ITEM NEXT
NXSINP:	MOVEI	X1,1		;GET A LINE OF INPUT; STRING ITEM NEXT
NXIN1:	SKIPN	IFIFG
	SETZB	LP,ODF
	JUMPN	LP,NXIN5
	PUSHJ	P,INLMES
	ASCIZ	/ ?/
	OUTPUT 0,
NXIN5:	MOVE	T,LINPT(LP)	;IF END# ENTERS HERE.
	PUSHJ	P,INLINE	;READ THE LINE AND GET FIRST CHAR.
	TLNE	C,F.CR		;NULL LINE?
	JUMPL	X1,CPOPJ1	;YES. ALLOW THIS ON MAT INPUT
NXIN4:	MOVE	T,LINPT(LP)
	JUMPE	LP,NXIN6
NXIN8:	PUSHJ	P,NXCH
	TLNE	C,F.CR
	JRST	NXIN5
	SKIPL	REAINP-1(LP)	;EXPECT A LINE NUMBER?
	JRST	NXIN6		;NO.
	MOVEI	A,4
	TLNN	C,F.DIG
	JRST	IMP
	PUSHJ	P,NXCHD
	TLNN	C,F.DIG
	JRST	.+3
	SOJGE	A,.-3
	JRST	IMP
	TLNE	C,F.CR		;EMPTY LINE?
	JRST	NXIN5		;YES.
	TLNE	C,F.SPTB	;DELIMITER AFTER LINE NUMBER
	JRST	NXIN3		;MUST BE A SPACE, A TAB, OR THE LETTER D.
	HRRZ	A,C
	CAIE	A,"D"
	JRST	IMP
NXIN3:	PUSH	P,T
	PUSHJ	P,NXCH
	TLNN	C,F.CR
	JRST	.+3
	POP	P,T		;LINE NO. FOLLOWED BY EMPTY LINE.
	JRST	NXIN5
	POP	P,T
	MOVEI	C,40
	DPB	C,T
NXIN6:	SKIPN	IFIFG
	JRST	NXIN2
	MOVEM	T,PINPNM-1(LP)
	JRST	NXIN9
NXIN2:	MOVEM	T,PINPUT
	PUSHJ	P,DATCHK	;CHECK
	JRST	.+1
NXIN9:	HRRZ	T,(P)
	CAIN	T,EOF32
	POPJ	P,		;BACK TO IF END#.
	SETZM	EOFFLG-1(LP)
	JUMPE	X1,DATAER	;GET NUMBER ITEM
IFN FTSTR,<
	JUMPG	X1,SDATAE		;GET STRING ITEM
>
	POPJ	P,

INPERP:	POP	P,X1		;GET RID OF CALL TO NXVINP!
INPERR:	SKIPE	IFIFG
	JRST	IMP
	PUSHJ	P,INLMES
	ASCIZ	/
? INPUT DATA NOT IN CORRECT FORM/
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3
	PUSHJ	P,INLMES
	ASCIZ	/--RETYPE LINE
/
	SETZM	PINPUT
INPER1:	HRRZ	X1,INPFLA
	JRST	(X1)		;START LINE OVER.

;R.A. READ/INPUT ROUTINES.

RANUM1:	PUSH	P,40		;NUM 1 DIM.
	SETZM	40
	PUSHJ	P,RANUM
	POP	P,40
	JRST	AST1ER


RANUM2:	PUSH	P,40		;NUM 2 DIM.
	SETZM	40
	PUSHJ	P,RANUM
	POP	P,40
	JRST	AST2ER

RANSTR:	SKIPG	STRLEN-1(LP)	;STR.
	JRST	RNERR1
	MOVE	T,POINT-1(LP)
	CAMLE	T,LASREC-1(LP)
	JRST	EOFFL
	HLRZ	B,STRLEN-1(LP)
	MOVEI	X1,^D128
	IDIVI	X1,(B)		;X1=NO. OF RECS/BLK.
	IDIVI	T,(X1)		;T=BLK NO. - 1.
	IMULI	T1,(B)		;T1=NO. OF WORDS INTO BLK.
	JRST	RANNM1

RANUM:	SKIPL	STRLEN-1(LP)	;NUM.
	JRST	RNERR1
	MOVE	T,POINT-1(LP)
	CAMLE	T,LASREC-1(LP)
	JRST	EOFFL
	AOJ	T,.+1
	IDIVI	T,^D128
RANNM1:	AOJ	T,.+1
	CAMN	T,BLOCK-1(LP)
	JRST	RANNM3
	SKIPN	MODBLK-1(LP)
	JRST	RANNM2
	MOVE	X2,BLOCK-1(LP)
	PUSHJ	P,OUTRAN
RANNM2:	MOVEI	X2,(T)
	PUSHJ	P,INRAN
	MOVEM	T,BLOCK-1(LP)
	SETZM	MODBLK-1(LP)
RANNM3:	HLRZ	A,BA-1(LP)
	ADDI	A,3(T1)
	SKIPL	STRLEN-1(LP)
	JRST	RANNM4
	MOVE	T,(A)		;READ NO.
	HRRZ	X1,40
	MOVEM	T,(X1)
	AOS	POINT-1(LP)
	POPJ	P,

RANNM4:	MOVE	T,(A)		;READ STR.
	CAIG	T,^D132
	JUMPGE	T,.+2
	JRST	RNERR3
	PUSHJ	P,VCHCKC
	PUSHJ	P,PNTADR
	SKIPE	(X1)
	SETZM	VPAKFL
	MOVE	X2,(A)
	HRLI	T,1(A)
	SOJL	X2,RANNM5
	PUSH	P,Q
	IDIVI	X2,5
	POP	P,Q
	ADDI	X2,(T)
        PUSH P,T
	BLT	T,(X2)
        POP P,T
	HRRM	T,(X1)
	MOVN	T,(A)
	HRLM	T,(X1)
	AOS	POINT-1(LP)
	POPJ	P,

RANNM5:	SETZM	(X1)
	JRST	.-3


;USING STATEMENT ROUTINES

;CHKIMG SETS UP THE STARTING AND CURRENT POINTER TO THE IMAGE IN MASAPP,
;THE TOTAL AND THE CURRENT NUMBER OF CHARS IN THE IMAGE IN B AND X2,
;AND BEGFLG IN T1.  THE CURRENT POINTER IS ALSO IN X1.

CHKIMG: TLNN	N,777777	;GET IMAGE KEY.
	JRST	IMGER1
	TLNE	N,377777
	JRST	CHKIM1
	MOVE	T,N
	MOVE	N,(T)
	TLNN	N,777777
	JRST	IMGER1

CHKIM1:	JUMPL	N,CHKIM2
	PUSHJ	P,STRETT
	TLNN	N,777777
	JRST	IMGER1
CHKIM2:	HLRE	B,N
	MOVM	B,B
	CAILE	B,^D132
	JRST	IMGER2
	MOVEI	X2,(B)
	HRLI	N,440700
	AOS	T1,MASAPP	;SAVE ORIGINAL AND CURRENT POINTERS
	MOVEM	N,(T1)		;ON MASAPP TO PROTECT THEM FROM
	AOS	T1,MASAPP	;SHIFTING CORE.
	MOVEM	N,(T1)
	SETO	T1,
	POP	P,X1
	PUSH	P,B
	PUSH	P,X2
	PUSH	P,T1
	JRST	(X1)

IMGLIN:	MOVE	G,HPOS(LP)	;END LINE IF NECESSARY.
	ADD	G,TABVAL(LP)
	JUMPN	G,CHKIM3
	SKIPE	G,MARWAI(LP)
	MOVEM	G,MARGIN(LP)
	PUSHJ	P,NUMINS
	JRST	CRLF1
CHKIM3:	JUMPE	LP,.+3
	CAIN	G,^D6
	SKIPL	WRIPRI-1(LP)
	JRST	.+2
	POPJ	P,
	PUSH	P,X2
;       PUSHJ	P,PCRLF
	JUMPN	LP,.+2
	OUTPUT 0,
	POP	P,X2
	POPJ	P,

;MISC. UTILITY ROUTINES FOR USING STATEMENTS.

NXCHU:	ILDB	C,X1		;GET NEXT CHAR OF IMAGE.
	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	SOJ	X2,.+1		;DECREMENT COUNTER.
	POPJ	P,

SCNOUT:	PUSH	P,F		;OUTPUT A CHAR.
	MOVE	F,HPOS(LP)
	CAIL	F,^D132		;USING MARGIN IS 132.
	JRST	SCNER3
	POP	P,F
	JRST	OUCH

IMGAPZ:	JUMPN	LEFT,CPOPJ1	;USED BY IMGAPS.
	JUMPN	EXTEND,CPOPJ1
	JUMPN	RIGHT,CPOPJ1
	JUMPN	CENTER,CPOPJ1
	POPJ	P,
;SCNIMG LOOKS FOR NEXT FIELD.
;X1 IS A FLAG THAT PREVENTS LOOPING IF AN IMAGE WITH NO FIELDS IS SEEN.

SCNIMN:	TDZA	A,A		;ARG IS NUMBER.
SCNIMS:	SETO	A,		;ARG IS STRING.
	POP	P,X1
	POP	P,T1
	POP	P,X2
	POP	P,B
	PUSH	P,X1
	MOVE	X1,MASAPP	;RETRIEVE CURRENT POINTER.
	MOVE	X1,(X1)
SCNIM1:	JUMPN	X2,SCNIM2	;CHAR LEFT IN IMAGE?
	JUMPN	T1,SCNER1	;NO--ANY FIELDS SEEN?
	MOVE	X1,MASAPP	;YES, OKAY. O'E, FAIL.
	MOVE	X1,-1(X1)	;MOVE PNTR AND
	MOVE	X2,B		;CHAR COUNT BACK TO BEGINNING.
	SETO	T1,
	PUSH	P,X2
	PUSHJ	P,PCRLF		;END LINE, BEGIN NEW LINE.
	JUMPN	LP,.+2
	OUTPUT 0,
	POP	P,X2
SCNIM2:	PUSHJ	P,NXCHU
SCNIM0:	TLNN	C,F.APOS
	JRST	SCNIM3
	JUMPE	A,SCNER2	;APOS SEEN, BETTER BE STR ARG.
	SETZ	T1,
	PUSHJ	P,IMGAPS
SCNEND:	MOVE	A,MASAPP	;PROTECT POINTER.
	MOVEM	X1,(A)
	POP	P,X1
	PUSH	P,B
	PUSH	P,X2
	PUSH	P,T1
	JRST	(X1)		;BACK TO USER CODE.
SCNIM3:	PUSHJ	P,SCNIM6
	JRST	SCNIM1
	JRST	.+2
	JRST	SCNIM0
	JUMPN	A,SCNER2
	SETZ	T1,
	PUSHJ	P,IMGPND
	JRST	SCNEND
SCNIM6:	TLNN	C,F.DOLL+F.STAR
	CAMN	C,[XWD F.STR,43]
	JRST	SCNIM4
SCNM35:	JRST	SCNOUT		;PRINTABLE CHAR.
SCNIM4:	JUMPE	X2,SCNOUT
	MOVE	G,C
	PUSHJ	P,NXCHU
	CAMN	C,G
	JRST	CPOPJ1
	EXCH	C,G
	PUSHJ	P,SCNOUT
	MOVE	C,G
	POP	P,G
	JRST	2(G)

;ENDIMG ENDS A USING STATEMENT.

ENDIMG:	POP	P,C
	POP	P,T1
	POP	P,X2
	POP	P,B
	PUSH	P,C
	MOVE	X1,MASAPP
	MOVE	X1,(X1)
ENDIM3:	JUMPE	X2,ENDIM1	;OUTPUT PRINTABLE CHARS
	PUSHJ	P,NXCHU		;UP TO THE NEXT FIELD.
ENDIM0:	TLNE	C,F.APOS
	JRST	ENDIM1
	PUSHJ	P,SCNIM6
	JRST	ENDIM3
	JRST	ENDIM1
	JRSTM0
        EXTERN  XLFLG1  ;FOR ; AT END OF PRINT USING -1 IF IS
ENDIM1: SKIPN   XLFLG1
        PUSHJ	P,PCRLF		;END LINE.
        SETZM   XLFLG1
ENDIM2:	JUMPN	LP,.+2
	OUTPUT 0,
	SETZM	FMTPNT(LP)
	SETOM	ZONFLG(LP)
	SOS	MASAPP
	SOS	MASAPP
	POPJ	P,

;IMGAPS ANALYZES STR FIELD AND OUTPUTS STR.

CENTER=G
EXTEND=E
LEFT=D
RIGHT=R

IMGAPS:	TLNE	N,777777	;GET OUTPUT STR KEY.
	TLNE	N,377777
	JRST	IMGAP1
	MOVE	T,N
	MOVE	N,(T)
IMGAP1:	JUMPLE	N,.+2
	PUSHJ	P,STRETT
	SETZB	CENTER,EXTEND	;CLEAR FLAGS.
	SETZB	LEFT,RIGHT
IMGAP0:	JUMPE	X2,IMGAP4	;FIND C, E, L, AND R'S.
	MOVE	F,X1
	PUSHJ	P,NXCHU
	TLNE	C,F.LETT
	JRST	IMGAP2
IMGP01:	MOVE	X1,F
	AOJA	X2,IMGAP4
IMGAP2:	TLZ	C,777777
	CAIE	C,"L"
	JRST	IMGA21
	JUMPN	LEFT,.+2
	PUSHJ	P,IMGAPZ
	AOJA	LEFT,IMGAP0
IMGA21:	CAIE	C,"E"
	JRST	IMGA22
	JUMPN	EXTEND,.+2
	PUSHJ	P,IMGAPZ
	AOJA	EXTEND,IMGAP0
IMGA22:	CAIE	C,"C"
	JRST	IMGP23
	JUMPN	CENTER,.+2
	PUSHJ	P,IMGAPZ
	AOJA	CENTER,IMGAP0
IMGP23:	CAIE	C,"R"
	JRST	IMGP01
	JUMPN	RIGHT,.+2
	PUSHJ	P,IMGAPZ
	AOJA	RIGHT,IMGAP0
	JRST	IMGP01

IMGAP4:	JUMPE	LEFT,.+2
IMGA41:	AOJA	LEFT,IMGAP5
	JUMPE	EXTEND,.+2
	AOJA	EXTEND,IMGAP5
	JUMPE	CENTER,.+2
	AOJA	CENTER,IMGAP5
	JUMPE	RIGHT,IMGA41
	AOJA	RIGHT,IMGAP5

IMGAP5:	HLRE	F,N		;HAVE ANALYZED FIELD.
	MOVM	F,F
	HRLI	N,440700	;GET PTR AND CHAR COUNT FOR ARG
	SKIPN	T,LEFT		;IN N AND F.
	SKIPE	T,EXTEND
	JRST	.+3
	SKIPN	T,CENTER
	MOVE	T,RIGHT
	CAIGE	F,(T)
	JRST	IMGAP6
	JUMPN	EXTEND,.+2	;OVERFLOW.
	MOVEI	F,(T)
IMGP51:	ILDB	C,N
	PUSHJ	P,SCNOUT
	SOJG	F,.-2
	POPJ	P,

IMGAP6:	SUBI	T,(F)
	JUMPE	CENTER,IMGAP7	;CENTER.
	IDIVI	T,2
	ADDI	T1,(T)
	JUMPE	T,IMGP61
	MOVEI	C," "
	PUSHJ	P,SCNOUT
	SOJG	T,.-1
IMGP61:	MOVEI	T,(T1)
	SETZ	T1,		;RESTORE FLAG.
	JRST	IMGAP8

IMGAP7:	JUMPE	RIGHT,IMGAP8	;RIGHT.
	JUMPE	T,IMGP71
	MOVEI	C," "
	PUSHJ	P,SCNOUT
	SOJG	T,.-1
IMGP71:	JUMPE	F,IMGP82
	JRST	IMGP51

IMGAP8:	JUMPE	F,IMGP81	;LEFT OR EXTEND.
	ILDB	C,N
	PUSHJ	P,SCNOUT
	SOJG	F,.-2
IMGP81:	JUMPE	T,IMGP82
	MOVEI	C," "
	PUSHJ	P,SCNOUT
	SOJG	T,.-1
IMGP82:	POPJ	P,

;IMGPND ANALYZES NUM FIELD AND THEN CALLS IMGINT, INGDEC, OR IMGEXP.

COMMA=G
EXPON=E
LCOUNT=D
RCOUNT=R

IMGPND:	MOVEI	LCOUNT,2	;SET UP FLAGS.
	SETZB	COMMA,EXPON
	SETZB	RCOUNT,TRAIL
	MOVEM	C,LEAD		;SAVE TYPE OF FIELD.
IMGPN2:	JUMPE	X2,IMGINT	;SORT THRU #,$, *, AND COMMAS
	MOVE	F,X1		;IN LH OF FIELD.
	PUSHJ	P,NXCHU
	CAME	C,[XWD F.STR,43]
	CAMN	C,LEAD
	AOJA	LCOUNT,IMGPN2
	TLNN	C,F.COMA
	JRST	IMGP21
	SETO	COMMA,
	AOJA	LCOUNT,IMGPN2
IMGP21:	TLNE	C,F.PER		;NOT LH ANYMORE; DEC PT?
	JRST	IMGPN3
	TLNE	C,F.MINS	;-?
	JRST	IMGP22
	MOVE	X1,F
	AOJA	X2,IMGINT
IMGP22:	SETOM	TRAIL
	JRST	IMGINT

IMGPN3:	JUMPE	X2,IMGDEC	;MUST BE DEC OR EXP FIELD, SINCE ".".
	MOVE	F,X1
	PUSHJ	P,NXCHU
	CAME	C,[XWD F.STR,43] ;SORT THRU #,$,*, AND COMMAS IN RH.
	CAMN	C,LEAD
	AOJA	RCOUNT,IMGPN3
	TLNN	C,F.COMA
	JRST	IMGP31
	SETO	COMMA,
	AOJA	RCOUNT,IMGPN3	;-?
IMGP31:	TLNN	C,F.MINS
	JRST	.+3
	SETOM	TRAIL
	JRST	IMGDEC
	CAIN	C,"^"		;POSSIBLY EXPON?
	JRST	IMGP32
	MOVE	X1,F
	AOJA	X2,IMGDEC
IMGP32:	MOVEI	EXPON,1

IMGPN4:	JUMPN	X2,IMGP41	;REALLY 4 UP-ARROWS?
	ADDI	X2,(EXPON)
IMGP40:	SUBI	EXPON,5
	IBP	X1
	AOJL	EXPON,.-1
	HRRI	X1,-1(X1)
	JRST	IMGDEC

IMGP41:	PUSHJ	P,NXCHU
	CAIE	C,"^"
	AOJA	EXPON,IMGP40	;NOT REALLY EXPON FIELD.
	AOJ	EXPON,.+1
	CAIGE	EXPON,4
	JRST	IMGPN4
	JUMPE	X2,IMGEXP	;SEEN 4 UP-ARROWS.
	MOVE	F,X1
	PUSHJ	P,NXCHU
	TLNE	C,F.MINS	;ALSO -?
	JRST	.+3
	MOVE	X1,F
	AOJA	X2,IMGEXP
	SETOM	TRAIL
	JRST	IMGEXP

;IMGINT OUTPUTS NUMBER WITHOUT DECIMAL POINT AND WITHOUT EXPON.

IMGINT:	PUSH	P,[Z IMGIN3]
IMG0:	MOVE	C,LEAD
	CAMG	N,MINONE
	SKIPE	TRAIL
	JRST	.+3
	TLNE	C,F.DOLL+F.STAR
	JRST	IMGER4
	MOVEI	F,(LCOUNT)	;F = NO. OF PLACES FOR DIGITS AND COMMAS.
	TLNE	C,F.DOLL
	SOJA	F,CPOPJ
	SKIPN	TRAIL
	CAME	C,[XWD F.STR,43]
	POPJ	P,
	SOJA	F,CPOPJ

IMGIN3:	MOVE	A,N		;A HAS ARG.
	MOVM	N,N		;N HAS /ARG/.
	CAML	N,ONE
	JRST	IMGN31
	MOVEI	C,1		;ANSWER IS 0.
	SETZ	COMMA,
	SETZB	N,A
	JRST	IMGIN7
IMGN31:	PUSH	P,[Z IMGIN1]

IMGDE2:	SETZ	C,
	FAD	N,FIXCON
	FSB	N,FIXCON
	JUMPE	N,CPOPJ
IMGD10:	CAMG	N,D1E14
	JRST	IMGD11
	ADDI	C,^D14
	FDVR	N,D1E14
	JRST	IMGD10
IMGD11:	MOVEI	T,^D14
	CAML	N,DECTAB(T)
	JRST	IMGD12
	SOJGE	T,.-2
	SETZ	T,
	MOVE	N,DECTAB
IMGD12:	ADDI	C,1(T)
	POPJ	P,

IMGIN1:	FDVR	N,DECTAB(T)
	FMPR	N,DECTAB+8	;FORCE 9 DIGITS.
	CAMGE	N,DECTAB+8
	MOVE	N,DECTAB+8
	CAMGE	N,DECTAB+9
	JRST	IMGN44
	MOVE	N,DECTAB+8
	AOJ	C,IMGN44
IMGN44:	MOVE	T,N
	MULI	T,400
	ASH	T1,-243(T)
	MOVE	N,T1

	PUSH	P,[Z IMGIN7]
IMG1:	JUMPE	COMMA,IMGIN5	;COMMA BECOMES NO. OF ,'S TO BE OUTPUT.
	MOVEI	T,-1(C)
	IDIVI	T,3
	MOVEI	COMMA,(T)
IMGIN5:	MOVEI	T,(COMMA)
	ADDI	T,(C)
	CAIG	T,(F)
	POPJ	P,
	PUSH	P,C		;OVERFLOWS FIELD.
	MOVEI	C,"&"
	PUSHJ	P,SCNOUT
	POP	P,C
	EXCH	T,LCOUNT	;WIDEN FIELD.
	CAIE	T,(F)
	AOJA	LCOUNT,.+1
	POPJ	P,

IMGIN7:	PUSH	P,[Z IMGIN8]
IMG2:	MOVEI	T,(LCOUNT)	;OUTPUT EVERYTHING BEFORE THE DIGITS.
	MOVEI	T1,(C)
	ADDI	T1,(COMMA)
	SUBI	T,(T1)		;T = LEADING PLACES.
	MOVE	T1,LEAD
	CAMN	T1,[XWD F.STR,43]
	JRST	IMGN71
	TLNE	T1,F.DOLL
	JRST	IMGN72
	JUMPE	T,CPOPJ		;* FIELD.
	PUSH	P,C
	MOVEI	C,"*"
	PUSHJ	P,SCNOUT
	SOJG	T,.-1
	POP	P,C
	POPJ	P,
IMGN71:	SKIPN	TRAIL		;# FIELD.
	JRST	IMGN74
	JUMPE	T,CPOPJ
	PUSH	P,C
	MOVEI	C," "
	PUSHJ	P,SCNOUT
	SOJG	T,.-1
	POP	P,C
	POPJ	P,
IMGN72:	SKIPA	T1,[777777777777] ;$ FIELD.
IMGN74:	MOVEI	T1,0
IMGN76:	PUSH	P,C
	SOJLE	T,IMGN75
	MOVEI	C," "
	PUSHJ	P,SCNOUT
	SOJG	T,.-1
IMGN75:	MOVEI	C," "
	JUMPGE	A,.+2
	MOVEI	C,"-"
	JUMPE	T1,.+2
	MOVEI	C,"$"
	PUSHJ	P,SCNOUT
	POP	P,C
	POPJ	P,

IMGIN8:	JUMPN	N,IMGN81	;NOW OUTPUT DIGITS.
	PUSH	P,C
	MOVEI	C,"0"
	PUSHJ	P,SCNOUT
	POP	P,C
	JRST	IMGIN9
IMGN81:	PUSH	P,[Z IMGIN9]

INTOUT:	JUMPE	COMMA,IMGN80	;GENERAL OUTPUT ROUTINE FOR DIGITS AND COMMAS.
	MOVEI	T,-1(C)		;AT ENTRY, C= NO. OF DIGITS REQ,
	IDIVI	T,3		;N=/NUMBER/, COMMA=0 UNLESS ,'S TO BE OUTPUT.
	IMULI	T,3		;T, T1, AND N ARE DESTROYED.
	MOVEI	T1,(C)
	SUBI	T1,(T)		;N.B. - N HAS THE LEADING DIGITS.
IMGN80:	MOVE	T,N
	MOVE	N,T1
	PUSH	P,C
	PUSH	P,A
	MOVEI	A,(C)
	PUSHJ	P,.+2
	JRST	IMGN84
	IDIVI	T,^D10
	JUMPE	T,IMGN82
	PUSH	P,T1
	PUSHJ	P,.-3
	POP	P,T1
IMGN82:	JUMPE	COMMA,IMGN87
	JUMPLE	A,IMGN87
	JUMPN	N,IMGN83
	MOVEI	C,","
	PUSHJ	P,SCNOUT
	MOVEI	N,3
IMGN83:	SOJ	N,.+1
IMGN87:	SOJL	A,.+3
	MOVEI	C,60(T1)
	PUSHJ	P,SCNOUT
	POPJ	P,
IMGN84:	JUMPLE	A,IMGN86
IMGN89:	JUMPE	COMMA,IMGN88
	JUMPN	N,IMGN85
	MOVEI	C,","
	PUSHJ	P,SCNOUT
	MOVEI	N,3
IMGN85:	SOJ	N,.+1
IMGN88:	MOVEI	C,"0"
	PUSHJ	P,SCNOUT
	SOJG	A,IMGN89
IMGN86:	POP	P,A
	POP	P,C
	POPJ	P,

IMGIN9:	SETZ	T1,		;RESTORE FLAG.
	SKIPN	TRAIL
	POPJ	P,
	MOVEI	C," "		;OUTPUT TRAILING SIGN.
	JUMPGE	A,.+2
	MOVEI	C,"-"
	JRST	SCNOUT
;IMGDEC OUTPUTS NUMBERS WITH DECIMAL POINTS BUT WITHOUT EXPONENTS.

IMGDEC:	PUSHJ	P,IMG0		;ERROR CHECKING AND CALC
				;F=NO. OF PLACES FOR DIGITS AND COMMAS.
	JUMPE	N,IMGX16
	PUSH	P,N
	MOVE	A,N
	PUSHJ	P,IMGEX1
	POP	P,N
	MOVSI	T1,(0.5)	;ROUND.
	JUMPG	C,IMGD34
	CAILE	RCOUNT,9
	JRST	IMGD21
IMGD20:	FDVR	T1,DECTAB(RCOUNT)
	JRST	IMGD26
IMGD21:	MOVM	C,C
	ADDI	C,9
	CAILE	C,(RCOUNT)
	JRST	IMGD20
IMGD31:	CAIG	C,^D14
	JRST	IMGD32
	FDVR	T1,D1E14
	SUBI	C,^D14
	JRST	IMGD31
IMGD32:	FDVR	T1,DECTAB(C)
	JRST	IMGD26
IMGD34:	ADDI	C,(RCOUNT)
	CAIGE	C,9
	JRST	IMGD20
	SUBI	C,9(RCOUNT)
	JUMPGE	C,IMGD27
	MOVM	C,C
	JRST	IMGD32
IMGD27:	CAIG	C,^D14
	JRST	IMGD28
	FMPR	T1,D1E14
	SUBI	C,^D14
	JRST	IMGD27
IMGD28:	FMPR	T1,DECTAB(C)
IMGD26:	MOVM	N,N
	FADR	N,T1

	JUMPL	A,.+2
	SKIPA	A,N
	MOVN	A,N
	PUSHJ	P,IMGEX1
	JUMPL	C,IMGDE6
	MOVEI	T1,(RCOUNT)
	ADDI	T1,(C)
IMGD61:	CAILE	T1,9
	MOVEI	T1,9		;T1 IS NO. OF DIGITS REQ.
	JRST	IMGD62
IMGDE6:	MOVEI	T1,1(RCOUNT)
	ADD	T1,C
	JUMPGE	T1,IMGD61
	SETZ	T1,
IMGD62:	ADDI	T,1
	SUBI	T,(T1)
	JUMPE	T,IMGD51
	JUMPL	T,IMGD52
	FDVR	N,DECTAB(T)
	JRST	IMGD51
IMGD52:	MOVM	T,T
	FMPR	N,DECTAB(T)
IMGD51:	FAD	N,FIXCON
	FSB	N,FIXCON
	JUMPN	T1,.+3
	SETZ	N,
	JRST	IMGD53
	CAMGE	N,DECTAB-1(T1)
	MOVE	N,DECTAB-1(T1)
	CAMGE	N,DECTAB(T1)
	JRST	.+3
	MOVE	N,DECTAB-1(T1)
	AOJ	C,.+1
IMGD53:	PUSH	P,A
	MOVEI	A,(T1)
	MOVE	T,N
	MULI	T,400
	ASH	T1,-243(T)
	MOVE	T,T1
	SETZB	T1,N
	JUMPLE	C,IMGD64
	CAIL	C,(A)
	JRST	IMGD69
	SUBI	A,(C)
	IDIV	T,INTTAB(A)
	MOVEI	N,(A)
	JUMPE	T1,.+4
	CAMGE	T1,INTTAB(A)
	SOJA	A,.-1
	SUBI	N,1(A)
	JRST	IMGD69
IMGD64:	MOVE	T1,T
	SETZ	T,
	MOVM	N,C
	CAILE	N,(RCOUNT)
	MOVEI	N,(RCOUNT)
IMGD69:	POP	P,A
	JUMPGE	A,IMGDE7	;CHECK AGAIN FOR NEG. * OR $ FIELD.
	SKIPE	TRAIL
	JRST	IMGDE7
	PUSH	P,N
	MOVE	N,LEAD
	TLNE	N,F.DOLL+F.STAR
	JRST	.+3
	POP	P,N
	JRST	IMGDE7
	POP	P,N
	JUMPN	T,IMGER4
	JUMPN	T1,IMGER4

IMGDE7:	PUSH	P,T1
	PUSH	P,N
	JUMPG	C,.+2
	MOVEI	C,1
	PUSH	P,T
	PUSHJ	P,IMG1
	PUSHJ	P,IMG2		;OUTPUT EVERYTHING BEFORE THE DIGITS.
	POP	P,N
	PUSHJ	P,INTOUT	;OUTPUT LH DIGITS AND COMMAS.
	MOVEI	C,"."
	PUSHJ	P,SCNOUT
	POP	P,N
	POP	P,T
	PUSHJ	P,INTTRA	;OUTPUT RH SIDE.
	JRST	IMGIN9

IMGX16:	SETZB	COMMA,A		;ZERO ARG.
	MOVEI	C,1
	PUSHJ	P,IMG2		;LEADING *,$, ETC.
	PUSHJ	P,IMGX17
	JRST	IMGIN9

;IMGEXP OUTPUTS NUMBERS WITH DECIMAL POINTS AND EXPONENTS.

IMGEXP:	MOVE	T,LEAD
	TLNE	T,F.STAR+F.DOLL
	JRST	IMGER3

	JUMPE	N,IMGEX8

	MOVEI	F,(LCOUNT)	;F= NO. OF PLACES FOR DIGITS IN LH.
	SKIPN	TRAIL
	SOJ	F,.+1
	JUMPE	COMMA,IMGEX4
	MOVEI	T,-1(F)
	IDIVI	T,4
	SUBI	F,(T)
	AOJ	T,.+1
	IMULI	T,3
	CAILE	F,(T)
	MOVEI	F,(T)

IMGEX4:	MOVEI	T1,(F)
	ADDI	T1,(RCOUNT)
	CAILE	T1,9
	MOVEI	T1,9
	PUSH	P,[Z IMGEX2]

	MOVE	A,N		;NUMBER TO A.
IMGEX1:	MOVM	N,N		;/NUMBER/ TO N.
	SETZ	C,		;C = TRUE EXPONENT.
IMGE51:	CAMG	N,D1E14
	JRST	IMGE50
	ADDI	C,^D14
	FDVR	N,D1E14
	JRST	IMGE51
IMGE50:	CAML	N,ONE
	JRST	IMGE52
	SUBI	C,^D14
	FMPR	N,D1E14
	JRST	IMGE50
IMGE52:	MOVEI	T,^D14
	CAML	N,DECTAB(T)
	JRST	IMGE53
	SOJGE	T,.-2
	MOVE	N,DECTAB
	SETZ	T,
IMGE53:	ADDI	C,1(T)
	POPJ	P,

IMGEX2:	SUBI	T,-1(T1)
	JUMPE	T,IMGE54
	JUMPL	T,.+3
	FDVR	N,DECTAB(T)
	JRST	IMGE54
	MOVM	T,T
	FMPR	N,DECTAB(T)
IMGE54:	FADRI	N,200400	;ROUND.
	FAD	N,FIXCON
	FSB	N,FIXCON
	PUSH	P,[Z IMGEX9]

IMGDIV:	CAMGE	N,DECTAB-1(T1)	;GET LH AND RH IN
	MOVE	N,DECTAB-1(T1)	;T AND T1 IN FIXED POINT.
	CAMGE	N,DECTAB(T1)
	JRST	IMGEX7
	MOVE	N,DECTAB-1(T1)
	AOJ	C,IMGEX7
IMGEX7:	MOVE	T,N
	CAIL	F,(T1)
	JRST	IMGE71
	PUSH	P,A
	MOVEI	A,(T1)
	SUBI	A,(F)
	MULI	T,400
	ASH	T1,-243(T)
	MOVE	T,T1
	IDIV	T,INTTAB(A)
	MOVEI	N,(A)
	JUMPE	T1,.+4
	CAMGE	T1,INTTAB(A)
	SOJA	A,.-1
	SUBI	N,1(A)
	POP	P,A
	POPJ	P,		;T HAS LEADING NUMBER OF DIGITS.
IMGE71:	MULI	T,400		;T1 HAS TRAILING NO. OF DIGITS.
	ASH	T1,-243(T)
	MOVE	T,T1		;N HAS NO. OF LEADING ZEROES IN FRONT OF T1.
	SETZB	T1,N
	POPJ	P,

IMGEX9:	SUBI	C,(F)
	CAIGE	C,^D100
	CAMG	C,[-^D100]
	JRST	.+2
	JRST	IMGE91
	PUSH	P,C
	MOVEI	C,"&"
	PUSHJ	P,SCNOUT
	POP	P,C
IMGE91:	SKIPE	TRAIL
	JRST	IMGX10
	PUSH	P,C
	MOVEI	C," "
	JUMPGE	A,.+2
	MOVEI	C,"-"
	PUSHJ	P,SCNOUT
	POP	P,C

IMGX10:	PUSH	P,C
	MOVEI	C,(F)		;NO. OF DIGITS TO C.
	PUSH	P,T1
	PUSH	P,N
	MOVE	N,T		;N = NUMBER.
	PUSHJ	P,INTOUT
	MOVEI	C,"."
	PUSHJ	P,SCNOUT
	POP	P,N
	POP	P,T
	PUSH	P,[Z IMGX12]

INTTRA:	JUMPE	RCOUNT,CPOPJ	;OUTPUT RH SIDE.
	JUMPLE	N,INTTR0
	MOVEI	C,"0"
	PUSHJ	P,SCNOUT
	SOJ	RCOUNT,.+1
	SOJG	N,.-2
	JUMPE	RCOUNT,CPOPJ
INTTR0:	PUSHJ	P,.+2
	JRST	INTTR2
	IDIVI	T,^D10
	JUMPE	T,INTTR1
	PUSH	P,T1
	PUSHJ	P,.-3
	POP	P,T1
INTTR1:	SOJL	RCOUNT,CPOPJ
	MOVEI	C,60(T1)
	JRST	SCNOUT
	SOJA	RCOUNT,CPOPJ
INTTR2:	JUMPLE	RCOUNT,CPOPJ
	MOVEI	C,"0"
	PUSHJ	P,SCNOUT
	SOJG	RCOUNT,.-1
	POPJ	P,


IMGX12:	POP	P,N
IMGX11:	MOVEI	C,"E"		;PRINT EXPONENT.
	PUSHJ	P,SCNOUT
	MOVEI	C,"+"
	JUMPGE	N,.+2
	MOVEI	C,"-"
	PUSHJ	P,SCNOUT
	MOVM	T,N
	IDIVI	T,^D10
	CAIGE	T,^D10
	JRST	IMGX13
	PUSH	P,T1
	IDIVI	T,^D10
	MOVEI	C,60(T)
	PUSHJ	P,SCNOUT
	MOVE	T,T1
	POP	P,T1
IMGX13:	MOVEI	C,60(T)
	PUSHJ	P,SCNOUT
	MOVEI	C,60(T1)
	PUSHJ	P,SCNOUT
	JRST	IMGIN9

IMGEX8:	SOJ	LCOUNT,.+1	;EXP FIELD IS 0.
	MOVEI	C," "
	PUSHJ	P,SCNOUT
	SOJG	LCOUNT,.-1
	PUSH	P,[Z IMGE81]
IMGX17:	MOVEI	C,"0"
	PUSHJ	P,SCNOUT
	MOVEI	C,"."
	PUSHJ	P,SCNOUT
	JUMPE	RCOUNT,CPOPJ
	MOVEI	C,"0"
	PUSHJ	P,SCNOUT
	SOJG	RCOUNT,.-1
	POPJ	P,
IMGE81:	SETZB	N,A
	JRST	IMGX11

INTTAB:	^D1
	^D10
	^D100
	^D1000
	^D10000
	^D100000
	^D1000000
	^D10000000
	^D100000000
	^D1000000000

;RESTORE DATA POINTER

RESTOR:	PUSHJ	P,RESTOS	;RESTORE BOTH NUMBERS AND STRINGS
RESTON:	TDZA	X1,X1		;RESTORE NUMERIC DATA
RESTOS:	MOVEI	X1,1		;RESTORE STRINGS
	MOVE	T,DATAFF
	ADD	T,FLLIN
	SUB	T,[XWD 1,1]
	MOVEM	T,DATLIN(X1)
	SETZM	PREAD(X1)		;CLEAR CURRENT LINE POINTER
	POPJ	P,


NXRE2:	PUSHJ	P,INLMES	;OUT OF DATA
	ASCIZ	/
? OUT OF DATA/
	HRRZ	T,L
	JRST	GOSR2

INERR:	PUSHJ	P,INLMES
	ASCIZ/
? DATA FILE LINE TOO LONG/
	JRST	GOSR2

PTXER1:	PUSHJ	P,INLMES
	ASCIZ	/
? ILLEGAL CHARACTER IN STRING/
	JRST	GOSR2

FNMX0:	MOVEI	LP,(X1)
FNMXER:	SKIPN	ACTBL-1(LP)
	JRST	FNR
FNMX1:	PUSHJ	P,INLMES
	ASCIZ	/
? MIXED RANDOM & SEQ. ACCESS/
	JRST	GOSR2

PTXER2:	PUSHJ	P,INLMES
	ASCIZ	/
? OUTPUT ITEM TOO LONG FOR LINE/
	JRST	GOSR2


IMP:	PUSHJ	P,INLMES
	ASCIZ	/
? BAD DATA/
	JRST	GOSR2

FNR:	PUSHJ	P,INLMES
	ASCIZ/
?  FILE NEVER ESTABLISHED - REFERENCED/
	JRST	GOSR2

LKFAIL:	PUSHJ	P,INLMES
	ASCIZ	/
? FAILURE ON LOOKUP/
	JRST	GOSR2

ENFAIL:	PUSHJ	P,INLMES
	ASCIZ	/
? FAILURE ON ENTER/
	JRST	GOSR2


ILWRT:	PUSHJ	P,INLMES
	ASCIZ	/
? ILLEGAL DSK WRITE/
	JRST	GOSR2
ILRD:	PUSHJ	P,INLMES
	ASCIZ	/
? ILLEGAL DSK READ/
	JRST	GOSR2

RANSRF:	PUSHJ	P,INLMES
	ASCIZ	/
? CANNOT ERASE FILE ON CHANNEL /
RAN2:	HRRZ	T,LP
	PUSHJ	P,PRTNUM
	JRST	GOSR2

LOKFAL:	SETZM	ODF
	PUSHJ	P,INLMES
	ASCIZ/
? FILE NOT FOUND BY RESTORE COMMAND/
	JRST	GOSR2

EOFFAL:	POP	P,X1
EOFFL:	PUSHJ	P,INLMES
	ASCIZ/
? EOF/
	JRST	GOSR2


CHAERR:	PUSHJ	P,INLMES
	ASCIZ	/
? LINE NUMBER/
	JRST	OUTBND
RNERR1:	PUSHJ	P,INLMES
	ASCIZ	/
? MIXED STRINGS AND NUMBERS/
	JRST	GOSR2

RNERR2:	PUSHJ	P,INLMES
	ASCIZ	/
? OUTPUT STRING LENGTH > RECORD LENGTH/
	JRST	GOSR2

RNERR3:	PUSHJ	P,INLMES
	ASCIZ	/
? FILE NOT IN CORRECT FORM/
	JRST	GOSR2

CHAER1:	PUSHJ	P,INLMES
	ASCIZ	/
? ILLEGAL FILENAME/
	JRST	GOSR2

WRPRER:	PUSHJ	P,INLMES
	ASCIZ	"
? MIXED WRITE#/PRINT#"
	JRST	GOSR2

SCNER1:	PUSHJ	P,INLMES
	ASCIZ	/
? NO FIELDS IN IMAGE/
	JRST	GOSR2

SCNER2:	PUSHJ	P,INLMES
	ASCIZ	/
? IMPROPER FIELD/
	JRST	GOSR2

SCNER3:	PUSHJ	P,INLMES
	ASCIZ	/
? OUTPUT LINE > 132 CHARACTERS/
	JRST	GOSR2

IMGER1:	PUSHJ	P,INLMES
	ASCIZ	/
? NO CHARACTERS IN IMAGE/
	JRST	GOSR2

IMGER2:	PUSHJ	P,INLMES
	ASCIZ	/
? > 132 CHARACTERS IN IMAGE/
	JRST	GOSR2

IMGER3:	PUSHJ	P,INLMES
	ASCIZ	/
? EXPONENT REQUESTED FOR * OR $ FIELD/
	JRST	GOSR2

IMGER4:	PUSHJ	P,INLMES
	ASCIZ	/
? ATTEMPT TO OUTPUT A NEGATIVE NUMBER TO A * OR $ FIELD/
	JRST	GOSR2

MARERR:	PUSHJ	P,INLMES
	ASCIZ	/
? MARGIN TOO SMALL/
	JRST	GOSR2

REINER:	PUSHJ	P,INLMES
	ASCIZ	"
? MIXED READ#/INPUT#"
	JRST	GOSR2

MARER1:	PUSHJ	P,INLMES
	ASCIZ	/
? MARGIN /

INTERNAL SETERR
SETERR:	PUSHJ	P,INLMES
	ASCIZ	/
? SET ARGUMENT/
	JRST	OUTBND
OUTBND:	PUSHJ	P,INLMES
	ASCIZ	/ OUT OF BOUNDS/
	JRST	GOSR2

PAGERR:	PUSHJ	P,INLMES
	ASCIZ	/
? PAGE LENGTH/
	JRST	OUTBND

EXTERN STSTRP
TRPMSG:	HLRZ	T,TRPLOC+3
	SETZM	TRPLOC+2
	SETZM	TRPLOC+3
	DPB	T,[POINT 4,STSTRP,12]
	XCT	STSTRP
	MOVEI	T,TRPMS1
	JRST	ERRMSG
TRPMS1:	ASCIZ	/
? DEVICE OK?
/
;RUNTIME MAT INPUT ROUTINE

MATIN:	SETZM	IFIFG
	PUSHJ	P,DOINPT	;SETUP INPUT LOOP
	HRRZ	X1,40		;GET VECTOR 2-WD BLOCK ADDRESS
	HRRZ	X2,(X1)		;GET ADDRESS OF FIRST ELEMENT
	MOVEM	X2,NUMRES	;SAVE THIS VALUE FOR COUNTING ELEMENTS LATER
	HLRZ	X1,(X1)		;GET MAXIMUM VECTOR SIZE
	ADD	X1,X2		;UPPER BOUND OF VECTOR
	SUBI	X1,1
	MOVEM	X1,ELETOP	;SAVE FOR COMPARISON LATER
	HRRM	X2,40		;SET UP ELEMENT ADDRESS FOR DATA ROUTINES

MATIN1:	MOVEI	X1,MATIN4	;POINT "INPUT ERR" TO SPECIAL ROUTINE
	HRL	X1,40		;REMEMBER FIRST ELEMENT ON LINE
	MOVEM	X1,INPFLA
	PUSHJ	P,NXVINP	;INPUT THE LINE

MATIN5:	CAIA		;THERE IS ANOTHER ELEMENT.
	JRST	MATIN6	;NULL LINE. NO MORE ELEMENTS.
	HRRZ	X1,40		;MAY WE ACCEPT ANOTHER ELEMENT?
	CAML	X1,ELETOP
	JRST	MATIN3		;NO
	AOS	40		;POINT TO NEXT ELEMENT
	PUSH	P,[EXP MATIN2]	;YES. SETUP RETURN FROMDATA ROUTINE
IFN FTSTR,<
	CAML	X1,SVRBOT	;NUMBER OR STRING VECTOR?
	JRST	SDATAE		;STRING
>
	JRST	DATAER		;NUMBER

MATIN2:	TLNE	C,F.CR		;END OF INPUT?
	JRST	MATIN6		;YES, SET UP "NUM" FUNCTION AND RETURN.
	CAIE	C,"&"
	JRST	MATIN7
	MOVE	T,(R)
	PUSHJ	P,NXCH
	TLNN	C,F.CR
	JRST	INPERR
	JRST	MATIN1
MATIN7:	TLNN	C,F.COMA
	JRST	INPERR
	MOVE	T,(R)
	PUSHJ	P,NXCH
	TLNE	C,F.CR
	JRST	MATIN6
	CAIE	C,"&"
	JRST	MATIN5
	PUSHJ	P,NXCH
	TLNN	C,F.CR
	JRST	MATIN5
	JRST	MATIN1

MATIN3:	PUSHJ	P,INLMES
	ASCIZ /
? TOO MANY ELEMENTS/
	SKIPE	CHAFL2
	PUSHJ	P,ERRMS3
	PUSHJ	P,INLMES
	ASCIZ	/-- RETYPE LINE
/
	JRST	INPER1

MATIN4:	HLRZ	X1,INPFLA	;AN ERROR HAS OCCURRED. START LINE OVER
	HRRM	X1,40		;WITH SAME ELEMENT
	JRST	MATIN1

MATIN6:	HRRZ	X1,40		;CALCULATE NUMBER OF ELEMENTS
	SUB	X1,NUMRES
	TLO	X1,233400	;FLOAT  RESULT
	FSB	X1,FIXCON
	MOVEM	X1,NUMRES
	POPJ	P,
	EXTERN	QUOFL1

IFN FTSTR,<
REDSTR:	SKIPE	INPFLA
	JRST	REDS9
	TLNN	C,F.LETT+F.QUOT
	POPJ	P,
REDS9:	SKIPN	IFIFG
	SKIPN	INPFLA
	JRST	.+3
	TLNE	C,F.COMA	;TEST FOR LEADING COMMA FOR INPUT.
	POPJ	P,
	AOS	(P)		;THIS IS A LEGITIMATE STRING
	PUSH	P,G
	PUSH	P,E
	PUSHJ	P,GETSTR
	MOVEI	N,(X1)
	MOVE	G,T
	SETZ	T,
	PUSHJ	P,VCHCKC	;MAKE SPACE
	EXCH	G,T
	SKIPN	IFIFG
	JRST	REDS4
	MOVEI	X1,F.COMA+F.CR+F.SPTB+F.QUOT
	JRST	REDS3
REDS4:	MOVEI	X1,F.COMA+F.CR	;ASSUME A STRING WITHOUT QUOTES
	SKIPN	INPFLA
	ADDI	X1,F.APOS
REDS3:	SETZM	QUOFL1
	TLNN	C,F.QUOT	;IS IT A QUOT STRING?
	JRST	REDS1		;NO
	SETOM	QUOFL1
	MOVEI	X1,F.QUOT+F.CR
	PUSHJ	P,NXCHD		;SKIP QUOTE
REDS1:	MOVE	X2,N
	SKIPE	(X2)		;NEW STRING?
	SETZM	VPAKFL		;NO, GARBAGE NOW EXISTS
	SETZ	X2,		;INITIALIZE COUNT.
	HRRI	F,(G)		;GET FREE LOCATION
	PUSH	P,T
	MOVE	T,N
	HRRM	F,(T)
	POP	P,T
REDS2:	TLNN	C,(X1)
	JRST	REDS6
	SKIPE	QUOFL1
	JRST	REDQOT
	TLNN	C,F.QUOT
	JRST	REDS8
REDS7:	POP	P,E
	POP	P,G
	SOS	(P)
	POPJ	P,
REDQOT:	TLNN	C,F.QUOT
	JRST	REDS7
	PUSHJ	P,NXCHD
	JRST	REDS8
REDS6:	IDPB	C,F		;STORE A CHAR
	PUSHJ	P,NXCHD
	SOJA	X2,REDS2	;COUNT THE CHAR

REDS8:	HRRZ	X1,F		;GET NEW FREE LOCATION
	POP	P,E
	MOVE	G,N
	HRLM	X2,(G)
	POP	P,G
	AOJ	X1,
	HRRM	X1,VARFRE
	POPJ	P,

SSKIP:	SKIPE	INPFLA		;IS THIS INPUT OR READ?
	JRST	SSKP1		;INPUT. CANT SKIP ANY FIELDS
	PUSHJ	P,SKIPDA	;SKIP OVER A DATA FIELD
	HALT	.		;IMPOSSIBLE ERROR
	POP	P,X1
	TLNE	C,F.TERM	;END OF DATA LINE?
	JRST	-10(X1)		;YES. FORCE DATA SEARCH
	JRST	-7(X1)		;RETURN TO DATAER OR SDATAE

SSKP1:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSH LIST
	JRST	INPERR

;ROUTINE THAT SKIPS OVER ONE DATA FIELD
SKIPDA:	TLNE	C,F.QUOT	;QUOTE STRING?
	JRST	QSKIP		;YES, USE QSKIP ROUTINE
	TLNE	C,F.COMA+F.TERM	;FIELD TERMINATOR?
	JRST	CPOPJ1
	PUSHJ	P,NXCH	
	JRST	.-3
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

IFE FTSTR,<
SKIPDA:	POPJ	P,	;STRINGS NOT ALLOWED. DATA ERROR
SSKIP:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSHLIST
	JRST	INPERR
>
	SUBTTL	RUN-TIME ROUTINES FOR PRINTING

FINPNT:	MOVE	X1,FMTPNT(LP)	;FINISH WITH CR?
	CAIE	X1,1
	POPJ	P,
	SETOM	ZONFLG(LP)
	PUSHJ	P,PCRLF
FINPT4:	JUMPN	LP,.+2
	OUTPUT 0,
	POPJ	P,


PCRLF:  MOVEI	C,15		;ROUTINE TO END A LINE AND
	PUSHJ	P,OUCH		;POSSIBLY BEGIN A NEW LINE.
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZM	TABVAL(LP)
	SETZM	HPOS(LP)
	SKIPG	C,PAGLIM(LP)
	JRST	PCRLF2
	AOS	PAGCNT(LP)
	CAME	C,PAGCNT(LP)
	JRST	PCRLF2
	MOVEI	C,14
	PUSHJ	P,OUCH
	SETZM	HPOS(LP)
	SETZM	PAGCNT(LP)
PCRLF2:	SKIPE	C,MARWAI(LP)
	MOVEM	C,MARGIN(LP)
	JUMPE	LP,FINPT3
	MOVE	C,MARGIN(LP)
	CAIL	C,^D7
	JRST	.+3
	SKIPGE	WRIPRI-1(LP)
	JRST	MARERR
FINPT3:	HRRZ	X2,(P)
	CAIE	X2,FINPT4
	CAIN	X2,CRLF8
	POPJ	P,
	CAIE	X2,ENDIM2
	PUSHJ	P,NUMINS
	POPJ	P,

CRLF:	MOVE	C,HPOS(LP)	;ROUTINE USED BY "EMPTY" OUTPUT
	ADD	C,TABVAL(LP)	;STATEMENTS, AND RESTORE AND UXIT.
	JUMPE	C,CRLF4
	JUMPE	LP,CRLF5
	CAIN	C,^D6
	SKIPL	WRIPRI-1(LP)
	JRST	.+2
	JRST	CRLF3
CRLF5:	PUSHJ	P,PCRLF
CRLF8:	JRST	CRLF2
CRLF4:	PUSHJ	P,PCRLF2
CRLF3:	MOVEI	C,15
	PUSHJ	P,OUCH
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	SKIPG	T,PAGLIM(LP)
	JRST	CRLF2
	AOS	PAGCNT(LP)
	CAME	T,PAGCNT(LP)
	JRST	CRLF2
	MOVEI	C,14
	PUSHJ	P,OUCH
	SETZM	PAGCNT(LP)
CRLF2:	SETZM	HPOS(LP)
CRLF1:	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	JUMPN	LP,.+2
	OUTPUT 0,
	SETOM	FIRSFL(LP)
	POPJ	P,


;RUN-TIME NUMBER PRINTER

PRNMER:	PUSHJ	P,FIRCHK
	PUSHJ	P,MARCHK
	PUSHJ	P,TABBR
	SKIPGE	TABVAL(LP)
	PUSHJ	P,PCRLF
	PUSHJ	P,NUMINS
	MOVE	N,@40		;GET THE NUMBER
	PUSHJ	P,OUTNUM
	AOS	TABVAL(LP)	;CAUSE A SPACE TO FOLLOW NUMBER.
	SETZM	ZONFLG(LP)
	JRST	FINPNT

;RUN-TIME TAB PRINTER

PRNTBR:	PUSHJ	P,FIRCHK
	PUSHJ	P,MARCHK
	PUSHJ	P,TABBR		;CALCULATE AMOUNT OF SPACING REQUESTED BY
				;LAST FORMAT CHAR.  ADD THAT TO "TABVAL".
	SKIPGE	B,TABVAL(LP)	;IGNORE ZERO AND MINUS TABS.
	PUSHJ	P,PCRLF
	JUMPL	N,FINPNT
	PUSHJ	P,NUMINS
	PUSHJ	P,IFIX
	MOVE	X1,N
	MOVE	N,MARGIN(LP)
	IDIV	X1,N
	SUB	X2,HPOS(LP)
	SUB	X2,TABVAL(LP)
	JUMPL	X2,FINPNT
	ADDM	X2,TABVAL(LP)	;NO, ADD THE DIFFERENCE TO THE SPACING  REQUEST
	SETOM	ZONFLG(LP)
	JRST	FINPNT

;RUNTIME DELIMITER SPACING ROUTINE.

PRDLER:	PUSHJ	P,FIRCHK
	PUSHJ	P,MARCHK
	SKIPE	X1,FMTPNT(LP)
	CAIN	X1,4
	SETOM	ZONFLG(LP)
	PUSHJ	P,TABBR
	SKIPGE	TABVAL(LP)
	PUSHJ	P,PCRLF
	PUSHJ	P,NUMINS
	JRST	FINPNT

FIRCHK:	SKIPN	FIRSFL(LP)
	POPJ	P,
	PUSHJ	P,PCRLF2
	SETZM	FIRSFL(LP)
	POPJ	P,

MARCHK:	SKIPN	T,HPOS(LP)
	JRST	MARCH2
	JUMPE	LP,CPOPJ
	CAIN	T,^D6
	SKIPL	WRIPRI-1(LP)
	POPJ	P,
MARCH2:	SKIPE	T,MARWAI(LP)
	MOVEM	T,MARGIN(LP)
	POPJ	P,


NUMINS:	JUMPE	LP,CPOPJ
	SKIPGE	WRIPRI-1(LP)	;NEED A LINE NUMBER?
	SKIPE	HPOS(LP)
	POPJ	P,		;NO.
	MOVEI	X2,12		;YES.
	ADDB	X2,LINNUM-1(LP)
	CAILE	X2,^D99999
	JRST	NUMLRG
	PUSH	P,T
	MOVE	T,@OUTCNT-1(LP)
	JUMPLE	T,NUMIN2
	IDIVI	T,5
	JUMPE	T1,NUMIN2
	SETZ	C,		;PAD WITH NULLS SO THAT THE LINE
	PUSHJ	P,OUCH		;NUMBER STARTS IN A NEW WORD.
	SOJG	T1,.-2
NUMIN2:	MOVE	T,LINNUM-1(LP)
	SETZM	NUMCOT
	PUSHJ	P,PRTNUM
	MOVEI	T,5
	MOVEM	T,HPOS(LP)
	MOVE	T,NUMCOT
	SUBI	T,5
	MOVE	T1,@OUTPT-1(LP)
	MOVE	T1,(T1)
	JUMPE	T,NUMIN3
NUMIN4:	LSH	T1,-7		;PAD WITH LEADING ZEROES (RE-
	TLO	T1,300000	;QUIRED BY THE LINED CUSP).
	IBP	@OUTPT-1(LP)
	SOS	@OUTCNT-1(LP)
	AOJL	T,NUMIN4
NUMIN3:	TRO	T1,1		;SET THE "SEQ. NO." BIT.
	MOVE	T,@OUTPT-1(LP)
	MOVEM	T1,(T)
	POP	P,T
	MOVEI	C,11		;TAB.
	PUSHJ	P,OUCH
	POPJ	P,

EXTERN	NUMCOT


NUMLRG:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
? ATTEMPT TO WRITE A LINE NUMBER > 99,999/
	JRST	GOSR2

;TAB CONTROL

;"TABBER" CALLS "TABBR" AND THEN MOVES SPACES OR A CRLF TO THE TTYOUT BUFFER.
;"TABBR" ANALYSES THE LAST FORMAT CHARACTER USING "TABB0", "TABB1", AND
;"TABB3", WHICH HANDLE THE <PA>, COMMA, AND SEMICOLON, RESPECTIVELY.
;"TABVAL" CONAINS THE NUMBER OF SPACES WAITING TO BE TYPED OUT
;(OR IS NEGATIVE IF A <RETURN> MUST FOLLOW.)


TABBER:	PUSHJ	P,TABBR		;PROCESS LAST FORMAT CHAR
	MOVEI	X1,0		;TABBER CALLS ALLOW A PRINT FIELD OF ANY SIZE
CHROOM:	MOVE	B,TABVAL(LP)
	ADD	X1,B		;TOTAL SPACE NEEDED FOR FIELD
	ADD	X1,HPOS(LP)
	CAMLE	X1,MARGIN(LP)
	JRST	PCRLF		;NO ROOM, GO TO NEXT LINE.
	JUMPL	B,PCRLF
	JUMPE	B,CPOPJ		;NO SPACING TO DO.
	MOVEI	C," "		;HERE TO PUT OUT SPACES
	PUSHJ	P,OUCH
	SOJG	B,.-2
	SETZM	TABVAL(LP)
	POPJ	P,

TABBR:	LDB	X1,[POINT 4,40,12]
	EXCH	X1,FMTPNT(LP)	;GET OLD POSITION AND SAVE NEW FORMAT
	SKIPGE	A,TABVAL(LP)
	POPJ	P,
	ADD	A,HPOS(LP)
	JRST	.+1(X1)
	POPJ	P,		;NO FMT CHAR
	POPJ	P,		;<CR> WAS TYPED WHEN FIRST SEEN.
	JRST	TABB3		;SEMICOLON
	JRST	TABB1		;COMMA
TABB0:	PUSH	P,FMTPNT(LP)	;<PA>
	PUSHJ	P,PAGE1
	POP	P,FMTPNT(LP)
	POPJ	P,
TABB1:	MOVE	X1,MARGIN(LP)
	JUMPE	LP,.+3
	SKIPGE	WRIPRI-1(LP)	;FIRST ZONE STARTS AFTER LINE NUMBER.
	SUBI	X1,6
	IDIVI	X1,^D14
	SUBI	X1,1
	IMULI	X1,^D14
	JUMPE	LP,.+3
	SKIPGE	WRIPRI-1(LP)
	SUBI	A,6
	CAMLE	A,X1
	JRST	SETCR
	IDIVI	A,^D14
	JUMPE	B,.+3
	SETOM	ZONFLG(LP)
	JRST	TABB2
	SKIPN	ZONFLG(LP)
	JRST	.+3
	MOVEI	B,^D14
	JRST	TABB31
	SETOM	ZONFLG(LP)
	POPJ	P,
TABB2:	SUBI	B,^D14
	MOVNS	B
TABB31:	ADDM	B,TABVAL(LP)
	POPJ	P,

TABB3:	MOVE	X1,MARGIN(LP)
	CAML	A,X1
	JRST	SETCR
	POPJ	P,

SETCR:	SETOM	TABVAL(LP)		;FORCE <RETURN TO BE NEXT>
	POPJ	P,

IFN FTSTR,<
	SUBTTL  RUN-TIME STRING MANIPULATION ROUTINES.


;GETSTR IS CALLED WITH THE ADDRESS OF A POINTER IN REG.
;THE ROUTINE SETS UP THE POINTER IN F, AND THE NEGATIVE COUNT OR
;(FOR LITERAL STRINGS) A POSITIVE QUANTITY IN G. (G=0 IF NULL STRING)

GETSTR:	PUSHJ	P,PNTADR	;GET ADDRESS OF STRING POINTER
	MOVE	F,(X1)
	HLRE	G,F		;PUT NEGATIVE CHAR LENGTH IN G, IF NOT APP BLK OR 0.
	JUMPG	G,CPOPJ
	HRLI	F,440700	;NOTAPP BLK, INITIALIZE POINTER.
	POPJ	P,

;ROUTINE TO SET UP A NUMBER VECTOR INSTEAD OF A STRING
GETVEC:	HRRZ	F,@40		;THE LEFT SIDE OF (F) IS ZERO, IMPLYING VECTOR ADR,
	MOVE	G,(F)		;GET VECTOR LENGTH
	JUMPL	G,GETVF		;NEGATIVE? 
	FAD	G,FIXCON	;FIX THE LENGTH
	TLZ	G,777400
	HLRZ	X1,@40		;DOES THE LENGTH EXCEED VECTOR BOUNDS?
	MOVNS	G
	ADD	X1,G
	JUMPLE	X1,.+2
	AOJA	F,CPOPJ		;NO. POINT TO FIRST "CHAR" AND RETURN

GETVF:	PUSHJ	P,INLMES
	ASCIZ /
? IMPOSSIBLE VECTOR LENGTH/
	JRST GOSR2

;ROUTINE TO GET NEXT VECTOR ELE AS A CHARACTER
GETEL:	AOJG	G,CPOPJ		;IS THERE ANOTHER ELEMENT?
	MOVE	C,(F)		;YES. GET IT
	JUMPL	C,GETELF		;TOO SMALL TO BE AN ASCII
	PUSH	P,R
	LDB	R,[POINT 8,C,8]		;GET EXPONENT
	TLZ	C,777000		;TURN IT OFF
	LSH	C,-233(R)		;SHIFT INTO INTEGER POSTION
	POP	P,R
	CAIGE	C,^D128
	CAIGE	C,1
	JRST	GETELF
	CAIG	C,^D12
	CAIGE	C,^D10
	AOJA	F,CPOPJ1
	JRST	GETELF
	AOJA	F,CPOPJ1	;BUMP ELEMENT POINTER AND RETURN

GETELF:	PUSHJ	P,INLMES
	ASCIZ /
? ILLEGAL CHAR SEEN/
	JRST	GOSR2

;ROUTINE TO STORE "NUMERIC" CHARS INTO A STR.
STRCHA:	PUSHJ	P,PNTADR
	MOVM	T,G		;GETVEC SET UP F AND G.
	PUSH	P,X1
	PUSHJ	P,VCHCKC
	POP	P,X1
	SKIPE	(X1)
	SETZM	VPAKFL
	MOVEM	T,(X1)

	HRLM	G,(X1)
	HRLI	T,440700
STRCH1:	PUSHJ	P,GETEL
	JRST	CPOPJ
	IDPB	C,T
	JRST	STRCH1


;ROUTINE TO MOVE "STRING" CHARS INTO A VECTOR
PUTVEC:	TLNN	N,777777
	JRST	PUTV3
	TLNE	N,377777
	JRST	PUTV2
	MOVE	T,N
	MOVE	N,(T)
	JRST	PUTV3
PUTV2:	JUMPLE	N,PUTV3
	PUSHJ	P,STRETT
PUTV3:	HLRE	G,N
	HRRZ	F,N
	HRLI	F,440700
	HRRZ	X1,40
	HRRZ	N,(X1)		;SAVE FIRST LOC ADDRESS FOR LENGTH STORE
	HLRZ	X2,(X1)		;GET SIZE
	HRRZ	X1,(X1)

PUTV1:	JUMPE	G,PUTV9		;GET CHAR.
	ILDB	C,F
	AOJ	G,.+1
	SOJL	X2,PUTVF	;ROOM FOR ANOTHER CHAR?
	TLO	C,233400	;YES. FLOAT IT
	FSB	C,FIXCON
	MOVEM	C,1(X1)
	AOBJP	X1,PUTV1	;COUNT CHARS IN LEFT HALF OF X1

PUTV9:	HLRZ	X1,X1		;GET SIZE
	HRLI	X1,233400	;FLOAT IT
	FSB	X1,FIXCON
	MOVE	X2,N
	MOVEM	X1,(X2)		;FIRST ELEMENT GETS SIZE
	POPJ	P,

PUTVF:	PUSHJ	P,INLMES
	ASCIZ /
? NO ROOM FOR STRING/
	JRST	GOSR2


;STORE STR FOR LET STATEMENT.
PUTSTR:	TLNN	N,777777
	JRST	PUTST2
	TLNE	N,377777
	JRST	PUTST1
	MOVE	T,N
	MOVE	N,(T)
PUTST1:	JUMPG	N,PUTST4
PUTST2:	HLRE	G,N
	MOVM	T,G
	AOS	F,MASAPP
	MOVEM	N,(F)
	PUSHJ	P,VCHCKC
	MOVE	N,(F)
	SOS	MASAPP
	HRRZ	F,N
	HRLI	F,440700
	PUSHJ	P,PNTADR
	SKIPE	(X1)
	SETZM	VPAKFL
	HRRZM	T,(X1)
	HRLM	G,(X1)
	HRLI	T,440700
	JUMPE	G,CPOPJ
PUTST3:	ILDB	C,F
	IDPB	C,T
	AOJL	G,PUTST3
	POPJ	P,
PUTST4:	PUSHJ	P,STRETR
	MOVE	T,N
	PUSHJ	P,PNTADR
	SKIPE	(X1)
	SETZM	VPAKFL
	MOVEM	T,(X1)
	POPJ	P,
;COMSTR COMPARES TWO STRINGS. ONE HAS BEEN FETCHED. THE POINTER
;TO THE OTHER IS IN REG.  THE COMPARE RELATION IS IN (P)
;COMSTR GETS A PAIR OF CHARS, ONE FROM EACH STRING, USING "GETPCH".
;WHEN IT REACHES THE END OF ONE OR BOTH STRINGS, OR WHEN IT FINDS
;AN UNEQUAL CHAR PAIR, THE ROUTINE USES THIS PAIR OF CHACTERS
;WHILE EXECUTING THE RELATION (NOTE: FIRST, HOWEVER, A CHECK IS MADE
;FOR TRAILING BLANKS).

COMSTR:	TLNN	N,777777
	JRST	COMST2
	TLNE	N,377777
	JRST	COMST1
	MOVE	T,N
	MOVE	N,(T)
	JRST	COMST2
COMST1:	JUMPLE	N,COMST2
	PUSHJ	P,STRETT
COMST2:	AOS	F,MASAPP
	MOVEM	N,(F)
	PUSHJ	P,PNTADR
	MOVE	N,(X1)
	TLNN	N,777777
	JRST	COMST3
	JUMPLE	N,COMST3
	PUSHJ	P,STRETT
COMST3:	HRRZ	F,N
	HLRE	G,N
	HRLI	F,440700
	SOS	T,MASAPP
	MOVE	T,1(T)	
	HLRE	T1,T
	HRLI	T,440700

IFST1:	PUSHJ	P,GETPCH	;GET PAIR OF CHARS IN (A) AND (C)
	JUMPG	X2,IFST3	;HAVE BOTH STRINGS ENDED?
	JUMPE	X2,IFST2	;HAS ONE STRING ENDED?
	CAMN	C,A		;ARE THESE TWO CHARS THE SAME?
	JRST	IFST1		;YES. LOOK AT NEXT PAIR

IFST2:	SETOI	X2,		;CHECK BOTH STRINGS FOR TRAILING BLANKS
IFST2A:	CAIN	C," "		;IS THIS CHAR A BLANK?
	PUSHJ	P,IFST4		;YES, GO CHECK STRING
	PUSHJ	P,EXCH6		;LOOK AT OTHER STRING
	AOJLE	X2,IFST2A

IFST3:	HLLZ	X1,@(P)	;GET RELATION
	AOS	(P)
	IOR	X1,[Z A,C]	;SETUP COMPARE
	XCT	X1
	POPJ	P,		;RETURN AND "GOTO"
	JRST	CPOPJ1		;RETURN AND STAY IN LINE

IFST4:	JUMPE	G,IFST5		;IS BLANK REALLY A TRAILING BLANK?
	ILDB	C,F
	AOJ	G,.+1
	CAIN	C," "		;IS NEXT CHAR A BLANK?
	JRST	IFST4		;YES KEEP LOOKING
IFST5:	MOVEI	C," "		;NO. USE BLANK FOR COMPARE
	POPJ	P,

;ROUTINE TO GET A PAIR OF CHARS
GETPCH:	SETOI	X2,	;COUNT TERMINATED STRINGS IN X2
	PUSHJ	P,GETCH
	PUSHJ	P,EXCH6		;LOOK AT OTHER STRING
	PUSHJ	P,GETCH

EXCH6:	EXCH	T,F		;MOVE OTHER STRING INFO TO (C),(F),(G)
	EXCH	T1,G
	EXCH	A,C
	POPJ	P,

GETCH:	JUMPE	G,.+3
	ILDB	C,F
	AOJA	G,CPOPJ
	SETZ	C,
	AOJ	X2,
	POPJ	P,
;PRSTRR PRINTS A STRING WHOSE POINTER IS ADDRESSED IN (40)

PRSTRR:	PUSHJ	P,FIRCHK
	PUSHJ	P,MARCHK
	PUSHJ	P,NUMINS
	SKIPE	QUOTBL(LP)	;QUOTE MODE?
	JRST	PRSTDS		;YES.
	PUSH	P,G		;SAVE G (FOR MAT READ AND PRINT)
	PUSHJ	P,GETSTR	;SETUP STRING FETCH
	JUMPLE	G,PRST1
	MOVE	N,(X1)
	PUSHJ	P,STRETT
	HLRE	G,N
	HRR	F,N
	HRLI	F,440700
PRST1:	PUSHJ	P,TABBER	;MOVE TO TAB STOP
	JUMPE	G,PRST2
	SETZM	ZONFLG(LP)
PRST3:	ILDB	C,F
	PUSHJ	P,OUCH0		;PRINT CHAR
	AOJL	G,PRST3
PRST2:	POP	P,G
	JRST	FINPNT

PRSTDS:	PUSHJ	P,TABBER	;QUOTE MODE.
	PUSHJ	P,GETSTR
	JUMPLE	G,PRST4
	MOVE	N,(X1)
	PUSHJ	P,STRETT
	HLRE	G,N
	HRR	F,N
	HRLI	F,440700
PRST4:	MOVMS	G,G
	PUSH	P,F
	PUSH	P,G
	JRST	PRTXD1
PRTXD8:	MOVEI	C," "		;OUTPUT A DELIMITER.
	PUSHJ	P,OUCH
	PUSHJ	P,PRTXD4
	JUMPE	G,PRTXD3
PRTXD5:	ILDB	C,F
	PUSHJ	P,OUCH
	SOJG	G,PRTXD5
PRTXD3:	PUSHJ	P,PRTXD4
	JRST	FINPNT
PRTXD4:	SKIPN	QUOFLG		;OUTPUT A QUOTE?
	POPJ	P,		;NO.
	MOVEI	C,42		;YES.
	JRST	OUCH
EXTERN	QUOFLG
PRTXD1:	SETZM	QUOFLG		;QUOFLG NE 0 SAYS MUST
	SETZM	ZONFLG(LP)
PRTXD9:	MOVE	X1,MARGIN(LP)	;WRITE THIS STRING WITH QUOTES.
	SUBI	X1,1
	SUB	X1,HPOS(LP)
	JUMPG	X1,.+3
	PUSHJ	P,PCRLF
	JRST	PRTXD9
	SETO	X2,
	JUMPE	G,PRTXD2
PRTXD7:	ILDB	C,F
	SOJGE	G,.+2
	JRST	PRTXD0
	CAIN	C,42
	JRST	PTXER1
	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.CR		;IF STR CONTAINS SPACE, TAB,
	JRST	PTXER1		;OR COMMA, IT MUST BE WRITTEN WITH QUOTES.
	TLNN	C,F.SPTB+F.COMA
	JRST	PRTXD6
	SKIPN	QUOFLG
PRTXD2:	SUBI	X1,2		;ONCE ONLY, SUBTRACT THE 2 SPACES
	SETOM	QUOFLG		;THE QUOTES TAKE UP.
PRTXD6:	SOJGE	X1,PRTXD7
	JUMPE	X2,PTXER2	;STRING IS TOO LONG FOR LINE.
	MOVE	D,MARGIN(LP)
	SUB	D,HPOS(LP)
	SUB	D,X1
	PUSHJ	P,PCRLF
	ADD	D,HPOS(LP)
	CAML	D,MARGIN (LP)
	JRST	PTXER2
	MOVE	X1,MARGIN(LP)
	SUB	X1,D
	SETZ	X2,
	JRST	PRTXD7
PRTXD0:	POP	P,G
	POP	P,F
	JRST	PRTXD8

>;ASSEMBLE ABOVE FOR STRINGS

IFN FTSTR,<
;ROUTINE TO PUT ADDRESS OF POINTER IN REG
PNTADR:	HRRZ	X1,40		;GET UUO ADDRESS
	MOVE	X2,(X1)
	JUMPGE	X2,CPOPJ	;ALL DONE IF THIS IS 0 OR AN APP BLK.
	TLNN	X2,377777	;ALL DONE IF THIS IS NEGATIVE COUNT
	MOVEI	X1,(X2)
	POPJ	P,
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY

;STRRET IS A UTILITY ROUTINE WHICH RETRIEVES A STRING FROM
;AN APPEND BLOCK AND CREATES THE ACTUAL STRING EITHER IN THE
;TEMPORARY STRING AREA OR IN THE REAL STRING AREA, DEPENDING ON 
;WHICH OF THE ENTRY POINTS STRETT AND STRETR IS USED.  STRRET EXPECTS
;THE APPEND KEY IN AC N. IT RETURNS THE ANSWER KEY IN AC N. IT
;DESTROYS NO AC'S EXCEPT T.

STRETT:	SETOM	REATMP		;STORE IN TEMP SPACE.
	JRST	.+2
STRETR:	SETZM	REATMP		;STORE IN REAL SPACE.
	PUSH	P,X1
	PUSH	P,X2
	PUSH	P,T1
	PUSH	P,C
	PUSH	P,E
	MOVE	X1,N		;SAVE APP KEY.
	PUSHJ	P,LENAPB
	MOVE	T,N		;LENGTH TO T FOR CORE MANAGER.
	SKIPN	REATMP
	JRST	.+3
	PUSHJ	P,VCHTSC	;GET SPACE FOR THE STRING.
	JRST	.+2		;LOWER BOUND IS RETURNED IN T.
	PUSHJ	P,VCHCKC
	MOVN	N,N
	HRLZ	N,N
	HRRI	N,(T)		;ALMOST ANSWER KEY.
	HLRZ	E,X1
	HRLI	T,440700	;DESTINATION POINTER.
	HRRZI	X1,(X1)
STRET1:	HRR	X2,1(X1)
	HRLI	X2,440700	;ORIGINAL POINTER.
	HLRE	T1,1(X1)	;LOOP COUNTER.
	JUMPE	T1,STRET2
	ILDB	C,X2
	IDPB	C,T
	AOJL	T1,.-2
STRET2:	AOJ	X1,.+1
	SOJG	E,STRET1
	POP	P,E
	POP	P,C
	POP	P,T1
	POP	P,X2
	POP	P,X1
	POPJ	P,		;EXIT.


;UTILITY ROUTINE TO HANDLE THE "+" OPERATOR FOR STRINGS.

APPEND:	MOVE	T,MASAPP
	MOVE	T,(T)
	TLNN	T,777777
	JRST	APPOU1		;T IS NULL STR.
	TLNN	N,777777
	JRST	APPOU2		;N IS NULL STR.
	TLNE	T,377777
	JRST	APPND1
	MOVE	T,(T)
	TLNN	T,777777
	JRST	APPOU1		;T IS NULL STR.
APPND1:	PUSH	P,X1
	TLNE	N,377777
	JRST	APPND2
	MOVE	X1,N
	MOVE	N,(X1)
	TLNN	N,777777
	JRST	APPOU3		;N IS NULL STR.

APPND2:	JUMPG	T,APPND3
	JUMPG	N,APPND4
	MOVE	X1,MASAPP	;BOTH REAL.
	MOVEM	N,1(X1)		;PROTECT THE KEYS.
	MOVEM	T,(X1)
	AOS	MASAPP
	PUSHJ	P,VCHAPP	;GET AN APP BLK.
	MOVE	N,(X1)	;SET UP THE BLK.
	MOVEM	N,1(T)
	MOVE	N,1(X1)
	MOVEM	N,2(T)
	HRLI	N,2
	HLRZM	N,(T)
	HRRI	N,(T)		;KEY IN N.
	SOS	MASAPP
	JRST	APPOU0		;EXIT.

APPND3:	PUSH	P,X2
	JUMPG	N,APPND5
	HLRZ	X1,T		;T IS APP BLK, N IS REAL.
	HRRZ	X2,T
	ADDI	X1,1(X2)
	MOVEM	N,(X1)		;STORE T.
	AOS	(X2)
	HRL	N,(X2)		;KEY IN N.
	HRRI	N,(T)
	JRST	APPOUT		;EXIT.

APPND4:	PUSH	P,X2		;N IS REAL, T IS APP BLK.
	HLRZ	X1,N
	HRRZ	X2,N
	ADDI	X1,(X2)
	MOVEM	T,(X2)		;STORE T IN ZEROTH LOC IN N.
	HLRZ	T,N
	AOJ	T,.+1
	HRL	N,T
APPN41:	MOVE	X2,(X1)
	MOVEM	X2,1(X1)
	SOJ	X1,.+1
	SOJG	T,APPN41
	MOVEM	N,1(X1)
	JRST	APPOUT		;EXIT.

APPND5:	HLRZ	X1,T		;BOTH N AND T ARE APP BLKS.
	HRRZ	X2,T
	ADDI	X2,1(X1)
	HRRZ	X1,N
	HRLI	X2,1(X1)
	HLRZ	X1,N
	HLRZ	N,T
	ADD	X1,N
	HRLM	X1,(T)
	ADDI	X1,(T)
	BLT	X2,(X1)
	MOVE	N,(T)

APPOUT:	POP	P,X2
APPOU0:	POP	P,X1
APPOU1:	SOS	MASAPP
	POPJ	P,

APPOU3:	POP	P,X1
APPOU2:	MOVE	N,T
	SOS	MASAPP
	POPJ	P,

SUBTTL	SUBSCRIPTED VARIABLE FETCH/STORE ROUTINES

;MATRIX ELEMENT FETCH/STORE UUO ROUTINES


IFN	FTSTR, <
SAD1ER:	MOVE	D,[JRST SADEND]	;FETCH ADR OF ARRAY ELEMENT
	JRST	AFT1ER+1
>

ASN1ER:	MOVE	D,[MOVNM N,(A)] ;NEGATIVE ARRAY STORE
	JRST	.+3
AST1ER:	SKIPA	D,[MOVEM N,(A)]	;POSITIVE ARRAY STORE
AFT1ER:	MOVSI	D,A(MOVE N,)	;ARRAY FETCH
	MOVEI	A,0		;PSEUDO LEFT HALF
	MOVE	B,40		;ARRAY ADDRESS
	HRRZ	C,1(B)		;TRY RIGHT DIMENSION
	TRNN	C,777776	;ROW VECTOR?
	HLRZ	C,1(B)		;NO, MUST BE COLUMN VECTOR
	JRST	AFT2C		;FINISH UP WITH 2-DIM CODE

ASN2ER:	MOVE	D,[MOVNM N,(A)] ;NEGATIVE ARRAY STORE
	JRST	.+3
AST2ER:	SKIPA	D,[MOVEM N,(A)]	;POSITIVE ARRAY STORE
AFT2ER:	MOVSI	D,A(MOVE N,)	;ARRAY FETCH
	MOVE	B,40		;ARRAY ADDRESS
	HLRZ	C,1(B)		;LEFT DIMENSION
	PUSHJ	P,SUBSCR	;GET AND FIX SUBSCRIPT IN E
	HRRZ	A,1(B)
	IMUL	A,E		;LEFT SCRIPT TIMES RIGHT DIM!
	HRRZ	C,1(B)		;RIGHT DIMENSION
AFT2C:	PUSHJ	P,SUBSCR	;GET AND FIX SUBSCRIPT IN E
	ADD	A,E		;ADD TO LEFT DIM
	ADD	A,(B)		;ADD ARRAY ADDRS
	XCT	D               ;DO THE OPERATION
	POPJ	P,		;RETURN

IFN	FTSTR, <
SADEND:	HRRZI	N,(A)		;PUT STRING VECTOR POINTER ADDRESS IN N
	TLO	N,(1B0)		;MAKE IT LOOK LIKE AN ADDRESS, NOT A POINTER
	POPJ	P,
>
;ROUTINE TO FETCH AND CHECK SUBSCRIPT

;CALL:	MOVE	C,DIMENSION
;	PUSHJ	P,SUBSCR

SUBSCR:	MOVE	E,@-1(P)		;GET SUBSCRIPT
	AOS	-1(P)		;SKIP ARGUMENT
	MOVE	E,(E)
	FAD	E,[XWD 233400,0];FIX SUBSCRIPT
	TLZ	E,777400
	CAMGE	E,C		;CHECK DIMENSION
	POPJ	P,
				;ON ERROR, FALL INTO DIMERR


;DIMENSION ERR ROUTINE

DIMERR:	PUSHJ	P,INLMES
	ASCIZ	/
? DIMENSION ERROR/
	JRST	GOSR2
	SUBTTL	MATRIX OPERATION RUN-TIME ROUTINES

IFN FTMAT, <
;SET MATRIX DIMENSION -- SDIM UUO


SDIMER:	MOVSI	C,1		;DONT FAIL IN SUBSCR
	PUSHJ	P,SUBSCR	;FIRST DIM
	HRLZ	A,E		;SAVE IT
	PUSHJ	P,SUBSCR	;SECOND DIM
	HRR	A,E
	AOBJP	A,MS0CHK		;GO CHECK DIMS AND STORE THEM
>
IFN FTMAT, <
;MATRIX OPERATION SETUP ROUTINE
;USE ENTRY POINT MS2 IF 2 ARGS, MS1 IF 1 ARG, MS0 OR MS0CHK IF 0 ARGS.
;ALL ENTRIES EXPECT MS0 EXCEPT DIMENSION [XWD ROWS,COLS]
;  OF DESTINATION TO BE SET UP IN A AND CHECK FOR ROOM
;  AND SET DIMENSION OF DESTINATION.
;AT CALL, LOCATION 40 CONTAINS THE ADDRS OF DESTINATION DOPE VECTOR,
;  RIGHT SIDE OF T1 CONTAINS ADDRS OF DOPE VECTOR FOR ARG 1
;  RIGHT SIDE OF T CONTAINS ADDRS OF DOPE VECTOR FOR ARG 2
;RIGHT SIDES OF T1,T,B ARE REPLACED WITH ADDRESSES OF ELEMENTS 0,0
;  OF ARG 1, ARG 2, DEST, RESPECTIVELY, WITHOUT CHANGING LEFT SIDES,
;  AND THE RESULTS ARE STORED IN TEMP1, TEMP2, AND TEMP3, RESPECTIVELY.
;THE MAXIMUM ROW NUMBER OF DEST IS STORED IN SB1M1, THE MAXIMUM
;  COLUMN NUMBER OF DEST IS STORED IN SB2M1
;E, T1, AND G ARE SET TO FIRST ROW NUMBER, FIRST COL NUMBER,
;  AND RELATIVE LOCATION OF FIRST ELEMENT, RESPECTIVELY
;IT IS INTENDED THAT E, T1, G, TEMP1, TEMP2, TEMP3 BE SET UP FOR
;  IMMEDIATE CALL TO MLP, AND THAT ELEMENTS OF FIRST
;  ARGUMENT, SECOND ARGUMENT, AND DESTINATION BE ACCESSED
;  BY INDIRECT ADDRESSING THROUGH TEMP1, TEMP2, AND TEMP3, RESPECTIVELY.

MS2:	HRR	T,(T)		;ADDRS OF FIRST ARG
MS1:	HRR	T1,(T1)		;ADDRS OF SECOND OR ONLY ARG
MS0CHK:	HRR	B,40		;DOPE VECTOR OF DEST
	HLLZ	X1,A		;CHECK NEW DIMENSION
	IMULI	X1,(A)		;X1 := (TOTAL SIZE)0
	CAMLE	X1,0(B)		;IS THERE ROOM IN ARRAY?
	JRST	DIMERR		;NO.  DIMENSION ERROR
	MOVEM	A,1(B)		;STORE NEW DIMENSION

MS0:	HRR	B,40		;ENTER HERE FOR NO DIM CHECK
	MOVE	A,1(B)		;FETCH DIMENSIONS
	SUB	A,[XWD 1,1]	;E := (MAX ROW)MAX COL
	HLRZM	A,SB1M1		;FIRST DIMENSION -1
	HRRZM	A,SB2M1		;SECOND DIMENSION -1

	HRR	B,(B)		;ADDRS OF DEST (LEAVE IN B FOR MINV)
	MOVEM	T1,TEMP1	;STORE FIRST XCT INSTRUCTION
	MOVEM	T,TEMP2		;STORE SECOND XCT INSTRUCTION
	MOVEM	B,TEMP3		;STORE THIRD XCT INSTRUCTION

;NOW SETUP E, T1, AND G FOR "MLP"

	SKIPE	E,SB1M1		;MORE THAN 0'TH ROW?
	MOVEI	E,1		;YES.  USE FIRST
	SKIPE	T1,SB2M1		;MORE THAN 0'TH COL
	MOVEI	T1,1		;YES.  USE FIRST
	MOVE	G,SB2M1		;CALCULATE FIRST ELT OF RESLT
	ADDI	G,1
	IMULI	G,(E)
	ADDI	G,(T1)
	POPJ	P,
>
IFN FTMAT, <
;MATRIX OPERATION MAIN LOOP

;ON CALLING, T, T1, G ARE SET UP TO ROW NUMBER, COL NUMBER, AND
;  REL LOC OF CURRENT ELEMENT IN DESTINATION MATRIX.
;MLP EXECUTES THE CONTENT OF TEMP1, TEMP2, TEMP3 FOR EACH
;  ELEMENT OF CURRENT ROE.  AT END OF ROW, MLP RETURNS
;  WITHOUT SKIP TO ALLOW ONCE-PER-ROW OPERATIONS TO BE PERFORMED.
;  WHEN ALL ROWS HAVE BEEN PROCESSED, MLP RETURNS WITH SKIP.
;NOTE SPECIAL CODING SO THAT ROW AND COLUMN VECTORS ARE
;  HANDLED CORRECTLY.

MLP:	XCT	TEMP1
	XCT	TEMP2
	XCT	TEMP3

	SKIPN	INVFLG
	JRST	MLP2
	PUSH	P,G
	MOVM	G,A
	CAMLE	G,INVLRG
	MOVEM	G,INVLRG
	POP	P,G
MLP2:	ADDI	G,1
	CAMGE	T1,SB2M1
	AOJA	T1,MLP
	SKIPE	SB2M1		;MORE THAN A 0'TH COL?
	AOJA	G,.+2		;YES.  SKIP 0'TH COL
	TDZA	T1,T1		;NO.  SET TO USE 0'TH COL
	MOVEI	T1,1		;YES AGAIN.  SET TO USE COL 1.

	CAML	E,SB1M1		;ALL ROWS USED?
	AOS	(P)		;YES.  SET FOR SKIP RETURN
	AOJA	E,CPOPJ		;BUMP ROW AND RETURN
>
IFN FTMAT, <
;MATRIX READ ROUTINE

;SET UP AND CALL MLP. FOR EACH ELEMENT, THE FOLLOWING
;ARE PERFORMED:
;	TEMP1:	PUSHJ	P,MTRELT
;	TEMP2:	...	;(SKIPPED)
;	TEMP3:	MOVEM	N,<DEST>(G)
;MTRELT READS A NUMBER INTO N

MTRDER:	SETZM	IFIFG
	PUSHJ	P,DOREAD
MTRDE1:	MOVE	T1,[PUSHJ P,MTRELT]
	HRRZ	X1,@40		;GET ADRESS OF ZEROTH ELEMENT
	CAML	X1,SVRBOT	;IS THIS A STRING VECTOR?
	JRST	MTRDS		;ELEMENTS WILL BE STRINGS.
	HRLI	B,G(MOVEM N,)
MTRD1:	PUSHJ	P,MS0		;SET UP FOR LOOP
	SETZM	40		;NOP THE STORE THAT DATAER USES
MTRD2:	PUSHJ	P,MLP		;EXECUTE LOOP
	JRST	.-1		;NO ACTION ON ROW
	POPJ	P,

;ROUTINE CALLED BY MTRDER TO PRINT AN ELEMENT

MTRELT: PUSH P,T1
	PUSHJ	P,DATAER
        POP P,T1
	JRST	CPOPJ1		;SKIP SECOND XCT

MTRDS:	MOVSI	T1,(SKIPA)
	MOVSI	B,G(STRIN)
	JRST	MTRD1


;MATRIX PRINT ROUTINE

;SET UP AND CALL MLP:
;	TEMP1:	PUSH	P,T
;	TEMP2:	PRNM	<FORMAT CODE>,<DEST>(G)
;	TEMP3:	POP	P,T
MTPRER:	MOVE	T1,[PUSH P,T1]	;TO SAVE T1 AROUND PRNM
	PUSHJ	P,MS0		;SET UP FOR LOOP
	HLL	B,40		;PICK UP UUO AC FIELD
	TLZ	B,777000	;CONSTRUCT PRNM INSTR
	SKIPN	SB2M1		;COLUMN VECTOR?
	JRST	.+3		;YES. ALLOW <CR> FORMAT
	TLNN	B,(Z 16,)	;OH, NO.  TREAT <RET> FORMAT ==<COMA> FORMAT.
	HRLI	B,(Z 3,)
	HRRZ	X1,@40
	CAMGE	X1,SVRBOT	;NUMBER ARRAY?
	TLO	B,G(PRNM)	;YES, SETUP NUMBER UUO
	CAML	X1,SVRBOT	;STRING ARRAY?
	TLO	B,G(PRSTR)	;YSE SEUP STRING PRINT UUO.$
	MOVEM	B,TEMP2		;SET UP TEMP2 AND TEMP3
	MOVE	X1,[POP P,T1]
	MOVEM	X1,TEMP3
        SKIPE ODF
        JRST MTP1D
	SETZB	LP,HPOS
	SETZM	TABVAL
	SETZM	FMTPNT
MTP2D:	PUSHJ	P,MTP3D		;TWO BLANK LINES
MTP1D:  SKIPE ODF
        JRST MTP4D
	SKIPE	SB2M1		;FOR THE SPECIAL CASE OF A COLUMN
	JRST	MTP5D		;VECTOR IN COMMA OR SEMICOLON
	MOVE	LP,TEMP2
	TLNN	LP,(Z 16,) 	;FORMAT, DON'T ZERO THE FLAGS
	JRST	MTP5D		;BECAUSE WE ARE IN THE MIDDLE OF THE ROW.
	SETZ	LP,
	JRST	MTP4D
MTP5D:	SETZB	LP,HPOS
	SETZM	TABVAL
	SETZM	FMTPNT
MTP4D:	PUSHJ	P,MLP		;PRINT A ROW
	JRST	MTPRE1		;NOW SEE WHETHER TO SPACE BETW ROWS
MTP3D:  SKIPE ODF
        POPJ P,
        PUSHJ P,INLMES
	ASCIZ	/

/
	OUTPUT 0,
	SETZM	HPOS
	SETZM	TABVAL
	SETZM	FMTPNT
	POPJ	P,

MTPRE1:	SKIPE	SB1M1		;VECTOR OR ARRAY?
	SKIPN	SB2M1
	JRST	MTP1D		;ARRAY... SPACE BETW ROWS
	JRST	MTP2D		;VECTOR...DONT SPACE BETW ROWS

MTPRUS: POP P,ADR
         PUSHJ P,MS0
        HRRZ X1,@40
        CAMGE X1,SVRBOT
        MOVE X2,[PUSHJ P,SCNIMN]
        CAML X1,SVRBOT
        MOVE X2,[PUSHJ P,SCNIMS]
        MOVEM X2,TEMP3
        HRLI B,G(MOVE N,)
        MOVEM B,TEMP2
MTPRU2:        MOVE X2,[POPJ P,]
        MOVEM X2,TEMP1
MTPRU1:         MOVEM G,SVG
        MOVEM T1,SVT1
        MOVEM E,SVE
        XCT TEMP2
        XCT TEMP3
        MOVE E,SVE
        MOVE T1,SVT1
        MOVE G,SVG
        PUSHJ P,MLP2
        JRST MTPRU1
        JRST @ADR

MTRPRT: POP P,ADR
        PUSHJ P,MS0
        HRRZ X1,@40
        MOVE X2,[PUSHJ P,RNSTRO]
        CAMGE X1,SVRBOT
        MOVE X2,[PUSHJ P,RNNUMO]
        MOVEM X2,TEMP3
        HRLI B,G(MOVE N,)
        MOVEM B,TEMP2
        JRST MTPRU2

MTRRD:  POP P,ADR
        PUSHJ P,MS0
        HRRZ X1,@40
        MOVE X2,[PUSHJ P,RANSTR]
        CAMGE X1,SVRBOT
        MOVE X2,[PUSHJ P,RANUM]
        MOVEM X2,TEMP2
        HRLI B,G(MOVEM N,)
        MOVEM B,TEMP3
        SETZM 40
        JRST MTPRU2
>
IFN FTMAT, <
;MATRIX ADD AND SUBTRACT ROUTINES

;SET UP AND CALL MLP:
;	TEMP1:	MOVE	N,<ARG 2>(G)	;OR MOVN
;	TEMP2:	FADR	N,<ARG 1>(G)
;	TEMP3:	MOVEM	N,<DEST>(G)
MTADER:	TLOA	T1,G(MOVE N,)		;MAKE ADD INSTR (T LOADED WITH MOVEI)
MTSBER:	HRLI	T1,G(MOVN N,)		;MAKE SUBTRACT INSTR
	HRLI	T,G(FADR N,)		;FETCH
	HRLI	B,G(MOVEM N,)
	MOVE	A,1(T)		;GET AND CHECK DIMENSIONS OF ARGS
	CAME	A,1(T1)
	JRST	DIMERR
	PUSHJ	P,MS2		;SET UP MATRIX LOOP
	JRST	MTRD2		;FINISH -- NO EACH ROW RTN


;MATRIX SCALE ROUTINE

;SET UP AND CALL MLP:
;	TEMP1:	MOVE	A,<ARG 1>(G)
;	TEMP2:	FMPR	A,N
;	TEMP3:	MOVEM	A,<DEST>(G)
MTSCER:	HRLI	T1,G(MOVE A,)
	MOVSI	T,(FMPR A,N)
MTSC1:	HRLI	B,G(MOVEM A,)
	MOVE	A,1(T1)
	PUSHJ	P,MS1
	JRST	MTRD2
>
IFN FTMAT, <
;MATRIX ZERO, IDENTITY, AND ONE ROUTINES

;SET UP AND CALL MLP:
;		..IDEN..	..ZERO..	..ONE..
;	TEMP1:	SETZM@TEMP3	SETZM @TEMP3	CAIA
;	TEMP2:	CAMN T,T1	CAIA		...
;	TEMP3:	MOVEM A,<DEST>(G)......................

MTIDER:	SKIPA	T,[CAMN E,T1]
MTZRER:	MOVSI	T,(CAIA)
	SKIPA	T1,[SETZM @TEMP3]
MTCNER:	MOVSI	T1,(CAIA)
MTCN1:	HRLI	B,G(MOVEM D,)
	MOVSI	D,(DEC 1.0)	;CONSTANT 1.0 TO STORE
	JRST	MTRD1		;GO FINISH WITH READ CODE


;MATRIX TRANSPOSE ROUTINE

;SET UP AND CALL MLP:
;A CONTAINS RELATIVE LOC OF CURRENT ELE IN SOURCE
;	TEMP1 :	FETCH SOURCE ELEMENT
;	TEMP2 :	UPDATE SOURCE INDEX
;	TEMP3 :	STORE DESTINATION ELEMENT


MTTNER:	MOVS	A,1(T1)		;FETCH DESTINATION DIMENSION
	HRLI	T1,A(MOVE N,)
	HLRZ	T,A		;E := ADDI A,<NBR ROWS>
	HRLI	T,(ADDI A,)
	HRLI	B,G(MOVEM N,)
	PUSHJ	P,MS1		;SET UP AND CHK DIMENSION

MTTN1:	MOVE	A,SB1M1		;A := <NBR ROWS>*COL + ROW
	ADDI	A,1
	IMUL	A,T1
	ADD	A,E

	PUSHJ	P,MLP		;MOVE A ROW
	JRST	MTTN1
	POPJ	P,
>


IFN FTMAT, <
;MATRIX MULTIPLY ROUTINE

;SET UP AND CALL MLP
;FOR EACH ELEMENT OF DESTINATION MATRIX, CALL SUBROUTINE
;	MYELT TO FORM THE DOT PRODUCT OF THE APPROPRIATE ROW AND COLUMN


MTMYER:	MOVE	A,1(T)		;CHECK DIMENSIONS
	HLRZ	D,1(T1)		;D := INNER DIMENSION
	CAIE	D,(A)		;SAME AS FIRST ARG?
	JRST	DIMERR		;NO
	HRR	A,1(T1)

	HRLI	T1,T1(MOVEI X2,)	;TO COMPUTE ADDRS OF 1ST ELT 2ND ARG
	HRLI	T,(MOVEI X1,)	;DITTO 1ST ARG
	HRLI	B,G(MOVEM N,)	;STORE INSTR
	PUSHJ	P,MS2		;SETUP NEW DIMENSIONS AND MLP ARGS
	MOVEI	X1,1(A)		;PREPARE TO SKIP ROW ZERO IF..
	CAIE	D,1		;INNER DIM=1?
	ADDM	X1,TEMP1
	MOVE	B,[PUSHJ P,MYELT]	;CALL TO ELT COMPUTATION
	EXCH	B,TEMP2

	CAIE	D,1		;INNER DIM 1?  (IE PROD OF VECTORS)
	ADDI	B,1		;NO.  SKIP 0'TH COL OF 1'ST ARG
	JUMPE	E,MTMY2		;DONT SKIP FIRST ROW IF ONLY 1

MTMY1:	ADDM	D,B		;NEXT ROW OF FIRST ARG
MTMY2:	PUSHJ	P,MLP
	JRST	MTMY1
	POPJ	P,

;SUBROUTINE TO COMPUTE ELEMENT OF PRODUCT
;X1 CONTAINS ADDRS OF 1ST ELT OF 1ST ARG FOR DOT PRODUCT,
;  AFTER FIRST XCT BELOW, X2 CONTAINS ADDRS OF SAME FOR 2ND ARG

MYELT:	XCT	B
	MOVEI	N,0		;TO ACCUMULATE DOT PRODUCT
	MOVEI	C,-1(D)	;NUMBER OF ADDS= REAL INNER DIMENSION

MYEL1:	PUSH	P,R
	MOVE	R,(X1)		;PRODUCT OF 2 ELTS
	FMPR	R,(X2)
	FADR	N,R		;ADD INTO DOT PRODUCT
	ADDI	X2,1(A)		;NEXT ROW OF 2ND ARG
	POP	P,R
	SOJLE	C,CPOPJ		;DONE?
	AOJA	X1,MYEL1	;NO.  TO NEXT ELT
>
	SUBTTL	RUN-TIME MATRIX INVERTER

IFN FTMAT, <
;SUBROUTINE TO CALL MATRIX INVERTER

	EXTERN	INVFLG,INVLRG
MTIVER:	SETOM	INVFLG
	SETZM	INVLRG
	MOVS	A,1(T1)		;MAKE SURE SQUARE MATRIX
	CAME	A,1(T1)
	JRST	DIMERR

	HRLI	T1,G(SKIPA A,)	;MOVE DESTINATION
	PUSHJ	P,MTSC1		;(USE MTCNER CODE)
	SKIPE	SB1M1	;GO INVERT UNLESS ONLY ELT IS (0,0)
	JRST	MINVB

	SUBI	B,3
	MOVEM	B,TEMP3		;ONLY ELEMENT IS (0,0)
	AOS	SB1M1		;FOOL MINV INTO THINKING ITS (1,1)
	JRST	MINVB

;THIS PORTION OF THE MAT INVERSE PROG RUNS IN ACS 0-7

JLOOP:
	PHASE	0

ZERO:	CAMN	JX,NT		;SKIP SAME COL
	JRST	JXIT
	MOVE	IX,@TEMP1	;A(I,J)=A(I,J)+A(NT,J)*A(I,NT)
	FMPR	IX,(KX)	;***
MOD:	FADRM	IX,0(JX)	;ADDR MODIFIED BY OUTER LOOP
JXIT:	CAMGE	JX,SB1M1	;LOOP DONE?
	AOJA	JX,ZERO
	JRST	IXIT2		;YES RETURN

	DEPHASE

;SOME AC DEFS FOR MINV

NT=10		;OUTERMOST LOOP INDEX
IX=11		;I SUBSCRIPT
JX=12		;J SUBSCRIPT
KX=13		;SCRATCH INDEX REG
LX=14		;    "     "    "
TAC1=16		;   "   (MUST BE SAVE & RESTORED)
>
IFN FTMAT, <
;MAIN ROUTINE ENTERS HERE TO SET UP REGS
;ROUTINE EXPECTS	1) ARRAY ADDR IN TEMP3
;			2) ORDER OF ARRAY IN SB1M1
;ROUTINE USES	1) VECT1 & VECT2 AS SCRATCH
;		2) SB2M1 AS CNT OF ELEMENTS / ROW

MINVB:	SETZM	LIBFLG
	SETZM	INVFLG
	HRRZS	TEMP3		;MAKE SURE ADDR ONLY
	PUSH	P,TAC1
	MOVE	TAC1,SB1M1	;GET ORDER
	ADDI	TAC1,1		;ADD ONE FOR 0'TH ROW & COL
	MOVEM	TAC1,SB2M1	;SAVE IN SB2
	MOVSI	TAC1,(1.0)	;INIT DETERM.
	MOVEM	TAC1,DETER
	HRLZI	TAC1,JX		;SET INDEX REG IN
	HLLZM	TAC1,TEMP1	;TEMP1 FOR INDIRECT
	MOVE	TAC1,[XWD JLOOP,ZERO]
	BLT	TAC1,7		;PUT JLOOP INTO ACS

	MOVEI	NT,1		;INITIALIZE OUTER LOOP
MINVLP:	MOVE	TAC1,NT
	IMUL	TAC1,SB2M1	;CALC (NT,NT) SUBSCR
	ADD	TAC1,NT
	ADD	TAC1,TEMP3	;***
	MOVEM	TAC1,TEMP2	;SAVE IT FOR LATER
	CAMN	NT,SB1M1	;LAST ITER?
	JRST	FOUND1		;SAVE SEARCH STUFF
	MOVM	TAC1,(TAC1)	;GET A(NT,NT)
	MOVE	IX,NT		;INITIALIZE SEARCH

LUPI:	MOVE	KX,SB2M1	;CALC I INDEX
	IMUL	KX,IX
	ADD	KX,TEMP3	;***
	MOVE	JX,NT		;INIT J INDEX
LUPJ:	MOVE	LX,KX
	ADD	LX,JX		;FINISH INDEX FOR ELEMENT
	MOVM	LX,(LX)		;GET IT
	CAMGE	LX,TAC1		;IS IT LARGER THAN PRESENT
	JRST	LUPEND		;NO
	MOVE	TAC1,LX		;YES SAVE IT
	MOVEM	IX,VECT1(NT)	;AND INDEXES
	MOVEM	JX,VECT2(NT)
LUPEND:	CAMGE	JX,SB1M1	;END OF J LOOP LOGIC
	AOJA	JX,LUPJ
	CAMGE	IX,SB1M1
	AOJA	IX,LUPI
>
IFN FTMAT, <
FOUND:	CAMN	NT,VECT1(NT)
	MOVNS	DETER
	CAMN	NT,VECT2(NT)
	MOVNS	DETER
	PUSHJ	P,FSWAP
FOUND1:	SKIPN	INVLRG		;TEST FOR SINGULARITY.
	JRST	SING
FOUND2:	MOVE	TAC1,@TEMP2	;GET PIVOT ELEMENT
	MOVEM	TAC1,PIVOT	;SAVE IT
	FMPRB	TAC1,DETER	;PERPETUATE DETERM
	JUMPE	TAC1,SING
	MOVSI	TAC1,(1.0)	;1./A(NT,NT)
	FDVRM	TAC1,PIVOT	;***

	MOVEI	IX,1		;SET UP I
ILOOP:	CAMN	IX,NT		;SKIP SAME ROW
	JRST	IXIT		;AS PIVOT ROW
	MOVE	LX,SB2M1	;CALCULATE ALL ROW OFFSETS
	IMUL	LX,IX
	ADD	LX,TEMP3	;LX= IX*N+A
	MOVE	KX,LX
	ADD	KX,NT		;KX=LX+NT
	MOVN	TAC1,PIVOT	;GET -PIVOT
	FMPRM	TAC1,(KX)	;A(I,NT)=A(I,NT)/(-A(NT,NT))
	MOVEI	JX,1		;SET J LOOP START
	MOVE	TAC1,SB2M1
	IMUL	TAC1,NT
	ADD	TAC1,TEMP3	;TAC=NT*N+A
	HRRM	TAC1,TEMP1	;STORE FOR @TEMP1(JX)
	HRR	MOD,LX	;SAT ADDR IN INNER LOOP
	PUSH	P,IX
	JRST	ZERO		;GO
IXIT2:	POP	P,IX

IXIT:	CAMGE	IX,SB1M1	;RETURN HERE FROM ACS
	AOJA	IX,ILOOP
	MOVEI	JX,1		;SET LOOP FOR LAST COL
	MOVE	TAC1,PIVOT	;GET PIVOT
LCOL:	FMPRM	TAC1,@TEMP1	;A(NT,J)=A(NT,J)/A(NT,NT)
	CAMGE	JX,SB1M1	;DONE
	AOJA	JX,LCOL
	MOVEM	TAC1,@TEMP2	;A(NT,NT)=PIVOT
	CAMGE	NT,SB1M1	;INVERSE DONE?
	AOJA	NT,MINVLP	;NOPE, ITER AGAIN
>
IFN FTMAT, <
;HERE WHEN INVERSE DONE PUT MATRIX BACK TOGETHER

	MOVE	NT,SB1M1	;DO LOOP IN REVERSE ORDER
INVFIX:	SOJLE	NT,OUT		;FINISHED
	PUSHJ	P,BSWAP		;SWAP ROW - COL IN REV.
	JRST	INVFIX

BSWAP:	MOVE	KX,VECT2(NT)
	MOVE	LX,VECT1(NT)	;SET REGS
	JRST	SWAP
FSWAP:	MOVE	KX,VECT1(NT)
	MOVE	LX,VECT2(NT)
SWAP:	MOVE	TAC1,NT
	IMUL	TAC1,SB2M1
	IMUL	KX,SB2M1	;CALC BOTH ROW OFFSETS
	ADD	TAC1,TEMP3
	ADD	KX,TEMP3	;***
	MOVEI	JX,1
	HRLI	TAC1,JX
	HRLI	KX,JX
SWP1:	MOVE	IX,@TAC1
	EXCH	IX,@KX		;EXCHANGE ITEMS IN ROWS
	MOVEM	IX,@TAC1
	CAMGE	JX,SB1M1
	AOJA	JX,SWP1
	MOVEI	IX,1
	MOVE	TAC1,NT
	MOVE	KX,SB2M1
	ADD	KX,TEMP3	;GET COL ADDR
	HRLI	TAC1,KX
	HRLI	LX,KX
SWP2:	MOVE	JX,@LX
	EXCH	JX,@TAC1
	MOVEM	JX,@LX
	CAML	IX,SB1M1	;CHECK DONE
	POPJ	P,		;RETURN
	ADD	KX,SB2M1	;TO NEXT COL
	AOJA	IX,SWP2

;HERE TO RETURN OR MAKE SINGULAR

SING:	SETZB	ZERO,DETER
	PUSHJ	P,INLMES
	ASCIZ	/
% SINGULAR MATRIX INVERTED/
	PUSHJ	P,GOSR3
OUT:	SKIPE	LIBFLG
	JRST	OUT2
OUT3:	POP	P,TAC1
	POPJ	P,0
OUT2:	PUSHJ	P,INLMES
	ASCIZ	/
% OVER OR UNDERFLOW OCCURRED DURING MAT INV/
	PUSHJ	P,GOSR3
	JRST	OUT3


>
	SUBTTL	INTRINSIC FUNCTIONS (ADAPTED FROM LIB4 V.005)

;FLOATING POINT SINGLE PRECISION ARCTANGENT FUNCTION
;ATAN(X) = X(B0+A1(Z+B1-A2(Z+B2-A3(Z+B3)**-1)**-1)**-1)
;WHERE Z=X^2, IF 0<X<=1

;IF X>1, THEN ATAN(X) = PI/2 - ATAN(1/X)
;IF X>1, THEN RH(A) =-1, AND LH(A) = -SGN(X)
;IF X<1, THEN RH(A) = 0, AND LH(A) =  SGN(X)

ATANB:				;ENTRY TO ARCTANGENT ROUTINE
	MOVM	T, N		;GET ABSF OF ARGUMENT
	CAMG	T, A1		;IF A<2^-33, THEN RETURN WITH...
	POPJ	P,		;ATAN(X)=X
	HLLO	B, N		;SAVE SIGN, SET RH(A) = -1
	CAML	T, A2		;IF A>2^33, THEN RETURN WITH
	JRST	AT4		;ATAN(X) = PI/2
	MOVSI	T1, (1.0)	;FORM 1.0 IN T1
	CAMG	T, T1		;IS ABSF(X)>1.0?
	TRZA	B, -1		;IF T .LE. 1.0, THEN RH(A) = 0
	FDVM	T1, T		;B IS REPLACED BY 1.0/B
	TLC	B, (B)		;XOR SIGN WITH .G. 1.0 INDICATOR
	MOVEM	T, C3		;SAVE THE ARGUMENT
	FMP	T, T		;GET B^2
	MOVE	T1, KB3		;PICK UP N CONSTANT
	FAD	T1, T		;ADD B^2
	MOVE	N, KA3		;ADD IN NEXT CONSTANT
	FDVM	N, T1		;FORM -A3/(B^2 + B3)
	FAD	T1, T		;ADD B^2 TO PARTIAL SUM
	FAD	T1, KB2		;ADD B2 TO PARTIAL SUM
	MOVE	N, KA2		;PICK UP -A2
	FDVM	N, T1		;DIVIDE PARTIAL SUM BY -A2
	FAD	T1, T		;ADD B^2 TO PARTIAL SUM
	FAD	T1, KB1		;ADD  B1 TO PARTIAL SUM
	MOVE	N, KA1		;PICK UP A1
	FDV	N, T1		;DIVIDE PARTIAL SUM BY A1
	FAD	N, KB0		;ADD B0
	FMP	N, C3		;MULTIPLY BY ORIGINAL ARGUMENT
	TRNE	B, -1		;CHECK .G. 1.0 INDICATOR
	FSB	N, PIOT		;ATAN(N) = -(ATAN(1/A)-PI/2)
	CAIA			;SKIP
AT4:	MOVE	N, PIOT		;GET PI/2 AS ANSWER
NEGANS:	SKIPGE	B		;LH(A)= -SGN(T) IF B>1.0
	MOVNS	N		;NEGATE ANSWER
	POPJ	P,		;EXIT

A1:	145000000000		;2**-33
A2:	233000000000		;2**33
KB0:	176545543401		;0.1746554388
KB1:	203660615617		;6.762139240
KB2:	202650373270		;3.316335425
KB3:	201562663021		;1.448631538
KA1:	202732621643		;3.709256262
KA2:	574071125540		;-7.106760045
KA3:	600360700773		;-0.2647686202
PIOT:	201622077325		;PI/2
;FLOATING POINT TRUNCATION FUNCTION
;TRUNCATES FRACTIONAL PART OF FLOATING POINT NUMBER
;AND RETURNS ANSWER AS N FLOATING POINT NUMBER. THE
;ALGORITHM MAKES USE OF THE NORMALIZING PROPERTIES OF FAD.
;ROUTINE EXITS WITH (T)=ZERO IF NUMBER WAS AN INTEGER.

INTB:	MOVE	B,N		;SAVE ARGUMENT
	MOVMS	N		;GET ABSF(ARG)
	SKIPGE	B		;NEGATIVE?
	FAD	N,ALMST1	;YES. MAKE AINT[-2.3]=-3  ETC.
	CAML	N,MOD1		;IS ARGUMENT<=2**26?
	JRST	NEGANS		;YES; IT MUST BE AN INTEGER ALREADY
	FAD	N,MOD1
	FSB	N,MOD1		;NOW FRACTIONAL PART HAS BEEN LOST
	JRST	NEGANS		;CHECK SIGN AND EXIT.

MOD1:	XWD 233400,000000	; 2**26

ALMST1:	XWD 200777,777777	;1.0-<SMALLEST QUANTITY>
;COMMON LOG FUNCTION (LOG TO BASE 10)

CLOGB:  PUSHJ   P,LOGB          ;GET LOGE(N)
        FMPR    N,[XWD 177674,557305] ;MULTIPLY BY LOG10(E)
        POPJ    P,
;FLOATING POINT SINGLE PRECISION LOGARITHM FUNCTION
;LOG(ABSF(X)) IS CALCULATED BY THE SUBROUTINE, AND AN
;ARGUMENT OF ZERO IS RETURNED AS MINUS INFINITY. THE ALGORITHM IS

;LOGE(X) = (I + LOG2(F))*LOGE(2)
;WHERE X = (F/2)*2^(I+1), AND LOG2(F) IS GIVEN BY
;LOG2(F) = C1*Z + C3*Z^3 + C5*Z^5 - 1/2
;AND Z = (F-SQRT(2))/(F+SQRT(2))

LOGB:	JUMPL	N,ALOGB1	;TEST FOR LOG OF NEG NUMBER.
ALOGB2:	MOVMS	N		;GET ABSF(X)
	JUMPE	N, LZERO	;CHECK FOR ZERO ARGUMENT
	CAMN	N, ONE		;CHECK FOR 1.0 ARGUMENT
	JRST	ZERANS		;IT IS 1.0 RETURN ZERO ANS.
	ASHC	N, -33		;SEPARATE FRACTION FROM EXPONENT
	ADDI	N, 211000	;FLOAT THE EXPONENT AND MULT. BY 2
	MOVSM	N, C3		;NUMBER NOW IN CORRECT FL. FORMAT
	MOVSI	N, 567377	;SET UP -401.0 IN N
	FADM	N, C3		;SUBTRACT 401 FROM EXP.*2
	ASH	T, -10		;SHIFT FRACTION FOR FLOATING
	TLC	T, 200000	;FLOAT THE FRACTION PART
	FAD	T, L1		;B = T-SQRT(2.0)/2.0
	MOVE	N, T		;PUT RESULTS IN N
	FAD	N, L2		;A = N+SQRT(2.0)
	FDV	T, N		;B = B/A
	MOVEM	T, LZ		;STORE NEW VARIABLE IN LZ
	FMP	T, T		;CALCULATE Z^2
	MOVE	N, L3		;PICK UP FIRST CONSTANT
	FMP	N, T		;MULTIPLY BY Z^2
	FAD	N, L4		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY Z^2
	FAD	N, L5		;ADD IN NEXT CONSTANT
	FMP	N, LZ		;MULTIPLY BY Z
	FAD	N, C3		;ADD IN EXPONENT TO FORM LOG2(X)
	FMP	N, L7		;MULTIPLY TO FORM LOGE(X)
	POPJ	P,		;EXIT

LZERO:	PUSHJ	P,INLMES	
	ASCIZ /
% LOG OF ZERO/
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER.
	MOVE	N, MIFI		;PICK UP MINUS INFINITY
	POPJ	P,		;EXIT

;COMMON EXITS:
ZERANS:	SETZI	N,		;MAKE ARG ZERO
	POPJ	P,		;EXIT

;CONSTANTS FOR ALOGB

ONE:	201400000000
L1:	577225754146		;-0.707106781187
L2:	201552023632		;1.414213562374
L3:	200462532521		;0.5989786496
L4:	200754213604		;0.9614706323
L5:	202561251002		;2.8853912903
ALOGB1:	PUSH	P,N		;SAVE ARGUMENT
	PUSHJ	P,INLMES
	ASCIZ /
% LOG OF NEGATIVE NUMBER/
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	POP	P,N		;GET ARG
	JRST	ALOGB2		;USE ABS VALUE.

L7:	200542710300		;0.69314718056
MIFI:	XWD 400000,000001	;GOAL POSTS. LARGEST NEGATIVE NUMBER.


;FLOATING POINT SINGLE PRECISION SINE AND COSINE FUNCTION
;THE ARGUMENT IS IN RADIANS.
;ENTRY POINTS ARE SIN AND COS.
;COS CALLS SIN TO CALCULATE SIN(PI/2 + X)

;THE ROUTINE CALCULATES SINES AFTER REDUCING THE ARGUMENT TO
;THE FIRST QUADRANT AND CHECKING THE OVERFLOW BITS TO DETERMINE
;THE QUADRANT OF THE ORIGINAL ARGUMENT
;000 - 1ST QUADRANT
;001 - 2ND QUADRANT, X=-(X-PI)
;010 - 3RD QUADRANT, X=-(X-PI)
;011 - 4TH QUADRANT, X=X-3*PI/2-PI/2
;THE ALGORITHM USES N MODIFIED TAYLOR SERIES TO CALCULATE
;THE SINE OF THE NORMALIZED ARGUMENT.


COSB:				;ENTRY TO COSINE RADIANS ROUTINE
	FADR	N,PIOT		;ADD PI/2
				;FALL INTO SINE ROUTINE

SINB:				;ENTRY TO SINE RADIANS ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	MOVEM	T, SX		;SAVE IT
	MOVMS	T		;GET ABSF OF ARGUMENT
	CAMG	T, SP2		;SINX = X IF X<2^-10
	POPJ	P,		;EXIT WITH ANS=ARG
	FDV	T, PIOT		;DIVIDE X BY PI/2
	CAMG	T, ONE		;IS X/(PI/2) < 1.0?
	JRST	S2		;YES, ARG IN 1ST QUADRANT ALREADY
	MULI	T, 400		;NO, SEPARATE FRACTION AND EXP.
	ASH	T1, -202(T)	;GET X MODULO 2PI
	MOVEI	T, 200		;PREPARE FLOATING FRACTION
	ROT	T1, 3		;SAVE 3 BITS TO DETERMINE QUADRANT
	LSHC	T, 33		;ARGUMENT NOW IN RANGE (-1,1)
	FAD	T, SP3		;NORMALIZE THE ARGUMENT
	JUMPE	T1, S2		;REDUCED TO FIRST QUAD IF BITS 00
	TLCE	T1, 1000		;SUBTRACT 1.0  FROM ARG IF BITS ARE
	FSB	T, ONE		;01 OR 11
	TLCE	T1, 3000		;CHECK FOR FIRST QUADRANT, 01
	TLNN	T1, 3000		;CHECK FOR THIRD QUADRANT, 10
	MOVNS	T		;01,10

S2:	SKIPGE	SX		;CHECK SIGN OF ORIGINAL ARG
	MOVNS	T		;SIN(-X) = -SIN(X)
	MOVEM	T, SX		;STORE REDUCED ARGUMENT
	FMPR	T, T		;CALCULATE X^2
	MOVE	N, SC9		;GET FIRST CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC7		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC5		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, SC3		;ADD IN NEXT CONSTANT
	FMP	N, T		;MULTIPLY BY X^2
	FAD	N, PIOT		;ADD IN LAST CONSTANT
S2B:	FMPR	N, SX		;MULTIPLY BY X
	POPJ	P,		;EXIT



SC3:	577265210372		;-0.64596371106
SC5:	175506321276		;0.07968967928
SC7:	606315546346		;0.00467376557
SC9:	164475536722		;0.00015148419

SP2:	170000000000		;2**-10
SP3:	0			;0
CD1:	90.0
SCD1:	206712273406
;FLOATING POINT SINGLE PRECISION SQUARE ROOT FUNCTION
;THE SQUARE ROOT OF THE ABSOLUTE VALUE OF THE ARGUMENT IS
;CALCULATED. THE ARGUMENT IS WRITTEN IN THE FORM
;	X=	F*(2**2B)	WHERE 0<F<1
;SQRT(X) IS THEN CALCULATED AS (SQRT(X))*(2**B)
;SQRT(F) IS CALCULATED BY N LINEAR APPROXIMATION, THE NATURE
;OF WHICH DEPENDS ON WHETHER 1/4 < F < 1/2 OR 1/2 < F < 1,
;FOLLOWED BY TWO ITERATIONS OF NEWTON'S METHOD.


SQRTB:	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	JUMPL	T,SQRMIN	;SQRT OF NEGATIVE NUMBER?
	JUMPE	T,SQRT1		;CHECK FOR ARGUMENT OF ZERO
SQRTB0:	ASHC	T, -33		;PUT EXPONENT IN T, FRACTION IN T1
	SUBI	T, 201		;SUBTRACT 201 FROM EXPONENT
	ROT	T, -1		;CUT EXP IN HALF, SAVE ODD BIT
	HRRM	T,EX1		;SAVE FOR FUTURE SCALING OF ANS
				;IN FSC N,. INSTRUCTION
	LSH	T, -43		;GET BIT SAVED BY PREVIOUS INST.
	ASH	T1, -10		;PUT FRACTION IN PROPER POSITION
	FSC	T1, 177(T)	;PUT EXPONENT OF FRACT TO -1 OR 0
	MOVEM	T1, N		;SAVE IT. 1/4 < F < 1
	FMP	T1, SQCON1(T)	;LINEAR FIRST APPROX,DEPENDS ON
	FAD	T1, SQCON2(T)	;WHETHER 1/4<F<1/2 OR 1/2<F<1.
	MOVE	T, N		;START NEWTONS METHOD WITH FRAC
	FDV	T, T1		;CALCULATE X(0)/X(1)
	FAD	T1, T		;X(1) + X(0)/X(1)
	FSC	T1, -1		;1/2(X(1) + X(0)/X(1))
	FDV	N, T1		;X(0)/X(2)
	FADR	N, T1		;X(2) + X(0)/X(2)
	XCT	EX1
SQRT1:	POPJ	P,		;EXIT

SQCON1:	0.8125			;CONSTANT, USED IF 1/4<FRAC<1/2
	0.578125		;CONSTANT, USED IF 1/2<FRAC<1
SQCON2:	0.302734		;CONSTANT, USED IF 1/4<FRAC<1/2
	0.421875		;CONSTANT, USED IF 1/2<FRAC<1

SQRMIN:	PUSH	P,T	;SAVE ARG
	PUSHJ	P,INLMES
	ASCIZ /
% SQRT OF NEGATIVE NUMBER/
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	POP	P,T		;GET ARG
	MOVMS	T
	JRST	SQRTB0		;USE ABSOLUTE VALUE
;TAN - SINGLE PRECISION TANGENT ROUTINE.
;
;BASED ON ACM ALGORITHM 229, (COMM. ACM, 7, MAY 1964, J. MORELOCK).

;METHOD:
;
;TAN(N*(PI/2)+A) = -(1/TAN(A)) IF N IS ODD,
;TAN(N*(PI/2)+A) = TAN(A) IF N IS EVEN.
;
;/A/ IS <= 0.5*(PI/2).

;ON ENTRY, THE ARG IS IN AC N.
;ON EXIT, THE ANSWER IS IN AC N.

;COTAN (X)=TAN(PI/2-X)

COTB:	JUMPE	N,TANB1
	MOVNS	N		;CALCULATE -X...
	FADR	N,PIOT		;PLUS PI/2
TANB:	PUSH	P,T1
	MOVM	T1,N
	CAMG	T1,[3.464102E-4] ;A CHECK FOR TAN(X)=X,
	JRST	TAN55		;MORE OR LESS.
	PUSH	P,T
	PUSH	P,A
	FDVR	T1,PIOT
	MOVEI	T,1
	CAMGE	T1,[XWD 200400,000000] ;REDUCE ARG?
	JRST	TAN2		;NO NEED.

TAN0:	MOVE	T,T1		;YES.
	MULI	T1,400
	SETZM	LIBFLG
	ASH	A,-243(T1)
	SKIPN	LIBFLG
	JRST	TAN05
	SETZ	N,
	JRST	TAN52
TAN05:	MOVE	T1,T
	ANDI	A,1		;A POINTS TO QUADRANT.
	JUMPE	A,.+2
	MOVN	N,N
	FSBRI	T1,200400
	MULI	T1,400
	EXCH	T1,A
	MOVEI	T,0
	CAIL	A,233
	TDZA	T1,T1
	ASHC	T,-200(A)
	ANDI	T,1		;T POINTS TO INVERSION.
	LSH	T1,-10
	TLO	T1,200000
	FSBRI	T1,200400
	MOVM	T1,T1
TAN1:	JUMPGE	N,.+2		;ORIGINAL ARG OR QUADRANT
	MOVN	T1,T1		;REQUIRES NEGATIVE.
	MOVE	N,T1
	FMPR	N,PIOT
	MOVM	A,N
	CAMGE	A,[3.464102E-4]
	JRST	TAN6

TAN2:	PUSH	P,B		;ROUTINE TO CALC TAN(A),
	MOVE	A,N		;BASED ON ACM ALGORITHM
	FMPR	A,A		;REFERENCED ABOVE.
	MOVE	B,A
	FDVRI	B,572340	;-18.
	FADRI	B,204700	;14.
	MOVN	T1,A
	FDVR	T1,B
	FADRI	T1,204500	;10.
	MOVN	B,A
	FDVR	B,T1
	FADRI	B,203600	;6.
	MOVN	T1,A
	FDVR	T1,B
	FADRI	T1,202400	;2.
	FMPRI	N,202400
	FMPR	N,T1
	FMPR	T1,T1
	FSBR	T1,A
	FDVR	N,T1
	POP	P,B

TAN6:	SETZM	LIBFLG
	JUMPN	T,TAN52		;IF T =0, INVERT.
	HRLZI	T,201400
	FDVRM	T,N
	SKIPE	LIBFLG
	PUSHJ	P,TANB1
TAN52:	POP	P,A
	POP	P,T
TAN55:	POP	P,T1
TAN4:	POPJ	P,

TANB1:	PUSH	P,N
	PUSHJ	P,INLMES
	ASCIZ ?
% TAN OF PI/2 OR COTAN OF ZERO?
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER AND EXIT WITH LARGE ANSWER.
	POP	P,N
	JUMPL	N,.+3
	HRLOI	N,377777
	POPJ	P,
	MOVE	N,MIFI
	POPJ	P,
;FLOATING POINT SINGLE PRECISION EXPONENTIAL FUNCTION
;THE ARGUMENT IS RESTRICTED TO THE FOLLOWING RANGE
;	-88.028<X<88.028
;IF X<-88.028, THE PROGRAM RETURNS ZERO AS THE ANSWER
;IF X>88.028, THE PROGRAM RETURNS +INFINITY AS THE ANSWER
;THE RANGE OF THE ARGUMENT IS REDUCED AS FOLLOWS:
;EXP(X) = 2**(X*LOG(B)BASE2) = 2**(M+F)
;WHERE M IS AN INTEGER AND F IS N FRACTION
;2**M IS CALCULATED BY ALGEBRAICALLY ADDING M TO THE EXPONENT
;OF THE RESULT OF 2**F. 2**F IS CALCULATED AS

;2**F = 2(0.5+F(A+B*F^2 - F-C(F^2 + D)**-1)**-1

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE:
;	PUSHJ	P, EXP
;
;THE ARGUMENT IS IN N
;THE ANSWER IS RETURNED IN ACCUMULATOR N


	EXTERN	EX1

EXPB:				;ENTRY TO EXPONENTIAL ROUTINE
	MOVE	T, N		;PICK UP THE ARGUMENT IN T
	MOVM	N, T		;GET ABSF(X)
	CAMLE	N, E7		;IS ARGUMENT IN PROPER RANGE?
	JRST	EXTOLG		;EXP TOO LARGE.;##MSG +CON OR STOP?

EXP1:	SETZM	ES2		;INITIALIZE ES2
	MULI	T, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	T, T		;GET N POSITIVE EXPONENT
	MUL	T1, E5		;FIXED POINT MULTIPLY BY LOG2(B)
	ASHC	T1, -242(T)	;SEPARATE FRACTION AND INTEGER
	AOSG	T1		;ALGORITHM CALLS FOR MULT. BY 2
	AOS	T1		;ADJUST IF FRACTION WAS NEGATIVE
	HRRM	T1, EX1		;SAVE FOR FUTURE SCALING
	ASH	A, -10		;MAKE ROOM FOR EXPONENT
	TLC	A, 200000	;PUT 200 IN EXPONENT BITS
	FADB	A, ES2		;NORMALIZE, RESULTS TO A AND ES2
	FMP	A, A		;FORM X^2
	MOVE	N, E2		;GET FIRST CONSTANT
	FMP	N, A		;E2*X^2 IN N
	FAD	A, E4		;ADD E4 TO RESULTS IN A
	MOVE	T, E3		;PICK UP E3
	FDV	T, A		;CALCULATE E3/(F^2 + E4)
	FSB	N, T		;E2*F^2-E3(F^2 + E4)**-1
	MOVE	T1, ES2		;GET F AGAIN
	FSB	N, T1		;SUBTRACT FROM PARTIAL SUM
	FAD	N, E1		;ADD IN E1
	FDVM	T1, N		;DIVIDE BY F
	FAD	N, E6		;ADD 0.5
	XCT	EX1		;SCALE THE RESULTS
	POPJ	P,		;EXIT

E1:	204476430062		;9.95459578
E2:	174433723400		;0.03465735903
E3:	212464770715		;617.97226953
E4:	207535527022		;87.417497202
E5:	270524354513		;LOG(B), BASE 2
E6:	0.5
E7:	207540071260		;88.028
EXTOLG:	JUMPG	T,EXTOL1
	PUSHJ	P,INLMES
	ASCIZ	/
% UNDERFLOW IN EXP/
	PUSHJ	P,GOSR3
	SETZ	N,
	POPJ	P,
EXTOL1:	PUSHJ	P,INLMES
	ASCIZ /
% OVERFLOW IN EXP/
	PUSHJ	P,GOSR3		;PRINT LINE NUMBER
	HRLOI	N,377777	;GET LARGEST ANSWER AND RETURN.
	POPJ	P,
;SINGLE PRECISION EXP.2 FUNCTION
;THIS ROUTINE CALCULATES A FLOATING POINT NUMBER TO A FIXED
;POINT POWER. THE CALCULATION IS A**B, WHERE T IS OF THE FORM

;	T=Q(0) + Q(1)*2 + Q(2)*4 + ...WHERE Q(I)=0 OR 1

;THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE IS
;CALLED. THE ANSWER IS RETURNED IN ACCUMULATOR N.
;EXP.2 IS CALLED ONLY BY EXP.3.  IT IS GUARANTEED THAT THE
;BASE AND THE EXPONENT ARE NON-ZERO.


	EXTERN	LIBFLG
EXP2.0:	PUSH	P,T		;SAVE FOR OVER/UNDERFLOW CHECKING.
	PUSH	P,N
	SETZM	LIBFLG		;CLEAR THE OVER/UNDERFLOW FLAG.
	MOVSI	T1,(1.0)
	JUMPGE	T,FEXP2
	MOVMS	T
	FDVRM	T1,N
	MOVSI	T1,(1.0)
	JRST	FEXP2
FEXP1:	FMP	N, N		;FORM A**N, FLOATING POINT
	LSH	T, -1		;SHIFT EXPONENT FOR NEXT BIT
FEXP2:	TRZE	T, 1		;IS THE BIT ON?
	FMP	T1, N		;YES, MULTIPLY ANSWER BY A**N
	JUMPN	T, FEXP1	;UPDATE A**N UNLESS ALL THROUGH
	MOVE	N, T1		;PICK UP RESULT FROM T1
	SKIPE	LIBFLG		;IF OVER/UNDERFLOW,
	JRST	FEXP4		;GO TO FEXP4.
	POP	P,T		;CLEAR OFF PLIST.  DO NOT POP INTO N!!!!
	POP	P,T		;(BECAUSE THE ANSWER IS IN N).
	POPJ	P,		;EXIT

FEXP4:	POP	P,N		;OVER/UNDERFLOW ROUTINE.
	POP	P,T
	MOVM	T1,N
	CAMG	T1,ONE
	JRST	.+3		;/BASE/>1,EXP>0 MEANS OVER.
	JUMPG	T,.+3		;/BASE/>1,EXP<0 MEANS UNDER.
	JRST	EXP3D3		;/BASE/<1,EXP>0 MEANS UNDER.
	JUMPG	T,EXP3D3	;/BASE/<1,EXP<0 MEANS OVER.
	JUMPG	N,.+3		;THIS IS OVER. WHAT IS THE SIGN?
	TRNE	T,1
	JRST	FEXP5
	PUSHJ	P,EXP3D2
	HRLOI	N,377777
	POPJ	P,
FEXP5:	PUSHJ	P,EXP3D2
	MOVE	N,MIFI
	POPJ	P,
;SINGLE PRECISION FORTRAN IV EXP.3 FUNCTION
;THIS ROUTINE CALCULATES A FLOATING POINT NUMBER RAISED TO A
;FLOATING POINT POWER. THE CALCULATION IS
;	A**B= EXP(B*LOG(N))

;IF THE EXPONENT IS AN INTEGER THE 
;RESULT WILL BE COMPUTED USING "EXP2.0" .

;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	PUSHJ	P, EXP3.0
;THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE
;IS CALLED. THE RESULT IS RETURNED IN ACCUMULATOR N.




EXP3.0:	JUMPE	T,EXP3A		;IS EXPONENT ZERO?
	JUMPN	N,EXP3A0	;IS BASE ZERO?
	JUMPL	T,EXPB3		;ERROR IF BASE=0, EXP <0.
	POPJ	P,		;IMMED. RETURN IF BASE=0, EXP>=0.
EXP3A0:	MOVM	A,T		;SET UP ABS VAL OF EXPON FOR SHIFTING
	JUMPL	N,EXP3C		;IS BASE NEGATIVE?
EXP3A1:	MOVEI	T1,0		;CLEAR AC T1 TO ZERO
	LSHC	T1,11		;SHIFT 9 PLACES LEFT
	SUBI	T1,200		;TO OBTAIN SHIFTING FACTOR
	JUMPLE	T1,EXP3GO	;IS T1 > 0
	HRRZ	B,T1		;SET UP B AS AN INDEX REG.
	CAILE	B,43
	JRST	EXP3GO
	MOVEI	T1,0		;CLEAR OUT AC T1
	LSHC	T1,(B)		;SHIFT LFT BY CONTENTS OF B
	JUMPN	A,EXP3GO	;IS EXPONENT AN INTEGER ?
	SKIPGE	T		;YES, WAS  IT NEG. ?
	MOVNS	T1		;YES, NEGATE IT
	MOVE	T,T1		;MOVE INTEGER INTO T
	JRST	EXP2.0		;OBTAIN RESULT USING EXP2.0
EXP3GO:	PUSH	P,T		;SAVE EXPONENT
	PUSHJ	P,LOGB		;CALCULATE LOG OF N
	SETZM	LIBFLG		;CLEAR THE OVER/UNDERFLOW FLAG.
	FMPR	N,(P)		;CALCULATE B*LOG(N)
	POP	P,T		;RESTORE EXP.
	SKIPE	LIBFLG		;EXP3D AND EXP3D1 ARE ERROR ROUTINES.
	JRST	EXP3D
	MOVM	T,N
	CAMLE	T,E7
	JRST	EXP3D1
	PUSHJ	P, EXPB		;CALCULATE EXP(B*LOG(N))
	POPJ	P,		;RETURN

EXP3D:	MOVM	T,N
	CAML	T,ONE
	JRST	EXP3A		;UNDERFLOW IN ARG TO EXP MEANS ANS=1.
EXP3D1:	JUMPL	N,EXP3D3	;OVERFLOW MEANS OVER/UNDER IN ANS.
EXP3D2:	PUSHJ	P,INLMES
	ASCIZ	/
% OVERFLOW/
	JRST	LRGNS1
EXP3D3:	PUSHJ	P,INLMES
	ASCIZ	/
% UNDERFLOW/
	PUSHJ	P,GOSR3
	SETZ	N,
	POPJ	P,



EXP3A:	MOVSI	N,(1.0)		;ANSWER IS 1.0
	POPJ	P,

EXPB3:	PUSHJ	P,INLMES
	ASCIZ /
% ZERO TO A NEGATIVE POWER/
LRGNS1:	PUSHJ	P,GOSR3
	HRLOI	N,377777	;LARGEST ANSWER.
	POPJ	P,

EXP3C:	MOVE	X1,A
	FAD	X1,FIXCON
	FSB	X1,FIXCON
	CAMN	A,X1
	JRST	EXP3A1		;NEGATIVE BASE, INTEGRAL POWER
	PUSH	P,N		;SAVE ARGUMENTS
	PUSH	P,T
	PUSHJ	P,INLMES
	ASCIZ /
% ABSOLUTE VALUE RAISED TO POWER/
	PUSHJ	P,GOSR3
	POP	P,T
	POP	P,N
EXP3C0:	MOVMS	N
	JRST	EXP3A0

;CHRB IS THE LIBRARY ROUTINE FOR CHR$.

CHRB:	CAMGE	N,ONE28		;ARG MUST TRUNCATE TO >= 0
	CAMG	N,MINONE	;AND < 128.
	JRST	CHRERR
	JUMPGE	N,.+2
	TDCA	N,N
	PUSHJ	P,IFIX
	CAIG	N,^D12
	CAIGE	N,^D10
	JRST	.+2
	JRST	PTXER1		;ILLEGAL LF, FF, VT CHARACTER.
	MOVEI	T,1
	PUSHJ	P,VCHTSW	;GET SPACE FOR STRING.
	LSH	N,^D29
	MOVEM	N,(T)
	HRRZI	N,(T)
	HRLI	N,777777
	POPJ	P,

CHRERR:	PUSHJ	P,INLMES
	ASCIZ	/
? CHR$ ARGUMENT/
	JRST	OUTBND


;INSTRB IS THE LIBRARY ROUTINE FOR INSTR.

INSTRB:	MOVEI	N,1		;ENTRY POINT.
	JRST	INSTR1
	JUMP
	POP	P,T
	POP	P,N
	PUSH	P,T
	CAMGE	N,ONE		;ENTRY POINT.
	JRST	INSERR
	PUSHJ	P,IFIX
INSTR1:	PUSH	P,X1
	PUSH	P,X2
	PUSH	P,F
	MOVE	F,N		;START POSITION IN F.
	SOS	N,MASAPP
	PUSHJ	P,LENBF		;GET LEN OF 1ST STR.
	AOS	MASAPP
	AOS	X2,MASAPP
	CAMG	F,N		;LEN < START POSITION?
	JRST	INSTR3		;NO.

INSOUT:	SETZ	N,
INSOU1:	POP	P,F
	POP	P,X2
	POP	P,X1
	SOS	MASAPP
	SOS	MASAPP
	POPJ	P,

INSTR3:	MOVE	X1,-1(X2)
	PUSH	P,C
	MOVE	C,N		;FIRST LEN IN C.
	MOVE	N,MASAPP
	PUSHJ	P,LENBF		;GET LENGTH OF 2ND STR.
	AOS	MASAPP
	JUMPN	N,INSTR4	;NULL?
	POP	P,C		;YES.
	MOVEI	N,(F)
	PUSHJ	P,IFLOAT
	JRST	INSOU1
INSTR4:	MOVE	X2,(X2)
	PUSH	P,G
	PUSH	P,A
	PUSH	P,B
	PUSH	P,E
	PUSH	P,T1
	MOVE	G,N		;2ND LEN IN G.
	MOVE	A,MASAPP	;GET ANY APPD STRS
	TLNN	X1,777777	;IN TEMP. SPACE.
	JRST	INSTR6		;ALSO KEYS IN THE
	TLNE	X1,377777	;FORM -N,LOC.
	JRST	INSTR5
	MOVE	X1,(X1)
	TLNN	X1,777777
	JRST	INSTR6
INSTR5:	JUMPLE	X1,INSTR6
	MOVE	N,X1
	PUSHJ	P,STRETT
	MOVE	X1,N
	MOVE	X2,(A)

INSTR6:	TLNN	X2,777777
	JRST	INSTR8
	TLNE	X2,377777
	JRST	INSTR7
	MOVE	X2,(X2)
	TLNN	X2,777777
	JRST	INSTR8
INSTR7:	JUMPLE	X2,INSTR8
	MOVEM	X1,-1(A)
	MOVE	N,X2
	PUSHJ	P,STRETT
	MOVE	X2,N
	MOVE	X1,-1(A)


INSTR8:	MOVEI	A,(F)		;SEARCH.
	MOVEI	B,1
INST85:	MOVEI	N,-1(A)		;GET C(A)TH CHAR OF 1ST
	IDIVI	N,5		;STR TO T1 AND C(B)TH
	ADDI	N,(X1)		;CHAR OF 2ND STR TO E.
	HLL	N,INSPTR(T)
	LDB	T1,N
	MOVEI	N,-1(B)
	IDIVI	N,5
	ADDI	N,(X2)
	HLL	N,INSPTR(T)
	LDB	E,N
	CAIE	T1,(E)		;CHARS EQUAL?
	JRST	INST11		;NO.
	AOJ	B,.+1		;YES.
	CAIG	B,(G)		;FINISHED WITH 2ND STR?
	JRST	INSTR9		;NO.
	MOVEI	N,(F)		;YES.
	PUSHJ	P,IFLOAT
INSOU2:	POP	P,T1
	POP	P,E
	POP	P,B
	POP	P,A
	POP	P,G
	POP	P,C
	JRST	INSOU1
INSTR9:	AOJ	A,.+1
	CAIG	A,(C)		;AT END OF 1ST STR?
	JRST	INST85		;NO.
INST11:	AOJ	F,.+1		;YES. TRY AGAIN FROM NEXT PLACE.
	CAIG	F,(C)		;NO MORE PLACES?
	JRST	INSTR8
	SETZ	N,		;NO MORE. FAIL.
	JRST	INSOU2

	440700000000
INSPTR:	350700000000
	260700000000
	170700000000
	100700000000
	010700000000

INSERR:	PUSHJ	P,INLMES
	ASCIZ	/
? INSTR ARGUMENT/
	JRST	OUTBND



;LEFTB IS THE LIBRARY ROUTINE FOR LEFT$.

LEFTB:	CAMGE	N,ONE		;ARG MUST BE >= 1.
	JRST	LEFERR
	PUSHJ	P,IFIX
	SOS	T,MASAPP
	MOVE	T,1(T)	;STRING KEY TO AC 1.
	TLNE	T,777777
	JRST	LEFTB1
LEFOU1:	SETZ	N,		;NULL ANSWER.
	POPJ	P,
LEFTB1:	JUMPL	T,LEFTB2
	EXCH	T,N		;APP BLK. IS KEY.
	JRST	LEFTB4
LEFTB2:	TLNE	T,377777
	JRST	LEFTB3
	MOVE	T,(T)
	TLNN	T,777777
	JRST	LEFOU1
LEFTB3:	PUSH	P,T1
	HLRE	T1,T
	EXCH	N,T
	MOVN	T,T
	CAMLE	T,T1
	HRL	N,T
	POP	P,T1
	POPJ	P,		;EXIT.
LEFTB4:	PUSH	P,T1
	PUSH	P,X1
	MOVE	T1,N		;SAVE KEY IN T1.
	MOVE	X1,T		;SAVE REQ. LEN IN X1.
	PUSHJ	P,LENAPB
	CAILE	N,(X1)
	JRST	LEFTB5
	MOVE	N,T1
	JRST	LEFOU2
LEFTB5:	HRRZ	T,T1
LEFTB6:	HLRE	N,1(T)		;SUCCESSIVELY "SUBTRACT"
	ADD	X1,N		;SUBSTRINGS UNTIL
	JUMPLE	X1,LEFTB7	;X1 BECOMES <= 0.
	AOJA	T,LEFTB6
LEFTB7:	JUMPE	X1,LEFTB8
	SUB	X1,N		;TRUNCATE THE SUBSTRING KEY.
	MOVN	X1,X1
	HRLM	X1,1(T)
LEFTB8:	SUBI	T,-1(T1)		;TRUNCATE THE BLOCK.
	MOVEM	T,(T1)
	HRLM	T,T1
	MOVE	N,T1
LEFOU2:	POP	P,X1
	POP	P,T1
	POPJ	P,		;EXIT.

LEFERR:	PUSHJ	P,INLMES
	ASCIZ	/
? LEFT$ ARGUMENT/
	JRST OUTBND

;LEN ROUTINE.

LENB:	SETZM	FLOAT
	JRST	.+2
LENBF:	SETOM	FLOAT
	SOS	T,MASAPP
	MOVE	N,+1(T)
	TLNE	N,777777	;NULL STRING?
	JRST	LENB4		;NO.
LENB2:	SETZ	N,		;YES, NULL STRING.
	POPJ	P,
LENB4:	JUMPG	N,LENAPP	;APPEND KEY?
	TLNE	N,377777	;NO. REAL KEY?
	JRST	LENB3		;YES, REAL KEY.
	MOVE	T,N		;NO, NOT REAL KEY, SO
	MOVE	N,(T)		;RETRIEVE THE REAL KEY.
	JUMPGE	N,LENB2		;MUST BE EITHER NULL STRING OR
LENB3:	HLRE	N,N		;LENGTH IN LH.
	MOVM	N,N
	JRST	LENAP2

LENAPP:	PUSHJ	P,LENAPB	;APPEND KEY.
LENAP2:	SKIPN	FLOAT
	PUSHJ	P,IFLOAT
	POPJ	P,

LENAPB:	PUSH	P,X1		;LENGTH OF STRING IN APP BLK ROUTINE.
	PUSH	P,X2
	HLRZ	T,N
	HRRZ	X1,N
	SETZ	N,
	SOJL	T,LENAP1	;T HAS NUMBER OF KEYS.
	HLRE	X2,1(X1)
	SUB	N,X2		;ADD UP THE LENGTHS
	AOJA	X1,.-3
LENAP1:	CAILE	N,^D132		;CHECK LENGTH <= 132.
	JRST	LENERR
	POP	P,X2
	POP	P,X1
	POPJ	P,

LENERR:	PUSHJ	P,INLMES
	ASCIZ	/
? STRING FORMULA > 132 CHARACTERS/
	JRST	GOSR2


;MIDB IS THE LIBRARY ROUTINE FOR MID$.

MIDB:	HRLOI	T,377777	;ENTRY POINT.
	MOVEM	T,MIDSAV
	JRST	MIDB1
	CAMGE	N,ONE		;ENTRY POINT.
	JRST	MIDERR
	PUSHJ	P,IFIX
	MOVEM	N,MIDSAV
	POP	P,T		;CLEAR PLIST AND ALSO GET ARG.
	POP	P,N
	PUSH	P,T
MIDB1:	CAMGE	N,ONE
	JRST	MIDERR
	PUSHJ	P,IFIX
	SOJ	N,.+1
	PUSH	P,C
	MOVE	C,N
	PUSHJ	P,LENBF
	AOS	MASAPP
	SUBI	N,(C)
	JUMPLE	N,MIDB2
	CAMLE	N,MIDSAV
	MOVE	N,MIDSAV
	EXCH	N,C
	MOVE	T,MASAPP
	JRST	RIENTY		;GO TO RIGHT$ ROUTINE.
MIDB2:	SETZ	N,
	JRST	RIGOU1

MIDERR:	PUSHJ	P,INLMES
	ASCIZ	/
? MID$ ARGUMENT/
	JRST	OUTBND



;RIGHTB IS THE LIBRARY ROUTINE FOR RIGHT$. IT IS ALSO
;USED BY MID$.

RIGHTB:	CAMGE	N,ONE		;ARG MUST BE >= 1.
	JRST	RIGERR
	PUSHJ	P,IFIX
	PUSH	P,C
	MOVE	C,N		;TOTAL LENGTH REQ. IN C.
	PUSHJ	P,LENBF
	AOS	T,MASAPP
	CAILE	N,(C)		;REQ. LEN >= ACTUAL LEN?
	JRST	RIGHT1		;NO.
	MOVE	N,(T)		;YES. RETURN THE ENTIRE STR.
	JRST	RIGOU1

RIGHT1:	SUBI	N,(C)		;START PLACE -1 IN N.
RIENTY:	PUSH	P,T1		;MID$ ENTERS HERE.
	PUSH	P,A
	PUSH	P,X1
	PUSH	P,X2
	MOVE	T1,(T)		;ORIGINAL KEY IN T1.
        JUMPLE  T1,RIGHT3
        MOVE    X1,N            ;APPEND KEY
        MOVE    X2,T    
        MOVE    N,T1
        PUSHJ   P,STRETT        ;GET APPENDED STRING
        MOVE    T1,N            ;INTO TEMP SPACE
        MOVE    T,X2
        MOVE    N,X1
        JRST    RIGHT2
RIGHT3:
	TLNN	T1,377777	;NON-APP KEY.
	MOVE	T1,(T1)
	HRRZI	T1,(T1)
	CAML	T1,VARFRE	;CAN THIS STR BE WRITTEN OVER?
	JRST	RIGHT2		;YES.
	MOVEI	T,(C)		;NO.
	PUSHJ	P,VCHTSC	;GET ROOM FOR NEW STR.
	HRRZI	A,(T)		;NEW LOW WORD TO A.
	MOVE	T1,MASAPP	;GET KEY
	MOVE	T1,(T1)		;AGAIN IN T1.
	TLNE	T1,377777
        JRST    .+3
        SKIPA   T1,(T1)
RIGHT2:	MOVEI	A,(T1)		;NEW LOW WORD IS OLD LOW WORD.

RIGH15:	IDIVI	N,5		;N HAS START CHAR -1.
	ADDI	N,(T1)		;T1 HAS OLD START WORD.
	JUMPN	T,RIGH16	;BLT OR ILDB?
	HRL	N,N		;BLT.
	HRRI	N,(A)		;A HAS NEW START WORD.
	MOVEI	X1,4(C)		;C HAS TOTAL SUBSTR. LENGTH.
	IDIVI	X1,5		;MOVE THIS MANY WORDS.
	ADDI	X1,-1(A)
        PUSH    P,N
	BLT	N,(X1)
        POP     P,N
	MOVN	C,C
	HRL	N,C		;KEY TO N.
        JRST    RIGOUT
RIGH16:	HLL	N,INSPTR-1(T)	;ILDB.
	HRRZI	T,(A)
	HRLI	A,440700
	MOVN	C,C
	HRL	T,C		;KEY TO T.
	ILDB	T1,N
	IDPB	T1,A
	AOJL	C,.-2
	MOVE	N,T		;KEY TO N.
RIGOUT: POP     P,X2
        POP     P,X1
        POP     P,A
        POP     P,T1
RIGOU1: POP     P,C
        SOS     MASAPP
        POPJ    P,

RIGERR:	PUSHJ	P,INLMES
	ASCIZ	/
? RIGHT$ ARGUMENT/
	JRST	OUTBND


;SPACEB IS THE LIBRARY ROUTINE FOR SPACE$.

SPACEB:	CAML	N,ONE		;ARG MUST BE >= 1 AND
	CAML	N,ONE33		;<= 132 CHARACTERS.
	JRST	SPACER
	PUSHJ	P,IFIX
	PUSH	P,X1
	PUSH	P,X2
	MOVE	T,N
	PUSHJ	P,VCHTSC	;GET SPACE FOR STRING.
	MOVE	X1,N		;SAVE NEGATIVE STRING LENGTH.
	SUBI	X1,1
	IDIVI	X1,5
	ADDI	X1,(T)
	MOVE	X2,[ASCIZ /     /]
	MOVN	N,N
	HRL	N,N
	HRR	N,T
	MOVEM	X2,(T)
	AOJ	T,.+1
	CAIG	T,(X1)
	JRST	.-3
	POP	P,X2
	POP	P,X1
	POPJ	P,		;EXIT.

SPACER:	PUSHJ	P,INLMES
	ASCIZ	/
? SPACE$ ARGUMENT/
	JRST	OUTBND



;STRB IS THE LIBRARY ROUTINE FOR STR$.

STRB:	MOVEI	T,3
	PUSHJ	P,VCHTSW	;GET SPACE FOR A THREE WORD
	HRLI	T,440700	;STRING.
	MOVEM	T,STRPTR	;SET UP BYTE POINTER.
	SETZM	STRCTR
	MOVEI	X2,.+2
	JRST	SAVCS1
	PUSH	P,Q
	PUSH	P,T
	PUSHJ	P,OUTSRF	;FORM STRING
	POP	P,N
	HRL	N,STRCTR	;SET UP ADDRESS KEY.
	POP	P,Q
	MOVEI	X2,.+2		;RESTORE AC'S.
	JRST	RESACS
	POPJ	P,		;EXIT.


;VALB IS THE LIBRARY ROUTINE FOR VAL.

VALB:	PUSHJ	P,STRPL1
	JRST	VALERR
	JRST	VALB6

STRPL1:	MOVE	T,MASAPP
	MOVE	T,(T)
	TLNN	T,777777
	POPJ	P,
	TLNE	T,377777	;REAL KEY?
	JRST	VALB2
	MOVE	T,(T)
	TLNN	T,777777
	POPJ	P,
VALB2:	POP	P,N
	PUSHJ	P,SAVACS
	PUSH	P,Q
	MOVE	Q,N
	MOVE	N,T
	HLRE	T,N
	JUMPG	N,VALB4

	MOVM	T,T		;NON-APP KEY.
	MOVEI	X1,(T)		;SAVE NO. OF CHARS. IN X1.
	IDIVI	T,5
	ADDI	T,1		;TRANSFER THE STRING AND
	HRRZ	X2,N		;GUARANTEE ROOM FOR "$"
	CAML	X2,VARFRE	;TERMINATING CHARACTER.
	JUMPN	T1,VALB5	;NO NEED TO TRANSFER IF IT IS
	MOVE	X2,MASAPP
	MOVEM	N,(X2)
	PUSHJ	P,VCHTSW	;ALREADY IN TEMP SPACE WITH
	HRLI	T,440700	;ROOM FOR "$".
	MOVE	X2,MASAPP
	MOVE	X2,(X2)
	HRLI	X2,440700
	HRRI	N,(T)		;NEW KEY IN N.
VALB3:	ILDB	T1,X2		;TRANSFER.
	IDPB	T1,T
	SOJG	X1,VALB3
	JRST	VALB5		;STRING IS SET UP, GO TO EVANUM.

VALB4:	HRRZ	X2,N		;APP. KEY.
	ADDI	T,(X2)
	HLRE	X1,(T)
	SOJ	X1,.+1
	HRLM	X1,(T)
	PUSHJ	P,STRETT	;TRANSFER THE STRING.
	HLRE	X1,N
	CAMN	X1,[-1]
	JRST	VALERR
	AOJ	X1,.+1
	HRLI	N,(X1)

VALB5:	HRRZ	T1,N		;GET BYTE POINTER TO LAST
	HLRE	X1,N		;CHAR + 1 INTO T.
	MOVM	X1,X1
	IDIVI	X1,5
	ADDI	T1,(X1)
	HRLI	T1,440700
	IBP	T1
	SOJGE	X2,.-1
	MOVEI	X2,"$"
	DPB	X2,T1		;DEPOSIT "$" TO GUARANTEE
	MOVEM	T1,VALPTR	;THAT EVANUM STOPS.
	HRR	T,N
	HRLI	T,440700
	PUSHJ	P,NXCH		;FIRST CHAR TO C.
	MOVEI	T1,1(Q)
	POP	P,Q
	PUSH	P,Q
	JRST	(T1)

VALB6:	PUSHJ	P,EVANUM
	JRST	VALERR		;FAIL.
	CAME	T,VALPTR	;STOPPED AT RIGHT PLACE?
	JRST	VALERR		;NO.
	POP	P,Q		;YES. RESTORE AC'S.
	MOVEI	X2,.+2
	JRST	RESACS
	SOS	MASAPP
	POPJ	P,		;EXIT.

VALERR:	PUSHJ	P,INLMES
	ASCIZ	/
? VAL ARGUMENT NOT IN CORRECT FORM/
	JRST	GOSR2

	SUBTTL	RUN-TIME RANDOM NUMBER ROUTINES

IFN FTRND, <
;;WRANB -- PSEUDO-RANDOM RESET/WARMUP
; PUSHJ	P,WRANB
;
;THE ARG IS IN ACCUMULATOR A
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 2.	W IS A BIT VECTOR (BITS 05-35 SIGNIFICANT).
; 3.	RETURNS NO USEFUL VALUE IN AC Z.
; 4.	CREATES A BASIS OF "NNN" VECTORS AT VRANT IN VRAN,
;	BASED ON THE WARMUP ARGUMENT W. (STANDARD VALUE
;	IS W=0.) RESETS VRAN'S OWN INDEX. USES VRAN LOCATIONS
	;		VRANR	; VRAN OWN INDEX RESET VALUE.
	;		VRANW	; VRAN'S WARMUP CONSTANT.
	;		VRANT	; VRAN'S VECTOR-TABLE.
	;		VRANN	; NEGATIVE TABLE LENGTH.
; 5.	FORTRAN AC ASSIGNMENTS ARE
;	N=00	; FUNCTION-VALUE RETURN AC.
;	T=1	; SCRATCH AC.
;	P=17	; PUSHDOWN LIST
;	T1=2	; INDEX AC.
;	A=3	; INDEX AC.
; 6.	WRAN MAY BE USED FREELY TO REPEAT A PREVIOUSLY GENERATED
;	SEQUENCE (BY CALLING WRAN WITH THE PREVIOUSLY USED VALUE
;	FOR W), OR TO CAUSE THE GENERATION OF A COMPLETELY NEW
;	SEQUENCE (BY CALLING WRAN WITH A NEW VALUE FOR W).


	...=0	; ELLIPSIS (FOR CONVENIENCE).
>


IFN FTRND, <
WRANB:	XOR	N,VRANW		;   ADJUST,
	TLZ	N,(37B4)	;   IGNORE BITS 00-04,
	JUMPE	N,WRANB		;   REJECT 0.
	MOVSI	T1,VRANN		; ESTABLISH OUTER LOOP.
WRAN2:	MOVNI	A,6	; ESTABLISH INNER LOOP.
WRAN3:	MOVE	T,N		; COPY ARGUMENT,
	ROT	T,13		;   POSITION BITS 05-10 FOR
	XOR	T,N		;   MOD 2 SUM WITH BITS 30-35.
	ROT	T,-6		; USE RESULT AS NEW
	LSHC	N,6		;   ARGUMENT BITS 30-35.
	AOJN	A,WRAN3		; SIX BYTES DONE? NO, BACK.
	MOVEM	N,VRANT(T1)	; YES, ARGUMENT IS BASIS VECTOR.
	AOBJN	T1,WRAN2		; "NNN" VECTORS DONE? NO, BACK.
	MOVE	N,VRANR		; RESET VRAN OWN INDEX.
	MOVEM	N,VRANX		; (AFTER RESTORING AC'S!)
	POPJ	P,			; RETURN (OVER "ARG").


;FRANB -- FLOATING-POINT PSEUDO-RANDOM GENERATOR.

; PUSHJ	P,FRANB
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 3.	RETURNS IN AC N A FLOATING-POINT NUMBER AS AN
;	INSTANCE OF A REAL RANDOM VARIABLE UNIFORMLY
;	DISTRIBUTED ON THE OPEN INTERVAL (0,1).
; 4.	REQUIRES THE VECTOR GENERATOR FUNCTION VRAN.
;VRAN
; 5.	FORTRAN AC ASSIGNMENTS ARE
RNDB:
FRAN1:	PUSHJ	P,VRANB		; GET RANDOM VECTOR,
	LSH	N,-9		;   SCALE TO MANTISSA,
	JUMPE	N,FRAN1		;   REJECT ZERO.
	TLO	N,(1B1)		; FORCE EXPONENT OF 2^0,
	FAD	N,[1B1]		;   NORMALIZE.
	POPJ	P,		; RETURN (IGNORE "ARG").
>
IFN FTRND, <
;VRAN7B -- 36-BIT PSEUDO-RANDOM GENERATOR.

;; NAME SHOULD ALWAYS BE
;; "VRANXX", WHERE "XX" IS THE ASSEMBLED VALUE OF
;; THE PARAMETER "NNN". (SEE 6. BELOW.) USE ONLY THE
;; STATISTICALLY BEST "EEE" VALUE FOR EACH "NNN" VALUE.

; PUSHJ	S,VRANB
;
; 1.	USES STANDARD BASIC "PUSHJ" CALLING SEQUENCE.
; 3.	RETURNS IN AC N A 36-BIT PSEUDO-RANDOM VECTOR.
;		VRANX	; AC STORAGE, OWN INDEX.
;		VRANR	; OWN INDEX RESET VALUE.
;		VRANW	; WARMUP CONSTANT.
;		VRANT	; VECTOR-TABLE.
;		VRANN	; NEGATIVE TABLE LENGTH.
; 6.	VRAN HAS THREE ASSEMBLY PARAMETERS:
	RADIX 10
	NNN=7	; VECTOR-TABLE SIZE.
	EEE=3	; VECTOR-TABLE OFFSET.
	RADIX 8
	W=013702175435	; VECTOR-TABLE GENERATOR.
;	WHICH ARE USED TO ESTABLISH AN INITIAL TABLE OF
;	"NNN" BASIS VECTORS <V[J] : 0 .LE. J .LT. NNN>, AND TO
;	GENERATE SUCCESSIVE VECTORS ACCORDING TO THE RULE:
;	V[NNN+J] = (V[0+J] + V[EEE+J]) MODULO (2^36) : 0 .LE. J.
;	(SEE RANPAK.TXT FOR ADMISSABLE VALUES FOR <NNN,EEE,W>,
;	AND A DISCUSSION OF THE ALGORITHM.)

	VRANN=-NNN	; NEGATIVE TABLE LENGTH (FOR WRAN).
>

IFN FTRND, <
VRANB:	MOVE	T1,VRANX		; SET UP OWN INDEX.
	MOVE	N,VRANT+NNN(T1)	; ADDEND V[E+J] IF J .LT. N-E.
	TRNN	T1,(1B0)		; [J.LT.N-E]=[RH(T1).LT.0]?
	MOVE	N,VRANT+0(T1)	; ADDEND V[E+J] IF J .GE. N-E.
	ADDB	N,VRANT+NNN-EEE(T1)	; AUGEND V[0+J] AND RESULT V[N+J].
	AOBJN	T1,VRAN1		; STEP J; J.GT.N? NO,OVER.
	MOVE	T1,VRANR		; YES, RESET J.
VRAN1:	MOVEM	T1,VRANX		; SAVE OWN INDEX.
	POPJ	P,		;EXIT

VRANR:	XWD	-<NNN>,-<NNN-EEE>	; OWN INDEX RESET VALUE.

VRANW:	EXP	W		; WARMUP CONSTANT (FOR WRAN).
>
;SUBROUTINES FOR GENERAL ROLL MANIPULATION



;BINARY SEARCH OF SORTED ROLL
;CALL WITH KEY IN A
;RETURN IN B ADDRS OF FIRST
;ENTRY NOT LESS THAN KEY
;SKIP RETURN IF LEFT SIDES EQUAL

SEARCH:	MOVE	B,FLOOR(R)
	SKIPA	X1,CEIL(R)
SEAR1:	MOVEI	B,1(X2)
	CAIGE	B,(X1)
	JRST	SEAR2
	CAML	B,CEIL(R)
	POPJ	P,
	JRST	SEAR3

SEAR2:	MOVEI	X2,@X1
	ADD	X2,B
	ASH	X2,-1
	CAMLE	A,(X2)
	JRST	SEAR1
	HRRI	X1,0(X2)
	CAIGE	B,(X1)
	JRST	SEAR2

SEAR3:	HLLZ	X2,(B)
	CAMN	X2,A
	AOS	(P)
	POPJ	P,
;ROUTINE TO QSA FOR "THEN" OR "GOTO" (USED IN "IF", "ON" STATEMENTS)
THENGO:	PUSHJ	P,QSA
	ASCIZ /THEN/
	CAIA
	POPJ	P,
	PUSHJ	P,QSA
	ASCIZ /GOTO/
	FAIL <? ILLEGAL FORMAT>
	POPJ	P,

;COMMON SUBROUTINE RETURNS

CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

;ERROR RETURNS

ILFORM:	FAIL	<? ILLEGAL FORMULA>
ILVAR:	FAIL	<? ILLEGAL VARIABLE>
GRONK:	FAIL	<? ILLEGAL FORMAT>
ILLINS:	FAIL	<? ILLEGAL INSTRUCTION>


;COMPILATION ERROR


FAILER:	SKIPN	RUNFLA		;IS THIS THE FIRST ERROR IN COMPILATION?
	JRST	FAIL0		;NO.
	PUSHJ	P,INLMES	;YES. SETUP <CRLF> TO FOLLOW HEADING.
	ASCIZ /
/
FAIL0:	PUSHJ	P,FAIL1
        GO (1,NXTST1)

FAIL1:	MOVE	T,40
FAILR:	MOVEI	D,0
	PUSHJ	P,PRINT
	LDB	X1,[POINT 4,40,12]	;IS AC FIELD NONZERO?
	JUMPE	X1,FAIL2
	MOVE	T,N			;ATTACH NUMBER IN 'N' TO MSG
	PUSHJ	P,PRTNUM
FAIL2:	PUSHJ	P,INLMES
	ASCIZ / IN LINE /
	MOVE	T,L
	ADD	T,FLLIN
	HLRZ	T,(T)
	PUSHJ	P,PRTNUM
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3
	PUSHJ	P,INLMES
	ASCIZ	/
/
	SETZM	RUNFLA
	POPJ	P,

;ROUTINES TO ALLOW AND DELAY REENTRY.
;LOCKON TEMPORARILY PREVENTS REENTRY
;LOCKOF ALLOWS REENTRY AND REENTERS IF THERE IS A STANDING REQUEST
;REENTR MAKES A REENTRY OR MAKES A REQUEST AND CONTINUES
LOCKON:	SKIPGE	RENFLA
	SETZM	RENFLA		;TURN ON REENTER PROTECT
	POPJ	P,

LOCKOF:	SKIPLE	RENFLA
        EXTERN REENT2
        JRST REENT2
	SETOM	RENFLA		;ALLOW REENTER
	POPJ	P,

;ROUTINE TO READ CHARACTER, SKIPPING BLANKS
;CALL:	MOVE	T,<POINTER TO CHAR BEFORE FIRST>
;	PUSHJ	P,NXCH
;	...	RETURN, C:= (<FLAGS>)CHARACTER

NXCHS:	ILDB	C,T		;DOESNT SKIP TAB OR BLANK
	CAIE	C," "
	CAIN	C,11
	POPJ	P,
	JRST	.+2		;SKIP INTO NXCH

NXCH:	ILDB 	C,T		;FETCH NEXT CHARACTER
	HLL	C,CTTAB(C)	;GET FLAGS FROM CTTAB
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.SPTB	;SPACE OR TAB?
	JRST	NXCH		;YES. IGNORE
	POPJ	P,

NXCHD:	ILDB	C,T
NXCHD2:	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	POPJ	P,

;GET NEXT CHAR, BUT CHECK FOR ILLEGAL CHARS (CHARS THAT COULD ONLY BE IN A STRING)
NXCHK:	PUSHJ	P,NXCH
	TLNE	C,F.STR
	FAIL	<? ILLEGAL CHARACTER>
	POPJ	P,

;SCAN INITIAL LETTER, LETTER IS PLACED LEFT
;JUSTIFIED IN A, 7-BIT ASCII.

SCNLT1:	HRRZ	A,C
	ROT	A,-7
	JRST	NXCH

;SCAN SECOND LETTER, NON-SKIP RETURN IF NOT LETTER.
;MAKE 7-BIT LETTER LEFT JUST IN A
;INTO 6-BIT. THAN PUT 6-BIT CURRENT LETTER IN A.

SCNLT2:	TLNN	C,F.LETT
	POPJ	P,
SCN2:	TLNN	A,400000	;ENTER HERE TO PROCESS NON-LETTER CHARS
	TLZA	A,200000
	TLO	A,200000
	LSH	A,1
	MOVE	X1,[POINT 6,A,5]
	JRST	SCNLTN	

;ENTER HERE TO SCAN SECOND CHAR EVEN IF BOTH ARE NOT LETTERS.


;SCAN THIRD LETTER, NON-SKIP IF NOT LETTER.
;PUT 6-BIT LETTER TO 3RD 6-BIT FIELD IN A.

SCNLT3:	TLNN	C,F.LETT
	POPJ	P,
SCN3:	MOVE	X1,[POINT 6,A,11]

;NOW PUT 6-BIT LETTER INTO A, ADJUSTING LOWER CASE, INCREMENTING POINTER.

SCNLTN:	TLNN	C,F.LCAS
	TRC	C,40
	IDPB	C,X1
	AOS	(P)
	JRST	NXCH


;THIS ROUTINE IS USED AT RUNTIME BY THE READ# STATEMENTS.
;DELAWY SKIPS THROUGH DELIMITERS AND STOPS ON THE FIRST
;NON-TAB, NON-SPACE, NON-COMMA.

DELAWY:	LDB	C,T
	JUMPE	C,.-1
	PUSHJ	P,NXCHD2
	TLNN	C,F.COMA+F.SPTB
	POPJ	P,
	PUSHJ	P,NXCH
	JRST	.-3


;QUOTE SCAN AND TEST
;CALL WITH PATTERN ADDRS IN X1
;SKIP IF EQUAL.	C,T UPDATED TO LAST CHAR SCANNED.
QST:	HRLI	X1,440700	;MAKE BYTE PNTR TO PATTERN
QST1:	ILDB	X2,X1		;GET PATTERN CHAR
	JUMPE	X2,CPOPJ1	;DONE ON NULL
	SUBI	X2,(C)
	JUMPE	X2,.+4		;DO CHARACTERS MATCH?
	TLNE	C,F.LCAS	;NO. LOWER CASE LETTER?
	CAME	X2,[ EXP -40]	;YES. SAME LETTER OF ALPHABET?
	JRST	QST2		;NO. MATCH FAILS
	PUSHJ	P,NXCH
	JRST	QST1
QST2:	ILDB	X2,X1		;ON FAIL
	JUMPN	X2,.-1		;SKIP TO NULL
	POPJ	P,


;QUOTE SCAN OR FAIL
;CALL WITH INLINE PATTERN
;GO TO GRONK IF NO MATCH

QSF:	POP	P,X1
	PUSHJ	P,QST
	JRST	GRONK
	JRST	1(X1)

;QUOTE SCAN UNTIL FAIL.
;CALL WITH INLINE PATTERN.

QSAX:	POP	P,X1
	PUSHJ	P,QST
	JRST	1(X1)
	JRST	1(X1)

;QUOTE SCAN WITH ANSWER
;CALL WITH INLINE PATTERN
;SKIP ON SUCCESS		;ON FAIL, RETURN WITH C,T RESTORED

QSA:	POP	P,X1		;GET PATTERN ADDRESS
	PUSH	P,C		;SAVE C,T
	PUSH	P,T
	PUSHJ	P,QST		;SAVE STRING
	JRST 	.+2
	JRST	QSA1		;MATCH
	POP	P,T		;NO MATCH.  BACK UP
	POP	P,C
	JRST	1(X1)

QSA1:	POP	P,X2
	POP	P,X2
	JRST	2(X1)

;ROUTINE TO READ NEXT INTEGER FROM SCANNED LINE
;CALL:	MOVE	T,POINTER TO FIRST CHAR
;	PUSHJ	P,GETNUM
;	...	FAIL RETURN
;	...	SUCCESS RETURN, INTEGER IN N

GETNU:	TDZA	X1,X1		;GET A NUMBER OF ANY LENGTH.
GETNUM:	MOVEI	X1,5		;GET A NUMBER OF AT MOST 5 DIGS
	TLNN	C,F.DIG		;NUMERAL?
	POPJ	P,		;NO.  FAIL RETURN
	MOVEI	N,-60(C)	;YES.  ACCUMULATE FIRST DIGIT
GETN1:	MOVE	G,T		;SAVE PNTR FOR USE BY INSERT
	PUSHJ	P,NXCH		;GET NEXT CHAR
	SOJE	X1,CPOPJ1	;EXIT IF FIVE DIGITS ALREADY
	TLNN	C,F.DIG		;NUMERAL?
	JRST	CPOPJ1		;NO.  RETURN.
	IMULI	N,^D10		;YES.  ACCUMULATE NUMBER
	ADDI	N,-60(C)
	JRST	GETN1		;GO FOR MORE
	EXTERN	STODSK
;ROUTINE TO READ A LINE INTO LINB0
;CALL:	PUSHJ	P,INLINE

INLINE:	PUSH	P,X1
	SETZB	X1,T1
	SKIPE	IFIFG
	SKIPA	T,LINPT(LP)
	MOVE	T,LINPT
	JRST	INLI1A


INLI1:	ILDB	C,TYI+1		;GET CHAR
	JRST	INLB
INLA:	SOSGE	@INCNT-1(LP)
	JRST	DSKIN
	ILDB	C,@INPT-1(LP)
INLB:	CAIE	C,15		;CR??
	CAIN	C,0
	SOJA	T1,INLI1A
	CAIN	C,"_"		;DELETE?
	JRST	INLI3		;YES
	CAIE	C,21		;IGNORE XON,XOFF
	CAIN	C,23
	SOJA	T1,INLI1A
	CAIG	C,14		;LINE TERMINATOR?
	CAIGE	C,12
	CAIA
	JRST	INLI2		;YES.  GO FINISH UP
	CAIG	T1,<%LOL>	;ROOM FOR CHAR+1 MORE?
	JRST	INLB1		;YES.
	SKIPE	IFIFG		;DISK?
	JRST	INERR		;YES, ERROR EXIT.
	MOVEI	T,INERR1	;NO, ERROR EXIT.
	JRST	ERRMSG
INLB1:	IDPB	C,T		;STORE CHAR
INLI1A:	SKIPE	IFIFG
	AOJA	T1,INLA
	SOSLE	TYI+2		;MORE INPUT?
	AOJA	T1,INLI1	;YES.  BUMP COUNT AND GO GET MORE
	INPUT 0,
	STATZ	20000
	JRST	[SKIPN CHAFLG
                GO (1,BASIC)
                GO (1,RUNNH)]
	STATO	740000
	AOJA	T1,INLI1
	MOVEI	T,INLSYS
	JRST	ERRMSG
INLSYS:	ASCIZ /
? SYSTEM ERROR/

INLI2:	MOVEI	C,15		;DONE.  PUT CR IN BFR.
	IDPB	C,T
	POP	P,X1
RESCAN:	SKIPN	IFIFG
	SKIPA	T,LINPT
	MOVE	T,LINPT(LP)
	SKIPE	IFIFG
	JRST	INLI8
	SETZM	HPOS		;CARRIAGE POSITION := LFT MRGN
	JRST	NXCH		;GET FIRST CHAR AND RETURN
INLI8:	SETZM	HPOS(LP)
	JRST	NXCH

INLI3:	SOJE	T1,INLI1A	;BACKARROW HANDLER, IGNORE IF AT LEFT
	MOVEI	C,4
	IBP	T		;BACK UP BYTE POINTER A LA JHB
	SOJG	C,.-1
	SUBI	T1,1
	SOJA	T,INLI1A

;ROUTINE TO START READING NEXT LINE OF PROGRAM
NXLINE:	MOVE	T,FLLIN
	ADDI	T,(L)
	MOVE	T,(T)
	MOVS	D,T		;SAVE LINE START
	HRLI	T,440700
	MOVE	G,FLREF	;SETUP REFROL REFERENCE.
	ADDI	G,(L)
	JRST	NXCH


DSKIN:  DPB     LP,[POINT 4,INDSK,12] ;DISK INPUT
	XCT	INDSK
	DPB	LP,[POINT 4,STADSK,12]
	XCT	STADSK
	JRST	[HRRZ T,-2(P)
		CAIE T,EOF32
		JRST EOFFAL
		JRST EOF31]
	DPB	LP,[POINT 4,STODSK,12]
	XCT	STODSK
	JRST	INLA
	MOVEI	T,INLSYS
	JRST	ERRMSG
	EXTERN	INDSK
;PRINTING SUBROUTINES

;PRINT TO QUOTE CHAR
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;ALTERNATE CALL: PRINT1, IF BYTE PNTR IN T.


PRINT:	HRLI	T,440700
PRINT1:	ILDB	C,T
	CAMN	C,D
	POPJ	P,
	PUSHJ	P,OUCH		;OUTPUT THE CHAR
	JRST	PRINT1


OUCH0:	PUSH	P,C
	AOS	HPOS(LP)
	MOVE	C,MARGIN(LP)
	SKIPGE	QUOTBL(LP)	;QUOTE MODE?
	JRST	OUCH4		;YES.
	CAML	C,HPOS(LP)	;NO.
	JRST	OUCH3
	PUSHJ	P,PCRLF
	JUMPN	LP,.+2
	OUTPUT 0,
	JRST	OUCH5
OUCH4:	CAML	C,HPOS(LP)
	JRST	.+3
	POP	P,C
	JRST	PTXER2
OUCH3:	SOS	HPOS(LP)
OUCH5:	POP	P,C
OUCH:	SKIPE	ODF		;DISK?
	JRST	DSKOT		;YES.
	SKIPLE	TYO+2		;NO.
	JRST	OUCH1
	OUTPUT 0,
	MOVEM	N,TEMLOC
        GETSTS 0,N
	TRNE	N,740000
	JRST	OUTERR
	MOVE	N,TEMLOC
OUCH1:	SOS	TYO+2
	IDPB	C,TYO+1
	AOS	HPOS
	POPJ	P,
DSKOT:	SKIPG	@OUTCNT-1(LP)
	JRST	DOS
	SOS	@OUTCNT-1(LP)
	IDPB	C,@OUTPT-1(LP)
	AOS	HPOS(LP)
	POPJ	P,
DOS:	DPB	LP,[POINT 4,OUTTDS,12]
	XCT	OUTTDS
	JRST	DSKOT
	DPB	LP,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR

;ROUTINE TO PRINT SIXBIT CHARACTERS IN ACCUM "T".
;IGNORES BLANKS.


PRNSIX:	MOVE	T1,[POINT 6,T]
	ILDB	C,T1
	JUMPE	C,PRNS1		;SKIP A BLANK
	ADDI	C,40
	PUSHJ	P,OUCH
PRNS1:	TLNE	T1,770000		;ALL SIX PRINTED?
	JRST	PRNSIX+1
	POPJ	P,


;UTILITY ROUTINE TO PRINT OUT "DEV:FILENM.EXT".
;FOR USE BY VARIOUS ERROR MESSAGES.
;DEV IS IN SAVE1, FILENM IN FILDIR, AND EXT IN FILDIR+1.
;IF LH(SAVE1)=0, DEV IS NOT PRINTED. DSK: AND .BAS ARE
;OMITTED.

PRNNAM:	PUSH	P,C
	PUSH	P,T
	PUSH	P,ODF
	SETZM	ODF
	HLRZ	T,SAVE1
	JUMPE	T,PRNAM1
	CAIN	T,<SIXBIT /   DSK/>
	JRST	PRNAM1
	MOVE	T,SAVE1
	PUSHJ	P,PRNSIX
	MOVSI	T,320000
	PUSHJ	P,PRNSIX
PRNAM1:	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,FILDIR+1
	CAIN	T,<SIXBIT /   BAS/>
	JRST	PRNAM2
	TLO	T,16
	PUSHJ	P,PRNSIX
PRNAM2:	POP	P,ODF
	POP	P,T
	POP	P,C
	POPJ	P,
;SPECIAL DECIMAL PRINT ROUTINE.  PRINTS X1,X2 AS DECIMAL NUMBERS
;SEPARATED BY THE CHARACTER IN ACCUM "A".
;IF X1 OR X2 ARE ZERO, THEY PRINT AS "00".

PRDE2:	MOVE	T,X1
	PUSHJ	P,PRDE1
	MOVE	C,A
PRDE2A:	PUSHJ	P,OUCH
	MOVE	T,X2
	MOVEI	A,177
PRDE1:	MOVEI	C,"0"		;A ONE DIGIT NUMBER?
	CAIG	T,^D9
	PUSHJ	P,OUCH		;YES. PUT OUT LEADING ZERO.
	JRST	PRTNUM

;SPECIAL RUNTIME PRINTER
RTIME:	PUSHJ	P,INLMES
	ASCIZ /
/
	SETZM	MTIME
	OUTPUT 0,
	POPJ	P,

;NUMBER PRINTER (PRINTS INTEGER IN T)


PRTNUX:	MOVEI	X1,3
	SKIPE	STRFCN
	JRST	PRTNX4
	JRST	PRTNX3
PRTNX1:	MOVEI   X1,3(B)         ;CHECK ROOM FOR INT. OF THIS SIZE " "
        SKIPN STRFCN
PRTNX3:	PUSHJ	P,CHROOM
PRTNX4:	PUSHJ	P,PSIGN
PRTNX2:	IDIVI	T,^D10
	JUMPE	T,PRTN0
	PUSH	P,T1
	PUSHJ	P,.-3
	POP	P,T1
PRTN0:	MOVEI	C,60(T1)
	AOS	NUMCOT
	SKIPE	STRFCN
	JRST	DPBSTR
	JRST	OUCH0

PRTNUM:	IDIVI	T,^D10
	JUMPE	T,PRTN1
	PUSH	P,T1
	PUSHJ	P,PRTNUM
	POP	P,T1
PRTN1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH


;OCTAL NUMBER PRINTER.
PRTOCT:	IDIVI	T,10
	JUMPE	T,PRTOC1
	PUSH	P,T1
	PUSHJ	P,PRTOCT
	POP	P,T1
PRTOC1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH


;ROUTINE USED BY OUTNUM FOR STRB.

DPBSTR:	EXCH	T,STRPTR
	IDPB	C,T
	EXCH	T,STRPTR
	SOS	STRCTR
	POPJ	P,



PSIGN:	MOVEI	C," "		;PRINT "SIGN" (BLANK OR MINUS)
	JUMPL	N,PSIGN2
	SKIPE	STRFCN
	POPJ	P,
	JRST	OUCH0
PSIGN2:	SKIPE	STRFCN
	JRST	PSIGN4
	SKIPL	QUOTBL(LP)
	JRST	PSIGN3
	MOVEI	C," "
	PUSHJ	P,OUCH0
PSIGN3:	MOVEI	C,"-"
	JRST	OUCH0
PSIGN4:	MOVEI	C,"-"
	JRST	DPBSTR


;MESSAGE PRINTER

INLMES:	PUSHJ	P,TTYIN
INLME1:	SETZM	HPOS
	EXCH	T,(P)	;GET MSG ADR AND SAVE T.
	PUSH	P,C
	PUSH	P,ODF
	SETZM	ODF
	MOVEI	D,0	;END ON NULL
	PUSHJ	P,PRINT	;PRINT THE MESSAGE
	POP	P,ODF
	POP	P,C
	EXCH	T,(P)
	SETZM	HPOS
	JRST	CPOPJ1	;RTN AFTER MSG.
	SUBTTL CORE COMPRESSION AND EXPANSION
;PANIC - ROUTINE TO COMPRESS CORE



PANIC1: ASCIZ/
? OUT OF ROOM
/
;UTILITY ROUTINE TO SET UP VRFBOT AND VRFTOP.
SETCOR:	PUSH	P,X2
	SETZM	VRFBOT
	SKIPN	SRTDBA
	JRST	SETCO3
	PUSH	P,T1
	PUSH	P,T
	PUSH	P,A
	PUSH	P,C
SETCO1:	MOVE	X2,VARFRE
	MOVEI	T1,^D200(X2)
	MOVEI	T,^D200
	SETZ	A,
	PUSHJ	P,VSUB1
	CAMG	T1,JOBREL
	JRST	SETCO2
	PUSHJ	P,VPANIC
	JRST	SETCO1
SETCO2:	MOVEM	T1,VRFBOT
	MOVEM	T1,VRFBTB
	POP	P,C
	POP	P,A
	POP	P,T
	POP	P,T1
	JRST	SETCO5
SETCO3:	MOVE	X2,VARFRE
	ADDI	X2,^D200
	CAMG	X2,JOBREL
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	SETCO3
	MOVEM	X2,VRFBOT
	MOVEM	X2,VRFBTB
SETCO5:	HRRZ	X2,JOBREL
	MOVEM	X2,VRFTOP
	POP	P,X2
	POPJ	P,

;THIS ROUTINE OBTAINS SPACE IN THE "FREE CORE AREA" FOR REAL STRINGS,
;APPEND BLOCKS, THE TEMPORARY STRINGS WHICH ARE THE RESULTS OF
;STRING FUNCTIONS, AND BUFFERS FOR DATA FILES. IT HAS SIX ENTRY POINTS:
;VCHCKC AND VCHCKW FOR REAL STRINGS, VCHTSC AND VCHTSW FOR TEMPORARY
;STRINGS, VCHAPP FOR APPEND BLOCKS, AND VCHBUF FOR DATA FILES.
;STRINGS HAVE TWO ENTRY POINTS SO THAT THEY MAY REQUEST SPACE IN UNITS
;OF EITHER CHARACTERS OR WORDS.  THE REQUEST IS IN AC T.  NO OTHER
;AC'S ARE DESTROYED. THE LOCATION OF THE LOWER BOUND OF THE OBTAINED
;SPACE IS RETURNED IN AC T.


LITLEN=^D27

VCHCKC:	PUSH	P,T1		;ENTRY POINT--REAL STRINGS.
	JUMPE	T,VCHCK1
	ADDI	T,4
	IDIVI	T,5
	JRST	VCHCK2
VCHCKW:	PUSH	P,T1		;ENTRY POINT--REAL STRINGS.
	JUMPN	T,.+2
VCHCK1:	MOVEI	T,LITLEN
VCHCK2:	MOVE	T1,VARFRE
	ADDI	T1,(T)
	SKIPN	VRFBOT
	JRST	VCHCK5
	CAMG	T1,VRFBTB
	JRST	VCHCK7
	JRST	VCHCK6
VCHCK5:	CAMG	T1,JOBREL
	JRST	VCHCK7
VCHCK6:	PUSHJ	P,VPANIC
	JRST	VCHCK2
VCHCK7:	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHCK3		;YES.
	MOVE	T,VARFRE	;NO.
	MOVEM	T1,VARFRE
	JRST	VOUT
VCHCK3:	PUSH	P,X2
	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHCK4:	MOVE	X2,VARFRE	;GET OUT OF THE WAY OF THE BUFFERS,
	MOVEI	T1,(X2)
	ADDI	T1,(T)
	SETZ	A,		;BY MOVING UP.
	PUSHJ	P,VSUB1
	SKIPN	VRFBOT
	JRST	VCHCK8
	CAMG	T1,VRFBTB
	JRST	VCHCK0
	JRST	VCHCK9
VCHCK8:	CAMG	T1,JOBREL
	JRST	VCHCK0
VCHCK9:	PUSHJ	P,VPANIC
	JRST	VCHCK4
VCHCK0:	MOVEM	T1,VARFRE
VOUT2:	MOVEI	T,(X2)
VOUT0:	POP	P,C
	POP	P,A
	POP	P,X1
VOUT1:	POP	P,X2
VOUT:	POP	P,T1
	POPJ	P,

VCHAPP:	PUSH	P,T1		;ENTRY POINT--APPEND BLOCKS.
VCHAP2:	MOVE	T1,VRFBOT
	ADDI	T1,^D47
	CAMG	T1,VRFTOP
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHAP2
	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHAP1		;YES.
	MOVE	T,VRFBOT	;NO.
	MOVEM	T1,VRFBOT
	JRST	VOUT		;NO.
VCHAP1:	PUSH	P,X2
	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHAP3:	MOVE	X2,VRFBOT
	MOVEI	T1,(X2)
	ADDI	T1,^D47
	HRRZI	T,^D47
	SETZ	A,
	PUSHJ	P,VSUB1		;GET OUT OF THEIR WAY BY MOVING UP.
	CAMG	T1,VRFTOP
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHAP3
	MOVEM	T1,VRFBOT
	JRST	VOUT2

VCHBUF:	PUSH	P,T1		;ENTRY POINT--DATA FILE BUFFERS.
	PUSH	P,X2
VCHBF4:	SKIPN	T1,VRFBOT	;LOWER BOUND IS VRFBOT, IF IT
	MOVE	T1,VARFRE	;EXISTS, OTHERWISE IT IS VARFRE.
	MOVEI	T,406
	ADDI	T1,(T)
	MOVE	X2,VRFTOP
	SKIPN	VRFBOT
	MOVE	X2,JOBREL
	CAIG	T1,(X2)
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHBF4
	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHBF2		;YES.
	SKIPE	T,VRFBOT	;NO.
	JRST	VCHBF3
	MOVE	T,VARFRE
	MOVEM	T1,VARFRE
	JRST	VOUT1
VCHBF3:	MOVEM	T1,VRFBOT
	JRST	VOUT1
VCHBF2:	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHBF5:	SETZ	A,
	SKIPN	T1,VRFBOT
	MOVE	T1,VARFRE
	MOVEI	X2,(T1)
	ADDI	T1,(T)
	PUSHJ	P,VSUB1		;GET OUT OF THEIR WAY BY MOVING UP.
	MOVE	X1,VRFTOP
	SKIPN	VRFBOT
	MOVE	X1,JOBREL
	CAIG	T1,(X1)
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHBF5
	SKIPN	VRFBOT
	JRST	.+3
	MOVEM	T1,VRFBOT
	JRST	VOUT2
	MOVEM	T1,VARFRE
	JRST	VOUT2

VCHTSC:	PUSH	P,T1		;ENTRY POINT--TEMP. STRINGS.
	JUMPE	T,VCHTS1
	ADDI	T,4
	IDIVI	T,5
	JRST	VCHTS2
VCHTSW:	PUSH	P,T1
	JUMPN	T,.+2
VCHTS1:	MOVEI	T,LITLEN
VCHTS2:	MOVE	T1,VRFTOP
	ADDI	T1,1
	SUBI	T1,(T)
	CAML	T1,VRFBOT
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHTS2
	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHTS3		;YES.
	MOVEI	T,(T1)		;NO.
	SUBI	T1,1
	MOVEM	T1,VRFTOP
	JRST	VOUT
VCHTS3:	PUSH	P,X2
	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHTS4:	MOVE	T1,VRFTOP
	ADDI	T1,1
	HRRZI	X2,(T1)
	SUBI	X2,(T)
	MOVE	A,T
	SETZ	T,
	PUSHJ	P,VSUB1		;GET OUT OF THE WAY OF THE BUFFERS BY MOVING DOWN.
	MOVE	T,A
	CAML	X2,VRFBOT
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHTS4
	MOVEI	X1,-1(X2)
	MOVEM	X1,VRFTOP
	JRST	VOUT2

;SUBROUTINE TO GET OUT OF THE WAY OF THE BUFFERS.

VSUB1:	SETZ	C,		;X2 HAS LOWER BOUND.
VSUB11:	HRRZ	X1,SRTDBA(C)	;T1 HAS UPPER BOUND.
	JUMPE	X1,CPOPJ	;T OR A HAS LENGTH, DEPENDING ON
	CAIG	X1,(X2)		;DIRECTION OF TRAVEL.
	JRST	VSUB12
	HLRZ	X1,SRTDBA(C)
	CAIL	X1,(T1)
	JRST	VSUB12
	JUMPN	A,VSUB13	;GOING DOWN OR UP?
	HRRZ	T1,SRTDBA(C)	;GOING UP.
	HRRZI	X2,(T1)
	ADDI	T1,(T)
	JRST	VSUB12
VSUB13:	HLRZ	T1,SRTDBA(C)	;GOING DOWN.
	HRRZI	X2,T1
	SUBI	X2,(A)
VSUB12:	AOJ	C,.+1
	CAIGE	C,9
	JRST	VSUB11
	POPJ	P,


VPANIC:	PUSH	P,R
	PUSH	P,X1
	PUSH	P,X2
	PUSH	P,G
	PUSH	P,A
	PUSH	P,C
	PUSH	P,E
	PUSH	P,T1
	PUSH	P,T
	SKIPN	VPAKFL
	PUSHJ	P,VPRESS
VPAN3:	MOVEI	R,^D18
	MOVE	G,VRFBTB
	SKIPN	VRFBOT
	MOVE	G,JOBREL
	MOVE	X2,VARFRE
	MOVEI	T,^D27
	SETZ	A,
VPAN31:	MOVEI	T1,^D27(X2)
	PUSHJ	P,VSUB1
	MOVEI	X2,(T1)
	SOJG	R,VPAN31
	SOJ	T1,.+1
	CAIG	T1,(G)
	JRST	VPN1
	SKIPE	X2,VRFBOT
	CAME	X2,VRFBTB
	JRST	VPAN32
	CAMLE	T1,VRFTOP
	JRST	VPAN32
VPAN30:	ADDI	T1,1
	MOVEM	T1,VRFBTB
	MOVEM	T1,VRFBOT
	JRST	VPN1
VPAN32:	PUSH	P,T1
	PUSHJ	P,VPAN16
	SKIPE	VRFBOT
	JRST	VPAN33
	POP	P,T1
	CAMLE	T1,JOBREL
	JRST	VPAN32
	JRST	VPAN92
VPAN33:	PUSHJ	P,VPRES1
	POP	P,T1
	SKIPN	A,APPLST
	JRST	VPAN30
	SETZ	E,
VPAN34:	MOVE	C,APPLST(A)
	CAILE	C,(T1)
	JRST	.+3
	AOJ	E,.+1
	SOJG	A,VPAN34
	JUMPE	E,VPAN30
	MOVE	X2,VRFBOT
	MOVEI	T,^D47
	SETZ	A,
	MOVEI	T1,^D47(X2)
	PUSHJ	P,VSUB1
	MOVEI	X2,(T1)
	SOJG	E,.-3
	SUBI	T1,1
VPAN35:	CAMG	T1,VRFTOP
	JRST	VPAN36
	PUSH	P,T1
	PUSHJ	P,VPAN16
	POP	P,T1
	JRST	VPAN35
VPAN36:	MOVEI	E,1
	ADDI	T1,1
	MOVEM	T1,VRFBOT
VPAN37:	SUBI	T1,^D47
	HRL	T1,APPLST(E)
        PUSH    P,T1
        PUSH    P,T
        MOVEI   T,^D46(T1)
        BLT     T1,(T)
        POP     P,T
        POP     P,T1
	MOVE	C,MASAPP
	SUBI	C,MASAPP
	JUMPE	C,VPAN38
	HRRZ	A,MASAPP(C)
	CAMN	A,APPLST(E)
	HRRM	T1,MASAPP(C)
	SOJG	C,.-3
VPAN38:	AOJ	E,.+1
	CAMLE	E,APPLST
	JRST	VPAN39
	MOVEI	T1,(T1)
	MOVEI	X2,-^D47(T1)
	SETZ	T,
	MOVEI	A,^D47
	PUSHJ	P,VSUB1
	JRST	VPAN37
VPAN39:	MOVEM	T1,VRFBTB
	JRST	VPN2
VPN1:	SKIPN	VRFBOT
	JRST	VPAN92
VPN2:	MOVEI	R,^D10
	MOVEI	T,^D47
	SETZ	A,
	MOVE	X2,VRFBOT
	MOVEI	T1,^D47(X2)
	PUSHJ	P,VSUB1
	MOVEI	X2,(T1)
	SOJG	R,.-3
	SUBI	T1,1
VPN3:	CAMG	T1,VRFTOP
	JRST	VPAN92
	PUSH	P,T1
	PUSHJ	P,VPAN16
	POP	P,T1
	JRST	VPN3

VPAN16:	MOVE	X2,JOBREL	;GET MORE CORE AND MOVE UP TEMP STRS.
	MOVEI	C,2000(X2)
	CORE	C,
	JRST	[MOVEI T,PANIC1
		JRST ERRMSG]
	SKIPN	VRFBOT
	POPJ	P,
	MOVE	C,VRFTOP
	CAIE	C,(X2)
	JRST	.+4
	MOVE	C,JOBREL
	MOVEM	C,VRFTOP
	POPJ	P,
	PUSHJ	P,VPRES1
	MOVE	X1,JOBREL
	MOVEI	T,10
VPAN41:	HRRZ	T1,SRTDBA(T)
        JUMPN   T1,VPAN42
        SOJGE   T,VPAN41
        JRST    VPAN43
VPAN42: MOVEI   T1,-1(T1)
        CAMLE   T1,VRFTOP
        JRST    VPAN44
        SETO    T,
VPAN43: MOVE    T1,VRFTOP
VPAN44:	MOVEI	R,(X1)
	SUBI	R,(X2)
	SKIPN	C,NUMMSP
	JRST	VPAN5
VPAN45:	HRRZ	E,MASAPP(C)	;UPDATE MASTER APP BLK.
	CAILE	E,(T1)
	CAILE	E,(X2)
	JRST	.+3
	ADDI	E,(R)
	HRRM	E,MASAPP(C)
	SOJG	C,VPAN45
VPAN5:	SKIPN	C,APPLST
	JRST	VPAN56
VPAN51:	MOVE	A,APPLST(C)	;UPDATE OTHER APP BLKS.
	HRRZ	E,(A)
	HRRZI	G,(A)
	ADDI	E,(G)
VPAN55:	HRRZ	A,(E)
	CAILE	A,(T1)
	CAILE	E,(X2)
	JRST	.+3
	ADDI	A,(R)
	HRRM	A,(E)
	SOJ	E,.+1
	CAIE	E,(G)
	JRST	VPAN55
	SOJG	C,VPAN51
VPAN56:	HRLI	T1,1(T1)
	ADDI	R,1(T1)
	HRRI	T1,(R)
        PUSH    P,T1
	BLT	T1,(X1)
        POP     P,T1
	MOVEI	X1,-1(T1)
	JUMPL	T,VPAN6
VPAN58:	HLRZ	X2,SRTDBA(T)
	SUBI	X2,1
	CAMG	X2,VRFTOP
	JRST	VPAN6
	SOJL	T,VPAN57
	HRRZ	T1,SRTDBA(T)
	CAIN	T1,1(X2)
	JRST	VPAN58
        SOJA    T1,VPAN44
VPAN57:	MOVE	T1,VRFTOP
	JRST	VPAN44
VPAN6:	HRRZM	X1,VRFTOP
	POPJ	P,
VPAN92:	POP	P,T
	POP	P,T1
	POP	P,E
	POP	P,C
	POP	P,A
	POP	P,G
	POP	P,X2
	POP	P,X1
	POP	P,R
	POPJ	P,

;PACK DOWN ROUTINE.

VPRESS:	PUSH	P,[Z VPR4]
VPRES1:	MOVE	A,MASAPP
	SUBI	A,MASAPP
	MOVEM	A,NUMMSP	;COUNT OF KEYS IN MASTER APPEND BLOCK.
	SETZM	NUMAPP		;COUNT OF KEYS IN ALL OTHER APP. BLKS.
	SETZM	APPLST		;COUNT OF OTHER APP. BLKS.
	SKIPN	A,VRFBOT
	POPJ	P,
	SETZB	G,E		;E IS INDEX FOR APPLST.
	SKIPN	SRTDBA		;BUFFERS IN THE WAY?
	JRST	VLOPF1		;NO.
VLOOP:	HLRZ	C,SRTDBA+10(G)	;FIND THE APPEND BLKS, WHICH ARE
	JUMPE	C,VLOPFN
	CAIL	C,(A)		;BETWEEN VRFBTB AND VRFBOT.
	JRST	VLOPFN
	HRRZ	C,SRTDBA+10(G)
	CAMG	C,VRFBTB
	JRST	VLOPFN
	PUSHJ	P,VCHPBK	;A BUFFER IS IN THE APP BLK SPACE.
	HLRZ	A,SRTDBA+10(G)
	CAMGE	A,VRFBTB
	JRST	VLOOP4		;NO APP BLKS. LEFT.
VLOPFN:	SOJ	G,.+1
	CAML	G,[777777777770]
	JRST	VLOOP
VLOPF1:	MOVE	C,VRFBTB	;POSSIBLY NO BUFFERS WERE SEEN.
	PUSH	P,[Z VLOOP4]
VCHPBK:	SUBI	A,^D47		;CUT UP THIS KNOWN SPACE.
	CAIGE	A,(C)
	POPJ	P,
	MOVEM	A,APPLST+1(E)
	AOJ	E,.+1
	JRST	VCHPBK

VLOOP4:	MOVEM	E,APPLST	;STORE COUNT OF APP BLKS.
	SETZ	A,		;FIND NO. OF KEYS.
	JUMPE	E,VLOOP5
	MOVE	X1,APPLST(E)
	HLRZ	X1,(X1)
	ADDI	A,(X1)
	SOJG	E,.-3
VLOOP5:	MOVEM	A,NUMAPP
	POPJ	P,


VPR4:	MOVE	G,SVRTOP	;SET UP LOWER BOUND.
	SETZ	C,
	MOVEI	E,10
	SKIPN	SRTDBA		;ANY BUFFERS?
	JRST	VPR0		;NO.
VPR5:	HLRZ	A,SRTDBA(C)
	CAIN	G,(A)		;GET ABOVE THE BUFFERS.
	JRST	.+3
	PUSHJ	P,PAKBLK
	JRST	VPR0
	HRRZ	G,SRTDBA(C)
	AOJ	C,.+1
	CAIG	C,10
	JRST	VPR5
	SETZM	SRTDBA(E)	;ABOVE ALL THE BUFFERS, SO "ERASE" THEM.
	SOJGE	E,.-1
	JRST	VPR0
PAKBLK:	JUMPE	C,CPOPJ
PAKBL0:	SETZ	X1,		;SET UP SRTDBA SO THAT
	SUBI	E,(C)		;THE NEXT HIGHEST BUFFER
PAKBL1:	MOVE	X2,SRTDBA(C)	;IS IN THE FIRST LOCATION,
	MOVEM	X2,SRTDBA(X1)	;AND "ERASE" THE LOWER BUFFERS.
	SETZM	SRTDBA(C)
	AOJ	X1,.+1
	AOJ	C,.+1
	SOJGE	E,PAKBL1
	CAILE	X1,10
	POPJ	P,
	SETZM	SRTDBA(X1)
	AOJA	X1,.-3

VPR0:	HRRZI	X2,-1		;THE LOWEST ADDRESS WILL GO INTO X1
	MOVE	A,FLVSP		;A POINTS TO EACH ENTRY ON THE ROLL.
	SETZI	X1,		;X1 WILL GET THE LOC OF NEXT LOWEST POINTER

VPR1:	CAMN	A,CEVSP		;STARTING TO SCAN SVRROL, OR STILL IN VSPROL?
	MOVE	A,SVRBOT
	CAML	A,SVRTOP
	JRST	VPR2		;SEARCH FOR MINIMUM IS OVER.
	HRRZ	E,(A)		;GET POINTER ADDRESS.
	JUMPE	E,VPR11		;NULL POINTER?
	CAIL	E,(G)		;HAVE WE MOVED THIS STRING ALREADY?
	CAIG	X2,(E)		;NO, IS IT A LOWER STRING ADDRESS?
VPR11:	AOJA	A,VPR1		;NO. LOOK AT NEXT STRING.

	MOVE	X1,A		;WE HAVE FOUND A STRING WITH LOWER ADDRESS.
	MOVE	X2,E
	AOJA	A,VPR1

VPR2:	JUMPE	X1,VPR3		;ANY MORE STRINGS TO MOVE?
	HLRE	E,(X1)		;CALCULATE WORD LENGTH..
	JUMPN	E,.+3		;IS THIS A NULL STRING?
	SETZM	(X1)		;YES. IGNORE IT.
	JRST	VPR0
	HRL	G,(X1)		;GET THE OLD ADDRESS OF THIS STRING
	MOVN	E,E		;GET WORD LENGTH
	ADDI	E,4
	PUSH	P,G
	IDIVI	E,5
	POP	P,G
	ADDI	E,-1(G)
	HRRZI	X2,(G)
	CAIN	X2,(X1)
	JRST	VPR28
	SKIPN	SRTDBA		;POSSIBLY BUFFERS IN THE WAY?
	JRST	VPR23		;NO.
	SETZ	C,
VPR21:	HLRZ	X2,SRTDBA(C)
	JUMPE	X2,VPR22
	CAILE	X2,(E)
	JRST	VPR22
	SUBI	E,-1(G)
	HRR	G,SRTDBA(C)
	ADDI	E,-1(G)
	AOJ	C,.+1
	CAIG	C,10
	JRST	VPR21
	MOVEI	E,10
	SETZM	SRTDBA(E)
	SOJGE	E,.-1
	JRST	VPR23
VPR22:	JUMPE	C,VPR23
	PUSH	P,E
	PUSH	P,X1
	MOVEI	E,10
	PUSHJ	P,PAKBL0	;WIND DOWN THE BUFFERS.
	POP	P,X1
	POP	P,E

VPR23:	HRRZ	X2,(X1)		;GET THE OLD STRING ADDRESS
	HRRM	G,(X1)		;STORE THE NEW ADDRESS IN THE MAIN KEY.
        PUSH    P,G
	BLT	G,(E)		;MOVE THE STRING DOWN
        POP     P,G
	SKIPN	X1,NUMMSP	;UPDATE MASTER APP BLK?
	JRST	VPR25		;NO NEED.
VPR24:	HRRZ	A,MASAPP(X1)	;POSSIBLY.
	CAIE	A,(X2)
	JRST	.+3
	HRRM	G,MASAPP(X1)
	SOS	NUMMSP
	SOJG	X1,VPR24
VPR25:	SKIPN	NUMAPP		;UPDATE OTHER APP BLKS?
	JRST	VPR28		;NO NEED.
	PUSH	P,E		;POSSIBLY.
	MOVE	X1,APPLST
VPR26:	HRRZ	A,APPLST(X1)
	HLRZ	C,(A)
	ADDI	C,(A)
VPR27:	HRRZ	E,(C)
	CAIE	E,(X2)
	JRST	.+3
	HRRM	G,(C)
	SOS	NUMAPP
	SOJ	C,.+1
	CAILE	C,(A)
	JRST	VPR27
	SOJG	X1,VPR26
	POP	P,E
VPR28:	AOS	G,E		;LOOK FOR A HIGHER ADDRESS NEXT TIME
	MOVEM	E,VARFRE
	JRST	VPR0

VPR3:	PUSHJ	P,BASORT	;RESTORE SRTDBA
	SETOM	VPAKFL		;STRINGS ARE TIGHTLY PACKED
	POPJ	P,


SUBTTL DECIMAL NUMBER EVALUATE/PRINT
;ROUTINE TO EVALUATE NUMBER
;T: PNTR TO FIRST CHAR, C: FIRST CHAR
;NON-SKIP IS FAIL RETURN
;RETURN NUMBER IN N

;N: ACCUM NBMR, B: SCA FAC, D: DIG CNT, USE FLGS IN LEFT OF F

EVANUM:	SETZB	N,B		;CLEAR ACS
	MOVEI	D,8
	MOVEI	F,(F)		;CLEAR LH OF F

	TLNE	C,F.PLUS	;SKIP +
	JRST	EVAN1
	TLNN	C,F.MINS	;CHECK FOR -
	JRST	EVAN2		;NO
	TLO	F,F.MIN		;SET MINUS FLG
EVAN1:	SKIPN	IFIFG
	JRST	EV1
	PUSHJ	P,NXCHD
	JRST	.+2
EV1:	PUSHJ	P,NXCH
EVAN2:	TLNN	C,F.DIG		;DIGIT?
	JRST	EVAN3		;NO

	TLO	F,F.NUM		;DIGIT SEEN FLAG
	JUMPE	N,EVAN2A	;DONT COUNT LEADING ZEROS
	SOJG	D,EVAN2A	;COUNT DIGIT,  GO ACCUM IF OK
;			REST OF DIGITS ARE INSIGNIFIGANT.
	AOJA	B,EVAN2B	;LEAD OR TRAIL 0, FUDGE SCA FAC

EVAN2A:	IMULI	N,^D10		;ACCUMULATE DIGIT
	ADDI	N,-60(C)
EVAN2B:	TLNE	F,F.DOT		;DECIMAL SEEN?
	SUBI	B,1		;YES.  COUNT DOWN SCALE FACT
	JRST	EVAN1		;GO TO NEXT CHAR

EVAN3:	TLNN	C,F.PER		;NOT DIGIT.  DEC PNT?
	JRST	EVAN4		;NO.
	TLOE	F,F.DOT		;YES, SET FLG & CHK ONLY ONE
	POPJ	P,		;2 DEC PNTS
	JRST	EVAN1
EVAN4:	TLNN	F,F.NUM		;DID WE SEE A DIGIT?
	POPJ	P,		;NO.  WHAT A LOUSY NUMBER

	MOVEI	X1,"E"
	CAIE	X1,(C)		;EXPLICIT SCALE FACTOR?
	JRST	EVAN8		;NO
	SKIPN	IFIFG
	JRST	EV2
	PUSHJ	P,NXCHD
	JRST	.+2
EV2:	PUSHJ	P,NXCH		;DO LOOK AHEAD
	TLNE	C,F.PLUS	;SCALE FACTOR SIGN
	JRST	EVAN5
	TLNN	C,F.MINS
	JRST	EVAN6
	TLO	F,F.MXP
EVAN5:	SKIPN	IFIFG
	JRST	EV3
	PUSHJ	P,NXCHD
	JRST	.+2
EV3:	PUSHJ	P,NXCH
EVAN6:	TLNN	C,F.DIG		;CHK FOR DIGIT
	POPJ	P,
	MOVEI	A,-60(C)	;SAVE FIRST EXPON DIGIT
	SKIPN	IFIFG
	JRST	EV4
	PUSHJ	P,NXCHD
	JRST	.+2
EV4:	PUSHJ	P,NXCH
	TLNN	C,F.DIG		;IS THERE A SECOND DIGIT
	JRST	EVAN7		;NO
	IMULI	A,^D10		;YES.  ACCUMULATE IT
	ADDI	A,-60(C)
	SKIPN	IFIFG
	JRST	EV5
	PUSHJ	P,NXCHD
	JRST	.+2
EV5:	PUSHJ	P,NXCH		;DO LOOK AHEAD

EVAN7:	TLNE	F,F.MXP		;NEG EXPON?
	MOVN	A,A		;YES.  NEGATE IT
	ADD	B,A		;ADD TO SCALE FACTOR
EVAN8:	JUMPE	N,CPOPJ1	;IGNORE SCALE IF NUMBER IS 0
EVAN8A:	MOVE	X1,N		;)
	IDIVI	X1,^D10		;)REMOVE ANY TRAILING ZEROS
	JUMPN	X2,EVAN8B	;)  IN MANTISSA.  (REASON:
	MOVE	N,X1		;)  SO THAT, E.G., .1,
	AOJA	B,EVAN8A	;)  .10, .100, ..., ARE THE SAME)
EVAN8B:	TLO	N,233000	;FLOAT N
	FAD	N,[0]
	SETZM	LIBFLG		;CLEAR OVER/UNDERFLOW FLAG.
EVAN8C:	CAIGE	B,^D15		;SCALE UP IF .GE. 10^15
	JRST	EVAN8D
	SUBI	B,^D14		;SUBTRACT 14 FROM SCALE FACTOR
	FMPR	N,D1E14		;MULTIPLY BY 10^14
	JRST	EVAN8C		;GO LOOK AT SCALE AGAIN
EVAN8D:	CAML	B,[EXP -^D4]	;SCALE DOWN IF .LT. 10^-4
	JRST	EVAN8E
	ADDI	B,^D18		;ADD 18 TO SCALE
	FMPR	N,D1EM18	;MULTIPLY BY 10^-18
	JRST	EVAN8D		;GO LOOK AT SCALE AGAIN
EVAN8E:	FMPR	N,DECTAB(B)	;SCALE N
	TLNE	F,F.MIN		;MINUS?
	MOVN	N,N		;YES.  NEGATE IT
	SKIPE	LIBFLG		;SKIP IF NO OVER/UNDERFLOW.
	JRST	CPOPJ
	JRST	CPOPJ1		;SUCCESS RETURN, NUMBER IN N
;ROUTINE TO PRINT NUMBER

OUTSRF:	SETOM	STRFCN
	JRST	.+2
OUTNUM:	SETZM	STRFCN
	MOVM	T,N
	JUMPN	T,OUTN1E
	JRST	PRTNUX
OUTN1E:	PUSH	P,E		;DO NOT CLOBBER E (FOR MATRX)
	MOVEI	E,0		;CHANGE IN EXPONENT
OUTN1A:	CAMG	T,D1E14		;SCALE IF .GT. 10^14
	JRST	OUTN1B
	ADDI	E,^D18		;ADD 18 TO SCALE
	FMPR	T,D1EM18	;AND MULTIPLY BY 10^-18
	JRST	OUTN1A
OUTN1B:	CAML	T,D1EM4		;SCALE IF .LT. 10^-4
	JRST	OUTN1C
	SUBI	E,^D14		;SUBTRACT 14 FROM SCALE
	FMPR	T,D1E14		;AND MULT BY 10^14
	JRST	OUTN1B		;GO SEE IF MORE SCALING
OUTN1C:	MOVE	A,T		;LOOK UP IN DEC ROLL
	MOVEI	R,DECROL
	PUSHJ	P,SEARCH
	JFCL			;DONT CARE IF FOUND
	CAME	A,(B)		;FUDGE BY 1 IF EXACT MATCH
	SUBI	B,1
	SUBI	B,DECTAB	;FIND DIST FROM MIDDLE
	JUMPN	E,OUTN2		;(NOT INTEGER IF WE SCALED)
	CAIGE	B,^D8		;CHK 8 DIG INTEGER
	CAIGE	B,0
	JRST	OUTN2
	CAML	T,FIXCON	;IS THIS 2^26?
	JRST	OUTN1D		;YES, ITS 27 BIT INT.
	MOVE	X1,T
	FAD	X1,FIXCON	;INTEGER?
	FSB	X1,FIXCON
	CAME	X1,T
	JRST	OUTN2		;NOT SUCH (LOST FRACTIONAL PART)
	FAD	T,FIXCON	;SUCH.  FIX NUMBER
	TLZ	T,377400
OUTN1D:	TLZ	T,377000	;(IN CASE 27-BIT INTEGER)
	POP	P,E		;RESTORE E
	JRST	PRTNX1

OUTN2:	SETZM	EXTFG
	FDVR	T,DECTAB(B)	;GET MANTISSA
	FMPR	T,DECTAB+5
	TRNN	T,7
	SETOM	EXTFG
	FADR	T,FIXCON
	TLZ	T,377400	;FIX
	CAMGE	T,[EXP ^D1000000]
	JRST	.+3
	IDIVI	T,^D10		;ROUNDING MADE 7 DIGITS
	ADDI	B,1		;MAKE IT 6 AGAIN
	CAIL	T,^D100000	;ROUNDING MADE 5 DIGITS?
	JRST	.+3
	IMULI	T,^D10		;YES.  MAKE 6 AGAIN
	SUBI	B,1
	ADDB	B,E		;ADD TOGETHER TWO PARTS OF SCALE
	AOJ	E,
	CAILE	E,6
	SETZM	EXTFG
	CAMG	E,[OCT -7]
	SETZM	EXTFG
	SKIPN	EXTFG
	JUMPL	E,.+2		;BETWEEN 10^-1 AND 10^6?
	CAILE	E,6
	SKIPA	E,[EXP 1]		;NO. PRINT 1 DIG BEFORE POINT
	PUSHJ	P,CHKNEF	;PRINT WITHOUT EXP (CHK ROOM FOR ^8 SP)
	PUSHJ	P,CHKEF		;PRINT WITH EXP (CHK ROOM FOR ^14 SP)
	PUSHJ	P,PSIGN		;PRINT "SIGN"
	SKIPN	EXTFG
	JUMPN	E,OUTN3		;SHOULD DEC. POINT PRECEDE NUMBER?
	MOVEI	C,"0"		;YES,SEND OUT LEADING ZERO.
	SKIPN	STRFCN
	JRST	.+3
	PUSHJ	P,DPBSTR
	JRST	.+2
	PUSHJ	P,OUCH0
	PUSHJ	P,DNPRN2	;AND DECIMAL POINT.
	SKIPN	EXTFG
	JRST	OUTN3
OUTN31:	AOJG	E,OUTN33
	MOVEI	C,"0"
	SKIPN	STRFCN
	JRST	.+3
	PUSHJ	P,DPBSTR
	JRST	.+2
	PUSHJ	P,OUCH0
	JRST	OUTN31
OUTN33:	SETZ	E,
OUTN3:	SETZM	EXTFG
	PUSHJ	P,DNPRNT	;GO PRINT NUMBER WITH DECIMAL


;HERE TO PRINT EXPONENT

	
	POP	P,E		;RESTORE E
	JUMPE	B,CPOPJ
	MOVEI	C,"E"
	SKIPN	STRFCN
	JRST	.+3
	PUSHJ	P,DPBSTR
	JRST	.+2
	PUSHJ	P,OUCH0
OUTN6:	MOVEI	C,"+"
	JUMPGE	B,.+2		;SPIT OUT SIGN
	MOVEI	C,"-"
	SKIPN	STRFCN
	JRST	.+3
	PUSHJ	P,DPBSTR
	JRST	.+2
	PUSHJ	P,OUCH0
	MOVM	T,B		;USE PRTNX2 TO PRINT EXPON
	JRST	PRTNX2


;SUBROUTINE USED BY OUTNUM TO PRINT DECIMAL NUMBER.  PRINTS
;SIX DIGITS (INTEGER IN T) WITH CONTENTS(E) DIGITS
;TO THE LEFT OF DECIMAL POINT

DNPRNT:	MOVEI	D,-1		;SIGNAL TRAILING ZERO UNLESS...
	JUMPE	B,.+2		;E-NOTATION
	MOVEI	D,0
DNPRN0:	IDIVI	T,^D10		;GET LAST DIGIT
	JUMPE	T,DNPRN1	;IS IT FIRST?
	JUMPN	T1,.+2		;NON ZERO DIGIT?
	SKIPA	T1,D		;NO, STASH ZERO OR TRAILZERO
	MOVEI	D,0		;YES. TRAILER IS OVER.
	HRLM	T1,(P)		;NO.  STASH DIGIT
	PUSHJ	P,DNPRN0	;CALL DNPRNT RECURSIVELY
	HLRE	T1,(P)		;RESTORE DIGIT
	JUMPGE	T1,.+3		;ORDINARY DIGIT?
	JUMPLE	E,CPOPJ		;NO, TRAILZERO. AFTER DECIMAL POINR?
	MOVEI	T1,0		;NO, STASH A ZERO.


	EXTERN EXTFG

DNPRN1:	MOVEI	C,60(T1)	;PRINT DIGIT
	SKIPN	STRFCN
	JRST	.+3
	PUSHJ	P,DPBSTR
	JRST	.+2
	PUSHJ	P,OUCH0
	SOJN	E,CPOPJ		;COUNT DIGITS.  POINT NEXT?
DNPRN2:	MOVEI	C,"."		;YES.  PRINT POINT
	SKIPE	STRFCN
	JRST	DPBSTR
	JRST	OUCH0

;CHECK FOR ROOM ON A LINE FOR E-FORM NUMBER:
CHKEF:	MOVEI	X1,^D14		;NEED 14 SP TO PRINT THIS NUMBER.
	PUSH	P,B		;SAVE EXPONENT
	SKIPN	STRFCN
	PUSHJ	P,CHROOM	;FIND ROOM OR DO CRLF
	POP	P,B
	POPJ	P,

;CHECK FOR ROOM FOR NON-EFORM DECIMAL NUMBER.
CHKNEF:	CAIL	E,0
	SETZM	EXTFG
	SKIPE	EXTFG
	SKIPA	X1,[EXP ^D14]
	MOVEI	X1,^D10
	SKIPN	STRFCN
	PUSHJ	P,CHROOM
	MOVEI	B,0		;NO EXPONENT.
	JRST	CPOPJ1		;SKIP-RTN

;POWER-OF-TEN TABLE.

D1EM18:	OCT	105447113564	;10^-18

DECFLO:
D1EM4:	OCT	163643334273	;10^-4
	OCT	167406111565
	OCT	172507534122
	OCT	175631463146
DECTAB:	DEC	1.0		;10^0
	DEC	1.0E1
	DEC	1.0E2
	DEC	1.0E3
	DEC	1.0E4
	DEC	1.0E5
	DEC	1.0E6
	DEC	1.0E7
	OCT	233575360401
	DEC	1.0E9
	DEC	1.0E10
	DEC	1.0E11
	OCT	250721522451	;10^12
	OCT	254443023471
D1E14:	OCT	257553630410	;10^14
DECCEI:

MAXEXP=^D38
DECFIX:	EXP 225400000000
FIXCON:	EXP 233400000000

;FLAGS USED BY DECIMAL READER/PRINTER

F.NUM=200000	;DIGIT SEEN
F.MIN=100000	;MINUS SEEN
F.MXP=40000	;MINUS EXPONENT
F.DOT=20000	;DECIMAL POINT SEEN
SUBTTL ERROR MESSAGES

;ERROR MESSAGE ROUTINE.
;
;AC T ENTERS WITH THE LOC OF THE MESSAGE.
;ALL OTHER AC'S, EXCEPT P, CAN BE DESTROYED.

ERRMSG:	SETZM	ODF
	SETZM	HPOS
	PUSHJ	P,TTYIN
	SETZ	D,		;END ON NULL.
	PUSHJ	P,PRINT		;PRINT MESSAGE.
	SKIPE	CHAFL2		;CHAINING?
	JRST	.+3
	OUTPUT 0,
	JRST	UXIT
ERRMS2:	PUSH	P,[Z UXIT]	;YES, ADD DEV, FILENM, ETC.
ERRMS3:	PUSHJ	P,INLMES
	ASCIZ	/ IN /
	PUSH	P,ODF
	SETZM	ODF
	HLRZ	T,CURDEV
	CAIN	T,<SIXBIT/   DSK/>
	JRST	ERRMS4
	MOVE	T,CURDEV	;DEV MAY BE > 3 LETTERS.
	PUSHJ	P,PRNSIX
	MOVEI	T,32
	PUSHJ	P,PRNSIX
ERRMS4:	MOVE	T,CURNAM
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	POP	P,ODF
	OUTPUT 0,
	SETZM	HPOS
	POPJ	P,

NOOUT:	ASCIZ	/
? CANNOT OUTPUT TO THIS DEVICE/
NOIN:	ASCIZ	/
? CANNOT INPUT FROM THIS DEVICE/
COMM1:	PUSHJ	P,INLMES
	ASCIZ /
? WHAT?
/
COMM1A:	SKIPE	CURNAM		;HAS A NEW OR OLD FILE BEEN SPECIFIED YET?
        GO (1,FIXUP)
        GO (1,ASKNEW)

BADDEL:	PUSHJ	P,INLMES	;DELETE COMMAND HAD NO ARGUMENTS.
	ASCIZ /
? DELETE COMMAND MUST SPECIFY WHICH LINES TO DELETE
/
	JRST	COMM1A

NOSAVE:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	"
? CANNOT OUTPUT "
	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	OUTPUT 0,
	SETZM	HPOS
        GO (1,BASIC)

INERR1:	ASCIZ	/
? LINE TOO LONG/

NOGETF:	PUSHJ	P,QNTFND
        GO (1,BASIC)

TTYIN:	PUSH	P,T
	MOVEI	T,TTYBUF	;SET UP TTY BUFFS
	MOVEM	T,JOBFF
	INIT 0 ,	1
	SIXBIT	/TTY/
	XWD	TYO,TYI
	HALT	.-3
	INBUF 0 ,	1
	OUTBUF 0 ,	1
	POP	P,T
	POPJ	P,

	EXTERN BADGNN,BADMSG,CRLFMS,FILUSN


NOGETD:	SETZM	ODF
	PUSH	P,T
	PUSHJ	P,INLMES
	ASCIZ	/
? NO SUCH DEVICE /
	POP	P,T
	PUSHJ	P,PRNSIX
	OUTPUT 0,
	JRST	UXIT

NOLIN:	ASCIZ	/
? NO SUCH LINE IN RUN(NH) OR CHAIN/

ILLIN:	ASCIZ	/
? ILLEGAL LINE REFERENCE IN RUN(NH) OR CHAIN/

NOTNEW:	ASCIZ /
? DUPLICATE FILE NAME. REPLACE OR RENAME/

RESERR:	ASCIZ	/
? COMMAND ERROR (YOU MAY NOT OVERWRITE LINES OR CHANGE THEIR ORDER)
/


OUTERR:	MOVEI	T,INLSYS	;OUTERR EXPECTS THE STATUS BITS IN N.
	TRNE	N,040000
	MOVEI	T,OUTQMS
	TRNE	N,400000
	MOVEI	T,OUTLMS
	JRST	ERRMSG
OUTLMS:	ASCIZ	/
? DEVICE IS WRITE LOCKED/
OUTQMS:	ASCIZ	/
? QUOTA EXCEEDED OR BLOCK NO. TOO LARGE ON OUTPUT DEVICE/
	DEFINE	R(A)
<IRP	A
<	EXP	OPS'A
	EXTERN	OPS'A>>
FILMOD:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+1	>>
OUTPT:	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+2
	EXTERN	DO'A	>>
OUTCNT:	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<	EXP	DI'A+1
	EXTERN	DI'A	>>
INPT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE	R(A)
<	IRP	A
<	EXP	DI'A+2	>>
INCNT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	POINT 7,LINB'A
	EXTERN	LINB'A	>>
LINPT:	R<0,1,2,3,4,5,6,7,8,9>


	EXTERN	IFIFG,ODF
INSET:	HRRZ	LP,40		;GET CHANNEL NUMBER
INST2:	JUMPN	LP,.+3		;TTY?
	SETZM	IFIFG		;YES.
	POPJ	P,
	SKIPG	X1,ACTBL-1(LP)	;NO.  GET CORRESPONDING ACCESS CODE.
	JRST	FNMXER
	CAIE	X1,1		;IF NOT EQUAL TO 1, FILE NOT OK FOR READING
	JRST	ILRD		;ILLEGAL READ ERROR MESSAGE
	SETOM	IFIFG
	POPJ	P,


EOF:	HRRZ	LP,40		;END OF FILE TEST.
EOF2:	SKIPG	X2,ACTBL-1(LP)	;ACTBL ENTRY = 1 MEANS A READABLE FILE.
	JRST	FNMXER
	CAIE	X2,1
	JRST	EOF6
	SETOM	IFIFG
EOF30:	SKIPN	T,PINPNM-1(LP)	;CHECK THE LINE BUFFER.
	JRST	EOF3
	PUSHJ	P,DELAWY
	TLNN	C,F.CR
	JRST	EOF0
	SETZM	PINPNM-1(LP)
EOF3:	SETZ	X1,		;NEED ANOTHER LINE.  NXIN5 WILL CHECK
	PUSHJ	P,NXIN5		;TO SEE IF IT SHOULD COME BACK HERE BY
EOF32:	JRST	EOF30		;LOOKING FOR EOF32 ON PLIST.
EOF31:	POP	P,X1		;BACK HERE FROM INLINE; CLEAR PUSH LIST.
	POP	P,X1
	POP	P,X1
	SETZM	IFIFG
	POPJ	P,
EOF0:	SETZM	IFIFG
	SKIPN	REAINP-1(LP)	;WARN READ# STATEMENTS TO SKIP
	SETOM	EOFFLG-1(LP)	;A LINE NUMBER; PROBLEM ONLY ARISES
	JRST	CPOPJ1		;IF MODE WAS NOT SET WHEN IF END# WAS EXECUTED.

EOF6:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
? IF END ASKED FOR UNREADABLE FILE/
	JRST	GOSR2



XRES:	HRRZ	X1,40		;HERE FOR RESTORE UUO
        JRST    .+2             ;SKIP MOVE
XRES2:  MOVE    X1,LP           ;SET X1
	SKIPG	X2,ACTBL-1(X1)	;GET ACCESS CODE.
	JRST	FNMXER
	CAIE	X2,3
	JRST	XRES0
	SETOM	ODF
	SKIPN	HPOS(X1)
	JRST	.+3
	MOVE	LP,X1
	PUSHJ	P,CRLF3
XRES0:	DPB	X1,[POINT 4,DREL,12]	;DEPOSIT CHANNEL NUMBER FOR RELEASE
	XCT	DREL			;DO RELEASE
	HLRZ	X2,BA-1(X1)	;GET BUFFER ADDRESS
	MOVEM	X2,JOBFF
	SETZM	@FILMOD-1(X1)	;SET MODE TO ASCII.
	XCT	INITO-1(X1)	;INIT THAT CHANNEL
	JRST	[MOVE T,OPS1+1
		JRST NOGETD]
	DPB	X1,[POINT 4, IBDSK, 12]
	XCT	IBDSK
	MOVE	X2,FILD-1(X1)	;GET FILE NAME
	MOVEM	X2,LOK		;SET FOR LOOKUP
	MOVE	X2,EXTD-1(X1)
	MOVEM	X2,LOK+1
	SETZM	LOK+2
	SETZM	LOK+3		;ZERO PJ-PG
	DPB	X1,[POINT 4,LOKUP,12]	;SET CHANNEL FOR LOOKUP
	XCT	LOKUP		;DO LOOKUP
	JRST	LOKFAL
	MOVE	X2,ACTBL-1(X1)
	CAIE	X2,3
	JRST	XRES00
	PUSHJ	P,UXIT7
	MOVEI	X2,1
	MOVEM	X2,ACTBL-1(X1)
	JRST	XRES0
XRES00:	MOVEI	X2,1		
	MOVEM	X2,ACTBL-1(X1)	;SET ACCESS TABLE FOR READ
	SETZM	PINPNM-1(X1)
	SETZM	REAINP-1(X1)
	SETZM	EOFFLG-1(X1)
	SETZM	ODF
	POPJ	P,
;SCRATCH UUO
SCATH:	HRRZ	X1,40		;GET CHANNEL NUMBER
        JRST    .+2
SCTH2:  MOVE    X1,LP           ;SET X1
	SKIPG	X2,ACTBL-1(X1)	;GET ACCESS CODE
	JRST	FNMXER
	HLRZ	X2,BA-1(X1)	;GET BUFFER ADDRESS
	MOVEM	X2,JOBFF
	SETZM	@FILMOD-1(X1)	;SET MODE TO ASCII.
	XCT	INITO-1(X1)	;DO INIT
	JRST	[MOVE T,OPS1+1
		JRST NOGETD]
	DPB	X1,[POINT 4,OBDSK2,12]	;SET CHANNEL FOR OUTBUF
	XCT	OBDSK2		;DO "OUTBUF"
	MOVE	X2,FILD-1(X1)	;GET FILE NAME
	MOVEM	X2,ENT		;SET FOR ENTER
	MOVE	X2,EXTD-1(X1)
	MOVEM	X2,ENT+1
	SETZM	ENT+2
	SETZM	ENT+3
	DPB	X1,[POINT 4,ENTDSK,12]	;SET CHANNEL FOR ENTER
	XCT	ENTDSK		;DO ENTER
	JRST	ENFAIL		;ENTER FAILED
	DPB	X1,[POINT 4,OUTDSK,12]	;SET FOR DUMMY OUTPUT
	XCT	OUTDSK		;DO DUMMY OUTPUT
	MOVEI	X2,3		;FILE OK FOR WRITING
	MOVEM	X2,ACTBL-1(X1)	;TELL ACCESS TABLE
	MOVEI	X2,^D990
	MOVEM	X2,LINNUM-1(X1)
	SETZM	WRIPRI-1(X1)
	SETZM	HPOS(X1)
	SETOM	FIRSFL(X1)
	SETZM	FMTPNT(X1)
	SETZM	PAGCNT(X1)
	SETZM	TABVAL(X1)
	SETOM	ZONFLG(X1)
	POPJ	P,


;R.A. RUNTIME SCRATCH.
RANSCR:	SKIPL	ACTBL-1(LP)
	JRST	FNMXER
	SETZM	LOK
	DPB	LP,[POINT 4,RENAMD,12]	;ERASE FILE.
	XCT	RENAMD
	JRST	RANSRF
	MOVE	X1,FILD-1(LP)
	MOVEM	X1,ENT
	MOVEM	X1,LOK
	MOVE	X1,EXTD-1(LP)
	MOVEM	X1,ENT+1
	MOVEM	X1,LOK+1
	SETZM	ENT+2
	SETZM	ENT+3
	DPB	LP,[POINT 4,ENTDSK,12]
	XCT	ENTDSK
	JRST	ENFAIL
	HLRZ	X1,BA-1(LP)
	ADDI	X1,203
	MOVEM	X1,JOBFF	;SET UP HEADER RECORD.
	DPB	LP,[POINT 4,OBDSK,12]
	XCT	OBDSK
	DPB	LP,[POINT 4,OUTTDS,12]
	XCT	OUTTDS
	JRST	.+2
	JRST	RANSC5
	MOVE	X2,JOBFF
	SOJ	X2,.+1
RANSC1:	SETZM	(X2)
	SOJ	X2,.+1
	CAIL	X2,3(X1)
	JRST	RANSC1
	SKIPG	X1,STRLEN-1(LP)
	JRST	.+3
	MOVEM	X1,2(X2)
	JRST	.+3
	HRLZI	X1,400000
	MOVEM	X1,1(X2)
RANSC3:	DPB	LP,[POINT 4,OUTTDS,12]
        XCT     OUTTDS
        JRST    RANCL1
        JRST    RANSC5
RANCL1: MOVEI   D,3
        HRLI    D,75040
        DPB     LP,[POINT 4,D,12]
        XCT     D
	JRST	RANSC4
RANSC5:	DPB	LP,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR
RANSC4:	DPB	LP,[POINT 4,CLOSED,12]
	XCT	CLOSED
	SETZM	LOK+2
	SETZM	LOK+3
	DPB	LP,[POINT 4,LOKUP,12]
	XCT	LOKUP
	JRST	LKFAIL
	HLLZS	ENT+1
	SETZM	ENT+2
	SETZM	ENT+3
	XCT	ENTDSK
	JRST	ENFAIL
	HLRZ	X1,BA-1(LP)
	MOVEM	X1,JOBFF
	DPB	LP,[POINT 4,IBDSK,12]
	XCT	IBDSK
	XCT	OBDSK
	DPB	LP,[POINT 4,OUTTDS,12]
	XCT	OUTTDS
	JRST	.+2
	JRST	RANSC5
	DPB	LP,[POINT 4,INNDSK,12]
	XCT	INNDSK
	JRST	.+2
	JRST	EXEC86
	SETZM	BLOCK-1(LP)
	SETZM	MODBLK-1(LP)
	SETZM	LASREC-1(LP)
	MOVEI	X1,1
	MOVEM	X1,POINT-1(LP)
	POPJ	P,
;THIS ROUTINE SORTS THE BOUNDARIES OF THE DISK BUFFERS INTO THE
;TABLE SRTDBA, FROM THE TABLE BA. SRTDBA IS IN ASCENDING ORDER,
;EXCEPT THAT ANY ZEROES ARE AT THE TOP, SO THAT IF NO BUFFERS
;ARE PRESENT SRTDBA CAN BE USED AS A FLAG WORD.
;BASORT DESTROYS AC'S C,E,X1, AND X2.

BASORT:	MOVE	X1,[XWD BA,SRTDBA]
	BLT	X1,SRTDBA+8
	MOVEI	E,8
BASOR1:	MOVE	X1,SRTDBA(E)
	MOVEI	C,(E)
BASOR2:	MOVE	X2,SRTDBA-1(C)
	CAMG	X2,X1
	JRST	BASOR3
	MOVEM	X2,SRTDBA(E)
	MOVEM	X1,SRTDBA-1(C)
	MOVE	X1,X2
BASOR3:	SOJG	C,BASOR2
	SOJG	E,BASOR1

BASOR4:	SKIPE	SRTDBA(C)
	JRST	BASOR5
	AOJ	C,.+1
	CAIG	C,8
	JRST	BASOR4
	POPJ	P,
BASOR5:	MOVEI	E,10
	JRST	PAKBL0
;SUBROUTINE TO CHECK DATA LINE
;ALSO CALLED AT RUN TIME TO CHECK INPUT LINE
;(NOTE.. <RETURN> NOT CHECKED AFTER INPUT LINE)

DATCHK:	TLNN	C,F.LETT+F.QUOT	;LETTER OR QUOT SIGN FIRST
	JRST	DATCH2		;NO, EVALUATE NUMBER
	PUSH	P,[DATCH3]	;YES, ASSUME STRING AND SKIP OVER
	JRST	SKIPDA

DATCH2:	PUSH	P,X1
	PUSHJ	P,EVANUM
	JRST	[POP P,X1
		 POPJ	P,]
	POP	P,X1
DATCH4:	CAIE	C,"&"		;IF "&", ASSUME MATINPUT TERM
	TLNE	C,F.CR		;MORE?
	JRST	CPOPJ1		;NO. RETURN
	SKIPE	INPFLA		;FOR READ AND MAT READ
	JRST	.+3		;BUT NOT FOR INPUT OR MAT
	TLNE	C,F.TERM	;INPUT, STOP ALSO ON AN
	JRST	CPOPJ1		;APOSTROPHE.
	TLNN	C,F.COMA	;DID FIELD END CORRECTLY?
	POPJ	P,		;NO. ERROR
	PUSHJ	P,NXCH		;YES. SKIP COMMA
	TLNE	C,F.TERM
	JRST	CPOPJ1
	JRST	DATCHK		;AND GO TO NEXT ITEM.

DATCH3:	POPJ	P,
	JRST	DATCH4
REUXIT:	SETZM	MTIME
UXIT:	SETZM	CHAFL2
	SETZM	CHAFLG		;ZERO CHAIN FLAG UNLESS WE ARE
CHAXIT:	SETZM	FUNAME		;REALLY CHAINING.
	SETZM	COMTIM
	SETZM	HPOS
	MOVE	P,PLIST
	SETZM	NUMCOT
	SETZB	LP,IFIFG
	SKIPN	UXFLAG		;END OF PROG EXECUTION?
	JRST	UXIT5		;NO.
	SETOM	ODF
	MOVEI	LP,^D9
UXIT3:	SKIPL	A,ACTBL-1(LP)
	JRST	.+3
	PUSHJ	P,CLSRAN
	JRST	UXIT49
	CAIE	A,3
	JRST	.+3
	SKIPE	HPOS(LP)
	PUSHJ	P,CRLF3
UXIT49:	SOJG	LP,UXIT3
	SETZM	ODF
	PUSHJ	P,PRDLER
UXIT5:	SETZM	ODF
	DEFINE R(A)
<	IRP	A
<	RELEASE	^D<A>,	>>
        R<1,2,3,4,5,6,7,8,9>     ;DISK DATA FILES 1-9
	SKIPN	UXFLAG		;END OF PROGRAM EXECUTION?
	JRST	UXIT1		;NO.
	SETZM	UXFLAG		;YES.
	SETZM	MARWAI
	MOVEI	X1,^D72
	MOVEM	X1,MARGIN
	SETZM	QUOTBL
	SETZM	HPOS
	SETOM	PAGLIM
	MOVEI	X1,^D9
UXIT2:	SKIPL	A,ACTBL-1(X1)	;ACTBL ENTRY = 3 IF FILE
	CAIN	A,3
	JRST	UXIT21		;IS BEING WRITTEN.
	SOJG	X1,UXIT2
	JRST	UXIT1
UXIT21:	PUSH	P,[Z UXIT4]
UXIT6:	MOVE	X2,FILD-1(X1)
	MOVEM	X2,LOK
	MOVE	X2,EXTD-1(X1)
	MOVEM	X2,LOK+1
	HLRZ	X2,BA-1(X1)
	MOVEM	X2,JOBFF
	XCT	INITO-1(X1)
	JRST	[MOVE T,OPS1+1
		JRST NOGETD]	;OUTPUT MESSAGE "NO SUCH DEVICE"
	DPB	X1,[POINT 4,LOKUP,12]	;AND GIVE UP BECAUSE
	HLLZS	LOK+1		;ALL DEVICES ARE THE SAME.
	SETZM	LOK+2
	SETZM	LOK+3
	XCT	LOKUP
	JRST	.+1
UXIT7:	HLLZS	LOK+1
	SETZM	LOK+3
	DPB	X1,[POINT 4,RENAMD,12]
	XCT	RENAMD	
	JRST	.+1		;RENAME FAILS FOR DECTAPES.
	POPJ	P,

UXIT4:	SOJG	X1,UXIT2	;RETURN HERE FROM RENFAL MESSAGE.
	JRST	CHAXIT
UXIT1:	SETZM	RUNFLA
	PUSHJ	P,TTYIN		;INIT TTY IN CASE OF ^O.
	SKIPE	CHAFLG		;CHAINING?
        GO (1,FIXUP)
	SKIPE	MTIME		;IS THERE SOME RUN TIME?
	PUSHJ	P,RTIME
        SKIPE RUNBB
        JRST UXIT1A
        SKIPE RUNBFG
        JRST RONLY
UXIT1A:	PUSHJ	P,INLMES
	ASCIZ	/
READY
/
        SETOM JUSTRN
        SETZM RUNBB
        GO (1,FIXUP)

RONLY:  OUTPUT 0,
        CALLI 1,12
        JRST .-1
STARX=.
LOC	41
	JSR	UUOH
RELOC	STARX

	INTERN UUOHAN
	EXTERN	UUOH
UUOHAN:	PUSH	P,UUOH		;RETURN ADDRS ON PUSH-DOWN LIST
	LDB	X1,[POINT 9,40,8]
IFL MAXUUO-37, <
	CAILE	X1,MAXUUO
	JRST	INLSYS		;ILLEGAL UUO.
>
UUOTBL:	JRST	.(X1)
	JRST	FAILER
	JRST	PRNMER
	JRST	PRDLER
	JRST	PRNTBR
	JRST	GOSBER
	JRST	AFT1ER
	JRST	AFT2ER
	JRST	AST1ER
	JRST	AST2ER
	JRST	ASN1ER
	JRST	ASN2ER
	JRST	DSKRT
	JRST	ADT1ER
	JRST	ADT2ER
	JRST	SDIMER
IFN FTMAT,<
	JRST	MTRD
	JRST	MTPRER
	JRST	MTSCER
	JRST	MTCNER
	JRST	MTIDER
	JRST	MTTNER
	JRST	MTIVER
	JRST	MTADER
	JRST	MTSBER
	JRST	MTMYER
	JRST	MTZRER
>
IFN FTSTR,<
	JRST	SUUOEX
	JRST	SAD1ER
	JRST	PRSTRR
>
	JRST	FORCOM
	JRST	MATIN
DSKRT:	LDB	X1,[POINT	4,40,12]
	JRST	.+1(X1)
	JRST	DATAER		;DATA 0, UUO.
	JRST	INSET		;DATA 1, -- SETS UP FOR READ(#) AND INPUT(#).
	JRST	EOF		;DATA 2, -- IF END# UUO.
	JRST	XRES		;DATA 3, -- RESTORE# UUO.
	JRST	SCATH		;DATA 4, -- SCRATCH# UUO.
	JRST	OUTSET		;DATA 5, -- SETS UP FOR WRITE#, PRINT#, AND PRINT.
	JRST	RANUM		;DATA 6, -- R.A.
	JRST	RANUM1		;DATA 7, -- R.A.
	JRST	RANUM2		;DATA 10, -- R.A.
	JRST	RANSTR		;DATA 11, -- R.A.
        JRST  MTPRUS    ;DATA 12, MAT PRINT USING-HOW'S THAT?
        JRST MTRPRT     ;DATA 13, MAT RANDOM PRINT
        JRST MTRRD      ;DATA 14, MATRAN READ
MTRD:   LDB X1,[POINT 4,40,12]
        JRST .+1(X1)
        JRST MTRDER
        JRST MTRDE1     ;READ FROM FILE
IFN FTSTR,<
SUUOEX:	LDB	X1,[POINT 4,40,12]	;STRING UUOS USE THE AC FIELD
	CAILE	X1,MASUUO		;AS AN EXTENSION OF THE OPCODE.
	HALT	.

UUOSTR:	JRST	.(X1)
	JRST	PUTSTR
	JRST	COMSTR
	JRST	INSTR
	JRST	GETVEC
	JRST	PUTVEC
	JRST	STRCHA
MASUUO=.-UUOSTR-1

	OPDEF	STRSTO	[STRUUO 1,]
	OPDEF	STRIF	[STRUUO 2,]
	OPDEF	STRIN	[STRUUO 3,]
	OPDEF	VECFET	[STRUUO 4,]
	OPDEF	VECPUT	[STRUUO 5,]
	OPDEF	STOCHA	[STRUUO 6,]
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
SUBTTL	COMMAND SUBROUTINES

;ROUTINE TO PICK UP FILE NAME AND SET UP FOR DSK ACTION.
;THE FLAG COPFLG IS EXPLAINED AT THE COPY ROUTINE COPER.
FILNAM:	SETZM	COPFLG
FILNM1:	POP	P,B		;COPER ENTERS HERE, WITH COPFLG = -1.
	MOVEI	A,<SIXBIT /   DSK/>
	HRLI	A,<SIXBIT /   BAS/>
	HRLZM	A,@(B)
	HLLZM	A,FILDIR+1
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	MOVEI	X2,FILDIR

        SETZM FILUSN
;CHECK FOR A LUSER NAME AND IF IT IS THERE THEN
;SET UP THE LUSER NAME BUFFER
	MOVEI	X1,"("		;BEG. OF USERNAME SPEC
	CAIE	X1,(C)		;DOES IT MATCH LAST CHAR?
	JRST	FILNU		;NO-NOT USERNAME
        PUSHJ P,ID
        JRST FILENU
;GOT A USER NAME - SET UP BUFFER
ID:	HRRZI	X1,FILUSN	;USER NAME BUFFER
	MOVEM	X1,FILDIR+3	;POINTER IS:  0,,BUFFER
	MOVEI	X1,-12		;12 CHARS
	MOVE	N,[POINT 6,FILUSN]
	SETZM	FILUSN
	SETZM	FILUSN+1	;RESET THE USERNAME BUFFER
FILRNN:	PUSHJ	P,NXCH		;GET NEXT CHARACTER
	TLNE	C,F.TERM	;TERMIMNATED?
	JRST	COMM2		;YES-THE GUY CANT TYPE
	MOVEI	D,")"		;CLOSING OF SPEC?
	CAIN	D,(C)
        POPJ P, ;FINISH
	AOJL	X1,FILRNN	;IGNORE PAST 12TH CHAR
	SUBI	C,40		;CONVERT TO 6-BIT
	IDPB	C,N		;SAVE CHAR IN BUFFER
	JRST	FILRNN		;ALL DONE
;END OF USER NAME SPEC
FILENU:	PUSHJ	P,NXCH		;NEXT CHARACTER FOR ATOM FINDER
FILNU:	PUSHJ	P,ATOMSZ
FILN7:	MOVEI	X1,":"		;DEVICE INDICATOR.
	CAIE	X1,(C)
	JRST	FILN1
	JUMPE	A,COMM2
	MOVEM	A,@(B)		
	PUSHJ	P,NXCH
	PUSHJ	P,ATOMSZ
	SKIPL	COPFLG
	JRST	FILN1
	JUMPN	A,FILN1
FILN8:	SETZM	COPFLG
	JRST	1(B)
FILNMO:	POP	P,B		;ENTRY POINT FOR NO DEVICE ALLOWED.
	MOVEI	A,<SIXBIT/   DSK/>
	HRLZM	A,@(B)
	SETZM	COPFLG
	HRRI	A,<SIXBIT /   BAS/>
	HRLZM	A,FILDIR+1
	MOVEI	X2,FILDIR
        SETZM FILUSN
        MOVEI X1,"("
        CAIE X1,(C)
        JRST .+3
        PUSHJ P,ID
        PUSHJ P,NXCH
	PUSHJ	P,ATOMSZ
FILN1:	TLNN	C,F.PER		;PERIOD SEEN?
	JRST	FILN2
	JUMPE	A,COMM2
	MOVEM	A,FILDIR
	MOVEI	X2,FILDIR+1
	PUSHJ	P,NXCH
	PUSHJ	P,ATOMSZ
FILN2:	JUMPN	A,FILN3
	CAIE	X2,FILDIR
	JRST	FILN3
	HRRZ	A,B
FILN9:	SKIPN	A,CURNAM
	JRST	COMM2
	MOVEM	A,FILDIR
	HLLZ	A,CUREXT
	MOVEM	A,FILDIR+1
	JRST	FILN5
FILN3:	CAIN	X2,FILDIR
	JRST	FILN4
FILN6:	TRNE	A,777777	;ONLY 3 CHARACTERS ALLOWED
	JRST	COMM2		;IN THE EXT.
FILN4:	MOVEM	A,(X2)
FILN5:	MOVEI	A,DRMBUF
	MOVEM	A,JOBFF
	JRST	1(B)


COMM2:	SKIPN	COMTIM		;COMMAND TIME?
	JRST	COMM1		;YES.
	SKIPL	COMTIM		;EXECUTION TIME?
	JRST	CHAER1		;YES.
	FAIL	<? ILLEGAL FILENAME> ;MUST BE COMPILE TIME.


;ROUTINE TO CONVERT NEXT ATOM TO SIXBIT

ATOMSZ:	HRLZI	D,F.LETT+F.DIG	;IT HAS SEVERAL
	JRST	ATOMS2		;ENTRY POINTS.
ALPHSX:	SKIPA	D,[Z (F.LETT)]
ATOMSX:	HRLZI	D,F.DIG+F.LETT	
ATOMS2:	TLZ	B,777777	;SET LH OF A+1 TO 0
	MOVEI	A,0
	MOVE	X1,[POINT 6,A]
ATOMS1:	TDNN	C,D
	POPJ	P,
	PUSHJ	P,SCNLTN	;PACK THIS LETTER INTO A.
	JFCL			;SCNLTN HAS SKIP RETURN.
	TLNE	X1,770000
	JRST	ATOMS1
	POPJ	P,
MAKNUZ: SETZM @SEQPNT ;CLEAR JUNK BEFORE LINE NO CALC
MAKNUM:	IDIVI	X1,^D10
	JUMPE	X1,MAKN1
	PUSH	P,X2
	PUSHJ	P,MAKNUM
	POP	P,X2
MAKN1:	MOVEI	X2,60(X2)
	IDPB	X2,SEQPNT
	POPJ	P,
QSKIP:	PUSHJ	P,NXCH		;SKIP TO NEXT QUOTE CHAR.
	TLNE	C,F.CR		;TERMINAL QUOTE MISSING?
	POPJ	P,		;YES
	TLNN	C,F.QUOT	;END OF STRING?
	JRST	QSKIP		;NO, GO ON.
	PUSHJ	P,NXCH		;YES. GET NEXT CHAR AND RETURN.
	JRST	CPOPJ1
QNTFND:	PUSHJ	P,INLMES	;HERE WHEN FILE NOT FOUND
	ASCIZ/
? FILE /
	PUSHJ	P,PRNNAM
	PUSHJ	P,INLMES
	ASCIZ	/ NOT FOUND/
	OUTPUT 0,
	SETZM	HEDFLG
	POPJ	P,
;RUNTIME ROUTINE TO CLOSE FILES FOR FILE STATEMENTS.

CLSFIL:	SKIPG	X2,ACTBL-1(LP)	;SEQ. OR R.A.?
	JRST	CLSRAN

	CAIE	X2,3		;SEQ.
	JRST	CLSSE1
	SETOM	ODF
	SKIPE	HPOS(LP)
	PUSHJ	P,CRLF3		;END CURRENT LINE.
CLSSE1:	DPB	LP,[POINT 4,DREL,12]
	XCT	DREL
	MOVEI	X1,3
	CAME	X1,ACTBL-1(LP)
	POPJ	P,
	MOVEI	X1,(LP)		;FILE IS IN WRITE MODE,
	PUSHJ	P,UXIT6		;SO SET UP PROTECTION CODE.
	XCT	DREL
	POPJ	P,

CLSRAN:	MOVE	X2,BLOCK-1(LP)	;R.A.
	CAIN	X2,1
	JRST	CLSRN1
	SKIPE	MODBLK-1(LP)
	PUSHJ	P,OUTRAN
	MOVEI	X2,1
	PUSHJ	P,INRAN
CLSRN1:	MOVE	X1,LASREC-1(LP)
	HLRZ	X2,BA-1(LP)
	HRRM	X1,3(X2)
	MOVEI	X2,1
	PUSHJ	P,OUTRAN
	MOVEI	X2,3
	MOVEM	X2,ACTBL-1(LP)
	JRST	CLSSE1


;RUNTIME ROUTINE TO OPEN FILES FOR THE FILE STATEMENT.

OPNFIL:	PUSHJ	P,STRPL1	;GET STR + 1 SPACE.
	JRST	CHAER1
	SOS	MASAPP
	PUSHJ	P,FILNMO	;GET FILENM.EXT.
	JUMP	SAVE1
	PUSH	P,T
	PUSH	P,C
	SETZM	FILD-1(LP)	;CHECK FOR DUPLICATE NAME.
	MOVEI	D,9
	MOVE	X1,FILDIR
	MOVE	X2,FILDIR+1
	CAMN	X1,FILD-1(D)
	JRST	.+3
	SOJG	D,.-2
	JRST	OPNFL1
	CAME	X2,EXTD-1(D)
	JRST	.-3
	JRST	OPNER2
OPNFL1:	MOVEM	X1,FILD-1(LP)
	MOVEM	X2,EXTD-1(LP)
        SKIPN FILDIR+3
        JRST OPN1
        MOVE X1,[FILUSN,,FUSE]
        MOVE X2,LP
        SOJ X2,
        IMULI X2,2
        ADDI X2,FUSE
        HRRM X2,X1
        AOJ X2,
        BLT X1,(X2)
OPN1:	HLRZ	T,BA-1(LP)	;GET BUFFERS.
	JUMPN	T,OPNFL2
	PUSHJ	P,VCHBUF
	HRLM	T,BA-1(LP)
	ADDI	T,406
	HRRM	T,BA-1(LP)
	PUSHJ	P,BASORT
	HLRZ	T,BA-1(LP)
OPNFL2:	MOVEM	T,JOBFF
	POP	P,C
	POP	P,T
	MOVE	N,VALPTR
	CAME	N,T		;SEQ. OR R.A.?
	JRST	OPNFL6		;R.A. OR ERROR.

	SKIPE	FILTYP		;SEQ.
	JRST	FNMX1
	MOVEI	A,1
OPNFL3:	MOVEM	A,ACTBL-1(LP)	;SET UP FOR EXEC.
	MOVE	X1,SORCLN
	MOVEM	X1,BLOCK-1(LP)
	MOVEI	X1,(LP)
	SETOM	FILFLG
	JRST	EXEC0
OPNFL4:	POP	P,Q		;RETURN HERE FROM EXEC.
	MOVEI	X2,.+2
	JRST	RESACS		;RESTORE THE AC'S.
	SKIPL	ACTBL-1(LP)	;CLEAR AND SET UP FLAGS.
	JRST	OPNFL5
	SETZM	BLOCK-1(LP)
	SETZM	MODBLK-1(LP)
	MOVEI	X1,1
	MOVEM	X1,POINT-1(LP)
	POPJ	P,
OPNFL5:	MOVEI	X1,^D72
	MOVEM	X1,MARGIN(LP)
	SETZM	MARWAI(LP)
	SETOM	PAGLIM(LP)
	SETZM	QUOTBL(LP)
	MOVEI	X1,(LP)
	JRST	XRES00

OPNFL6:	MOVEI	X2,"%"		;R.A. OR ERROR.
	CAIE	X2,(C)
	JRST	OPNFL8
	HRLZI	X1,400000
	MOVEM	X1,STRLEN-1(LP)
	PUSHJ	P,NXCH
OPNF11:	SKIPN	FILTYP
	JRST	FNMX1
	MOVE	N,VALPTR
	CAME	N,T
	JRST	CHAER1
	SETO	A,
	JRST	OPNFL3
OPNFL8:	TLNN	C,F.DOLL
	JRST	CHAER1
	PUSHJ	P,NXCH
	SETZ	B,
	TLNE	C,F.DIG
	JRST	.+3
	SETZM	STRLEN-1(LP)
	JRST	OPNF11
	PUSHJ	P,XFIL30
	JRST	OPNFL9
	CAILE	B,^D132
	JRST	OPNER4
	PUSHJ	P,NXCH
OPNFL9:	JUMPE	B,OPNER4
OPNF10:	MOVEM	B,STRLEN-1(LP)
	ADDI	B,4
	IDIVI	B,5
	ADDI	B,1
	HRLM	B,STRLEN-1(LP)
	JRST	OPNF11

OPNER2:	PUSHJ	P,INLMES
	ASCIZ	/
? FILE /
	SETZM	SAVE1
	PUSHJ	P,PRNNAM
	PUSHJ	P,INLMES
	ASCIZ	/ ON MORE THAN ONE CHANNEL/
	JRST	GOSR2

OPNER4:	PUSHJ	P,INLMES
	ASCIZ	/
? STRING RECORD LENGTH > 132 OR < 1/
	JRST	GOSR2
XFIL30:	HRRZI	B,-60(C)
	PUSHJ	P,NXCH
	TLNN	C,F.DIG
	POPJ	P,
	IMULI	B,^D10
	ADDI	B,-60(C)
	PUSHJ	P,NXCH
	TLNN	C,F.DIG
	POPJ	P,
	IMULI	B,^D10
	ADDI	B,-60(C)
	JRST	CPOPJ1
;CHECK FORMAT CHAR (PRINT AND MAT PRINT)

CHKFMT:	TLNE	C,F.TERM
	TLO	D,40		;CR ... AC = 1
	CAIN	C,";"		;SC ... AC = 2
	TLO	D,100		;CMA ... AC = 3
	TLNE	C,F.COMA	;<PA> ... AC = 4
	TLO	D,140
	CAIE	C,"<"
	JRST	CHKFM2
	HRRZ	C,(P)
	PUSHJ	P,NXCH
	PUSHJ	P,QSA
	ASCIZ	/PA>/
	JRST	GRONK
	TLO	D,200
	POPJ	P,
CHKFM2:	TLNN	D,140		;WAS THERE A FMT CHAR?
	TLO	D,100		;NO. ASSUME ";"
	CAIE	C,";"
	TLNE	C,F.COMA	;SKIP FMT CHAR IF THERE WAS ONE.
	JRST	NXCHK		;YES.  SKIP
	POPJ	P,

OUTSET:	HRRZ	LP,40		;GET CHANNEL NUMBER
OUTST2:	JUMPN	LP,.+3		;TTY?
	SETZM	ODF		;YES.
	POPJ	P,
	SKIPG	X2,ACTBL-1(LP)	;GET ACCESS CODE
	JRST	FNMXER
	CAIE	X2,3		;OPEN FOR WRITING?
	JRST	ILWRT		;NO
	SETOM	ODF
	POPJ	P,
;BEGIN EXECUTION

EXECUT:	SETZM	FCNLNK		;INITIALIZE FCN CALLS
	PUSHJ	P,RESTOR	;SET TO START AT BEGINNING OF DATA
	MOVEI	R,0		;POINTER TO GOSUB RTRN
	PUSHJ	P,INLMES	;RETURNS SIGNAL END OF COMPILATION.
	ASCIZ	/

/
	OUTPUT 0,

;INITIALIZE SOME SWITCHES:
	SETZM	INPFLA		;NO INPUT CURRENTLY BEING READ
	MOVEI	X1,1
	MOVEM	X1,COMTIM
	SETZM	FILFLG
EXEC4:	HRRZ	X1,VARFRE	;SET UP FILES.
	MOVEM	X1,JOBFF
	MOVEI	X1,9
EXEC6:	SKIPN	A,ACTBL-1(X1)
	JRST	EXEC11		;NO FILE ON THIS CHANNEL.
EXEC0:	HRRZ	T1,JOBFF
	HRLM	T1,BA-1(X1)
	SETZM	@FILMOD-1(X1)	;MODE IS ASCII FOR SEQ.
	JUMPG	A,EXEC7		;FILES AND STRING R.A. FILES,
	MOVEI	T1,34		;BINARY FOR NUMERIC R.A. FILES.
	SKIPL	STRLEN-1(X1)	;SET USER WORD COUNT FOR R.A. FILES.
	MOVEI	T1,20
	MOVEM	T1,@FILMOD-1(X1)
EXEC7:	XCT	INITO-1(X1)
	JRST	[MOVE T,OPS1+1
		JRST	NOGETD]
	DPB	X1,[POINT 4,LOKUP,12]
	MOVE	N,FILD-1(X1)
	MOVEM	N,LOK
	MOVE	N,EXTD-1(X1)
	MOVEM	N,LOK+1
	SETZM	LOK+2
	SETZM	LOK+3
        SETZM FILUSN
        MOVE X2,X1
        SOJ X2,
        IMULI X2,2
        ADDI X2,FUSE
        SKIPN (X2)
        JRST EXC1
        MOVE N,(X2)
        MOVEM FILUSN
        MOVE 1(X2)
        MOVEM FILUSN+1
        MOVEI FILUSN
        MOVEM LOK+3
        MOVEM ENT+3
EXC1:	JUMPL	A,EXEC8		;SEQ. OR R.A.?
	DPB	X1,[POINT 4,IBDSK2,12]	;SEQ.
	XCT	IBDSK2
	XCT	LOKUP
	SKIPA	T1,[OCT 2]
	MOVEI	T1,1
	MOVEM	T1,ACTBL-1(X1)	;SET UP ACTBL.
	HRRZ	T1,JOBFF
	HRRM	T1,BA-1(X1)	;SET UP BA.
	JRST	EXEC12
EXEC8:	DPB	X1,[POINT 4,IBDSK,12]	;RANDOM ACCESS.
	XCT	IBDSK
        MOVE N,LOK+1
	MOVEM	N,ENT+1
	MOVE	N,FILD-1(X1)
	MOVEM	N,ENT
	DPB	X1,[POINT 4,OBDSK,12]
	XCT	OBDSK
	DPB	X1,[POINT 4,ENTDSK,12]
	SETZM	ENT+2
        PUSHJ P,BLEK
	MOVE	T1,JOBFF
	XCT	LOKUP		;DOES FILE EXIST NOW.
	JRST	EXEC9		;NO.
	XCT	ENTDSK		;YES.
	JRST	ENFFAL
	DPB	X1,[POINT 4,OUTTDS,12]	;SET UP BUFFER.
	XCT	OUTTDS
	JRST	.+2
	JRST	EXEC86
	DPB	X1,[POINT 4,INNDSK,12]	;SET UP BUFFER.
	XCT	INNDSK
	JRST	EXEC81
EXEC89:	DPB	X1,[POINT 4,STODSK,12]
	XCT	STODSK
	JRST	EXEC91		;NULL FILE--SAME AS NON-EXISTENT.
EXEC86:	MOVEI	T,INLSYS	;SYSTEM ERROR.
	JRST	ERRMSG
EXEC81:	MOVE	T1,-403(T1)	;GET FIRST WORD.
	TLNN	T1,377777
	JRST	EXEC83
EXEC82:	PUSH	P,JOBFF
	PUSH	P,[Z EXNAME]
EXNAM:	PUSHJ	P,INLMES
	ASCIZ	/
? FILE /
EXNAM2:	MOVE	T,FILD-1(X1)
	MOVEM	T,FILDIR
	MOVE	T,EXTD-1(X1)
	MOVEM	T,FILDIR+1
	SETZM	SAVE1
	JRST	PRNNAM
EXNAME:	PUSHJ	P,INLMES
	ASCIZ	/ IS NOT RANDOM ACCESS IN LINE /
EXNAM1:	MOVE	T,BLOCK-1(X1)
	PUSHJ	P,PRTNUM
	SKIPE	CHAFL2
	PUSHJ	P,ERRMS3
	OUTPUT 0,
	POP	P,JOBFF
	SETZM	RUNFLA
	SKIPE	FILFLG
	JRST	UXIT
	JRST	EXEC12

EXEC83:	HRRZM	T1,LASREC-1(X1)
	MOVE	T1,JOBFF
	SKIPGE	A,STRLEN-1(X1)	;NUMERIC OR STRING.
	JRST	EXEC85		;NUMERIC.
	MOVE	T1,-402(T1)	;STRING.
	CAMGE	T1,[000001000000]
	JRST	EXEC82
	JUMPN	A,EXEC84
	MOVEM	T1,STRLEN-1(X1)
	HRRZI	T1,(T1)
	CAIG	T1,^D132
	CAIGE	T1,1
	JRST	EXEC82
	JRST	EXEC10
EXEC84:	CAME	A,T1
	JRST	.+3
	MOVEM	A,STRLEN-1(X1)
	JRST	EXEC10
	PUSH	P,JOBFF
	PUSHJ	P,EXNAM
	PUSHJ	P,INLMES
	ASCIZ	/ RECORD LENGTH OR TYPE DOES NOT MATCH IN /
	JRST	EXNAM1
EXEC85:	SKIPE	-402(T1)
	JRST	EXEC82
	SETOM	STRLEN-1(X1)
	JRST	EXEC10

EXEC9:	XCT	ENTDSK		;NON-EXISTENT FILE.
	JRST	ENFFAL
	DPB	X1,[POINT 4,OUTTDS,12]	;SET UP BUFFER.
	XCT	OUTTDS
	JRST	.+2
	JRST	EXEC86
EXEC91:	SETZM	LASREC-1(X1)
	MOVE	A,JOBFF		;CLEAR OUTPUT BUFFER.
	SUBI	A,200
	SETZM	-1(T1)
	SOJ	T1,.+1
	CAIE	T1,(A)
	JRST	.-3
	SKIPL	A,STRLEN-1(X1)	;NUMERIC OR STRING?
	JRST	EXEC92		;STRING.
	HRLZI	A,400000	;NUMERIC.
	MOVEM	A,(T1)
	JRST	EXEC93
EXEC92:	JUMPN	A,.+2
	MOVE	A,[XWD ^D8,^D34]
	MOVEM	A,1(T1)
	MOVEM	A,STRLEN-1(X1)
EXEC93:	MOVEI	A,200		;SET THE WORD COUNT.
	HRRM	A,-1(T1)
	DPB	X1,[POINT 4,OUTTDS,12]
	XCT	OUTTDS
	JRST	EXEC94		;OUTPUT THE HEADER RECORD.
	DPB	X1,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR
EXEC94:	DPB	X1,[POINT 4,CLOSED,12]
	XCT	CLOSED
	HLLZS	LOK+1
	SETZM	LOK+2
        PUSHJ P,BLEK
	XCT	LOKUP
	JRST	.+1
	HLLZS	ENT+1
	SETZM	ENT+2
	XCT	ENTDSK
	JRST	ENFFAL
	HLRZ	T1,BA-1(X1)
	MOVEM	T1,JOBFF
	DPB	X1,[POINT 4,IBDSK,12]
	DPB	X1,[POINT 4,OBDSK,12]
	XCT	IBDSK
	XCT	OBDSK
	DPB	X1,[POINT 4,OUTTDS,12]
	DPB	X1,[POINT 4,INNDSK,12]
	XCT	OUTTDS
	JRST	.+2
	JRST	EXEC86
	XCT	INNDSK
	JRST	.+2
	JRST	EXEC86
EXEC10:	HRRZ	T1,JOBFF
	HRRM	T1,BA-1(X1)
	JRST	EXEC12
EXEC11:	SETZM	BA-1(X1)
EXEC12:	SKIPGE	FILFLG		;DON'T LOOP--IF ONCE
	JRST	OPNFL4		;ONLY FILE STATEMENT.
	SOJG	X1,EXEC6	;GO BACK TO LOOP.
	MOVE	X1,JOBFF
	MOVEM	X1,VARFRE
	JRST	EXEC1

ENFFAL:	PUSH	P,JOBFF
	PUSHJ	P,INLMES
	ASCIZ	/
? CANNOT ENTER FILE /
	PUSHJ	P,EXNAM2
	PUSHJ	P,INLMES
	ASCIZ	/ IN LINE /
	JRST	EXNAM1


BLEK:   SKIPN FILUSN
        JRST [SETZM ENT+3
                SETZM LOK+3
                POPJ P,]
        MOVEI FILUSN
        MOVEM LOK+3
        MOVEM ENT+3
        POPJ P,
EXEC1:	PUSHJ	P,BASORT	;SORT THE TABLE BA INTO SRTDBA.
	MOVEI	X1,^D9
EXEC2:	SETZM	PINPNM-1(X1)
	SETZM	WRIPRI-1(X1)
	SETZM	REAINP-1(X1)
	SETZM	BLOCK-1(X1)
	SETZM	MODBLK-1(X1)
	SETZM	POINT-1(X1)
	AOS	POINT-1(X1)
	SETZM	EOFFLG-1(X1)
	SOJG	X1,EXEC2
	MOVEI	N,^D72
	MOVEI	X1,^D9
EXEC3:	SETZM	HPOS(X1)
	SETOM	FIRSFL(X1)
	SETZM	TABVAL(X1)
	SETZM	FMTPNT(X1)
	SETZM	MARWAI(X1)
	SETOM	PAGLIM(X1)
	SETZM	QUOTBL(X1)
	SETOM	ZONFLG(X1)
	MOVEM	N,MARGIN(X1)
	SOJGE	X1,EXEC3
	SETZ	N,		;SET UP AC N FOR RND FN.
	SETOM	UXFLAG
	SETOM	NUMRES		;NO MAT INPUT HAS OCCURRED YET
IFN FTRND,<
	PUSHJ	P,WRANB		;INITIALIZE THE "STANDARD" RANDOM NUMBERS.
>
	MOVEI	X1,OVTRAP
	HRRM	X1,JOBAPR
	MOVEI	X1,10
	CALLI	X1,16
	PUSHJ	P,LOCKOF		;EXECUTION MAY BE INTERRUPTED.
	SETZM	IFIFG
	SETZM	ODF
	EXTERN	QLIST
	MOVEI	Q,MASAPP
	MOVEM	Q,MASAPP
	MOVE	Q,QLIST
	SETZM	INVFLG
	SETZM	VRFBOT
	SKIPN	RUNFLA
	JRST	UXIT
	SKIPG	A,RUNLIN	;BEGIN EXECUTION---
	JRST	@FLCOD		;AT THE BEGINNING.
        JRST @RUNLIN
;	ADD	A,FLLAD		;AT A LINE NUMBER.
;	HLRZ	X1,(A)
;	ADD	X1,FLCOD
;	JRST	(X1)


CTTAB:
	XWD	F.NU,	F.STR	;NULL	, @
	XWD	F.STR,	F.LETT	;	, A
	XWD	F.STR,	F.LETT	;	, B
	XWD	F.STR,	F.LETT	;	, C
	XWD	F.STR,	F.LETT	;	, D
	XWD	F.STR,	F.LETT	;	, E
	XWD	F.STR,	F.LETT	;	, F
	XWD	F.STR,	F.LETT	;	, G
	XWD	F.STR,	F.LETT	;	, H
	XWD	F.SPTB,	F.LETT	;TAB	, I
	XWD	F.CR,	F.LETT	;LF	, J
	XWD	F.CR,	F.LETT	;VER.TAB, K
	XWD	F.CR,	F.LETT	;FFEED	, L
	XWD	F.CR,	F.LETT	;CR	, M
	XWD	F.STR,	F.LETT	;	, N
	XWD	F.STR,	F.LETT	;	, O
	XWD	F.STR,	F.LETT	;	, P
	XWD	F.STR,	F.LETT	;	, Q
	XWD	F.STR,	F.LETT	;	, R
	XWD	F.STR,	F.LETT	;	, S
	XWD	F.STR,	F.LETT	;	, T
	XWD	F.STR,	F.LETT	;	, U
	XWD	F.STR,	F.LETT	;	, V
	XWD	F.STR,	F.LETT	;	, W
	XWD	F.STR,	F.LETT	;	, X
	XWD	F.STR,	F.LETT	;	, Y
	XWD	F.STR,	F.LETT	;	, Z
	XWD	F.ESC,	F.STR	;ESC	, [
	XWD	F.STR,	F.STR	;	, \
	XWD	F.STR,	F.STR	;	, ]
	XWD	F.STR,	F.OTH	;	, ^
	XWD	F.STR,	F.OTH	;	, _
        XWD     F.SPTB, F.STR           ;SPACE  , <ACCENT GRAVE>
	XWD	F.STR,	F.LETT+F.LCAS	; !	, <LOWER CASE> A
	XWD	F.QUOT,	F.LETT+F.LCAS	; "	, <LOWER CASE> B
	XWD	F.STR,	F.LETT+F.LCAS	; #	, <LOWER CASE> C
	XWD	F.DOLL,	F.LETT+F.LCAS	; $	, <LOWER CASE> D
	XWD	F.STR,	F.LETT+F.LCAS	; %	, <LOWER CASE> E
	XWD	F.OTH,	F.LETT+F.LCAS	; &	, <LOWER CASE> F
	XWD	F.APOS,	F.LETT+F.LCAS	; '	, <LOWER CASE> G
	XWD	F.OTH,	F.LETT+F.LCAS	; (	, <LOWER CASE> H
	XWD	F.RPRN,	F.LETT+F.LCAS	; )	, <LOWER CASE> I
	XWD	F.STAR,	F.LETT+F.LCAS	; *	, <LOWER CASE> J
	XWD	F.PLUS,	F.LETT+F.LCAS	; +	, <LOWER CASE> K
	XWD	F.COMA,	F.LETT+F.LCAS	; , 	, <LOWER CASE> L
	XWD	F.MINS,	F.LETT+F.LCAS	; -	, <LOWER CASE> M
	XWD	F.PER,	F.LETT+F.LCAS	; .	, <LOWER CASE> N
	XWD	F.SLSH,	F.LETT+F.LCAS	; /	, <LOWER CASE> O
	XWD	F.DIG,	F.LETT+F.LCAS	; 0	, <LOWER CASE> P
	XWD	F.DIG,	F.LETT+F.LCAS	; 1	, <LOWER CASE> Q
	XWD	F.DIG,	F.LETT+F.LCAS	; 2	, <LOWER CASE> R
	XWD	F.DIG,	F.LETT+F.LCAS	; 3	, <LOWER CASE> S
	XWD	F.DIG,	F.LETT+F.LCAS	; 4	, <LOWER CASE> T
	XWD	F.DIG,	F.LETT+F.LCAS	; 5	, <LOWER CASE> U
	XWD	F.DIG,	F.LETT+F.LCAS	; 6	, <LOWER CASE> V
	XWD	F.DIG,	F.LETT+F.LCAS	; 7	, <LOWER CASE> W
	XWD	F.DIG,	F.LETT+F.LCAS	; 8	, <LOWER CASE> X
	XWD	F.DIG,	F.LETT+F.LCAS	; 9	, <LOWER CASE> Y
	XWD	F.OTH,	F.LETT+F.LCAS	; :	, <LOWER CASE> Z
	XWD	F.OTH,	F.STR		; ;	, <LEFT BRACE>
	XWD	F.OTH,	F.STR		; <	, <VERTICAL BAR>
	XWD	F.EQAL,	F.STR		; =	, <RIGHT BRACE>
	XWD	F.OTH,	F.STR		; >	, <TILDE>
	XWD	F.STR,	F.STR		; ?	, <RUBOUT>
        END
   
