BASE 0
FIND %DRIVE,%HOSTEND,%PDATE,%PRINTST,INP,%SETCOR,%VAL.ADDR
FIND %PVAL,ERRCNT,PRO.DP
GLOBAL RPTR,%PARSE,CREFSW,%OUTCH,STB
LOCAL V(),D(),ALT(),SUC(),RULE(),ERTB(),I,J,K,PRSER:
LOCAL RSFL,INIT2:,SCTB(255),%INITP,%CGGO,LASTPA:,XLP,XLN(9)
LOCAL %OUTSYM,%OUTLIN,%WARN1,%OUTNAM,%TTLOUT
LOCAL LNUM,BUF(150),TOKPTR,%SCAN,EOFR:,OLNUM
LOCAL %SCOMP,%WARN2,SCP,LFNUM,PARSER,TOKMAX
LOCAL RVLNK,RUL,RUL2,OUTPT,ERSTOP,ERDEP
LOCAL CRCNT,CRFBF(),CRPTR
FIND FNCR,%RINFIL,%RNXFIL,FNI
LOCAL STFLINUM
DEF BITSPCHAR AS 7
DEF INPUT.NUM AS 1
DEF OUTPUT.NUM AS 2	! FOR OPEN CALL
DEF FLAGCH AS OCT 177

DEF PA.CNT.SIZ AS 4
LOCAL PA.CNT(1:PA.CNT.SIZ)


!MACHINE DEPENDENT PARAMETERS *********************
DEF CR AS CAR.RET
DEF CHR.WORD AS CHARS.PER.WORD

! THE NEXT 4 DEFS DEFINE FIELDS FOR THE MACRO STORAGE WORD
DEF TKFLD AS 16
DEF ARGBFLD AS 1
DEF SBFLD AS 1
DEF TIDFLD AS 18


DEF BLOCK.SIZE AS 256
DEF RSW.TYP AS 15	!TYPE FOR A RESERVED WORD
DEF MAC.TYP AS 14	!TYPE FOR A MACRO
DEF TOK.SIZ AS 400 !NUMBER OF TOKENS PERMITTED IN A LINE
DEF SYM.SIZ AS 256	!MAX NUMBER OF CHRS IN A SYMBOL

!THIS IS INFORMATION ON THE SYMANTIC ENTRY FOR SYMBOLS
DEF VALUE.VI(I) AS BYT(^I,19,0)
DEF VALUE.V(I)  AS VALUE.VI((VAL.ADDR(I)))
DEF DEPTH.VI(I) AS BYT(^I,5,22)
DEF DEPTH.V(I)  AS DEPTH.VI((VAL.ADDR(I)))
DEF TYPE.VI(I)  AS BYT(^I,8,27)
DEF TYPE.V(I)   AS TYPE.VI((VAL.ADDR(I)))

!THIS STUFF MUST MATCH TABLE GENERATOR
DEF DOL.VAL AS 4
DEF QUOTE.VAL AS 3
DEF ID.VAL AS 1
DEF CON.VAL AS 2
DEF DEF.VAL AS 5
DEF COM.VAL AS 6
DEF LP.VAL AS 7
DEF RP.VAL AS 8
DEF UDEF.VAL AS 9
DEF ENDM.VAL AS 10
DEF SUC.SIG AS 1
DEF R.SIZ.RULE AS 10

!FOR MASK USE ON RULES
DEF RUL.MSK AS BNOT((BNOT 0) SHL R.SIZ.RULE)


FIND %NEW.BLOCK,%INITCOR,%INIT.SYM.PAK,%USTK.ID,%STK.ID
FIND SYM.BUF(64),%NEW.SYM.TBL,%SETERR,%PUT,%GET,%WARN,%ERROR
FIND %CIO,%WIO,%BIO,%CLOSE,%OPEN,%SETLN,CLNNO,FNO,TITLE.P,%SYSOPEN
FIND %SYMPOS,%PRINT,%HOST
FIND %RETLIN,%GET.SYM
GLOBAL %PRINT.LINE.CR,LSNUM,%STRINP,%CRR.SYM,%CRD.SYM
GLOBAL %REMOVMAC
LOCAL TOKEN(TOK.SIZ),TOKID(TOK.SIZ),TKPOS(TOK.SIZ)
TABLE SCINI(35)[301,$G,$H,$I,$J,$K,$L,$M,$N,$O,$P,$Q,$R,$S,&
	$T,$U,$V,$W,$X,$Y,$Z,302,$A,$B,$C,$D,$E,$F,$G,303,$0,$1,&
	$2,500]
TABLE SCIN2(50)[303,$3,$4,$5,$6,$7,$8,$9,304,$(,$),$[,$],$,,&
	$;,$-,$@,&
	$^,$#,$%,$*,$:,$_,$/,$;,$+,305,$',$",306,$$,307,$!,308,$.,&
	LN.FEED,CAR.RET,$&,OCT 14,309,E.O.LIT,310,$ ,OCT 11,311,$\,500]

!THESE ARE THE TOKENS APPEARING IN THE V TABLE
DEF VL.DEF AS 1	!RECURR DOWN
DEF VL.VAL AS 2	!TOKEN NUMBER
DEF VL.ERR AS 3	!ERROR
DEF VL.CMP AS 4	!COMPILER OP MACRO FOR NOW
DEF VL.SIG AS 5	!SIGMA
DEF VL.FENCE AS 6 !FENCE

DEF CMPNUM AS 4	!NUMBER OF COMPILER OPS
DEF DFMAC AS 1	!COMPILER OP FOR DEFINE MACRO
DEF UDFMAC AS 2	!COMPILER OP FOR UNDEF
DEF MULDFM AS 3	!COMPILER OP FORM MULTI-LINE DEF

DEF PDL.SZ AS 800	!PARSER PUSHDOWN LIST
DEF OUT.SZ AS 900	!OUTPUT ARRAY FOR CODE GENERATORS

DEF CKPDP AS IF PDP>PDL.SZ THEN GO STKOV	!CHECK PDL OV MACRO

LOCAL PPSH(PDL.SZ),GPSH(PDL.SZ)	!PUSHDOWN LIST
LOCAL CAR(PDL.SZ),CDR(PDL.SZ)	!FOR MAKING LIST STRUCTURE
LOCAL FRSTKY:,LNFLAG
GLOBAL RESULT(OUT.SZ) !LEVEL AND OUTPUT ARRAY

LOCAL P,G,TTOK,TOK,PDP,ERNUM,S,NARGS,MACSP,MACFK(1)
LOCAL MACARY(),MACSTRT,MACPTR,%G.NEW.MAC,MARG.FK(1)
LOCAL M.STK.AR(9),MLMAC,MLEXP,NXTOKM,ARGB,SB



%PARSE
LOCAL I,J,STOPLNK,FRMLNK,BKCDR,PARTIAL,GB
	INITP; PARTIAL_0; GO FRSTPA
PARSLP:	IF CREFSW#0 AND MLEXP=0 THEN [OUTCH(FLAGCH); OUTCH(OCT 106)]
FRSTPA: NULL
	SCAN
	G_2; TTOK_TOKEN(0); TOK_TOKMAX_0
	ERSTOP_0; ERDEP_ERNUM_-1
	P_-1; PDP_0
!P IS THE PDP LEVEL TO POP TO AFTER FINISHING THIS DEF
!G IS THE LOCATION IN THE PARSE GRAPH
!TTOK IS THE CURRENT TOKEN AND TOK IS THE POSITION IN
!THE TOKEN BUFFER. PDP IS THE PDL POINTER


MAINPRS: DO V(G) OF 6

!A DEF STACKS P AND G AND RECURS BY SETTING P TO CURRENT LEVEL
!AND G TO D(G)

VL.DEF:	CKPDP; PPSH(PDP)_P<==PDP; GPSH(PDP)_G<==D(G)
	INC PDP; GO MAINPRS

!A VALUE CHECKS THE CURRENT TOKEN AGAINS THE TOKEN NUMBER
!GIVEN IN THE D ARRAY. IF THEY MATCH, WE STACK P AND G
!IN CASE OF LATER TROUBLE AND GO TO THE SUCCESOR
!IF NO MATCH THEN TRY ALT ENTRY

VL.VAL:	IF D(G)#TTOK THEN GO GETALT

!IF MATCH, STACK -TOKEN NUMBER IN RESULT (A TEMPORAY THING)
!RESULT WILL BE USED TO BUILD THE LIST STRUCTURE

PLCTOK:	RESULT(PDP)_-TOK; TTOK_TOKEN(INC TOK); S_PDP
	TOKMAX_TOKMAX MAX TOK
!ALSO HAVE GOTTEN NEXT TOKEN

GETSUC:	CKPDP; PPSH(PDP)_P; P_PPSH(S)
	GPSH(PDP)_G; G_SUC(GPSH(S)); INC PDP

!IF THE SUC IS A SIGMA THEN WE HAVE FINISHED THIS DEF AND
!WE CAN GO UP A LEVEL AND ON TO ITS SUC

CKSIG:	IF G#SUC.SIG THEN GO MAINPRS
	S_P<==PPSH(DEC PDP); G_GPSH(PDP)

!IF RETURN POINT FORM DEF IS -1 THEN WE ARE AT TOP
	IF S=-1 THEN IF TOK=TOKPTR THEN GO PRSDON &
	ELSE IF G_ALT(GB_G)#0 THEN [TTOK_TOKEN(DEC TOK); GO CKSIG] &
	ELSE IF V(GB)=VL.VAL THEN [TTOK_TOKEN(DEC TOK);GO POPUP]&
        ELSE GO POPUP
!IF NOT	FINISHED WITH LINE, MUST BE WRONG. TRY ALT
	RESULT(S)_PDP; GO GETSUC
!RESULT IS LOADED WITH A POINTER TO THE END OF THE SCAN
!INFORMATION FOR THAT DEF

!GET THE ALT ENTRY
GETALT:	NULL
	IF G_ALT(G)#0 THEN GO CKSIG !SEE IF DONE

!OUT OF ALTERNATES, MUST POP OUT OF THIS DEF
POPUP:	P_PPSH(DEC PDP); G_GPSH(PDP)
!MIGHT JUST POP UP TO LOOK FOR A DIFFERENT SUC
	IF P=-1 THEN GO PRSFALT	!AT START, NO POSSIBLE PARSE
	IF V(G)=VL.VAL THEN TTOK_TOKEN(DEC TOK)
!RECOVER SCANNED TOKENS
	IF ERSTOP<=0 THEN GO GETALT	!NOW UP A LEVEL TRY ANOTHER ALT
	IF G#ERSTOP THEN GO POPUP
	ERSTOP_0; GO GETALT

!ERROR. RECORD NUMBER AND TREAT AS POP UP ONE

VL.ERR:	IF TOK>ERDEP THEN [ERDEP_TOK; ERNUM_D(G)]
	ERSTOP_SUC(G); GO POPUP

!SIGMA. TREAT AS TOKEN MATCHES BUT DON'T ADVANCE POINTER

SIGNODE: VL.SIG:	RESULT(PDP)_-TOK; S_PDP; GO GETSUC

!HANDLE FENCE OP HERE
VL.FENCE:	PARTIAL_-(TOKPTR<==TOK); GO SIGNODE

!HANDLE COMPILER OPERATIONS

VL.CMP:	DO D(G) OF CMPNUM

DFMAC:	MLMAC_0
MACDEF:	J_TOKID(1)	!GET SEMANTIC ENTRY OF NAME
	IF CREFSW#0 THEN CRD.SYM(J)

!WATCH FOR REDEFINING MACRO
	IF TYPE.V(J)=MAC.TYP AND DEPTH.V(J)=PRO.DP THEN &
	[WARN ('ATTEMPT TO REDEFINE MACRO'); GO PARSLP]
!TOK IS POINTING TO THE FIRST TOKEN OF THE MACRO SO
	NARGS_(TOK-4)/2; IF NARGS<0 THEN NARGS_0
	NXTOKM_TOK-1

!MACROS ARE STORED IN A LINKED LIST STRUCTURE. EACH LINK
!IS BLOCK.SIZE BIG. THE FIRST TWO WORDS ARE FORWARD AND
!BACKWARD LINKS. THE STORAGE CONSISTS OF WORD PAIRS. THE FIRST
!IS FROM TOKEN, THE SECOND FROM TOKID. THE FIRST WORD OF THE
!MACRO IS THE NUMBER OF ARGUMENTS. A WORD PAIR OF 0,0 IS
!END OF MACRO, -N,ANYTHING IS ARGUMENT N, AND 0,ADR
!IS LINK TO NEXT BLOCK

!SET UP THE SYMBOL TABLE ENTRY

	STK.ID(J); DEPTH.VI(J)_PRO.DP
	VALUE.VI(J)_IF MACSP>=3 THEN MACPTR ELSE G.NEW.MAC
	TYPE.VI(J)_MAC.TYP
	DEC TOK	!PREPARE TO READ MACRO BODY!
	^INC MACPTR_NARGS; DEC MACSP
RMACLN:	WHILE TTOK_TOKEN(INC TOK)#0 THEN DO
	IF TTOK=ENDM.VAL AND MLMAC#0 THEN DO
	IF TOK>TOKPTR-1 THEN DO
WMLM:	WARN('IMPROPER ENDM'); GO FINMAC
	END
	IF TOKID(1)=TOKID(TOK+1) THEN [MLMAC_0; &
	IF TOK#TOKPTR-2 THEN GO WMLM; INC TOK; GO EWHL]
	END
	IF TTOK=ID.VAL THEN DO
!CHECK FOR ARGUMENT
	I_0; J_3
	WHILE INC I<=NARGS THEN IF TOKID(TOK)=&
	TOKID(J) THEN [TTOK_-I; GO AFND] &
	ELSE J_J+2
	END
AFND:	IF MACSP<2 THEN [I_INC MACPTR; ^I_G.NEW.MAC]
	IF TTOK<0 THEN[TTOK_-TTOK; ARGB_-1] ELSE ARGB_0
	^INC MACPTR_[TKFLD,ARGBFLD,SBFLD,TIDFLD] * &
	[TTOK,ARGB,0,TOKID(TOK)]; DEC MACSP

EWHL:	NULL
	END
	IF MLMAC#0 THEN DO
	IF MACSP<2 THEN [I_INC MACPTR; ^I_G.NEW.MAC]
	^INC MACPTR_[TKFLD+ARGBFLD,SBFLD,TIDFLD]*[0,1,2]
	DEC MACSP
	IF CREFSW#0 THEN [OUTCH(FLAGCH); OUTCH (OCT 106)]
	SCAN; TOK_NXTOKM-1; GO RMACLN
	END
FINMAC:	^INC MACPTR_[TKFLD+ARGBFLD,SBFLD,TIDFLD]*[0,1,0]
	DEC MACSP; GO PARSLP

UDFMAC:	IF TOK#TOKPTR THEN [WARN1 ('ERROR IN UNDEF'); &
	GO PARSLP]
	INC TOK
	WHILE TOK_TOK-2>=1 THEN DO
		J_TOKID(TOK); IF TYPE.V(J)=MAC.TYP THEN DO
		IF DEPTH.V(J)=PRO.DP THEN [TOKMAX_TOK; &
		WARN1('MACRO DEFINED IN CURRENT LEVEL'); GO PARSLP]
		STK.ID(J); ^J_0
		END
	END
	GO PARSLP

MULDFM:	MLMAC_-1; GO MACDEF

	END	!OF VL.CMP

	END	!OF DO V(G)

STKOV:	PARSER_1; ERROR ('STACK OVERFLOW')

PRSFALT: PARSER_1
	WARN(IF ERNUM<0 THEN 'UNRECOGNIZABLE STATEMENT' ELSE &
	@ERTB(ERNUM))
	PARSER_0; GO PARSLP

PRSDON:	I_PDP+1
	WHILE DEC I>=0 THEN DO
	EIF J_RESULT(I)<=0 THEN [CAR(I)_CDR(I)_-1; &
	PPSH(I)_-J]
	ELSE DO
!FOR THE FIRST TEST WE CHECK TO SEE IF THIS NODE WAS ONE
!OF THE INPUT TOKENS. IF NOT THEN RESULT TELLS US HOW FAR
!TO LOOK DOWN. THE CAR LINK ALWAYS GOES TO THE NEXT SPOT
!ALL THOSE THINGS IN THE RANGE NOT ALREADY ZEROED OUT ARE
!THE THINGS TO LINK ON THE CDR CHAIN

	CDR(I)_-1; CAR(I)_I+1; RESULT(I+1)_0
	FRMLNK_BKCDR_I+1; STOPLNK_J
	WHILE INC FRMLNK<=STOPLNK THEN &
	IF J_RESULT(FRMLNK)>0 THEN [CDR(BKCDR)_J; &
	BKCDR_J; RESULT(FRMLNK)_0]
	END
	RESULT(I)_I	!FLAG AS NOT USED
	END

!NOW APPLY THE RULES TO THE PARSE STACK AND GENERATE OUTPUT

	I_0; RVLNK_OUTPT_-1
!RVLNK IS THE RECURSION POINTER STORED IN THE CAR CHAIN

SETRUL:	DO (RULE(GPSH(I))BAND RUL.MSK) SHR 3 OF 0:4

!BINARY RULE. CONVERT A+B TO AB+

1:	J_I
	WHILE K_CDR(J)>=0 THEN [&
	CDR(K)_CDR(CDR(J)_CDR(K))<==K; J_K]

!UNARY RULE. CONVERT -A TO A- BY SWITHCING CAR AND CDR

2:	IF CDR(I)>=0 THEN CAR(I)_CDR(I)<==-1

!R RULE. CONVERT A_B TO BA_

3:	IF J_CDR(I)>=0 THEN DO
	K_CDR(J); CDR(J)_CDR(I)<==I<==K<==CDR(K)
	IF K>=0 THEN [J_CDR(J)_CDR(K)<==-1; CDR(J)_K]
	END

!P RULE. CONVERT AB TO BA

4:	IF J_CDR(I)>=0 THEN DO
		CDR(I)_CDR(J)<==I; I_J
	END

	END !OF DO RUL SHR 3 OF

ACTRUL:	IF CAR(I)>=0 THEN [I_CAR(I)<==RVLNK<==I; GO SETRUL]
!SET UP RECURSION. FOLLOW CAR CHAIN FIRST. COME BACK UP AND
!GET THE CDRS LATER. USE CAR CHAIN FOR POINTERS

ACTRUL2: DO (RUL2_RULE(GPSH(I))) BAND 7 OF 0:7

1:	RESULT(INC OUTPT)_RUL2 SHR R.SIZ.RULE

2:	RESULT(INC OUTPT)_OCT 403
	RESULT(INC OUTPT)_TOKID(PPSH(I))

3:	RESULT(INC OUTPT)_OCT 403
	RESULT(INC OUTPT)_TOKID(PPSH(I))
	RESULT(INC OUTPT)_RUL2 SHR R.SIZ.RULE

4:	RESULT(INC OUTPT)_OCT 402
	RESULT(INC OUTPT)_J_D(GPSH(I))
	RESULT(INC OUTPT)_0
	PA.CNT(J)_OUTPT

5:	INC RESULT(PA.CNT(D(GPSH(I))))
	END

	IF OUTPT>=OUT.SZ-3 THEN ERROR('OUTPUT TABLE OVERFLOW')

	IF I_CDR(I)>=0 THEN GO ACTRUL
	IF RVLNK>=0 THEN [I_RVLNK<==CAR(RVLNK)<==0; &
	GO ACTRUL2]

	RESULT(INC OUTPT)_OCT 401
	CGGO
IF PARTIAL=0 THEN GO PARSLP
	PDP_1; P_0; PPSH(0)_-1; GPSH(0)_G<==D(G)
	TOKPTR_-(PARTIAL<==0); GO MAINPRS
EOFR:	CLOSE(FNI)
	 IF LNFLAG#0 THEN [LNFLAG_0; GO LASTPA]
	IF RNXFIL=0 THEN[SETERR(FNI,EOFR); SETLN(FNI,FRSTKY); &
	    STFLINUM_LFNUM; GO FRSTPA]
	IF CREFSW#0 THEN DO
	CLOSE(FNCR)
	END
	IF MLMAC#0 THEN ERROR ('DEF DOES NOT END')
	PUT(CARRET); HOSTEND
	RETURN
END PARSE

%TTLOUT(I)
LOCAL CHAR
IF CREFSW=0 THEN RETURN
WHILE CHAR_NCHV(I)#E.O.LIT THEN OUTCH(CHAR)
I_CHPT(' - SIMPL VERS 2.00 ',-1)
WHILE CHAR_NCHV(I)#E.O.LIT THEN OUTCH(CHAR)
PDATE(FNCR); OUTCH(CAR.RET); I_4
WHILE DEC I>=0 THEN OUTCH(LN.FEED); RETURN
END TTLOUT

%INITP
LOCAL %INSCT,TMP
	SETCOR
	FNI _SYSOPEN(CHPT('SIMPL.RSW',-1),INPUT.NUM,36,PRSER)
	SETERR(FNI,PRSER)
	J_WIO(FNI)
	I_WIO(FNI)
	K_(I_5*J+I)/BLOCK.SIZE+1
!GET CORE FOR TABLES
	INITCOR; K_NEW.BLOCK(K,0)
	V_K; D_K_K+J; ALT_K_K+J; SUC_K_K+J; RULE_K_K+J
	ERTB_K+J
	BIO(FNI,V+1,I)	! READ IN ALL TABLES EXCEPT SYMBOLS
	INIT.SYM.PAK; STB_NEW.SYM.TBL(2,0)
	TYPE.VI(@RSFL)_RSW.TYP
	I_WIO(FNI)	!NUMBER OF RESERVED WORDS
	WHILE DEC I>=0 THEN DO
	SYMBUF(0) _ WIO(FNI)
	BIO(FNI,SYMBUF+1,SYMBUF(0)+1)
NXX:	J_SYMPOS(STB)+BLOCK.SIZE
	^J_(SYM.BUF(SYM.BUF(0)+1)<==0)+RSFL
	END
!SHOULD BE ALL RESERVED WORDS. CHECK
	SETERR(FNI,INIT2); I_WIO(FNI)
PRSER:	PRINT('PARSER TABLES GARBAGED'); HALT

INIT2:	J_256
!FILL CHARACTER TABLES FOR SCANNER
	WHILE DEC J>=0 THEN SCTB(J)_0
	INSCT(SCINI); INSCT(SCIN2)
	OLNUM_LNUM_-1; PARSER_CREFSW_0
	CLOSE(FNI)
GTIN:	IF INP=0 THEN TTY_$*; RINFIL
	IF INP#0 THEN [PRINT('SIMPL: '); PRINTST (TITLE.P)]
	SETERR(FNI,EOFR); SETLN(FNI,FRSTKY)
!SET UP ORIGINAL MACRO STORAGE
	MACSP_0; MACSTRT_MACARY_@MACFK(2)
	MACFK(0)_MACFK(1)_0; MACPTR_0
	MARG.FK(0)_MARG.FK(1)_M.STK.AR(9)_0
	LFNUM_MLEXP_0
	TTLOUT(TITLE.P)
	HOST	!INITIALIZE HOST
	RETURN

%INSCT	(ARY())
	J_-1
	WHILE I_ARY(INC J)#500 THEN IF I>300 THEN K_I-300 &
	ELSE SCTB(I)_K
	RETURN
END INSCT
END INITP


%SCAN
!THIS ROUTINE SCANS THE INPUT LINE AND PUTS TOKENS IN THE
!ARRAY TOKEN (IDS AND CONS GET ENTRIES IN ARRAY TOKID)
LOCAL TXP,CHR,I,TXCNT,TTYP,SCV,TLOC,RDARG,%FINSB,STOPVL
LOCAL EXMAC,INMAC,ARGPTR(),MACPTR,%STK.MAC,%USTK.MAC
LOCAL M.STK.SP,M.STK.PTR,M.STK.DEP,NARGS
!M.STK.AR IS FOR STACKING MACROS. GET 2 WITH NO ARGS WITHOUT
!NEEDING MORE CORE
LOCAL ARGSP,ARGARY(),ARGPNT,N.MACPTR
LOCAL N.MAC.ARGS,PRNCNT,%NEW.ARG.PNT,N.MAC.ARGP()
LOCAL N.MAC.ARGN,BAKPTR
BLKLN:	TOKPTR_IF MLMAC=0 THEN 0 ELSE NXTOKM
	IF MLEXP#0 THEN GO GETMAC
	INC LNUM
	IF FNI = 0 THEN [PUT($'); GO TEEIN]
	IF I_LNUM/10>OLNUM THEN &
		IF INP=0 THEN WHILE I#OLNUM THEN[PUT($');INC OLNUM]
TEEIN:	SCP_STRINP(FNI)
	
	M.STK.DEP_EXMAC_INMAC_0; M.STK.AR(0)_0 !BACK POINTER
	M.STK.PTR_@M.STK.AR(0); M.STK.SP_2
	ARGSP_0; ARGARY_@MARG.FK(2)
	RDARG_BAKPTR_0
	IF CREFSW#0 THEN [OUTCH(FLAGCH); OUTCH(OCT 102)]
TOKRD:	IF INMAC#0 THEN GO GETMAC	!DOING A MACRO EXPANSION
	TXP_CHPT(@SYM.BUF(1),-1); TXCNT_0
CHR1:	CHR_NCHV(SCP)
	DO SCV_SCTB(CHR) OF 0:11

! . OR SPACE
10:8:	GO CHR1

!RETURN
9:CRFND: IF CREFSW#0 AND MLEXP=0 AND TOKPTR=0 THEN &
	[	OUTCH(FLAGCH);	OUTCH(OCT 106)]
	IF RDARG#0 THEN [WARN('MACRO ARGUMENT DOES NOT END'); &
	GO BLKLN]
	IF TOKPTR=0 THEN GO BLKLN
	TOKEN(TOKPTR)_0; TKPOS(TOKPTR)_TKPOS(TOKPTR-1)
	RETURN

!COMMENT
7:	WHILE E.O.LIT#I_NCHV(SCP)#$! THEN NULL
	IF I=E.O.LIT THEN GO CRFND ELSE GO CHR1

!$ SYMBOL
6:	NCHV(TXP)_I_NCHV(SCP); INC TXCNT
	IF I=E.O.LIT THEN [WARN('$ ENDS LINE'); GO BLKLN]
	TTYP_DOL.VAL; GO GENCOM
!' OR "
5:	NCHV(TXP)_CHR; INC TXCNT
	WHILE E.O.LIT#I_NCHV(SCP)#CHR THEN [J_SCP; &
	IF I=$& AND NCHV(J)=CARRET THEN [NCHV(SCP); NCHV(SCP) &
		; IF LNFLAG#0 THEN NCHV(SCP)] &
	ELSE [NCHV(TXP)_I; IF INC TXCNT>SYM.SIZ THEN GO SYMER]]
	NCHV(TXP)_I
	IF I=E.O.LIT THEN [WARN ('BAD QUOTE'); GO BLKLN]
	TTYP_QUOTE.VAL; INC TXCNT
GENCOM:	FINSB; TLOC_SYMPOS(STB)+BLOCK.SIZE

!SPECIAL CHARACTER
4:	NCHV(TXP)_CHR; INC TXCNT
COMSYM:	FINSB; TLOC_SYMPOS(STB)+BLOCK.SIZE
	IF ^TLOC=0 THEN [WARN2 ('BAD SYMBOL'); GO BLKLN]
	TTYP_VALUE.V(TLOC)

!IDENT TYPE SPECIAL SYMBOL
0:11:	NCHV(TXP)_CHR; INC TXCNT
	WHILE SCTB(CHR_NCHV(SCP))=SCV THEN [NCHV(TXP)_CHR; &
	IF INC TXCNT>SYM.SIZ THEN GO SYMER]
        IF SCV=11 THEN &
           WHILE 1<=SCTB(CHR)<=3 THEN &
              [NCHV(TXP)_CHR ; IF INC TXCNT>SYM.SIZ THEN GO SYMER &
              ; CHR_NCHV(SCP)]
	PCHV(SCP); GO COMSYM

!NUMBER
3:	STOPVL_2; TTYP_CON.VAL; GO IDSCN1

!IDENT
1:2:	STOPVL_1; TTYP_ID.VAL
IDSCN1:	NCHV(TXP)_CHR; INC TXCNT	!GET FIRST CHR
IDSCN:	WHILE 3>=I_SCTB(CHR_NCHV(SCP))>=STOPVL THEN &
	[NCHV(TXP)_CHR; IF INC TXCNT>SYM.SIZ THEN GO SYMER]
	IF I=8 THEN GO IDSCN
	FINSB; PCHV(SCP); TLOC_SYMPOS(STB)+BLOCK.SIZE
	IF TYPE.V(TLOC)=RSW.TYP THEN TTYP_VALUE.V(TLOC)
	END

!EXMAC TELLS IF WE SHOULD EXPAND. FOR DEF AND UNDEF
!RDARG IS #0 IF READING ARGUMENTS (NO EXPAND THEN)
HVTOK:	IF RDARG#0 THEN GO ARGRDR
	IF DEC EXMAC<0 AND TTYP=ID.VAL AND TYPE.V(TLOC)=MAC.TYP &
	THEN [IF CREFSW#0 THEN OUTSYM(TLOC);GO EXPMAC]
	IF NOT ENDM.VAL#TTYP#DEF.VAL THEN EXMAC_1
	IF TTYP=UDEF.VAL THEN EXMAC_999999
!STUFF TOKEN AWAY FOR PARSER
STRTOK:	TOKEN(TOKPTR)_TTYP; TOKID(TOKPTR)_TLOC
	TKPOS(TOKPTR)_SCP
	IF INMAC=0 AND NOT DOL.VAL#TTYP#QUOTE.VAL THEN &
	[TTYP_CON.VAL; INC TOKPTR; GO STRTOK]
	IF INC TOKPTR<=TOK.SIZ THEN GO TOKRD
	WARN2 ('TOKEN BUFFER OVERFLOW'); GO BLKLN
SYMER:	WARN2 ('SYMBOL TOO LONG'); GO BLKLN

!MACRO ARGUMENTS ARE STORED IN A LIST STRUCTURE LIKE THAT FOR
!THE MACRO BODIES. ARGPTR POINTS TO THE START OF THE BLOCK
!FOR THE CURRENT ARGUMENTS(ALMOST). ARGPTR(N) CONTAINS
!A POINTER TO THE START OF	ATHE TOKENS FOR ARGUMENT N.
!SINCE A MACRO MAY TERMINATE WHILE THE ARGUMENTS OF
!ANOTHER ARE BEING READ, CARE MUST BE TAKEN IN RECLAIMING
!THE MACRO ARGUMENT SPACE. ARGPTR(0) CONTAINS A FORWARD
!POINTER TO THE NEXT ARGUMENT STORAGE BLOCK (0 IF THIS IS
!THE LAST). ARGPTR(-1) CONTAINS A BACKWARD POINTER TO THE
!PREVIOUS BLOCK (0 IF FIRST). ON RECLAIMING SPACE, IF THE
!FORWARD POINTER IS 0 WE CAN RECLAIM. WE LOOK AT THE BACK
!POINTER AND GET THE FORWARD POINTER IT POINTS TO. THIS
!IS WHERE TO RESET STORAGE TO. IF THE BACK POINTER
!IS 0, RESET TO START. IF THE FORWARD POINTER
!IS NOT 0, WE RUN UP THE FORWARD POINTERS UNTIL WE FIND A
!NON-ZERO BACK POINTER. WE THEN CHANGE THIS TO BE THE
!BACK POINTER FROM THE CURRENT BLOCK AND ZERO THE
!BACK POINTER OF THE CURRENT BLOCK.	THE VARIABLE
!BAKPTR IS USED TO SET UP THE BACK POINTERS IN THE BLOCKS


!WHEN WE WANT TO START EXPANDING A MACRO, WE STACK
!THE CURRENT VALUES OF INMAC(IN EXPANSION), MACPTR, NARGS,
!AND ARGPTR. NARGS IS NUMBER OF ARGUMENTS AND IS SAVED
!TO TELL WHETHER TO RECLAIM STORAGE SPACE. WHEN THE MACRO
!ENDS, WE JUST	UNSTACK AND GO BACK TO SCANNING.
!A MACRO ARGUMENT ENTRY IN A MACRO IS TREATED JUST LIKE
!THE START OF A NEW EXPANSION. THE DIFFERENCE IS THAT MACRO
!ARGUMENTS END WITH 0,-1 INSTEAD OF 0,0. THIS IS TO
!SAY NOT TO RECLAIM ARGUMENT STORAGE SPACE ON COMPLETION


EXPMAC:	N.MACPTR_VALUE.V(TLOC)
	IF N.MAC.ARGS_^INC N.MACPTR=0 THEN GO STARTMAC
	RDARG_1; PRNCNT_-1	!PAREN COUNT
	IF ARGSP<N.MAC.ARGS+4 THEN NEW.ARG.PNT
	ARGSP_ARGSP-(N.MAC.ARGS+2)
	N.MAC.ARGP_ARGPNT+2; ARGPNT_ARGPNT+N.MAC.ARGS+2
	IF BAKPTR#0 THEN ^BAKPTR_N.MAC.ARGP
	N.MAC.ARGP(0)_0; N.MAC.ARGP(-1)_BAKPTR<==N.MAC.ARGP
	N.MAC.ARGP(1)_ARGPNT; N.MAC.ARGN_1
	GO TOKRD

!READ MACRO ARGUMENTS AND STORE. WATCH PAREN. COUNT
ARGRDR:	EIF TTYP=LP.VAL AND INC PRNCNT=0 THEN NULL
	ORIF PRNCNT<0 THEN ERROR ('MACRO NOT FOLLOWED BY (')
	ORIF TTYP=RP.VAL AND DEC PRNCNT<0 THEN DO
	^INC ARGPNT_[TKFLD+ARGBFLD,SBFLD,TIDFLD]* &
	[0,1,1]; DEC ARGSP
	IF N.MAC.ARGN#N.MAC.ARGS THEN &
	ERROR ('WRONG NUMBER OF ARGUMENTS')
	RDARG_0
!ACTUALLY START MACRO EXPANSION. STACK AND SET POINTERS
STARTMAC:	STK.MAC; INMAC_1; MACPTR_N.MACPTR
	ARGPTR_N.MAC.ARGP
	NARGS_N.MAC.ARGS; GO GETMAC
	END
	ORIF TTYP=COM.VAL AND PRNCNT=0 THEN DO
	IF INC N.MAC.ARGN>N.MAC.ARGS THEN &
	ERROR ('WRUMBER OF ARGUMENTS')
	^INC ARGPNT_[TKFLD+ARGBFLD,SBFLD,TIDFLD] * &
	[0,1,1]
	IF DEC ARGSP<2 THEN NEW.ARG.PNT
	N.MAC.ARGP(N.MAC.ARGN)_ARGPNT
	END
	ELSE DO
FOOONDOL:	IF ARGSP<2 THEN [I_INC ARGPNT; &
	^I_NEW.ARG.PNT]
	^INC ARGPNT_[TKFLD,ARGBFLD+SBFLD,TIDFLD]*[TTYP,0,TLOC]
	DEC ARGSP
	IF INMAC=0 AND NOT DOL.VAL #TTYP#QUOTE.VAL THEN&
	[TTYP_CON.VAL; GO FOOONDOL]
	END
	GO TOKRD

GETMAC:	[TKFLD,ARGBFLD,SBFLD,TIDFLD]*[TTYP,ARGB,SB,TLOC]_^INC MACPTR
	IF ARGB=0 THEN DO
	IF TTYP>0 THEN GO HVTOK
	IF SB=0 THEN [MACPTR_TLOC; GO GETMAC]
	GO CLOSMAC
	END
	STK.MAC; MACPTR_ARGPTR(TTYP); GO GETMAC
CLOSMAC: IF TLOC=2 THEN [MLEXP_-1; GO CRFND] ELSE MLEXP_0
	IF TLOC#0 OR NARGS=0 THEN [USTK.MAC; GO TOKRD]
!RECLAIM ARGUMENT STORAGE SPACE
	IF ARGPTR(0)=0 THEN DO
!LAST ON STACK. IF BACK POINTER =0 RESET TO START
	EIF ARGPTR(-1)=0 THEN [ARGARY_@MARG.FK(2); &
	BAKPTR_0; ARGSP_0]
	ELSE DO
!BACK POINTER #0. RECLAIM FROM POINTERS
	BAKPTR_ARGPTR(-1); ARGPNT_^BAKPTR-2
	^BAKPTR_0
	WHILE NOT ARGARY-1<=ARGPNT<=ARGARY+&
	BLOCK.SIZE-4 THEN IF&
	ARGARY_ARGARY(-2)=0 THEN &
	ERROR ('ERROR IN MACRO PROCESSING')
	ARGSP_BLOCK.SIZE-3-(ARGPNT-ARGARY)
	END
	END ELSE DO
!NOT LAST BLOCK OF ARGUMENTS. JUST RELINK FOR LATER
	I_ARGPTR(0)
	WHILE ^(I-1)=0 THEN I_^I
	^(I-1)_ARGPTR(-1)<==0
	END
	USTK.MAC; GO TOKRD


%NEW.ARG.PNT
!LINK IN NEXT ARGUMENT STORAGE LIST ELEMENT
	ARGSP_BLOCK.SIZE-2
	EIF ARGARY(-1)#0 THEN ARGARY_ARGARY(-1)
	ELSE ARGARY(-2)_ARGARY<==ARGARY(-1)_NEW.BLOCK(1,0)+2
	RETURN ARGPNT_ARGARY-1
END NEW.ARG.PNT

%FINSB
LOCAL I
!FINISH PUTTING SYMBOL IN SYMBOL. FILL WITH E.O.LITS. SET SIZE
	IF I_CHR.WORD-(TXCNT MOD CHR.WORD)<CHR.WORD THEN &
	WHILE DEC I>=0 THEN NCHV(TXP)_E.O.LIT
	SYM.BUF(0)_(TXCNT-1)/CHR.WORD+1
	RETURN
END FINSB


%STK.MAC
!STACK MACRO INFORMATION
	IF DEC M.STK.SP<0 THEN DO
	EIF ^INC M.STK.PTR=0 THEN	^M.STK.PTR_&
	(M.STK.PTR<==^M.STK.PTR_(NEW.BLOCK(1,0)))
	ELSE M.STK.PTR_^M.STK.PTR
	M.STK.SP_(BLOCK.SIZE-2)/4-1
	END
	^INC M.STK.PTR_NARGS
	^INC M.STK.PTR_INMAC; ^INC M.STK.PTR_ARGPTR
	^INC M.STK.PTR_MACPTR; INC M.STK.DEP
	RETURN
END STK.MAC

%USTK.MAC
!UNSTACK MACRO INFORMATION
	IF DEC M.STK.DEP<0 THEN ERROR('MACRO STACK UNDERFLOW')
	IF INC M.STK.SP=(BLOCK.SIZE-2)/4+1 THEN &
	[M.STK.PTR_^M.STK.PTR-1; M.STK.SP_1]
	MACPTR_^M.STK.PTR; ARGPTR_^DEC M.STK.PTR
	INMAC_^DEC M.STK.PTR; NARGS_^DEC M.STK.PTR
	DEC M.STK.PTR; RETURN
END USTK.MAC

END SCAN



%SCOMP(STR1,STR2)
!COMPARE TWO STRINGS. RETURN 0 FOR EQUAL 1 FOR UNEQUAL
LOCAL PTR1,PTR2,I
	PTR1_CHPT(STR1,-1); PTR2_CHPT(STR2,-1)
SC1:	IF I_NCHV(PTR1)#NCHV(PTR2) THEN RETURN 1
	IF I=E.O.LIT THEN RETURN 0; GO SC1
END SCOMP

%STRINP
LOCAL CHAR,NXSTKY:,CNT,NXLN,PTR,PTR1,CON.CH
DEF F.FED AS OCT 201004.020101  ! LINUMBER FOR F.F.
PTR1_PTR_CHPT(BUF+1,-1); CNT_5; LSNUM_LFNUM+1; XLP_-1
IF LNFLAG#0 AND NXLN=F.FED THEN DO
	BUF(0)_WIO(FNI); IF CREFSW#0 THEN OUTLIN(5,OCT 104); NXLN_WIO(FNI)
END
BUF(0)_IF LNFLAG#0 THEN NXLN ELSE 0

CHREAD: WHILE CHAR_CIO(FNI)#CAR.RET THEN DO
	IF CHAR#0 THEN DO
		INC CNT; NCHV(PTR)_CHAR
		IF CHAR=LNFEED THEN [NCHV(PTR)_CIO(FNI); INC CNT]
	END
END
INC LFNUM; CONCH_CHV(PTR); NCHV(PTR)_CAR.RET ;INC CNT
NCHV(PTR)_CIO(FNI); INC CNT
IF CON.CH=$& THEN [INC LNUM; GO CHREAD]
IF LNFLAG#0 THEN GO CHREAD

LASTPA: ENR: IF CREFSW#0 THEN OUTLIN(CNT,OCT 105)
 PCHV(PTR)_E.O.LIT  !MARK END OF LINE
RETURN PTR1

NXSTKY:	IF CON.CH=$& THEN [XLN(INC XLP)_CLNNO; GO CHREAD]
NXLN_CLNNO; GO ENR

FRSTKY: LNFLAG_-1; BUF(0)_CLNNO; SETLN(FNI,NXSTKY); GO CHREAD
END STRINP

%PRINT.LINE.CR
LOCAL I,J
!TYPE ERROR LINE. FORMAT DEPENDS ON PARSER
!0: JUST TYPE LINE
!1: ERROR FROM PARSER. USE TKPOS(TOKMAX) TO DETERMINE BREAK
!2: ERROR FROM SCAN. USE SCP TO DETERMINE BREAK
	IF FNI#0 THEN DO
	RETLIN; PRINT ('ERROR IN LINE')
	PRINT (IF LFNUM=LSNUM THEN ' ' ELSE 'S ')
	PVAL (I_LSNUM-STFLINUM)
	WHILE INC I<=LFNUM-STFLINUM THEN [PUT($,); PVAL(I)]
	RETLIN
	END
	DO PARSER OF 0:2
0:	IF FNI#0 THEN [PRINT(BUF); RETLIN]

1:	I_TKPOS(TOKMAX)
COMER:	J_CHPT(BUF,-1)
	WHILE I#J THEN PUT(NCHV(J))
	PRINT ('<<<'); RETLIN
	WHILE I_NCHV(J)#E.O.LIT THEN PUT(I)
	RETLIN

2:	I_SCP; GO COMER
	END
	IF FNI#0 THEN PUT(CR)
	INC ERRCNT
	RETURN
END PRINT.LINE.CR

%WARN2 (STR)
	PARSER_2; WARN(STR); PARSER_0
	RETURN
END WARN2

%G.NEW.MAC
!NEW MACRO STORAGE ELEMENT
	MACSP_BLOCK.SIZE-2
	EIF MACARY(-1)#0 THEN MACARY_MACARY(-1)
	ELSE MACARY(-2)_MACARY<==MACARY(-1)_NEW.BLOCK(1,0)+2
	RETURN MACPTR_MACARY-1
END G.NEW.MAC

%REMOVMAC(ADR)
LOCAL ARY()
!RECLAIM MACRO STORAGE SPACE. CALLED BY CODE GENERATORS
!AT END OF BLOCK WHEN DEFS GO AWAY. ADR IS THE POINTER
!TO START OF MACRO STORAGE TO RECLAIM
	ARY_MACARY
	WHILE NOT ARY-1<=ADR<=ARY+BLOCK.SIZE-4 THEN &
	IF ARY_ARY(-2)=0 THEN RETURN
	IF ADR>=MACPTR THEN RETURN
	MACPTR_ADR; MACARY_ARY
	MACSP_BLOCK.SIZE-3-(MACPTR-MACARY)
	RETURN
END REMOVMAC

%WARN1(STR)
	PARSER_1; WARN(STR); PARSER_0; RETURN
END WARN1

%OUTCH(CHR)
	CIO(FNCR,CHR) ; RETURN
END OUTCH

%OUTSYM(TLOC)
LOCAL I,PTR,PTR1
	OUTCH(1)	!SYMBOL COMING
%%OUTNAM(TLOC)	!TO PUT OUT OTHER SYMBOLS NOT TYPE 1
	GET.SYM(TLOC-BLOCK.SIZE)
	I_SYMBUF(SYMBUF(0)+1)_0
	PTR1_PTR_CHPT(@SYM.BUF(1),-1); WHILE NCHV(PTR)#E.O.LIT THEN INC I
	OUTCH(I_I MIN 6)
	WHILE DEC I>=0 THEN OUTCH(NCHV(PTR1))
	RETURN
END OUTSYM

%OUTLIN(CNT,CRC)
LOCAL PTR,CHAR,ACH,PTR2,I,LN
PTR_CHPT(BUF,-1); XLP_-1
OUTCH(FLAGCH); OUTCH(OCT 102); OUTCH(FLAGCH); OUTCH(CRC)
OUTCH(OCT 11)
WHILE DEC CNT>=0 THEN DO
	OUTCH(CHAR_NCHV(PTR))
	IF CHAR=CAR.RET THEN DO
	  ACH_PCHV(PTR); NCHV(PTR); OUTCH(NCHV(PTR));DEC CNT
	  IF ACH=$& THEN DO
	   OUTCH(FLAGCH); OUTCH(OCT 102); OUTCH(FLAGCH)
	   OUTCH(OCT 107)
	   OUTCH(FLAGCH); OUTCH(OCT 102); OUTCH(FLAGCH)
	   OUTCH(OCT 105); OUTCH(OCT 11); IF LNFLAG#0 THEN DO
		LN_XLN(INC XLP); PTR2_CHPT(@LN,-1)
		I_5; WHILE DEC I>=0 THEN OUTCH(NCHV(PTR2))
	   END
	   END
	END
END
	RETURN
END OUTLIN

!FC FOR 10---THIS LINKS PARSER AND CODEGEN

%CGGO
 RPTR_-1
! CALL CODE GENERATORS
	DRIVE
RETURN
END CGGO

%CRR.SYM(ID)
OUTSYM(ID); RETURN
END CRRSYM

%CRD.SYM(ID)
OUTSYM(ID); OUTCH(2); RETURN  !DEFINE SYMBOL
END CRDSYM

 tI5Ò