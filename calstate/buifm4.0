TITL(BASUIF,BASIC USER INTERFACE PACKAGE)

        LOC     137
JOBVER: EXP  BASVER

        RELOC
        HISEG

;EXTERNAL DEF'S FOR ENTRY-TYPE VECTORS


INTERN BASIC,ASKNEW,FIXUP,UXIT,REUXIT,CHAXIT
; EXTERNALS FOR BUFFERS
        DEFINE  R(A)<IRP A<EXP OPS'A
        EXTERN OPS'A>>
FILMOD: R<1,2,3,4,5,6,7,8,9>

        DEFINE  R(A)<IRP A<EXP DO'A+1>>
OUTPT:  R<1,2,3,4,5,6,7,8,9>

        DEFINE  R(A)<IRP A<EXP DO'A+2
        EXTERN DO'A>>
OUTCNT: R<1,2,3,4,5,6,7,8,9>

        DEFINE  R(A)<IRP A<EXP DI'A+1
        EXTERN DI'A>>
INPT:   R<1,2,3,4,5,6,7,8,9>

        DEFINE  R(A)<IRP A<EXP DI'A+2>>
INCNT:  R<1,2,3,4,5,6,7,8,9>

        DEFINE  R(A)<IRP A<POINT 7,LINB'A
        EXTERN LINB'A>>
LINPT:  R<0,1,2,3,4,5,6,7,8,9>

	INTERN CMDCEI,CMDFLO
       SUBTTL TABLE OF BASIC COMMANDS

DEFINE YYY (A,B)<
	EXP	SIXBIT /A/ + 'A'ER + 'B'0000>

CMDFLO:	YYY BYE
	YYY CAT
	YYY COP
	YYY DEL
	YYY GOO
        YYY HEA
	YYY KEY
	YYY LEN
	YYY LIS
	YYY LOC
	YYY NEW
        YYY NOH
	YYY OLD
	YYY REN
	YYY REP
	YYY RES
	YYY RUN
	YYY SAV
	YYY SCR
	YYY SYS
	YYY TAP
	YYY UNS
	YYY WEA
CMDCEI:

       SUBTTL  UUO HANDLER

MAXUUO==2                       ;MAX UUO [FAIL]

        STAR==.
        LOC     41
        JSR     UUOH
        RELOC	STAR

	INTERN UUOHAN
UUOHAN:	PUSH	P,UUOH		;RETURN ADDRS ON PUSH-DOWN LIST
	LDB	X1,[POINT 9,40,8]
	CAILE	X1,MAXUUO
	JRST	INLSYS		;ILLEGAL UUO.
UUOTBL:	JRST	.(X1)
        JRST    FAILER
	SUBTTL	COMMAND SCANNER AND EDITOR
;COLD START

BASIC:	CALLI	0
	MOVEI	BASIC
	SETDDT			;SET UP DDT INCORRECTLY
	MOVE	P,PLIST
	SETZM	IFIFG
	SETZM	QUOTBL
	SETZM	COMTIM
	SETZM	MARWAI
	MOVEI	X1,^D72
	MOVEM	X1,MARGIN
	MOVEI	X1,^D9
	SETZM	ACTBL-1(X1)
	SOJG	X1,.-1
	SETZM	HPOS
	SETZM	TRPLOC+2
	SETZM	TRPLOC+3
	SETOM	PAGLIM
	SETZM	CHAFLG
	SETZM	CHAFL2
	SETZM	UXFLAG
	SETZB	LP,ODF
	SETZM	MTIME
	SETOM	RENFLA		;ALLOW REENTERS.
	SKIPN	ONCESW		;FIRST TIME, SET THINGS UP
	JRST	BASI1
	SETZM	ONCESW

;FIRST TIME THROUGH
; HERE SET UP SEG CALLING CODES
        MOVE    N,[-1,,-25]
        GETTAB  N,
        SETZ    N,
        CAME    N,[1,,4]        ;CHECK FOR SYS
        JRST    NOTFSS          ;NOT FROM SYS
        MOVEM   N,SEGB+4        ;PUT 1,4 INTO IT
        MOVE    N,[SIXBIT /SYS   /]
        MOVEM   N,SEGB          ;DEV IS SYS:
        JRST    CWFSS
NOTFSS: MOVEM   N,SEGB+4        ;SAVE DIRECT
CWFSS:  SETZM   RANCNT
	HLRZ	T,JOBSA
	MOVEM	T,SJOBSA
	MOVEM	T,FLTXT		;TXTROL ON BOTTOM OF FREE SPACE
	MOVEM	T,CETXT
	MOVE	T,JOBREL	;LINROL ON TOP
	MOVEM	T,SJOBRL
	MOVEM	T,FLLIN
	MOVEM	T,CELIN
        EXTERN REENTR
        HRRZI T,REENTR
        HRRM T,JOBREN
	SETZM	PAKFLG		;DON'T HAVE TO CRUNCH CORE YET.

	SETZM	DSKSYS
	SETZM	SWAPSS
	HRLZI	X1,400000
	MOVEM	X1,MONLVL	;MONLVL CONTAINS THE
	MOVE	X1,[XWD 17,11]	;PROTECTION CODE "DON'T DELETE"
	CALLI	X1,41		;BIT APPROPRIATE TO THE MONITOR
	JRST	BASI1		;LEVEL UNDER WHICH BASIC IS RUNNING.
	TLNN	X1,(7B9)
	JRST	BASI0
	HRLZI	T,100000
	MOVEM	T,MONLVL
BASI0:	TLNE	X1,200000
	SETOM	SWAPSS		;SWAPPING SYSTEM.
	TLNE	X1,400000
	SETOM	DSKSYS		;DISK SYSTEM.

BASI1:	PUSHJ	P,TTYIN		;SET UP BUFFERS AND INIT TTY
	SKIPE	CURNAM
	JRST	UXIT
	SETZM	RUNFLA
ASKNEW:	PUSHJ	P,INLMES

	ASCIZ	/
NEW OR OLD--/			;FALL INTO FIXUP

FIXUP:	OUTPUT 0,			;WRITE LAST MESSAGE
	SKIPE	CORN
	JRST	NAMED
	MOVE	X1,[SIXBIT /DSK/]	;INITIALIZE BASIC WITH
	MOVEM	X1,CURDEV		;CURRENT DEVICE==DSK
	MOVE	X1,[SIXBIT /NONAME/]
	MOVEM	X1,CURNAM		;CURRENT NAME==NONAME
	MOVE	X1,[SIXBIT /BAS/]
	MOVEM	X1,CUREXT		;CURRENT EXT==BAS
NAMED:	SETOM	CORN
CLR:	SETZM	IFIFG
	SETZM	ODF
        SETZ    X1,             ;IGNORE OVERFLOW DURING COMMANDS
	HRRM	X1,JOBAPR
	MOVEI	X1,10		;SETUP ARITH OVFLOW TRAP
	CALLI	X1,16
	MOVEI	X1,TXTROL
	MOVEM	X1,TOPSTG	;EDIT TIME. ONLY TXTROL IS STODGY.
;				;OTHER ROLLS MOVE.
	MOVE	T,CELIN	;CLOBBER ALL COMPILE ROLLS WITH "CELIN"
	MOVEI	X1,LINROL	;PROTECT TXTROL +LINROL FROM CLOBBER:
	PUSHJ	P,CLOB
				;FALL INTO MAINLP
;MAIN LOOP FOR EDITOR/MONITOR

MAINLP:	MOVE	P,PLIST
	PUSHJ	P,LOCKOF	;TURN OFF REENTR LOCK
	SKIPE	CHAFLG		;CHAINING?
	JRST	OLDER		;YES.
	PUSHJ	P,INLINE	;READ A LINE
	PUSHJ	P,GETDNM	;LOOK FOR SEQUENCE NO
	JRST	COMMAN		;NONE.  GO INTERPRET COMMAND
	SKIPE	PAKFLG		;CRUNCH CORE?
	PUSHJ	P,SCRER3	;YES.
	SKIPN	CURNAM		;MAKE SURE THERE IS A CURRENT FILE NAME.
	JRST	ASKNEW

;HERE, WE HAVE SEQUENCED LINE INPUT.  NUMBER IS IN N,

	SKIPE	LOKFLG		;ARE WE LOCKED IN CORE?
	JRST	[OUTSTR [ASCIZ /INDIRECT STATEMENTS LOCKED OUT
/]
		JRST UXIT]
;POINTER TO FIRST CHAR AFTER NUMBER IS IN T

	PUSHJ	P,LOCKON
	PUSHJ	P,ERASE
	PUSHJ	P,INSERT
	PUSHJ	P,LOCKOF
	JRST	MAINLP

;HERE ON COMMAND

COMMAN:	MOVEI	R,CMDROL
	TLNE	C,F.CR		;TEST FOR NULL COMMAND
	JRST	MAINLP
	PUSHJ	P,SCNLT1		;SCAN COMMAND
	PUSHJ	P,SCNLT2
	JRST	COMM1			;SECOND CHAR NOT A LETTER
	PUSHJ	P,SCNLT3
	JRST	COMM1			;THIRD CHAR NOT A LETTER

;NOW THE FIRST THREE LETTERS OF THE COMMAND ARE PACKED IN LH OF A.

	PUSHJ	P,SEARCH	;LOOK FOR COMMAND
	JRST	COMM1		;NOT FOUND
	HRRZ	X1,(B)
	SKIPE	CURNAM
	JRST	(X1)
	CAIE	X1,OLDER
	CAIN	X1,NEWER
	JRST	(X1)
	JRST	ASKNEW

;FAILER - DOES THE FAILING THING
FAILER: LDB     X1,[POINT 4,40,12]       ;GET AC VALUE
        JRST    .+1(X1)         ;AND JUMP TO IT
        REPEAT  17,<
        JRST    FAILX>

; FAIL ROUTINES
FAILX:  OUTPUT 0,
        OUTSTR  [ASCIZ /
BASIC SYSTEMS ERROR:
ILLEGAL AC IN FAIL CALLED FROM BASUIF
/]
        HALT    .-2
;"GOODBY" OR "BYE"
GOOER:	PUSHJ	P,QSA		;"GOODBYE"
	ASCIZ	/DBYE/
	JRST	BYEER		;AND "BYE"
BYEER:	MOVE	A,[XWD 17,11]	;BYE AND GOO ARE NOT IMPLEMENTED
	CALLI	A,41		;FOR NON-LOGIN SYSTEMS--SO
	JRST	.+1		;FIND OUT WHAT TYPE OF SYSTEM
	TLNE	A,100000	;BASIC IS RUNNING UNDER.
	JRST	BYEER5		;LOGIN SYSTEM--GO EXECUTE.
	MOVEI	T,NOTIMP	;NON-LOGIN SYSTEM--SEND MESSAGE OUT.
	JRST	ERRMSG
BYEER5:	MOVSI	A,(SIXBIT /SYS/)
	MOVEM	A,FILDIR
	MOVE	A,[SIXBIT /LOGOUT/]
	MOVEM	A,FILDIR+1
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	SETZM	FILDIR+4
	SETZM	FILDIR+5
	MOVSI	A,1
	HRRI	A,FILDIR
	CALL	A,[SIXBIT /RUN/]
	MOVEI	T,BY1
	JRST	ERRMSG
BY1:	ASCIZ	/
LOGOUT FAILED -- TRY AGAIN
/


;LOCK COMMAND - SET'S LOKFLG =1 TO SHUT OFF GETTING PROGRAM
;
LOCER:	SKIPE	LOKFLG
	JRST	LKDOUT
	PUSHJ	P,INLMES
	ASCIZ	/DO YOU HAVE A COPY OF THE SOURCE PROGRAM SAVED? /
	OUTPUT 0,
	PUSHJ	P,INLINE
	TLNE	C,F.TERM	;TERMINATED?
	JRST	LOCNO		;YES
	CAME	C,[F.LETT,,"Y"]
	JRST	LOCNO
	PUSHJ	P,NXCH
	TLNE	C,F.TERM
	JRST	LOCOK
	CAME	C,[F.LETT,,"E"]
	JRST	LOCNO
	PUSHJ	P,NXCH
	TLNE	C,F.TERM
	JRST	LOCOK
	CAME	C,[F.LETT,,"S"]
	JRST	LOCNO
	PUSHJ	P,NXCH
	TLNE	C,F.TERM
	JRST	LOCOK
LOCNO:	JRST	[OUTSTR [ASCIZ /COMMAND ABORTED
/]
			JRST UXIT]
LOCOK:	SETOM	LOKFLG
	OUTSTR	[ASCIZ /PROGRAM LOCKED OUT
/]
	JRST UXIT

LKDOUT:	OUTSTR	[ASCIZ /COMMAND LOCKED OUT
/]
	JRST	UXIT
;"CATALOG" OR "CAT" 
;     RESULTS IN A LISTING OF USER PROGRAMS ON TTY
;     WHILE RUNNING "BASIC"

CATER:	PUSHJ	P,QSA
	ASCIZ	/ALOG/
	JRST	.+1
	SETZM	CATFLG		;FLAG IS ZERO FOR DSK, NE 0 FOR DTA'S.
	MOVSI	A,(SIXBIT/DSK/)
	TLNE	C,F.CR
	JRST	CAT2
	PUSHJ	P,ATOMSX
	JUMPN	A,.+2
	MOVSI	A,(SIXBIT/DSK/)
	CAIN	C,72
	PUSHJ	P,NXCH
	TLNE	C,F.CR
	JRST	CAT2
	JRST	COMM1
CAT1:	MOVEI	T,CATFAL
	JRST	ERRMSG
CAT2:	MOVEM	A,DEVICE
	CALL	A,[SIXBIT/DEVCHR/]
	JUMPN	A,.+3
	MOVE	T,DEVICE
	JRST	NOGETD
	TLNN	A,200100
	JRST	CAT1
	TLNN	A,200000
	SETOM	CATFLG
	MOVEI	N,IBF		;ININI1:          14
	MOVEM 	N,DEVICE+1  	;DEVICE:
	MOVEI	N,14		;DEVICE+1:        IBF
	MOVEM	N,ININI1
	OPEN	3,ININI1	;TRY TO GET THE CAT DEVICE.
	JRST	[MOVE T,DEVICE
		JRST NOGETD]
	MOVEI	N,DRMBUF
	MOVEM	N,JOBFF
	INBUF	3,1		
	INIT	2,1		;INIT THE TTY FOR LISTING.
	SIXBIT	/TTY/
	XWD	OBF,
	JRST	[MOVEI T,(SIXBIT/TTY/)
		JRST NOGETD]
	MOVEI	N,LINB2
	MOVEM	N,JOBFF
	OUTBUF	2,1
	PUSHJ	P,CLRF
	SKIPN	CATFLG
	JRST	DSKHAN
DTAHAN:	USETI	3,144		;POINT TO THE DIRECTORY BLOCK.
	INPUT	3,
	STATUS	3,D
	TRNE	D,740000	;ERROR?
	JRST	CATERR		;YES.
	MOVEI	X2,^D82		;NO.
	MOVEI	B,^D22
	MOVEM	B,CATFLG
	ADD	X2,IBF+1	;SET UP BYTE POINTERS TO FILENAMES
	ADD	B,X2		;AND EXTENSIONS.
CATLP:	ILDB	N,X2
	ILDB	1,B
	JUMPE	N,CATTST	;GO TO CATTST IF NO FILENAME HERE.
	MOVEM	N,FILNM
	HLLZM	1,FILNM+1
	PUSHJ	P,CLSTU3	;OUTPUT FILENAME AND EXT.
CATTST:	SOSG	CATFLG		;ONLY 22 FILES ON A DECTAPE.
	JRST	UXIT
	JRST	CATLP

DSKHAN:	CALLI	T1,24		;PREPARE FOR LOOKUP
	MOVEM	T1,UFD		;UFD  : P# ,P#
	MOVSI	N,(SIXBIT/UFD/)	;UFD+1:SIXBIT /UFD/
	MOVEM	N,UFD+1		;UFD+2:
	SETZM	UFD+2
	MOVE	N,[XWD 1,1]	;UFD+3: 1 ,, 1
	MOVEM	N,UFD+3
	LOOKUP	3,UFD		;LOOKUP DIRECTORY
	JRST	DSKERR
	JRST	CLSTU1
DSKERR:	PUSHJ	P,INLMES
	ASCIZ	/
FILE /
	SETZM	ODF
	SETZM	HPOS
	HLRZ	T,DEVICE
	CAIN	T,<SIXBIT/   DSK/>
	JRST	DSKER1
	MOVE	T,DEVICE
	PUSHJ	P,PRNSIX
	MOVSI	T,320000
	PUSHJ	P,PRNSIX
DSKER1:	HLRZ	T,UFD
	PUSHJ	P,PRTOCT
	MOVSI	T,14
	PUSHJ	P,PRNSIX
	HRRZ	T,UFD
	PUSHJ	P,PRTOCT
	HLRZ	T,UFD+1
	CAIN	T,<SIXBIT/   BAS/>
	JRST	DSKER2
	TLO	T,16
	PUSHJ	P,PRNSIX
DSKER2:	PUSHJ	P,INLMES
	ASCIZ	/ NOT FOUND
/
	OUTPUT 0,
	JRST	BASIC
CLSTU1:	SOSLE	IBF+2
	JRST	CLSTU5
CLSTU2:	INPUT	3,		;FOR ERROR AND EOF CHECK
	STATUS	3,D
	TRNN	D,760000	;ERROR OR EOF?
	JRST	CLSTU5		;NO.
	TRZE	D,20000		;YES, EOF?
	JRST	UXIT		;YES, EOF.
CATERR:	MOVEI	T,INLSYS		;NO, ERROR.
	JRST	ERRMSG
CLSTU5:	ILDB	N,IBF+1
	JUMPE	N,CLSTU2
	MOVEM	N,FILNM
	SOS	IBF+2
	ILDB	X2,IBF+1
	HLLZM	X2,FILNM+1
	PUSHJ	P,CLSTU3	;OUTPUT FILENAME AND EXT.
	JRST	CLSTU1

CLSTU3:	MOVEI	G,6
	MOVE	N,FILNM
	PUSHJ	P,SIXOUT
	JUMPE	G,.+2
	PUSHJ	P,SPACES
	MOVEI	G,4
	MOVE	N,FILNM+1
	JUMPE	N,CLSTU6
	MOVEI	X1,56
	PUSHJ	P,PUT
	SOJ	G,
	PUSHJ	P,SIXOUT
	JUMPE	G,CLSTU4
CLSTU6:	PUSHJ	P,SPACES
CLSTU4:	PUSHJ	P,CLRF
	POPJ	P,
SPACES:	MOVEI	X1,40
	PUSHJ	P,PUT
	SOJG	G,.-1
	POPJ	P,
SIXOUT:	MOVE	L,[POINT 6,0]
SIX02:	ILDB	X1,L
	JUMPE	X1,SIX01
	ADDI	X1,40
	PUSHJ	P,PUT
	SOJ	G,
	TLNN	L,770000
SIX01:	POPJ	P,
	JRST	SIX02
CLRF:	MOVEI	X1,15
	PUSHJ	P,PUT
	MOVEI	X1,12
PUT:	SOSG	OBF+2		;PREPARE OUTPUT
	OUTPUT	2,
	IDPB	X1,OBF+1
	POPJ	P,


;"COPY" HAS THE FORM:
;
;	COPY DEVICE:FILENAME.EXT > DEVICE:FILENAME.EXT
;
;COPER USES THE FILENAME ANALYZER ROUTINE FILNAM AND THE FLAG COPFLG
;WHEN ANALYZING ITS TWO ARGS.  COPER SETS COPFLG TO -1 BEFORE
;CALLING FILNAM AND THEN ENTERS FILNAM AT FILNM1.  ALL OTHER ROUTINES
;THAT USE FILNAM ENTER THROUGH AN ENTRY POINT THAT SETS
;COPFLG TO 0.  COPFLG IS USED BY FILNAM IN THE SPECIAL CASE IN WHICH
;A DEVICE BUT NOT A FILENAME IS SPECIFIED.  WHEN FILNAM IS FINISHED
;PROCESSING THAT SPECIAL CASE, IT SETS COPFLG TO 0.


COPER:	PUSHJ	P,QSA
	ASCIZ	/Y/
	JRST	.+1
	SETOM	COPFLG
	PUSHJ	P,FILNM1	;PROCESS THE FIRST ARG.
	JUMP	IBF+1
	MOVEI	A,">"
	CAIE	A,(C)
	JRST	COMM1
	PUSHJ	P,NXCH
	MOVE	A,COPFLG
	MOVEM	A,CATFLG	;STORE TEMPORARILY IN CATFLG.
	SETZM	IBF		;IBF:	0
	MOVEI	N,TYI		;IBF+1:	DEVICE
	MOVEM	N,IBF+2		;IBF+2:	TYI
	MOVE	N,FILDIR
	MOVEM	N,FILD1		;FILD1:	FILENAME
	MOVE	N,FILDIR+1	;FILD1+1:	EXT,,0
	MOVEM	N,FILD1+1	;FILD1+2:	0
	SETZM	FILD1+2		;FILD1+3:	0
	SETZM	FILD1+3
COPER0:	SETOM	COPFLG		;PROCESS THE SECOND ARG.
	PUSHJ	P,FILNM1
	JUMP	OBF+1
	MOVEI	N,20		;OBF:	20	;USER WORD COUNT IS SET.
	MOVEM	OBF		;OBF+1:	DEVICE
	MOVEI	N,TYO		;OBF+2:	TYO,,0
	HRLZM	N,OBF+2
	MOVE	N,MONLVL	;FILDIR:	FILENAME
	TLNE	N,400000	;FILDIR+1:	EXT,,0
	JRST	COPER1		;FILDIR+2:	0 FOR A 4 SERIES
	MOVE	N,[XWD 12,16]	;		MONITOR, PROTECTION CODE
	CALLI	N,41		;		FOR A 5 SERIES MONITOR.
	JRST	.+3		;FILDIR+3:	0
	IOR	N,MONLVL
	MOVEM	N,FILDIR+2
COPER1:	MOVE	N,IBF+1		;CHECK THE FIRST DEVICE.
	CALLI	N,4
	JUMPN	N,.+3
COPERR:	MOVE	T,IBF+1
	JRST	NOGETD
	TLNE	N,2		;CAN THE DEVICE DO INPUT?
	JRST	.+3		;YES.
	MOVEI	T,NOIN		;NO.
	JRST	ERRMSG
	TLNN	N,4		;IS IT A DIRECTORY DEVICE?
	JRST	.+3		;NO, GO AHEAD.
	SKIPN	CATFLG		;YES.  WAS AN EXPLICIT FILENAME GIVEN?
	JRST	COMM1		;NO--YOU LOSE.
	MOVE	N,OBF+1		;YES, OKAY.  NOW CHECK THE
	CALLI	N,4		;ANALOGOUS THINGS FOR THE
	JUMPN	N,.+3		;OUTPUT DEVICE.
COPERX:	MOVE	T,OBF+1
	JRST	NOGETD
	TLNE	N,1
	JRST	.+3
	MOVEI	T,NOOUT
	JRST	ERRMSG
	TLNN	N,4
	JRST	.+3
	SKIPN	COPFLG
	JRST	COMM1
	OPEN	1,IBF
	JRST	COPERR
	LOOKUP	1,FILD1
	JRST	[MOVE T,IBF+1
		MOVEM T,SAVE1
		MOVE T,FILD1
		MOVEM T,FILDIR
		MOVE T,FILD1+1
		MOVEM T,FILDIR+1
		JRST NOGETF]
	OPEN	2,OBF
	JRST	COPERX
	ENTER	2,FILDIR
	JRST	NOSAVE
	PUSH	P,E		;SET UP THE BUFFERS.
	MOVEI	E,1015		;4 BUFFERS + 1.
	PUSHJ	P,PANIC
	POP	P,E
	MOVE	N,CETXT
	MOVEM	N,JOBFF
	INBUF	1,2
	PUSHJ	P,COPER2	;FOR A DESCRIPTION OF THE FOLLOWING
	JRST	COPER5		;CODE, SEE MEMO #100-365-033-00,
COPER2:	OUT	2,		;SECTION 2.2.1.
	JRST	.+3		;OUTPUT OKAY.
	GETSTS	2,N		;OUTPUT ERROR.
	JRST	OUTERR
	MOVE	N,TYO+2
	IDIVI	N,5
	JUMPE	T,.+2
	ADDI	N,1
	HRRZ	T,TYO
	ADDI	T,1
	MOVEM	N,(T)		;STORE THE WORD COUNT.
	ADD	N,T		;N AND T CONTAIN RESPECTIVELY
	ADDI	T,1		;THE 1ST AND LAST LOCS TO BE FILLED
	EXCH	N,T		;WITH DATA IN THIS OUTPUT AREA.
	POPJ	P,
COPER5:	IN	1,
	JRST	COPER3		;INPUT OKAY.
	GETSTS	1,N		;INPUT ERROR OR EOF.
	TRNE	N,020000
	JRST	COPEND		;EOF
	MOVEI	T,INLSYS	;INPUT ERROR.
	JRST	ERRMSG
COPER3:	HRRZ	T1,TYI
	ADDI	T1,1
	HRRZ	A,(T1)
	JUMPE	A,COPER5	;NO DATA WORDS IN THIS BUFFER.
	ADD	A,T1		;T1 AND A CONTAIN RESPECTIVELY THE 1ST
	ADDI	T1,1		;AND LAST LOCS FROM WHICH DATA CAN BE
COPER6:	MOVE	B,T		;TRANSFERRED IN THIS INPUT AREA.
	SUB	B,N		;B CONTAINS SIZE OF OUTPUT AREA -1.
	MOVE	C,A
	SUB	C,T1		;C CONTAINS SIZE OF INPUT AREA -1.
	CAMG	B,C		;COMPARE OUT SIZE TO IN SIZE.
	JRST	COPER4
	ADD	C,N		;OUT SIZE > IN SIZE.
	HRL	N,T1
	BLT	N,(C)
	MOVEI	N,1(C)		;RESET 1ST LOC TO BE FILLED WORD.
	JRST	COPER5		;GO BACK FOR MORE INPUT.
COPER4:	HRL	N,T1		;OUT SIZE <= IN SIZE.
	BLT	N,(T)
	ADD	T1,B
	ADDI	T1,1		;RESET 1ST LOC TO BE TRANSFERRED WORD.
	PUSHJ	P,COPER2	;OUTPUT.
	CAMG	T1,A		;CAN MORE BE TAKEN FROM THIS IN BUFFER?
	JRST	COPER6		;YES.
	JRST	COPER5		;NO.
COPEND:	OUT	2,		;END OF FILE SEEN.
	JRST	.+3
	GETSTS	2,N
	JRST	OUTERR
	CLOSE	2,		;(OUTPUT DEVICE WILL BE RELEASED
	RELEASE 1,		;VIA "BASIC").
	MOVE	N,MONLVL
	TLNN	N,400000
	JRST	BASIC		;5 SERIES MONITOR.
	JRST	PROCOD		;4 SERIES--PROTECTION CODE MUST BE SET.
;DELETE (DEL) ROUTINE

DELER:	PUSHJ	P,QSA
	ASCIZ	/ETE/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	TLNE	C,F.CR			;DOES DELETE HAVE ANY ARGUMENTS?
	JRST	BADDEL			;NO. DONT ALLOW.
DELIM:	PUSHJ	P,GETNUM
	JRST	COMM1
	MOVEM	N,FRSTLN
	SETOM	PAKFLA		;MARK FACT THAT THERE IS A HOLE.
	TLNN	C,F.CR
	TLNE	C,F.COMA
	JRST	DELIM2
	TLNN	C,F.MINS
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
	JRST	COMM1
DELIM2:	SKIPE	PAKFLG		;CRUNCH CORE?
	PUSHJ	P,SCRER3	;YES.
	MOVEM	N,LASTLN
	PUSH	P,C
	PUSHJ	P,DELL1
	POP	P,C
	TLNN	C,F.COMA
	JRST	DELIM3
	PUSHJ	P,NXCH
	JRST	DELIM
DELIM3:	TLNE	C,F.CR
	JRST	UXIT
	JRST	COMM1
DELL1:	MOVE	A,FLLIN		;FIND FIRST LINE TO DELETE
DELL2:	CAML	A,CELIN
	POPJ	P,		;THERE IS NONE
	HLRZ	N,(A)		;GET LINE NO
	CAMLE	N,LASTLN	;DONE?
	POPJ	P,
	CAMGE	N,FRSTLN
	AOJA	A,DELL2	
	PUSHJ	P,LOCKON
	PUSHJ	P,ERASE
	PUSHJ	P,LOCKOF
	JRST	DELL1		;GO LOOK FOR FIRST LINE AGAIN


;ERROR ROUTINE WHEN CANT FIND FILE
QNTFND: PUSHJ   P,INLMES
        ASCIZ   /
FILE /
        PUSHJ   P,PRNNAM
        PUSHJ   P,INLMES
        ASCIZ   / NOT FOUND/
        OUTPUT 0,
        SETZM   HEDFLG
        POPJ    P,
MARERR: PUSHJ   P,INLMES
        ASCIZ   /
MARGIN OUT OF BOUNDS/
        JRST    COMM1

;HEADING AND NOHEADING COMMANDS

NOHER:  SETOM   %HDFKG
        JRST    UXIT

HEAER:  SETZM   %HDFKG
        JRST    UXIT
;WEAVE COMMAND

WEAER:	PUSHJ	P,QSA
	ASCIZ	/VE/
	JRST	.+1
	PUSHJ	P,FILNAM
	JUMP	WEAV
	OPEN	WEAVI
	JRST	[MOVE T,WEAV
		JRST NOGETD]
	HLLZS	FILDIR+1		;LEVEL D FIX.
	SETZM	FILDIR+2
	LOOKUP	FILDIR
	JRST	[MOVE T,WEAV
		MOVEM T,SAVE1
		JRST NOGETF]
	SKIPE	PAKFLG		;CRUNCH CORE?
	PUSHJ	P,SCRER3	;YES.
GETT2:	SETZM	BADGNN
	INBUF	1


GETT1:	PUSHJ	P,INLINE
	PUSHJ	P,GETDNM
	JRST	[TLNN  C,F.CR
		JRST   BADGET
		JRST   GETT1]
	MOVEM	N,BADGNN		;LAST GOOD LINE WEAVED
	PUSHJ	P,LOCKON
	PUSHJ	P,ERASE
	PUSHJ	P,INSERT
	PUSHJ	P,LOCKOF
	JRST	GETT1

;THIS ROUTINE PICKS UP A LINE NUMBER AND STOPS ON THE FIRST
;NON-DIGIT CHARACTER, INCLUDING SPACES AND TABS.
;IT IS USED BY OLD, WEAVE, AND MAINLP.

GETDNM:	MOVEI	X1,5
	TLNN	C,F.DIG
	POPJ	P,
	MOVEI	N,-60(C)
GETD1:	MOVE	G,T
	PUSHJ	P,NXCHS
	SOJE	X1,CPOPJ1
	TLNN	C,F.DIG
	JRST	CPOPJ1
	IMULI	N,^D10
	ADDI	N,-60(C)
	JRST	GETD1

;LENGTH OF PROGRAM IN CORE.

LENER:	PUSHJ	P,QSA
	ASCIZ	/GTH/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	PUSHJ	P,LOCKON	;ROUTINE TO CALCULATE PROGRAM LENGTH IN CHARS.
	PUSHJ	P,PRESS		;NOTE#### LENGTH DOES NOT INCLUDE
	PUSHJ	P,LOCKOF		;LINE NUMBERS!
	MOVE	T,CETXT
	SUB	T,FLTXT
	IMULI	T,5
	SETZM	HPOS
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ / CHARACTERS
/
	OUTPUT 0,
	JRST	FIXUP



;TTCALL DEFINITION FOR "TAPE" AND "KEY"
OPDEF	TTCALL	[51B8]
;TTY BACK TO KEYBOARD
BIT16=2
KEYER:	SETO	A,
	TTCALL	6,A
	TLZ	A,BIT16
	TTCALL	7,A
	JRST	BASIC
;TTY INTO PAPERTAPE READER
TAPER:	PUSHJ	P,QSA
	ASCIZ	/E/
	JRST	.+1
	SETO	A,
	TTCALL	6,A
	TLO	A,BIT16
	TTCALL	7,A
	JRST	BASIC
;ROUTINE TO LIST FILE

LISER:	PUSHJ	P,QSA
	ASCIZ	/T/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	SETZI	F,		;ASSUME NO HEADING DESIRED.
	PUSHJ	P,QSA
	ASCIZ /NH/
	SETOI	F,		;HEADING IS DESIRED, OR CMD ERROR
        SKIPE   %HDFKG
        SETZI   F,
	SETZM	REVFL
	PUSHJ	P,QSA
	ASCIZ	/REV/
	JRST 	.+2
	SETOM	REVFL
NUMER:	PUSHJ	P,LINLIM	;GET LINE LIMITS OR ERROR
	SKIPE	RETUR1
	PUSHJ	P,NXCH
	JUMPE	F,LISTX		;SKIP HEADING-
	PUSH	P,T
	PUSH	P,C

	PUSHJ	P,INLMES	;NO, PRINT IT.
	ASCIZ /

/
	PUSHJ	P,LIST01		;TYPE THE HEADING
	PUSHJ	P,INLMES		;AND A FEW BLANK LINES
	ASCIZ /



/
	POP	P,C
	POP	P,T
LISTX:	SKIPE	REVFL
	JRST	LIST4
	JRST	LIST1

LIST01:	PUSH	P,T		;SAVE POINTER TO INPUT LINE
	PUSH	P,C		;SAVE CURRENT CHAR.
	HLRZ	T,CURDEV
	CAIN	T,<SIXBIT /   DSK/>	;PRINT DEVICE ONLY IF UNCOMMON.
	JRST	LIST02
	PUSHJ	P,PRNSIX	;PRINT THE DEVICE NAME
	MOVSI	T,320000	;PRINT THE
	PUSHJ	P,PRNSIX	;:.
LIST02:	MOVE	T,CURNAM
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT		;DONT PRINT EXT. UNLESS UNCOMMON
	CAIN	T,<SIXBIT /   BAS/>
	JRST	LIST03
	TLO	T,16		;INSERT SIXBIT "." BEFORE EXT
	PUSHJ	P,PRNSIX
LIST03:	PUSHJ	P,TABOUT	;EXECUTE A FORMAT ","
	CALLI	X1,23
	IDIVI	X1,^D60000IVI	X1,^D60
	MOVEI	A,":"		;THE SEPARATION CHAR BETWEEN FIELDS.
	PUSHJ	P,PRDE2	
	PUSHJ	P,TABOUT		;ANOTHER FORMAT ","
	CALL	X1,[SIXBIT /DATE/]
	IDIVI	X1,^D31
	AOJ	X2,
	MOVE	A,X1
	IDIVI	A,^D12
	AOJ	B,
	ADDI	A,^D64
	MOVE	T,X2
	PUSHJ	P,LIST06
	MOVEI	C,"-"
	PUSHJ	P,OUCH
	MOVEI	T,DATTBL-1(B)
	SETZ	D,
	PUSHJ	P,PRINT
	MOVEI	C,"-"
	PUSHJ	P,OUCH
	MOVE	T,A
	PUSHJ	P,LIST06
	POP	P,C		;RECOVER INPUT CHAR
	POP	P,T		;RECOVER INPUT POINTER
	POPJ	P,
LIST06:	IDIVI	T,^D10
	MOVEI	C,60(T)
	PUSHJ	P,OUCH
	MOVEI	C,60(T1)
	JRST	OUCH


LIST1:	PUSH	P,C
	PUSH	P,T
	SETZM	HPOS
	MOVE	A,FLLIN
LIST2:	CAML	A,CELIN		;READ LINE LIMITS
	JRST	LIST3		;DONE IF NO MORE
	HLRZ	T,(A)		;T := LINE NO
	CAMG	T,LASTLN
	CAMGE	T,FRSTLN	;AFTER FIRST TO PRINT?
	AOJA	A,LIST2		;NO
	PUSHJ	P,PRTNUM	;LINE NUMBER AS A
	JRST	LIST25		;SEQUENCE NUMBER.
	MOVE	T,TYO+2
	JUMPLE	T,LIST22
	IDIVI	T,5
	JUMPE	T1,LIST22
	SETZ	C,		;PAD WITH NULLS SO THAT THE LINE
	PUSHJ	P,OUCH		;NUMBER STARTS IN A NEW WORD.
	SOJG	T1,.-2
LIST22:	HLRZ	T,(A)
	SETZM	NUMCOT
	PUSHJ	P,PRTNUM
	MOVE	T,NUMCOT
	SUBI	T,5
	MOVE	T1,@TYO+1
	JUMPE	T,LIST23
LIST21:	LSH	T1,-7		;PAD WITH LEADING ZEROES (RE-
	TLO	T1,300000	;QUIRED BY THE LINED CUSP).
	IBP	TYO+1
	SOS	TYO+2
	AOJL	T,LIST21
LIST23:	TRO	T1,1		;SET THE "SEQ. NO." BIT.
	MOVEM	T1,@TYO+1
LIST25:	MOVE	T,(A)
	MOVEI	D,15		;QUOTE CHAR
	PUSHJ	P,PRINT
	PUSHJ	P,INLME1
	ASCIZ /
/
	AOJA	A,LIST2
LIST3:	POP	P,T
	POP	P,C
	CLOSE
	SETZI	F,
	SKIPE	RETUR1
	JRST	NUMER
	SETZM	REVFL
	SKIPE	RENSW
	JRST	RENFIL
	JRST	BASIC
LIST4:	PUSH	P,C
	PUSH	P,T
	SETZM	HPOS
	MOVE	A,CELIN
	CAMG	A,FLLIN
	JRST	LIST3
	SOJ	A,
LIST5:	HLRZ	T,(A)
	CAML	T,FRSTLN
	CAMLE	T,LASTLN
	JRST	LIST6
	PUSHJ	P,PRTNUM
	MOVE	T,(A)
	MOVEI	D,15
	PUSHJ	P,PRINT
	PUSHJ	P,INLME1
	ASCIZ	/
/
LIST6:	SOJ	A,
	CAMGE	A,FLLIN
	JRST	LIST3
	JRST	LIST5


TABOUT: PUSH	P,LP		;ROUTINE TO TAB OVER TO
	SETZ	LP,		;ABOUT THE NEXT ZONE, FOR THE HEADING
	MOVE	A,HPOS		;TYPEOUT.
	IDIVI	A,^D14
	JUMPE	B,.+3
	SUBI	B,^D14
	MOVNS	B
	MOVEI	C," "
	PUSHJ	P,OUCH		;AT LEAST ONE SPACE OUT.
	SOJG	B,.-2
	POP	P,LP
	POPJ	P,



DATTBL:	ASCIZ	/JAN/	;TABLE OF MONTHS, USED BY HEADING TYPEOUT.
	ASCIZ	/FEB/
	ASCIZ	/MAR/
	ASCIZ	/APR/
	ASCIZ	/MAY/
	ASCIZ	/JUN/
	ASCIZ	/JUL/
	ASCIZ	/AUG/
	ASCIZ	/SEP/
	ASCIZ	/OCT/
	ASCIZ	/NOV/
	ASCIZ	/DEC/


NEWER:	SETZM	OLDFLA		;FLAG WOULD BE -1 FOR "OLD" REQUEST.
	SKIPE	LOKFLG
	JRST	LKDOUT
	TLNN	C,F.CR
	JRST	NEWOL4
	PUSHJ	P,INLMES
	ASCIZ /NEW /
	JRST	NEWOLD
OLDER:	SETOM	OLDFLA
	SKIPE	LOKFLG

	JRST	LKDOUT
	SKIPN	CHAFLG		;CHAINING?
	JRST	OLDER1		;NO.
	MOVEI	T,DRMBUF
	MOVEM	T,JOBFF
	JRST	NEWOL3
OLDER1:	TLNN	C,F.CR
	JRST	NEWOL4
	PUSHJ	P,INLMES
	ASCIZ /OLD /
NEWOLD:	PUSHJ	P,INLMES
	ASCIZ /FILE NAME--/
	OUTPUT 0,
	PUSHJ	P,INLINE
NEWOL4:	PUSHJ	P,FILNAM
	JUMP	NEWOL1
	TLNN	C,F.CR
	JRST	COMM1
	SKIPN	OLDFLA		;OLDFILE NAME?
	JRST	NEWOL2		;NO. ASSUME NEW NAME IS OK FOR NOW.

NEWOL3:	OPEN	SPEC		;YES
	JRST	[HLRZ T,NEWOL1
		JRST	NOGETD] ;ILLEGAL DEV NAME.  BOMB CURNAM.
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	MOVE	C,NEWOL1
	CALLI	C,4		;CAN THIS DEVICE
	TLNE	C,2		;INPUT?
	JRST	.+3		;YES.
	MOVEI	T,NOIN		;NO.
	JRST	ERRMSG
	LOOKUP	FILDIR		;REALLY AN OLD FILE?
	JRST	[MOVE T,NEWOL1
		MOVEM T,SAVE1
		JRST NOGETF]	;CAN'T FIND FILE.
NEWOL2:	MOVE	C,[XWD	F.CR,15]
	PUSHJ	P,LINL1		;HAVING ACCEPTED THE NAME, DO A "DELETE"
	PUSHJ	P,SCRER1
	PUSHJ	P,NAMOVE	;ACCEPT NEW CURRENT FILNAM
	MOVE	X1,NEWOL1
	MOVEM	X1,CURDEV
	SKIPE	CHAFLG		;CHAINING?
	SETOM	CHAFL2		;YES, SET ERROR MESSAGE FLAG.
	SKIPE	OLDFLA
	JRST	GETT2		;OLD FILE. FINISH BY GETTING IT.
	JRST	BASIC
	;ROUTINE TO CHANGE CURRENT NAME

RENER:	PUSHJ	P,QSA
	ASCIZ	/AME/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	TLNN	C,F.CR		;IS THERE A NAME TO RENAME TO?
	JRST	RENA1		;YES
	PUSHJ	P,INLMES	;PROMPT USER FOR A NAME
	ASCIZ	/FILE NAME--/
	OUTPUT 0,
	PUSHJ	P,INLINE	;THERE BETTER BE A NAME NOW.
RENA1:	SETZM	OLDFLA		;REQUEST FOR NEW FILE
	PUSHJ	P,FILNAM
	JUMP	CURDEV			;SAVE DEVICE IN CURNAM
	TLNN	C,F.CR
	JRST	COMM1
	PUSHJ	P,NAMOVE		;SET CURINFO FROM FILDIR
	JRST	UXIT
				;ROUTINE TO SAVE NEW COPY OR AN OLD FILE
REPER:	PUSHJ	P,QSA
	ASCIZ	/LACE/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	SETOM	OLDFLA
	JRST	SAVER0
;ROUTINE TO RENUMBER THE BASIC PROGRAM THAT IS IN CORE.
;THE COMMAND IS 
;       RESEQUENCE NN,MM,LL
;WHERE NN IS THE FIRST NUMBER AND LL IS THE STEP VALUE.
;IF OMITTED, LL, OR BOTH NUMBERS=10

;ALL LINE NUMBERS LESS THAN MM WILL NOT BE RESEQUENCED. MM MUST NOT
;BE GREATER THAN NN

;A NUMBER IS A LINE NUMBER IF:
;IT IS THE FIRST ATOM ON A LINE.
;	IT FOLLOWS AN ATOM BEGINNING WITH THE LETTERS:
;		"GOS"   OR   "GOT"   OR   "THE"
;ALSO, AFTER THE ATOM "GOTO" HAS BEEN IDENTIFIED, THE NUMBER

;FOLLOWING A COMMA IS A LINE NUMBER.
;REENTRY IS NOT ALLOWED DURING "RESEQUENCE".

RESER:	PUSHJ	P,QSA
	ASCIZ	/EQUENCE/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	SETZM	USGFLG
	PUSHJ	P,LIMITS
	MOVE	N,LASTLN	;GET THE SECOND NUMBER(::=LOWEST)
	HRRZM	N,LOWEST
	MOVEI	N,^D10		;IF FIRST ARG=0, ASSUME FIRST LINE=10
	SKIPN	FRSTLN
	MOVEM	N,FRSTLN
	TLNN	C,F.COMA	;IS THERE A THIRD ARG (THE INCREMENT)?
	JRST	RES1		;NO. LET INCREMENT =^D10
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
	JRST	COMM1

RES1:	SKIPE	PAKFLG		;CRUNCH CORE?
	PUSHJ	P,SCRER3	;YES.
	MOVEM	N,LASTLN	;SAVE INCREMENT
SEQ1:	HRLZ	A,LOWEST	;SEARCH FOR FIRST LINE TO CHANGE
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	JFCL
	CAMN	B,FLLIN		;RESEQ ALL LINES?
	JRST	SEQ0			;YES.
	HLRZ	N,-1(B)			;NO. MAKE SURE LINE ORDER WILL NOT CHANGE
	CAMGE	N,FRSTLN
	JRST	SEQ0
	MOVEI	T,RESERR
	JRST	ERRMSG
SEQ0:	MOVN	X2,B
	ADD	X2,CELIN	;THIS IS THE NUMBER OF LINES TO RESEQ
	SUBI	X2,1
	IMUL	X2,LASTLN
	ADD	X2,FRSTLN
	CAILE	X2,^D99999
	JRST	SEQOV
	PUSHJ	P,LOCKON	;DONT ALLOW REENTRY.
	MOVE	E,CELIN	;COMPUTE NUMBER OF LINES
	SUB	E,B
	JUMPE	E,UXIT	;NOTHING TO RENUMBER
	MOVN	L,E
	MOVSI	L,(L)
	SUB	B,FLLIN
	MOVEM	B,LOWSTA
	HRR	L,B
	PUSH	P,L		;SAVE L FOR SECOND LOOP.
	HRL	B,B		
	SUB	L,B

;THE LOOP THAT COPIES EACH LINE FOLLOWS:
SEQ2:	MOVE	D,[POINT 7,LINB0]	;BUILD EACH LINE IN LINB0. THEN REINSERT IT.
	MOVEM	D,SEQPNT
	HRRZ	F,L
	ADD	F,FLLIN
	HRRZ	T,(F)
	HRLI	T,440700	;POINTER TO OLD LINE IS IN G
				;F USED AS A FLAG REGISTER FOR " ' ETC.
;THE FLAGS ARE
			REST.F=1	;COPY  THE REST (APOST SEEN)
			TOQU.F=2	;COPY TO QUOTE SIGN
			COMM.F=4	;LINE NUMBER FOLLOWS ANY COMMA
			NUM.F=10	;NEXT NUMBER IS LINE NUMBER
;THE CHARACTER/ATOM LOOP:
SEQ3:	PUSHJ	P,NXCHD		;GET NEXT CHAR, EVEN IF SPACE OR TAB
	TLNE	C,F.CR
	JRST	SEQCR
	TLNE	C,F.QUOT		;TEST FOR QUOTE CHAR
	TLCA	F,TOQU.F		;REVERSE QUOTE SWITCH AND COPY THIS CHAR
	TLNE	F,TOQU.F
	JRST	SEQ5
	JRST	SEQ52
SEQ5:	SKIPN	USGFLG
	JRST	SEQCPY
	TLZ	F,NUM.F
	SETZM	USGFLG
	JRST	SEQCPY
SEQ52:	TLNE	C,F.APOS
	TLOA	F,REST.F		;APOST SEEN, COPY REST
	TLNE	F,REST.F
	JRST	SEQ5
	MOVE	G,T			;SAVE POINTER
	TLNN	F,NUM.F		;EXPECTING A LINE NUMBER?
	JRST	SEQ4			;NO. LOOK FOR KEYW ATOMS
	TLNE	C,F.DIG
	JRST	SEQ7
	SKIPN	USGFLG
	JRST	SEQ5
	CAMN	C,[1000000043]
	JRST	SEQ8
	TLNE	C,F.SPTB
	JRST	SEQCPY
	TLZ	F,NUM.F
	JRST	SEQ5
SEQ8:	IDPB	C,SEQPNT
	PUSHJ	P,NXCHD
	TLNE	C,F.CR
	JRST	SEQCR
	TLNE	C,F.SPTB
	JRST	SEQ8
	TLNE	C,F.DIG
	JRST	SEQ9
	TLZ	F,NUM.F
	JRST	SEQ5
SEQ9:	IDPB	C,SEQPNT
	PUSHJ	P,NXCHD
	TLNE	C,F.CR
	JRST	SEQCR
	TLNE	C,F.SPTB
	JRST	SEQ9
	CAIE	C,":"
	TLNE	C,F.COMA
	JRST	.+2
	JRST	SEQ5
SEQ10:	IDPB	C,SEQPNT
	PUSHJ	P,NXCHD
	TLNE	C,F.SPTB
	JRST	SEQ10
	TLNN	C,F.DIG
	JRST	SEQ5
SEQ7:	SKIPN	USGFLG
	JRST	SEQNUM
	PUSH	P,G
	PUSH	P,C
	PUSH	P,T
	PUSHJ	P,GETNUM
	JUMP
	TLZ	F,NUM.F
	TLNN	C,F.COMA
	CAMN	C,[1000000043]
	JRST	SEQ51
	POP	P,T
	POP	P,C
	JRST	SEQ4
SEQ51:	POP	P,A
	POP	P,A
	SETZM	USGFLG
	JRST	SEQ6
SEQ4:	SETZM	USGFLG
	TLNE	F,COMM.F
	TLNN	C,F.COMA
	JRST	.+3
	TLO	F,NUM.F		;THIS COMMA IMPLIES NUMBER TO FOLLOW
	JRST	SEQCPY
	PUSHJ	P,ALPHSX		;PUT NEXT ALL-LETTER ATOM IN A
	MOVEI	B,SEQTND-SEQTBL	;SET INDEX FOR TABLE OF KEYWORDS PRECEDING LINE NUMBERS
	MOVE	T,G			;RESET CHAR POINTER TO START OF ATOM.
	CAMN	A,SEQTBL(B)
	TLOA	F,NUM.F+COMM.F		;WE FOUND A KEYWORD
	SOJGE	B,.-2
	CAME	A,[SIXBIT /USING/]
	JRST	SEQCP1
	TLO	F,NUM.F
	SETOM	USGFLG
	LDB	C,T
	IDPB	C,SEQPNT
	MOVEI	A,4
	PUSHJ	P,NXCHS
	IDPB	C,SEQPNT
	SOJG	A,.-2
	JRST	SEQ3
SEQCP1:	LDB	C,T
SEQCPY:	IDPB	C,SEQPNT
	JRST	SEQ3

SEQTBL:	SIXBIT /GOSUB/		;TABLE OF KEYWORDS PRECEDINGLINE NUMBERS
	SIXBIT /GOTO/
SEQTND:	SIXBIT /THEN/

SEQNUM:	PUSH	P,G		;SAVE POINTER IN CASE OF "GLOBAL" LINE NUMBER
	PUSHJ	P,GETNUM
	HALT	.
SEQ6:	CAMGE	N,LOWEST
	JRST	SEQB1		;DONT RESEQ THIS NUMBER
	MOVEI	R,LINROL
	HRLZ	A,N
	PUSHJ	P,SEARCH
	JRST	SEQBAD
SEQCAL:	SUB	B,FLLIN
	SUB	B,LOWSTA
	IMUL	B,LASTLN
	ADD	B,FRSTLN		;THIS IS THE NEW LINE NUMBER
	MOVE	X1,B
	PUSHJ	P,MAKNUM		;DEPOSIT THE NUMBER IN LINB0
	POP	P,X1			;CLEAR PLIST A LITTLE
SEQCA1:	TLZ	F,NUM.F
	LDB	C,T
	PUSHJ	P,NXCHS+1
	JRST	SEQ3+1
SEQBAD:	PUSH	P,N
	PUSHJ	P,INLMES	;PRINT ? FOR BATCH.
	ASCIZ	/
UNDEFINED LINE NUMBER /
	POP	P,T		;PRINT "GLOBAL" LINE NUMBER
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ / IN LINE /
	HLRZ	T,(F)
	PUSHJ	P,PRTNUM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	OUTPUT 0,
;IN A ROLL, AND THEN PRINTED AT THE END, WITH REENTRY ALLOWED.
SEQB1:	POP	P,T			;POINT TO BAD NUMBER.
	LDB	C,T
	TLZ	F,NUM.F
	JRST	SEQCPY			;COPY IT
SEQCR:	SETZM	USGFLG
	IDPB	C,SEQPNT
	HLRZ	N,(F)
	PUSHJ	P,ERASE		;ERASE OLD LINE COPY
	MOVE	T1,SEQPNT		;POINT TO END OF LINE FOR NEWLIN
	PUSHJ	P,NEWLIN		;INSERT NEW ONE WITH OLD LINE NUMBER.
	AOBJN	L,SEQ2			;DO NEXT LINE
	POP	P,L
	ADD	L,FLLIN
	MOVE	N,FRSTLN
	HRLM	N,(L)
	ADD	N,LASTLN
	AOBJN	L,.-2
	JRST	UXIT			;FINISHED. ALLOW REENTRY.
SEQOV:	PUSHJ	P,INLMES
	ASCIZ /
COMMAND ERROR (LINE NUMBERS MAY NOT EXCEED 99999)
/
	JRST	FIXUP
;ROUTINE TO SAVE PROGRAM

SAVER:	PUSHJ	P,QSA
	ASCIZ	/E/
	JRST 	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	SETZM	OLDFLA		;SAVE "NEW" FILE ONLY
SAVFIL:
SAVER0:	PUSHJ	P,FILNAM
	JUMP	SAVE1
	TLNN	C,F.CR
	JRST	COMM1
	PUSHJ	P,LIMITS
	MOVE	A,SAVE1		;CAN THE DEVICE
	CALLI	A,4		;BE
	TLNE	A,1		;OUTPUT TO?
	JRST	.+3		;YES.
	MOVEI	T,NOOUT
	JRST	ERRMSG
	OPEN	SAVI
	JRST	[MOVE T,SAVE1	 ;ILLEGAL DEVICE NAME
		JRST NOGETD]
	PUSHJ	P,LOCKON	;DONT ALLOW REENTRY UNTIL
				;SAVE IS CHANGED TO BUILD TEMP FILE AND RENAME.
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	SKIPE	OLDFLA		;TRYING TO SAVE NEW FILE?
	JRST	SAVE3
	TLNN	A,4		;YES, DOES THE DEVICE HAVE A DIR?
	JRST	SAVE2		;NO.
	LOOKUP	FILDIR		;YES, DOES THE FILE EXIST?
	JRST	SAVE2		;NO, GOOD
	MOVEI	T,NOTNEW
	JRST	ERRMSG
SAVE3:	LOOKUP	FILDIR		;IS THIS REALLY AN OLDFILE?
	JRST	NOGETF		;NO. GRONK.
SAVE2:	CLOSE			;OTHERWISE REPLACE WILL APPEND.
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	ENTER	FILDIR
	JRST	NOSAVE
	OUTBUF	1
	SETOM	RENSW
	JRST	LIST1

RENFIL:	SETZM	RENSW
	MOVE	A,SAVE1		;IF THE DEVICE IS A DECTAPE,
	CALL	A,[SIXBIT/DEVCHR/] ;THE RENAME WILL FAIL AND IS UN-
	TLNE	A,100		;NECESSARY ANYWAY, SO RETURN IMMEDIATELY.
	JRST	BASIC		
	OPEN	SAVI		;THIS STRANGE PROCEDURE IS
	JRST	[MOVE T,SAVE1	;FOLLOWED BECAUSE THE
		JRST NOGETD]	;GETTAB UUO ENTRY
;** FIX BY GMG 17/1 SO FILE USES STANDARD PROTECTION
;   (DEC WITH FONEY IDEA ABOUT PROTECTION--SAVED 25 LINES CODE)
PROCOD:	JRST	BASIC		;HOWS THAT FOR PROTECTION DEC!
;ROUTINE TO CLEAR TXTROL.

SCRER:	PUSHJ	P,QSA
	ASCIZ	/ATCH/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	PUSH	P,[EXP UXIT]
SCRER1:	SKIPN	SWAPSS		;ENTRY POINT FOR NEW, OLD, AND SCRATCH
	JRST	SCRER2		;TO CRUNCH CORE FOR A SWAPPING SYSTEM.
	MOVE	X1,JOBREL
	CAILE	X1,377777
	JRST	SCRER2		;DON'T CRUNCH--ERRORS WILL RESULT.
	MOVE	X1,SJOBRL
	CORE	X1,
	JRST	.+1
	MOVE	X1,SJOBSA
	MOVEM	X1,FLTXT	;WIPE OUT LINROL AND TXTROL.
	MOVEM	X1,CETXT
	MOVE	X1,JOBREL
	MOVEM	X1,FLLIN
	MOVEM	X1,CELIN
	SETZM	PAKFLG
	POPJ	P,
SCRER2:	MOVE	X1,FLTXT	;WIPE OUT LINROL AND TXTROL.
	MOVEM	X1,CETXT
	MOVE	X1,FLLIN
	MOVEM	X1,CELIN
	POPJ	P,

SCRER3:	PUSH	P,X1		;ENTRY POINT FOR EDITS TO CRUNCH CORE
	MOVE	X1,JOBREL	;THEY ONLY GET HERE FOR SWAPPING SYSTEMS.
	CAILE	X1,377777
	JRST	SCRER5		;DON'T CRUNCH--ERRORS WILL RESULT.
	MOVE	X1,CELIN	;SAVE LINROL AND TXTROL.
	CAMG	X1,SJOBRL	;CELIN > ORIGINAL JOBREL?
	SKIPA	X1,SJOBRL
	ADDI	X1,2000		;ALLOW SOME EXTRA SPACE.
	CAML	X1,JOBREL
	JRST	SCRER5
SCRER4:	CORE	X1,
	JRST	.+1
SCRER5:	SETZM	PAKFLG
	POP	P,X1
	POPJ	P,

;ROUTINE TO RETURN TO THE SYSTEM.

SYSER:	PUSHJ	P,QSA
	ASCIZ	/TEM/
	JRST	.+1
	CALLI	12

;ROUTINE TO UNSAVE FILES "UNS" OR "UNSAVE"

UNSER:	PUSHJ	P,QSA
	ASCIZ	/AVE/
	JRST	.+1
	SKIPE	LOKFLG
	JRST	LKDOUT
	SETZM	HEDFLG		;PRINT HEADING WHEN HEDFLG =0.
UNS3:	TLNN	C,F.CR
	JRST	UNS1
	PUSHJ	P,FILNAM	;DSK:CURFIL.CUREXT.
UNSVFL:	JUMP	SAVE1
	PUSHJ	P,UNSER1
	JRST	BASIC

UNS1:	TLNN	C,F.COMA
	JRST	UNS2
	PUSHJ	P,FILNAM	;DSK:CURFIL.CUREXT.
	JUMP	SAVE1
	PUSHJ	P,UNSER1
	JRST	UNS6
UNS2:	PUSHJ	P,FILNAM	;MORE OR LESS REAL FILENAME.
	JUMP	SAVE1
	TLNE	C,F.CR		;CHECK LEGAL FORM BEFORE DOING ANYTHING.
	JRST	.+3
	TLNN	C,F.COMA
	JRST	COMM1
	MOVE	A,SAVE1
	DEVCHR	A,		;DEVICE MUST BE DISK OR DECTAPE.
	TLNN	A,200100
	JRST	UNS4		;FAIL.
	PUSHJ	P,UNSER1
UNS5:	TLNE	C,F.CR
	JRST	BASIC
	TLNN	C,F.COMA
	JRST	COMM1
UNS6:	PUSHJ	P,NXCH
	JRST	UNS3
UNS4:	PUSHJ	P,INLMES
	ASCIZ	/
UNSAVE DEVICE MUST BE DISK OR DECTAPE, FILE /
	PUSHJ	P,PRNNAM
	OUTPUT 0,
	SETZM	HEDFLG
	JRST	UNS5

UNSATP:

UNSER1:	OPEN	SAVI
	JRST	UNER1
	HLLZS	FILDIR+1	;LEVEL D FIX.
	SETZM	FILDIR+2
	LOOKUP	FILDIR		;LOOKUP THE FILENAME
	JRST	UNER2
	CLOSE
	MOVE	A,FILDIR
	SETZM	FILDIR
	RENAME	FILDIR		;ZERO DIRECTORY ENTRY
	JRST	UNER3
	SKIPE	HEDFLG
	JRST	UNSR12
	PUSHJ	P,INLMES
	ASCIZ	/

FILES UNSAVED:
/
	OUTPUT 0,
	SETOM	HEDFLG
UNSR12:	PUSHJ	P,TTYIN
	MOVEM	A,FILDIR
	PUSHJ	P,PRNNAM
	PUSHJ	P,INLMES
	ASCIZ	/
/
	OUTPUT 0,
	POPJ	P,


UNER1:	PUSHJ	P,INLMES	;ERROR MESSAGES.
	ASCIZ	/
NO SUCH DEVICE /
	PUSHJ	P,PRNNAM
UNEROU:	OUTPUT 0,
	SETZM	HEDFLG
	POPJ	P,
UNER2:	PUSHJ	P,QNTFND
	JRST	UNEROU
UNER3:	PUSHJ	P,INLMES
	ASCIZ	/
FILE /
	MOVEM	A,FILDIR
	PUSHJ	P,PRNNAM
	PUSHJ	P,INLMES
	ASCIZ	/ COULD NOT BE UNSAVED/
	JRST	UNEROU
SUBTTL	COMMAND SUBROUTINES

;ROUTINE TO PICK UP FILE NAME AND SET UP FOR DSK ACTION.
;THE FLAG COPFLG IS EXPLAINED AT THE COPY ROUTINE COPER.

FILNAM:	SETZM	COPFLG
FILNM1:	POP	P,B		;COPER ENTERS HERE, WITH COPFLG = -1.
	MOVEI	A,<SIXBIT /   DSK/>
	HRLI	A,<SIXBIT /   BAS/>
	HRLZM	A,@(B)
	HLLZM	A,FILDIR+1
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	MOVEI	X2,FILDIR

;CHECK FOR A LUSER NAME AND IF IT IS THERE THEN
;SET UP THE LUSER NAME BUFFER
	MOVEI	X1,"("		;BEG. OF USERNAME SPEC
	CAIE	X1,(C)		;DOES IT MATCH LAST CHAR?
	JRST	FILNU		;NO-NOT USERNAME
;GOT A USER NAME - SET UP BUFFER
	HRRZI	X1,FILUSN	;USER NAME BUFFER
	MOVEM	X1,FILDIR+3	;POINTER IS:  0,,BUFFER
	MOVEI	X1,-12		;12 CHARS
	MOVE	N,[POINT 6,FILUSN]
	SETZM	FILUSN
	SETZM	FILUSN+1	;RESET THE USERNAME BUFFER
FILRNN:	PUSHJ	P,NXCH		;GET NEXT CHARACTER
	TLNE	C,F.TERM	;TERMIMNATED?
        JRST    [PUSHJ P,INLMES
                ASCIZ /
ILLEGAL USER NAME GIVEN/
                JRST COMM1]
	MOVEI	D,")"		;CLOSING OF SPEC?
	CAIN	D,(C)
	JRST	FILENU		;YES--FINISH UP
	AOJL	X1,FILRNN	;IGNORE PAST 12TH CHAR
	SUBI	C,40		;CONVERT TO 6-BIT
	IDPB	C,N		;SAVE CHAR IN BUFFER
	JRST	FILRNN		;ALL DONE
;END OF USER NAME SPEC
FILENU:	PUSHJ	P,NXCH		;NEXT CHARACTER FOR ATOM FINDER
FILNU:	PUSHJ	P,ATOMSZ
FILN7:	MOVEI	X1,":"		;DEVICE INDICATOR.
	CAIE	X1,(C)
	JRST	FILN1
	JUMPE	A,[PUSHJ P,INLMES
                ASCIZ /
ILLEGAL DEVICE NAME GIVEN/
                JRST COMM1]
	MOVEM	A,@(B)		
	PUSHJ	P,NXCH
	PUSHJ	P,ATOMSZ
	SKIPL	COPFLG
	JRST	FILN1
	JUMPN	A,FILN1
FILN8:	SETZM	COPFLG
	JRST	1(B)
FILNMO:	POP	P,B		;ENTRY POINT FOR NO DEVICE ALLOWED.
	MOVEI	A,<SIXBIT/   DSK/>
	HRLZM	A,@(B)
	SETZM	COPFLG
	HRRI	A,<SIXBIT /   BAS/>
	HRLZM	A,FILDIR+1
	MOVEI	X2,FILDIR
	PUSHJ	P,ATOMSZ
FILN1:	TLNN	C,F.PER		;PERIOD SEEN?
	JRST	FILN2
	JUMPE	A,[PUSHJ P,INLMES
                ASCIZ /
FILE CANNOT HAVE NULL NAME/
                JRST COMM1]
	MOVEM	A,FILDIR
	MOVEI	X2,FILDIR+1
	PUSHJ	P,NXCH
	PUSHJ	P,ATOMSZ
FILN2:	JUMPN	A,FILN3
	CAIE	X2,FILDIR
	JRST	FILN3
	HRRZ	A,B
	CAIN	A,SAVFIL+1	;ONLY SAVE AND UNSAVE CAN OMIT THE FILENAME.
	JRST	FILN9
	CAIGE	A,UNSER
	CAILE	A,UNSATP
	JRST	.+2
        JRST    [PUSHJ P,INLMES
                ASCIZ /
ONLY SAVE AND UNSAVE CAN OMIT THE FILE NAME/
                JRST COMM1]
FILN9:	SKIPN	A,CURNAM
        JRST    [PUSHJ P,INLMES
                ASCIZ /
NO CURRENT FILE NAME/
                JRST COMM1]
	MOVEM	A,FILDIR
	HLLZ	A,CUREXT
	MOVEM	A,FILDIR+1
	JRST	FILN5
FILN3:	CAIN	X2,FILDIR
	JRST	FILN4
FILN6:	TRNE	A,777777	;ONLY 3 CHARACTERS ALLOWED
        JRST    [PUSHJ P,INLMES
                ASCIZ /
ONLY 3 CHARACTERS ALLOWED IN EXTENSION/
                JRST COMM1]
FILN4:	MOVEM	A,(X2)
FILN5:	MOVEI	A,DRMBUF
	MOVEM	A,JOBFF
	JRST	1(B)

COMM2:  PUSHJ   P,INLMES
        ASCIZ   /
ILLEGAL FILE NAME GIVEN/
	JRST	COMM1		;YES.


;ROUTINE TO CONVERT NEXT ATOM TO SIXBIT

ATOMSZ:	HRLZI	D,F.LETT+F.DIG	;IT HAS SEVERAL
	JRST	ATOMS2		;ENTRY POINTS.
ALPHSX:	SKIPA	D,[Z (F.LETT)]
ATOMSX:	HRLZI	D,F.DIG+F.LETT	
ATOMS2:	TLZ	B,777777	;SET LH OF A+1 TO 0
	MOVEI	A,0
	MOVE	X1,[POINT 6,A]
ATOMS1:	TDNN	C,D
	POPJ	P,
	PUSHJ	P,SCNLTN	;PACK THIS LETTER INTO A.
	JFCL			;SCNLTN HAS SKIP RETURN.
	TLNE	X1,770000
	JRST	ATOMS1
	POPJ	P,

NAMOVE:	MOVE	X1,FILDIR
	MOVEM	X1,CURNAM
	MOVE	X1,FILDIR+1
	MOVEM	X1,CUREXT
	POPJ	P,

;ROUTINES TO SET LINE LIMITS
LIMITS:	TLNE	C,F.CR
	JRST	LIMIT1
	PUSHJ	P,GETNUM
LIMIT1:	MOVEI	N,0
	MOVEM	N,FRSTLN
	TLNE	C,F.CR
	JRST	LIMIT2
	TLNN	C,F.COMA
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
LIMIT2:	MOVSI	N,1
	MOVEM	N,LASTLN
	POPJ	P,
LINLIM:	SETZM	RETUR1
	SKIPN	REVFL
	TLNE	C,F.CR
	JRST	LINL3
	PUSHJ	P,GETNUM
LINL1:	MOVEI	N,0
	MOVEM	N,FRSTLN
	TLNN	C,F.CR
	JRST	LINL4
LINL6:	MOVEM	N,LASTLN
	POPJ	P,
LINL4:	TLNN	C,F.COMA
	JRST	LINL5
	SETOM	RETUR1
	JRST	LINL6
LINL5:	TLNN	C,F.MINS
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,GETNUM
LINL2:	MOVSI	N,1
	MOVEM	N,LASTLN
RETRN:	HRRZ	C,C
	CAIN	C,54
	SETOM	RETUR1
	POPJ	P,
LINL3:	SETZM	FRSTLN
	MOVSI	N,1
	MOVEM	N,LASTLN
	POPJ	P,

;A NONPRINTING ROUTINE SIMILAR TO PRTNUM:

MAKNUZ: SETZM @SEQPNT ;CLEAR JUNK BEFORE LINE NO CALC
MAKNUM:	IDIVI	X1,^D10
	JUMPE	X1,MAKN1
	PUSH	P,X2
	PUSHJ	P,MAKNUM
	POP	P,X2
MAKN1:	MOVEI	X2,60(X2)
	IDPB	X2,SEQPNT
	POPJ	P,
;ROUTINE TO ERASE LINE.  LINE NO IN N.

ERASE:	HRLZ	A,N		;LOOK FOR LINE
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	POPJ	P,		;NONE.  GO TO INSERTION

	MOVE	D,(B)		;PICK UP LOC OF LINE
	HRLI	D,440700	;MAKE BYTE POINTER
	MOVEI	T1,0		;TO USE IN DEPOSITING
ERAS1:	ILDB	C,D		;GET CHAR
	DPB	T1,D		;CLOBBER IT
	CAIE	C,15		;CARRIAGE RET?
	JRST	ERAS1		;NO.  GO FOR MORE

	SETOM	PAKFLA		;MARK FACT THAT THERE IS A HOLE

	MOVEI	E,1		;REMOVE ENTRY FROM LINE TABLE
	JRST	CLOSUP

;HERE WE HAVE A LINE OF INPUT AND THERE IS NO EXISTING LINE

INSERT:	MOVE	T1,[POINT 7,LINB0]
	MOVE	T,G		;RESTORE PNTR TO 1ST CHR
INSE2:	ILDB	C,T		;GET NEXT CHAR
INSE3:	CAIN	C,15		;CHECK FOR CAR RET
	JRST	INSE4
	IDPB	C,T1
	JRST	INSE2

INSE4:	JUMPL	T1,CPOPJ	;CR SEEN.  DONE IF JUST DELETION
	IDPB	C,T1		;STORE THE CR
	MOVEI	C,0		;CLEAR REST OF WORD
	TLNE	T1,760000
	JRST	.-3
	JRST	NEWLIN

;AT THIS POINT, N CONTAINS A LINE NUMBER AND LINB0 CONTAINS
;A NON-EMPTY INSERTED LINE.  T1 CONTAINS ADDRESS OF LAST
;WORD OF THE LINE.

NEWLIN:	MOVEI	T1,(T1)		;COMPUTE LINE LENGTH
	SUBI	T1,LINB0-1

	ADD	T1,CETXT	;COMPUTE NEW CEILING OF TEXT ROLL
	CAMGE	T1,FLLIN	;ROOM FOR LINE PLUS LINROL ENTRY?
	JRST	NEWL1		;YES
NEWL0:	SUB	T1,CETXT	;ASK FOR MORE CORE
	MOVE	E,T1
	ADDI	E,1
	PUSHJ	P,PANIC
	ADD	T1,CETXT

NEWL1:	MOVE	D,CETXT	;LOC OF NEW LINE
	MOVE	T,D		;CONSTRUCT BLT PNTR
	HRLI	T,LINB0
	BLT	T,-1(T1)	;MOVE THE LINE
	MOVEM	T1,CETXT	;STORE NEW CEILING


;HERE, LINE IS IN PLACE, ITS LOC IN D, LINE NUMBER IN N.
;MUST STILL PUT LINE NUMBER IN LINROL.

NEWNBR:	PUSH	P,D		;*****JUST IN CASE*****
	MOVEI	R,LINROL
	HRLZ	A,N
	PUSHJ	P,SEARCH
	JRST	.+2
	HALT	.		;*****IMPOSSIBLE CONDITION*****

	MOVEI	E,1
	PUSHJ	P,OPENUP	;MAKE ROOM FOR IT
	POP	P,D		;*****OTHER HALF OF JUST IN CASE*****
	HRRI	A,(D)		;CONSTRUCT LINROL ENTRY
	MOVEM	A,(B)		;STORE ENTRY
	POPJ	P,		;ALL DONE

SUBTTL ERROR MESSAGES

;ERROR MESSAGE ROUTINE.
;
;AC T ENTERS WITH THE LOC OF THE MESSAGE.
;ALL OTHER AC'S, EXCEPT P, CAN BE DESTROYED.

ERRMSG:	SETZM	ODF
	SETZM	HPOS
	PUSHJ	P,TTYIN
	SETZ	D,		;END ON NULL.
	PUSHJ	P,PRINT		;PRINT MESSAGE.
	SKIPE	CHAFL2		;CHAINING?
	JRST	.+3
	OUTPUT 0,			;NO.
	JRST	UXIT
ERRMS2:	PUSH	P,[Z UXIT]	;YES, ADD DEV, FILENM, ETC.
ERRMS3:	PUSHJ	P,INLMES
	ASCIZ	/ IN /
	PUSH	P,ODF
	SETZM	ODF
	HLRZ	T,CURDEV
	CAIN	T,<SIXBIT/   DSK/>
	JRST	ERRMS4
	MOVE	T,CURDEV	;DEV MAY BE > 3 LETTERS.
	PUSHJ	P,PRNSIX
	MOVEI	T,32
	PUSHJ	P,PRNSIX
ERRMS4:	MOVE	T,CURNAM
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	POP	P,ODF
	OUTPUT 0,
	SETZM	HPOS
	POPJ	P,

NOOUT:	ASCIZ	/
CANNOT OUTPUT TO THIS DEVICE/
NOIN:	ASCIZ	/
ANNOT INPUT FROM THIS DEVICE/
COMM1:	PUSHJ	P,INLMES
	ASCIZ /
WHAT?
/
COMM1A:	SKIPE	CURNAM		;HAS A NEW OR OLD FILE BEEN SPECIFIED YET?
	JRST	FIXUP		;YES, SAY "READY"
	JRST	ASKNEW		;NO, ASK "NEW OR OLD"

BADDEL:	PUSHJ	P,INLMES	;DELETE COMMAND HAD NO ARGUMENTS.
	ASCIZ /
DELETE COMMAND MUST SPECIFY WHICH LINES TO DELETE
/
	JRST	COMM1A

NOSAVE:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	"
CANNOT OUTPUT "
	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	OUTPUT 0,
	SETZM	HPOS
	JRST	BASIC

CATFAL:	ASCIZ	/
CATALOG DEVICE MUST BE DISK OR DECTAPE
/

NOTIMP: ASCIZ   /
NOT A DISK SYSTEM.. TYPE KJOB AT MONITOR LEVEL/

INERR1: ASCIZ   /
LINE TOO LONG/

NOGETF:	PUSHJ	P,QNTFND
	JRST	BASIC

TTYIN:	PUSH	P,T
	MOVEI	T,TTYBUF	;SET UP TTY BUFFS
	MOVEM	T,JOBFF
	INIT 0 ,	1
	SIXBIT	/TTY/
	XWD	TYO,TYI
	HALT	.-3
	INBUF 0 ,	1
	OUTBUF 0 ,	1
	POP	P,T
	POPJ	P,

BADGET:	MOVEI	T,BADMSG
	MOVE	X1,[POINT 7,BADGNN]
	MOVEM	X1,SEQPNT
	MOVE	X1,BADGNN		;LAST GOOD LINE NUMBER.
	TLNN	X1,-1		;HAS IT BEEN CHANGED ALREADY?
	PUSHJ P,MAKNUZ  ;NO, MAKE THE NUMBER
	CALL	T,[SIXBIT /DDTOUT/ ]
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3
	MOVEI	T,CRLFMS
	CALL	T,[SIXBIT /DDTOUT/]
	JRST	GETT1


NOGETD:	SETZM	ODF
	PUSH	P,T
	PUSHJ	P,INLMES
	ASCIZ	/
NO SUCH DEVICE /
	POP	P,T
	PUSHJ	P,PRNSIX
	OUTPUT 0,
	JRST	UXIT

NOTNEW:	ASCIZ /
DUPLICATE FILE NAME, USE REPLACE OR RENAME COMMAND/

RESERR:	ASCIZ	/
ILLEGAL RESEQUENCE: YOU CANNOT OVERWRITE LINES OR CHANGE THEIR ORDER
/


OUTERR:	MOVEI	T,INLSYS	;OUTERR EXPECTS THE STATUS BITS IN N.
	TRNE	N,040000
	MOVEI	T,OUTQMS
	TRNE	N,400000
	MOVEI	T,OUTLMS
	JRST	ERRMSG
OUTLMS:	ASCIZ	/
DEVICE IS WRITE LOCKED/
OUTQMS:	ASCIZ	/
QUOTA EXCEEDED OR BLOCK NO. TOO LARGE ON OUTPUT DEVICE/
SUBTTL COMPILER MAIN LOOP

;BEGINNING OF COMPILATION

RUNER:	SETOM	COMTIM
	MOVEI	A,0
        PUSHJ P,QSA             ;IS IT RUNNH
	ASCIZ /NH/
	MOVEI	A,1		;NO, PRINT HEADING
        SKIPE   %HDFKG
        MOVEI   A,0
	SETOM	RUNLIN
	TLNE	C,F.CR		;IS THERE A LINE NUMBER ARGUMENT?
	JRST	RUNER3		;NO, LEAVE RUNLIN SET TO -1.
	PUSHJ	P,GETDNM
	JRST	COMM1
	TLNN	C,F.CR
	JRST	COMM1
	MOVEM	N,RUNLIN	;YES, STORE THE LINE NUMBER IN RUNLIN.
RUNER3:	JUMPE	A,RUNNH		;SHALL WE PRINT THE HEADING?
	PUSHJ	P,INLMES	
	ASCIZ	/
/
	PUSHJ	P,LIST01	;PRINT HEADING SANS <RETURN>
RUNNH:  OUTPUT 0,
	PUSHJ	P,INLMES
	BYTE (7) 15,12,12	;SKIP TWO LINES
        MOVE    N,[2,,%RUNNH]          ;BASCOM ENTER AT COMENT
        JRST    %LINKUP                 ;AND GO TO IT
;END OF COMPILE/EXECUTE PHASE





;END OF COMPILE/EXECUTE PHASE

	EXTERN	UXFLAG
EXTERN	CLOSED,RENAMD


REUXIT:	SETZM	MTIME
UXIT:	SETZM	CHAFL2
	SETZM	CHAFLG		;ZERO CHAIN FLAG UNLESS WE ARE
CHAXIT:	SETZM	FUNAME		;REALLY CHAINING.
	SETZM	COMTIM
	SETZM	HPOS
	MOVE	P,PLIST
	SETZM	NUMCOT
	SETZB	LP,IFIFG
	SKIPN	UXFLAG		;END OF PROG EXECUTION?
	JRST	UXIT5		;NO.
	SETOM	ODF
	MOVEI	LP,^D9
UXIT3:	SKIPL	A,ACTBL-1(LP)
	JRST	.+3
	PUSHJ	P,CLSRAN
	JRST	UXIT49
	CAIE	A,3
	JRST	.+3
	SKIPE	HPOS(LP)
	PUSHJ	P,CRLF3
UXIT49:	SOJG	LP,UXIT3
	SETZM	ODF
UXIT5:	SETZM	ODF
	DEFINE R(A)
<	IRP	A
<	RELEASE	^D<A>,	>>
        R<1,2,3,4,5,6,7,8,9>     ;DISK DATA FILES 1-9
	SKIPN	UXFLAG		;END OF PROGRAM EXECUTION?
	JRST	UXIT1		;NO.
	SETZM	UXFLAG		;YES.
	SETZM	MARWAI
	MOVEI	X1,^D72
	MOVEM	X1,MARGIN
	SETZM	QUOTBL
	SETZM	HPOS
	SETOM	PAGLIM
	MOVEI	X1,^D9
UXIT2:	SKIPL	A,ACTBL-1(X1)	;ACTBL ENTRY = 3 IF FILE
	CAIN	A,3
	JRST	UXIT21		;IS BEING WRITTEN.
	SOJG	X1,UXIT2
	JRST	UXIT1
UXIT21:	PUSH	P,[Z UXIT4]
UXIT6:	MOVE	X2,FILD-1(X1)
	MOVEM	X2,LOK
	MOVE	X2,EXTD-1(X1)
	MOVEM	X2,LOK+1
	HLRZ	X2,BA-1(X1)
	MOVEM	X2,JOBFF
	XCT	INITO-1(X1)
	JRST	[MOVE T,OPS1+1
		JRST NOGETD]	;OUTPUT MESSAGE "NO SUCH DEVICE"
	DPB	X1,[POINT 4,LOKUP,12]	;AND GIVE UP BECAUSE
	HLLZS	LOK+1		;ALL DEVICES ARE THE SAME.
	SETZM	LOK+2
	SETZM	LOK+3
	XCT	LOKUP
	JRST	.+1
UXIT7:	HLLZS	LOK+1
	SETZM	LOK+3
	DPB	X1,[POINT 4,RENAMD,12]
	XCT	RENAMD	
	JRST	.+1		;RENAME FAILS FOR DECTAPES.
	POPJ	P,

UXIT4:	SOJG	X1,UXIT2	;RETURN HERE FROM RENFAL MESSAGE.
	JRST	CHAXIT
UXIT1:	SETZM	RUNFLA
	PUSHJ	P,TTYIN		;INIT TTY IN CASE OF ^O.
	SKIPE	CHAFLG		;CHAINING?
	JRST	FIXUP		;YES.
	SKIPE	MTIME		;IS THERE SOME RUN TIME?
	PUSHJ	P,RTIME
	PUSHJ	P,INLMES
	ASCIZ	/
READY
/
	JRST	FIXUP		;GO TO MAIN LOOP AFTER CLEARING ROLLS
;SUBROUTINES FOR GENERAL ROLL MANIPULATION

CLOSUP:	MOVN	X1,E		;COMPUTE NEW END OF ROLL
	ADDB	X1,CEIL(R)	;AND STORE IT
	MOVE	X2,B		;CONSTRUCT BLT WORD
	ADD	X2,E
	MOVS	X2,X2
	HRR	X2,B
	BLT	X2,-1(X1)		;MOVE DOWN TOP OF ROLL
	POPJ	P,

CLOB:	MOVEI	T1,COMTOP	;ROUTINE TO CLOBBER ALL MOVEABLE ROLLS
	MOVEM	T,FLOOR(T1)		;T CONTAINS CLOBBER VALUE.
	MOVEM	T,CEIL(T1)
	CAILE	T1,1(X1)	;DO NOT CLOBBER ROLLS <=(X1)
	SOJA	T1,.-3
	POPJ	P,



OPEN2:	MOVE	X2,E		;IS THERE ROOM ABOVE THIS STODGY ROLL?
	ADD	X2,CEIL(R)	;THE NEW CEILING
	CAMLE	X2,FLOOR+1(R)
	JRST	OPENU0		;NO ROOM, PACK OTHER ROLLS UP
	ADDM	E,CEIL(R)	;THERE IS ROOM, INCREMENT CEILING
	POPJ	P,

OPENU0:	SUB	B,FLOOR(R)
	PUSHJ	P,PANIC
	ADD	B,FLOOR(R)

OPENUP:	CAMG	R,TOPSTG		;OPEN UP THE TOP STODGY ROLL?
	JRST	OPEN2		;YES. OPEN UPWARDS, NOT DOWN
	MOVN	X2,E
	MOVE	X1,TOPSTG	;DO NOT MOVE STODGY ROLLS
	ADD	X2,FLOOR+1(X1)
	CAMGE	X2,CEIL+0(X1)
	JRST	OPENU0		;NEED MORE ROOM
	HRL	X2,FLOOR+1(X1)	;CONSTRUCT BLT WORD
	SUB	B,E		;FIRST WORD OF GAP
	BLT	X2,-1(B)	;MOVE ROLLS DOWN

	MOVEI	X1,1(X1)		;ADJUST POINTERS FOR ROLLS JUST BLT'D.
	MOVN	X2,E
OPEN1:	ADDM	X2,FLOOR(X1)
	CAML	X1,R
	POPJ	P,
	ADDM	X2,CEIL(X1)
	AOJA	X1,OPEN1


;RPUSH - PUSH A ON TOP OF DESIGNATED ROLL

RPUSH:	MOVEI	E,1
	PUSHJ	P,BUMPRL	;MAKE ROOM
	MOVEM	A,(B)		;STORE WORD
	POPJ	P,

;ROUTINE TO ADD TO END OF ROLL
;E CONTAINS SIZE, R CONTAINS ROLL NUMBER

BUMPRL:	MOVE	B,CEIL(R)
	ADD	B,E
	CAIE	R,ROLTOP
	SKIPA	X1,FLOOR+1(R)
	HRRZ	X1,JOBREL
	CAMLE	B,X1
	JRST	BUMP1
	EXCH	B,CEIL(R)
	POPJ	P,

BUMP1:	MOVE	B,CEIL(R)
	CAIE	R,CODROL
	CAIN	R,SEXROL
	JRST	.+2
	JRST	OPENUP
	ADDI	E,^D10		;***EXTRA 10 LOCS
	PUSHJ	P,OPENUP
	MOVNI	X1,^D10	;TAKE BACK THE 10 LOCS
	ADDM	X1,CEIL(R)
	POPJ	P,


;BINARY SEARCH OF SORTED ROLL
;CALL WITH KEY IN A
;RETURN IN B ADDRS OF FIRST
;ENTRY NOT LESS THAN KEY
;SKIP RETURN IF LEFT SIDES EQUAL

SEARCH:	MOVE	B,FLOOR(R)
	SKIPA	X1,CEIL(R)
SEAR1:	MOVEI	B,1(X2)
	CAIGE	B,(X1)
	JRST	SEAR2
	CAML	B,CEIL(R)
	POPJ	P,
	JRST	SEAR3

SEAR2:	MOVEI	X2,@X1
	ADD	X2,B
	ASH	X2,-1
	CAMLE	A,(X2)
	JRST	SEAR1
	HRRI	X1,0(X2)
	CAIGE	B,(X1)
	JRST	SEAR2

SEAR3:	HLLZ	X2,(B)
	CAMN	X2,A
	AOS	(P)
        POPJ    P,

;ROUTINE TO QSA FOR "THEN" OR "GOTO" (USED IN "IF", "ON" STATEMENTS)
THENGO:	PUSHJ	P,QSA
	ASCIZ /THEN/
	CAIA
	POPJ	P,
	PUSHJ	P,QSA
	ASCIZ /GOTO/
        JRST    [PUSHJ P,INLMES
                ASCIZ /
ILLEGAL THEN-GO SETUP/
                JRST BASIC]
	POPJ	P,

;COMMON SUBROUTINE RETURNS

CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

;ROUTINES TO ALLOW AND DELAY REENTRY.
;LOCKON TEMPORARILY PREVENTS REENTRY
;LOCKOF ALLOWS REENTRY AND REENTERS IF THERE IS A STANDING REQUEST
;REENTR MAKES A REENTRY OR MAKES A REQUEST AND CONTINUES
LOCKON:	SKIPGE	RENFLA
	SETZM	RENFLA		;TURN ON REENTER PROTECT
	POPJ	P,

LOCKOF:	SKIPLE	RENFLA
	JRST	BASIC		;ACT ON OLD REENTER REQUEST
	SETOM	RENFLA		;ALLOW REENTER
	POPJ	P,

        EXTERN REENTR
;ROUTINE TO READ CHARACTER, SKIPPING BLANKS
;CALL:	MOVE	T,<POINTER TO CHAR BEFORE FIRST>
;	PUSHJ	P,NXCH
;	...	RETURN, C:= (<FLAGS>)CHARACTER

NXCHS:	ILDB	C,T		;DOESNT SKIP TAB OR BLANK
	CAIE	C," "
	CAIN	C,11
	POPJ	P,
	JRST	.+2		;SKIP INTO NXCH

NXCH:	ILDB 	C,T		;FETCH NEXT CHARACTER
	HLL	C,CTTAB(C)	;GET FLAGS FROM CTTAB
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.SPTB	;SPACE OR TAB?
	JRST	NXCH		;YES. IGNORE
	POPJ	P,

NXCHD:	ILDB	C,T
NXCHD2:	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	POPJ	P,

;SCAN INITIAL LETTER, LETTER IS PLACED LEFT
;JUSTIFIED IN A, 7-BIT ASCII.

SCNLT1:	HRRZ	A,C
	ROT	A,-7
	JRST	NXCH

;SCAN SECOND LETTER, NON-SKIP RETURN IF NOT LETTER.
;MAKE 7-BIT LETTER LEFT JUST IN A
;INTO 6-BIT. THAN PUT 6-BIT CURRENT LETTER IN A.

SCNLT2:	TLNN	C,F.LETT
	POPJ	P,
SCN2:	TLNN	A,400000	;ENTER HERE TO PROCESS NON-LETTER CHARS
	TLZA	A,200000
	TLO	A,200000
	LSH	A,1
	MOVE	X1,[POINT 6,A,5]
	JRST	SCNLTN	

;ENTER HERE TO SCAN SECOND CHAR EVEN IF BOTH ARE NOT LETTERS.


;SCAN THIRD LETTER, NON-SKIP IF NOT LETTER.
;PUT 6-BIT LETTER TO 3RD 6-BIT FIELD IN A.

SCNLT3:	TLNN	C,F.LETT
	POPJ	P,
SCN3:	MOVE	X1,[POINT 6,A,11]

;NOW PUT 6-BIT LETTER INTO A, ADJUSTING LOWER CASE, INCREMENTING POINTER.

SCNLTN:	TLNN	C,F.LCAS
	TRC	C,40
	IDPB	C,X1
	AOS	(P)
	JRST	NXCH


;QUOTE SCAN AND TEST
;CALL WITH PATTERN ADDRS IN X1
;SKIP IF EQUAL.	C,T UPDATED TO LAST CHAR SCANNED.
QST:	HRLI	X1,440700	;MAKE BYTE PNTR TO PATTERN
QST1:	ILDB	X2,X1		;GET PATTERN CHAR
	JUMPE	X2,CPOPJ1	;DONE ON NULL
	SUBI	X2,(C)
	JUMPE	X2,.+4		;DO CHARACTERS MATCH?
	TLNE	C,F.LCAS	;NO. LOWER CASE LETTER?
	CAME	X2,[ EXP -40]	;YES. SAME LETTER OF ALPHABET?
	JRST	QST2		;NO. MATCH FAILS
	PUSHJ	P,NXCH
	JRST	QST1
QST2:	ILDB	X2,X1		;ON FAIL
	JUMPN	X2,.-1		;SKIP TO NULL
	POPJ	P,


;QUOTE SCAN OR FAIL
;CALL WITH INLINE PATTERN
;GO TO GRONK IF NO MATCH

QSF:	POP	P,X1
	PUSHJ	P,QST
        JRST    [PUSHJ P,OUCH
                PUSHJ P,INLMES
                ASCIZ / MISSING/
                JRST BASIC]
	JRST	1(X1)

;QUOTE SCAN UNTIL FAIL.
;CALL WITH INLINE PATTERN.

QSAX:	POP	P,X1
	PUSHJ	P,QST
	JRST	1(X1)
	JRST	1(X1)

;QUOTE SCAN WITH ANSWER
;CALL WITH INLINE PATTERN
;SKIP ON SUCCESS		;ON FAIL, RETURN WITH C,T RESTORED

QSA:	POP	P,X1		;GET PATTERN ADDRESS
	PUSH	P,C		;SAVE C,T
	PUSH	P,T
	PUSHJ	P,QST		;SAVE STRING
	JRST 	.+2
	JRST	QSA1		;MATCH
	POP	P,T		;NO MATCH.  BACK UP
	POP	P,C
	JRST	1(X1)

QSA1:	POP	P,X2
	POP	P,X2
	JRST	2(X1)

;ROUTINE TO READ NEXT INTEGER FROM SCANNED LINE
;CALL:	MOVE	T,POINTER TO FIRST CHAR
;	PUSHJ	P,GETNUM
;	...	FAIL RETURN
;	...	SUCCESS RETURN, INTEGER IN N

GETNU:	TDZA	X1,X1		;GET A NUMBER OF ANY LENGTH.
GETNUM:	MOVEI	X1,5		;GET A NUMBER OF AT MOST 5 DIGS
	TLNN	C,F.DIG		;NUMERAL?
	POPJ	P,		;NO.  FAIL RETURN
	MOVEI	N,-60(C)	;YES.  ACCUMULATE FIRST DIGIT
GETN1:	MOVE	G,T		;SAVE PNTR FOR USE BY INSERT
	PUSHJ	P,NXCH		;GET NEXT CHAR
	SOJE	X1,CPOPJ1	;EXIT IF FIVE DIGITS ALREADY
	TLNN	C,F.DIG		;NUMERAL?
	JRST	CPOPJ1		;NO.  RETURN.
	IMULI	N,^D10		;YES.  ACCUMULATE NUMBER
	ADDI	N,-60(C)
	JRST	GETN1		;GO FOR MORE
;ROUTINE TO READ A LINE INTO LINB0
;CALL:	PUSHJ	P,INLINE

INLINE:	PUSH	P,X1
	SETZB	X1,T1
	SKIPE	IFIFG
	SKIPA	T,LINPT(LP)
	MOVE	T,LINPT
	JRST	INLI1A


INLI1:	ILDB	C,TYI+1		;GET CHAR
	JRST	INLB
INLA:	SOSGE	@INCNT-1(LP)
	JRST	DSKIN
	ILDB	C,@INPT-1(LP)
INLB:	CAIE	C,15		;CR??
	CAIN	C,0
	SOJA	T1,INLI1A
	CAIN	C,"_"		;DELETE?
	JRST	INLI3		;YES
	CAIE	C,21		;IGNORE XON,XOFF
	CAIN	C,23
	SOJA	T1,INLI1A
	CAIG	C,14		;LINE TERMINATOR?
	CAIGE	C,12
	CAIA
	JRST	INLI2		;YES.  GO FINISH UP
	CAIG	T1,<%LOL>	;ROOM FOR CHAR+1 MORE?
	JRST	INLB1		;YES.
	SKIPE	IFIFG		;DISK?
        JRST    [PUSHJ P,TTYIN
                PUSHJ P,INLMES
                ASCIZ /DSK I-O ERROR/
                JRST BASIC]
	MOVEI	T,INERR1	;NO, ERROR EXIT.
	JRST	ERRMSG
INLB1:	IDPB	C,T		;STORE CHAR
INLI1A:	SKIPE	IFIFG
	AOJA	T1,INLA
	SOSLE	TYI+2		;MORE INPUT?
	AOJA	T1,INLI1	;YES.  BUMP COUNT AND GO GET MORE
	INPUT 0,
	STATZ 0 ,	20000
	JRST	[SKIPN CHAFLG
		JRST BASIC
		JRST RUNNH]
	STATO 0 ,	740000
	AOJA	T1,INLI1
	MOVEI	T,INLSYS
	JRST	ERRMSG
INLSYS:	ASCIZ /
SYSTEMS ERROR ON TTY I-O/

INLI2:	MOVEI	C,15		;DONE.  PUT CR IN BFR.
	IDPB	C,T
	POP	P,X1
RESCAN:	SKIPN	IFIFG
	SKIPA	T,LINPT
	MOVE	T,LINPT(LP)
	SKIPE	IFIFG
	JRST	INLI8
	SETZM	HPOS		;CARRIAGE POSITION := LFT MRGN
	JRST	NXCH		;GET FIRST CHAR AND RETURN
INLI8:	SETZM	HPOS(LP)
	JRST	NXCH

INLI3:	SOJE	T1,INLI1A	;BACKARROW HANDLER, IGNORE IF AT LEFT
	MOVEI	C,4
	IBP	T		;BACK UP BYTE POINTER A LA JHB
	SOJG	C,.-1
	SUBI	T1,1
	SOJA	T,INLI1A

;ROUTINE TO START READING NEXT LINE OF PROGRAM
NXLINE:	MOVE	T,FLLIN
	ADDI	T,(L)
	MOVE	T,(T)
	MOVS	D,T		;SAVE LINE START
	HRLI	T,440700
	MOVE	G,FLREF	;SETUP REFROL REFERENCE.
	ADDI	G,(L)
	JRST	NXCH


DSKIN:  DPB     LP,[POINT 4,INDSK,12] ;DISK INPUT
	XCT	INDSK
	DPB	LP,[POINT 4,STADSK,12]
	XCT	STADSK
        JRST    BASIC
	DPB	LP,[POINT 4,STODSK,12]
	XCT	STODSK
	JRST	INLA
	MOVEI	T,INLSYS
	JRST	ERRMSG
;PRINTING SUBROUTINES

;PRINT TO QUOTE CHAR
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;ALTERNATE CALL: PRINT1, IF BYTE PNTR IN T.


PRINT:	HRLI	T,440700
PRINT1:	ILDB	C,T
	CAMN	C,D
	POPJ	P,
	PUSHJ	P,OUCH		;OUTPUT THE CHAR
	JRST	PRINT1


OUCH0:	PUSH	P,C
	AOS	HPOS(LP)
	MOVE	C,MARGIN(LP)
	SKIPGE	QUOTBL(LP)	;QUOTE MODE?
	JRST	OUCH4		;YES.
	CAML	C,HPOS(LP)	;NO.
	JRST	OUCH3
	PUSHJ	P,PCRLF
	JUMPN	LP,.+2
	OUTPUT 0,
	JRST	OUCH5
OUCH4:	CAML	C,HPOS(LP)
	JRST	.+3
	POP	P,C
	JRST	PTXER2
OUCH3:	SOS	HPOS(LP)
OUCH5:	POP	P,C
OUCH:	SKIPE	ODF		;DISK?
	JRST	DSKOT		;YES.
	SKIPLE	TYO+2		;NO.
	JRST	OUCH1
	OUTPUT 0,
	MOVEM	N,TEMLOC
        GETSTS 0,N
	TRNE	N,740000
	JRST	OUTERR
	MOVE	N,TEMLOC
OUCH1:	SOS	TYO+2
	IDPB	C,TYO+1
	AOS	HPOS
	POPJ	P,
DSKOT:	SKIPG	@OUTCNT-1(LP)
	JRST	DOS
	SOS	@OUTCNT-1(LP)
	IDPB	C,@OUTPT-1(LP)
	AOS	HPOS(LP)
	POPJ	P,
DOS:	DPB	LP,[POINT 4,OUTTDS,12]
	XCT	OUTTDS
	JRST	DSKOT
	DPB	LP,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR

;ROUTINE TO PRINT SIXBIT CHARACTERS IN ACCUM "T".
;IGNORES BLANKS.


PRNSIX:	MOVE	T1,[POINT 6,T]
	ILDB	C,T1
	JUMPE	C,PRNS1		;SKIP A BLANK
	ADDI	C,40
	PUSHJ	P,OUCH
PRNS1:	TLNE	T1,770000		;ALL SIX PRINTED?
	JRST	PRNSIX+1
	POPJ	P,


;UTILITY ROUTINE TO PRINT OUT "DEV:FILENM.EXT".
;FOR USE BY VARIOUS ERROR MESSAGES.
;DEV IS IN SAVE1, FILENM IN FILDIR, AND EXT IN FILDIR+1.
;IF LH(SAVE1)=0, DEV IS NOT PRINTED. DSK: AND .BAS ARE
;OMITTED.

PRNNAM:	PUSH	P,C
	PUSH	P,T
	PUSH	P,ODF
	SETZM	ODF
	HLRZ	T,SAVE1
	JUMPE	T,PRNAM1
	CAIN	T,<SIXBIT /   DSK/>
	JRST	PRNAM1
	MOVE	T,SAVE1
	PUSHJ	P,PRNSIX
	MOVSI	T,320000
	PUSHJ	P,PRNSIX
PRNAM1:	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,FILDIR+1
	CAIN	T,<SIXBIT /   BAS/>
	JRST	PRNAM2
	TLO	T,16
	PUSHJ	P,PRNSIX
PRNAM2:	POP	P,ODF
	POP	P,T
	POP	P,C
	POPJ	P,
;SPECIAL DECIMAL PRINT ROUTINE.  PRINTS X1,X2 AS DECIMAL NUMBERS
;SEPARATED BY THE CHARACTER IN ACCUM "A".
;IF X1 OR X2 ARE ZERO, THEY PRINT AS "00".

PRDE2:	MOVE	T,X1
	PUSHJ	P,PRDE1
	MOVE	C,A
PRDE2A:	PUSHJ	P,OUCH
	MOVE	T,X2
	MOVEI	A,177
PRDE1:	MOVEI	C,"0"		;A ONE DIGIT NUMBER?
	CAIG	T,^D9
	PUSHJ	P,OUCH		;YES. PUT OUT LEADING ZERO.
	JRST	PRTNUM

;NUMBER PRINTER (PRINTS INTEGER IN T)


PRTNUX:	MOVEI	X1,3
	SKIPE	STRFCN
	JRST	PRTNX4
	JRST	PRTNX3
PRTNX1:	MOVE	X1,B		;CHECK ROOM FOR INT. OF THIS SIZE " "
	MOVEI	X1,4(X1)
PRTNX3:	PUSHJ	P,CHROOM
PRTNX4:	PUSHJ	P,PSIGN
PRTNX2:	IDIVI	T,^D10
	JUMPE	T,PRTN0
	PUSH	P,T1
	PUSHJ	P,.-3
	POP	P,T1
PRTN0:	MOVEI	C,60(T1)
	AOS	NUMCOT
	SKIPE	STRFCN
	JRST	DPBSTR
	JRST	OUCH0

PRTNUM:	IDIVI	T,^D10
	JUMPE	T,PRTN1
	PUSH	P,T1
	PUSHJ	P,PRTNUM
	POP	P,T1
PRTN1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH


;OCTAL NUMBER PRINTER.
PRTOCT:	IDIVI	T,10
	JUMPE	T,PRTOC1
	PUSH	P,T1
	PUSHJ	P,PRTOCT
	POP	P,T1
PRTOC1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH


;ROUTINE USED BY OUTNUM FOR STRB.

DPBSTR:	EXCH	T,STRPTR
	IDPB	C,T
	EXCH	T,STRPTR
	SOS	STRCTR
	POPJ	P,



PSIGN:	MOVEI	C," "		;PRINT "SIGN" (BLANK OR MINUS)
	JUMPL	N,PSIGN2
	SKIPE	STRFCN
	POPJ	P,
	JRST	OUCH0
PSIGN2:	SKIPE	STRFCN
	JRST	PSIGN4
	SKIPL	QUOTBL(LP)
	JRST	PSIGN3
	MOVEI	C," "
	PUSHJ	P,OUCH0
PSIGN3:	MOVEI	C,"-"
	JRST	OUCH0
PSIGN4:	MOVEI	C,"-"
	JRST	DPBSTR


;MESSAGE PRINTER

INLMES:	PUSHJ	P,TTYIN
INLME1:	SETZM	HPOS
	EXCH	T,(P)	;GET MSG ADR AND SAVE T.
	PUSH	P,C
	PUSH	P,ODF
	SETZM	ODF
	MOVEI	D,0	;END ON NULL
	PUSHJ	P,PRINT	;PRINT THE MESSAGE
	POP	P,ODF
	POP	P,C
	EXCH	T,(P)
	SETZM	HPOS
        OUTPUT 0,          ;INLMES IN BASUIF ALWAYS CLRS OUTBUF
	JRST	CPOPJ1	;RTN AFTER MSG.
;PANIC - ROUTINE TO COMPRESS CORE

PANIC:	PUSHJ	P,PRESS		;COMPRESS MEMORY
	MOVE	X2,TOPSTG	;IS THERE ROOM BETWEEN STODGY AND
	MOVE	X1,FLOOR+1(X2)	;MOVEABLE ONES?
	SUB	X1,CEIL(X2)
	CAML	X1,E		;ENOUGH ROOM?
	POPJ	P,

	MOVE	X1,JOBREL	;EXPAND BY 1K
	ADDI	X1,2000
	CALL	X1,[SIXBIT /CORE/]
	JRST	[MOVEI T,PANIC1
		JRST ERRMSG]	;CANT
	JRST	PANIC		;OK.  GO MOVE ROLLS

PANIC1:	ASCIZ	/
OUT OF ROOM/


PRESS:	PUSH	P,G		;SAVE AC
	PUSH	P,A
	SKIPN	PAKFLA		;ARE LINES PACKED?
	JRST	PRESS5		;YES
	SETZM	PAKFLA

	MOVE	X1,FLTXT	;LOOK FOR EMPTY SPACE
PRESS2:	CAML	X1,CETXT	;THROUGH LOOKING?
	JRST	PRESS5
	SKIPE	(X1)		;A FREE WORD?
	AOJA	X1,PRESS2	;NO

	MOVEI	X2,1(X1)	;YES
PRESS3:	CAML	X2,CETXT
	JRST	PRESS4		;FREE TO END
	SKIPN	(X2)
	AOJA	X2,PRESS3	;LOOK FOR NON-FREE WORD

	SUB	X1,X2		;X1 :=-LNG OF MOVE
	MOVE	A,FLLIN
PRES3A:	CAML	A,CELIN		;MOVE DOWN THE REFERENCES
	JRST	PRES3B		;IN THE LINE ROLL.
	HRRZ	G,(A)
	CAML	G,X2
	ADDM	X1,(A)
	AOJA	A,PRES3A

PRES3B:	MOVE	G,CETXT		;MOVE DOWN THE TEXT ROLL.
	ADD	G,X1
	MOVEM	G,CETXT
	ADD	X1,X2
	HRL	X2,X1
	MOVSS	X2
	BLT	X2,-1(G)
	JRST	PRESS2

PRESS4:	MOVEM	X1,CETXT

;ROUTINE TO MOVE ROLLS UP

PRESS5:	MOVEI	G,ROLTOP	;HIGHEST MOVABLE ROLL
	MOVE	X1,JOBREL	;X1 IS PREVIOUS FLOOR
				;NOTE: TOP WORD OF USR CORE IS LOST

PRESS6:	MOVE	X2,CEIL(G)	;GET OLD CEIL AND FLOOR
	MOVE	A,FLOOR(G)
	SUBI	X2,1		;SET UP X2 FOR POP LOOP
	ORCMI	X2,777777
	MOVEM	X1,CEIL(G)	;NEW CEILING

PRESS7:	CAILE	A,(X2)		;DONE?
	JRST	PRESS8
	POP	X2,-1(X1)	;MOVE ONE WORD
	SOJA	X1,PRESS7

PRESS8:	MOVEM	X1,FLOOR(G)	;NEW FLOOR
	SOS	G		;GO TO NEXT LOWER ROLL
	CAMLE	G,TOPSTG	;IS THIS ROLL MOVEABLE?
	JRST	PRESS6		;YES. GO PRESS IT.
	POP	P,A
PRESS9:	POP	P,G	;RESTORE G
	POPJ	P,	;RETURN



PTXER2: PUSHJ   P,INLMES
        ASCIZ   /
?? OUTPUT ITEM TOO LONG FOR LINE/
        OUTPUT 0,
        JRST    UXIT

CHROOM: MOVE    B,TABVAL(LP)
        ADD     X1,B
        ADD     X1,HPOS(P)
        CAML    X1,MARGIN(LP)
        JRST    PCRLF
        JUMPL   B,PCRLF
        JUMPE   B,CPOPJ
        MOVEI   C," "
        PUSHJ   P,OUCH
        SOJG    B,.-2
        SETZM   TABVAL(LP)
        POPJ    P,

PCRLF:	MOVEI	C,15		;ROUTINE TO END A LINE AND
	PUSHJ	P,OUCH		;POSSIBLY BEGIN A NEW LINE.
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZM	TABVAL(LP)
	SETZM	HPOS(LP)
	SKIPG	C,PAGLIM(LP)
	JRST	PCRLF2
	AOS	PAGCNT(LP)
	CAME	C,PAGCNT(LP)
	JRST	PCRLF2
	MOVEI	C,14
	PUSHJ	P,OUCH
	SETZM	HPOS(LP)
	SETZM	PAGCNT(LP)
PCRLF2:	SKIPE	C,MARWAI(LP)
	MOVEM	C,MARGIN(LP)
	JUMPE	LP,FINPT3
	MOVE	C,MARGIN(LP)
	CAIL	C,^D7
	JRST	.+3
	SKIPGE	WRIPRI-1(LP)
	JRST	MARERR
FINPT3:	HRRZ	X2,(P)
	POPJ	P,


CRLF3:	MOVEI	C,15
	PUSHJ	P,OUCH
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	SKIPG	T,PAGLIM(LP)
	JRST	CRLF2
	AOS	PAGCNT(LP)
	CAME	T,PAGCNT(LP)
	JRST	CRLF2
	MOVEI	C,14
	PUSHJ	P,OUCH
	SETZM	PAGCNT(LP)
CRLF2:	SETZM	HPOS(LP)
CRLF1:	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	JUMPN	LP,.+2
	OUTPUT 0,
	SETOM	FIRSFL(LP)
	POPJ	P,
;SPECIAL RUNTIME PRINTER
RTIME:	PUSHJ	P,INLMES
	ASCIZ /
/
	SETZM	MTIME
	OUTPUT 0,
	POPJ	P,
;UTILITY ROUTINE TO INPUT A BLOCK FOR A R.A. FILE. THE DESIRED
;BLOCK NUMBER IS IN X2.

INRAN:	HRRM	X2,USETID-1(LP)
	XCT	USETID-1(LP)
	DPB	LP,[POINT 4,INNDSK,12]
	XCT	INNDSK
	POPJ	P,
	MOVEI	T,INLSYS
	JRST	ERRMSG


;UTILITY ROUTINE TO TRANSFER A BLOCK FROM A R.A. INPUT BUFFER TO THE 
;OUTPUT BUFFER FOR THAT CHANNEL. THE BLOCK NUMBER IS IN X2.

OUTRAN:	PUSH	P,X1
	HRRM	X2,USETOD-1(LP)
	XCT	USETOD-1(LP)
	HLRZ	X2,BA-1(LP)
	ADDI	X2,3
	HRLI	X2,(X2)
	MOVEI	X1,203
	ADDI	X1,(X2)
	HRRI	X2,(X1)
	BLT	X2,177(X1)
	MOVEI	X2,200
	HRRM	X2,-1(X1)
	DPB	LP,[POINT 4,OUTTDS,12]
	POP	P,X1
	XCT	OUTTDS
	POPJ	P,
	DPB	LP,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR
CLSSE1:	DPB	LP,[POINT 4,DREL,12]
	XCT	DREL
	MOVEI	X1,3
	CAME	X1,ACTBL-1(LP)
	POPJ	P,
	MOVEI	X1,(LP)		;FILE IS IN WRITE MODE,
	PUSHJ	P,UXIT6		;SO SET UP PROTECTION CODE.
	XCT	DREL
	POPJ	P,

CLSRAN:	MOVE	X2,BLOCK-1(LP)	;R.A.
	CAIN	X2,1
	JRST	CLSRN1
	SKIPE	MODBLK-1(LP)
	PUSHJ	P,OUTRAN
	MOVEI	X2,1
	PUSHJ	P,INRAN
CLSRN1:	MOVE	X1,LASREC-1(LP)
	HLRZ	X2,BA-1(LP)
	HRRM	X1,3(X2)
	MOVEI	X2,1
	PUSHJ	P,OUTRAN
	MOVEI	X2,3
	MOVEM	X2,ACTBL-1(LP)
	JRST	CLSSE1
CTTAB:
	XWD	F.NU,	F.STR	;NULL	, @
	XWD	F.STR,	F.LETT	;	, A
	XWD	F.STR,	F.LETT	;	, B
	XWD	F.STR,	F.LETT	;	, C
	XWD	F.STR,	F.LETT	;	, D
	XWD	F.STR,	F.LETT	;	, E
	XWD	F.STR,	F.LETT	;	, F
	XWD	F.STR,	F.LETT	;	, G
	XWD	F.STR,	F.LETT	;	, H
	XWD	F.SPTB,	F.LETT	;TAB	, I
	XWD	F.CR,	F.LETT	;LF	, J
	XWD	F.CR,	F.LETT	;VER.TAB, K
	XWD	F.CR,	F.LETT	;FFEED	, L
	XWD	F.CR,	F.LETT	;CR	, M
	XWD	F.STR,	F.LETT	;	, N
	XWD	F.STR,	F.LETT	;	, O
	XWD	F.STR,	F.LETT	;	, P
	XWD	F.STR,	F.LETT	;	, Q
	XWD	F.STR,	F.LETT	;	, R
	XWD	F.STR,	F.LETT	;	, S
	XWD	F.STR,	F.LETT	;	, T
	XWD	F.STR,	F.LETT	;	, U
	XWD	F.STR,	F.LETT	;	, V
	XWD	F.STR,	F.LETT	;	, W
	XWD	F.STR,	F.LETT	;	, X
	XWD	F.STR,	F.LETT	;	, Y
	XWD	F.STR,	F.LETT	;	, Z
	XWD	F.ESC,	F.STR	;ESC	, [
	XWD	F.STR,	F.STR	;	, \
	XWD	F.STR,	F.STR	;	, ]
	XWD	F.STR,	F.OTH	;	, ^
	XWD	F.STR,	F.OTH	;	, _
        XWD     F.SPTB, F.STR           ;SPACE  , <ACCENT GRAVE>
	XWD	F.STR,	F.LETT+F.LCAS	; !	, <LOWER CASE> A
	XWD	F.QUOT,	F.LETT+F.LCAS	; "	, <LOWER CASE> B
	XWD	F.STR,	F.LETT+F.LCAS	; #	, <LOWER CASE> C
	XWD	F.DOLL,	F.LETT+F.LCAS	; $	, <LOWER CASE> D
	XWD	F.STR,	F.LETT+F.LCAS	; %	, <LOWER CASE> E
	XWD	F.OTH,	F.LETT+F.LCAS	; &	, <LOWER CASE> F
	XWD	F.APOS,	F.LETT+F.LCAS	; '	, <LOWER CASE> G
	XWD	F.OTH,	F.LETT+F.LCAS	; (	, <LOWER CASE> H
	XWD	F.RPRN,	F.LETT+F.LCAS	; )	, <LOWER CASE> I
	XWD	F.STAR,	F.LETT+F.LCAS	; *	, <LOWER CASE> J
	XWD	F.PLUS,	F.LETT+F.LCAS	; +	, <LOWER CASE> K
	XWD	F.COMA,	F.LETT+F.LCAS	; , 	, <LOWER CASE> L
	XWD	F.MINS,	F.LETT+F.LCAS	; -	, <LOWER CASE> M
	XWD	F.PER,	F.LETT+F.LCAS	; .	, <LOWER CASE> N
	XWD	F.SLSH,	F.LETT+F.LCAS	; /	, <LOWER CASE> O
	XWD	F.DIG,	F.LETT+F.LCAS	; 0	, <LOWER CASE> P
	XWD	F.DIG,	F.LETT+F.LCAS	; 1	, <LOWER CASE> Q
	XWD	F.DIG,	F.LETT+F.LCAS	; 2	, <LOWER CASE> R
	XWD	F.DIG,	F.LETT+F.LCAS	; 3	, <LOWER CASE> S
	XWD	F.DIG,	F.LETT+F.LCAS	; 4	, <LOWER CASE> T
	XWD	F.DIG,	F.LETT+F.LCAS	; 5	, <LOWER CASE> U
	XWD	F.DIG,	F.LETT+F.LCAS	; 6	, <LOWER CASE> V
	XWD	F.DIG,	F.LETT+F.LCAS	; 7	, <LOWER CASE> W
	XWD	F.DIG,	F.LETT+F.LCAS	; 8	, <LOWER CASE> X
	XWD	F.DIG,	F.LETT+F.LCAS	; 9	, <LOWER CASE> Y
	XWD	F.OTH,	F.LETT+F.LCAS	; :	, <LOWER CASE> Z
	XWD	F.OTH,	F.STR		; ;	, <LEFT BRACE>
	XWD	F.OTH,	F.STR		; <	, <VERTICAL BAR>
	XWD	F.EQAL,	F.STR		; =	, <RIGHT BRACE>
	XWD	F.OTH,	F.STR		; >	, <TILDE>
	XWD	F.STR,	F.STR		; ?	, <RUBOUT>
EXTERN STSTRP
TRPMSG:	HLRZ	T,TRPLOC+3
	SETZM	TRPLOC+2
	SETZM	TRPLOC+3
	DPB	T,[POINT 4,STSTRP,12]
	XCT	STSTRP
	MOVEI	T,TRPMS1
	JRST	ERRMSG
TRPMS1:	ASCIZ	/
? DEVICE OK?
/
	END	BASIC
  U@+N