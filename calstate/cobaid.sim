GLOBAL NOCORE:

LOCAL %ADD.EXT,%OUTTEL,%OUTTELC,%OUTFL,%OUTFLC
LOCAL %OPEN.OUTFL,%UPD.OUTFL,%OPEN.INFL,OUT.FILE,IN.FILE
LOCAL %CLOSE.OUTFL,%CLOSE.INFL,%EOF.CHECK
LOCAL %LINE.GET,%END.LINE,%COMAND,%FILE.SCAN,%GD.CMND,COMLINE
LOCAL %HELP,%HELP.SIZE,%ALPHA.NUM,%GET.FILE
LOCAL %READ.TMP,%WRITE.TMP,%RUN,%DELETE.TMP

TABLE CBL.EXT[OCT 43.42.54.00.00.00]  ! 'CBL' IN SIXBIT

DEF ADDRESS(A) AS (10<A<=OCT 777.777)
DEF STR.PNT(A) AS (A<0 OR OCT 777.777<A)
DEF REMOVE.CR(X) AS CH(X,GLCNT-1)_EOLIT
DEF REMOVE.SP(X) AS WHILE NCHV X=$  THEN NULL ; PCHV X

LOCAL %GET.PROG.ID,PROGRAM(0:1)
LOCAL %MAIN.INIT,%MAIN,%INITIALIZE

!COBAID IS EITHER ENTERED AT 'ENTRY0' OR 'ENTRY1'.
!'ENTRY0' IS THE INITIAL ENTRY. IT PROMPTS FOR THE PROGRAM-ID.
!'ENTRY1' IS THE CONTINUATION ENTRY AFTER CALLS TO EDITOR, DETAP
!OR ONE OF THE TRANSLATORS. IT READS THE PROGRAM ID FROM THE TMPCOR
!FILE CREATED ON EXIT.
!
LOCAL ENTRY:
ENTRY: GO ENTRY0
\\->ENTRY
ENTRY1: INITIALIZE ; READ.TMP('CBA',PROGRAM,2) ; DELETE.TMP('SVC') ; GO START
ENTRY0: INITIALIZE ; GET.PROG.ID ; GO START

START: MAIN ; EXIT

NOCORE: OUTTEL('NO MORE CORE') ; EXIT

%INITIALIZE
IOCS(2)
MAIN.INIT
RETURN
END INITIALIZE

!GET PROGRAM ID AND STORE IN 'PROGRAM'.
!
%GET.PROG.ID
LOCAL %PROG.ID
WHILE NOT PROG.ID THEN DO
   OUTTEL('PROGRAM-ID MUST BE SIX OR LESS LETTERS OR DIGITS')
END

REMOVE.CR(IMAGE)

MOVE 2 FROM IMAGE TO PROGRAM

RETURN

%PROG.ID
LOCAL P,C
OUTTEL('')
OUTTELC('PROGRAM-ID: ')
P_GET.LINE(TEL)
IF GLCNT>7 THEN RETURN 0
WHILE C_NCHV P#CARRET THEN IF NOT ALPHA.NUM(C) THEN RETURN 0
RETURN 1
END PROG.ID
END GET.PROG.ID

!MAIN COMMAND LOOP.
!DIRECTS USER TO DIFFERENT SUBSYSTEMS OF COBAID.
!IN THIS AND IN ALL OTHER COMMAND LOOPS, 'STATE' HAS THE
!FOLLOWING MEANS:
!
!  VALUE  MEANING
!  -----  -------
!   -1    RETURN TO EXEC
!    0    GO UP ONE COMMAND LEVEL
!    1    INITIALIZE THIS LEVEL
!    2    ERROR. TYPE '?'
!    3    NORMAL COMMAND PROCESSING
!
!EACH COMMAND LOOP HAS THE FOLLOWING ARRAYS ASSOCIATED WITH IT.
!
! XXXX.LIST(0:N)   COMMAND LIST. XXXX.LIST(0)_N
! XXXX.HELP(N)     HELP MESSAGES
! XXXX.SIZE(N)     # OF SPACES TO PRINT BETWEEN COMMAND AND HELP MESSAGE
! XXXX.HD(5)       XXXX.HD(1)_XXXX.LIST
!                  XXXX.HD(2)_XXXX.SIZE
!                  XXXX.HD(3)_XXXX.HELP
!                  XXXX.HD(4)_ HELP COMMAND HEADING
!                  XXXX.HD(5)_ COMMAND PROMPT
!
%MAIN
LOCAL MAIN.HD(5),MAIN.SIZE(12),MAIN.HELP(12)
TABLE MAIN.LIST(0:12)[12,'BUILD','TRANSLATE','CONSTD','STDCON' &
        ,'DETAP','IBMDEC','RCADEC','DECB35','QUIT','END' &
        ,'INSTRUCTIONS','HELP']
LOCAL %BUILD,%TRANSLATE,%STDCON,%CONSTD
LOCAL %BLD.INIT,%TRN.INIT
LOCAL STATE,N

STATE_1
WHILE STATE>0 THEN DO
   DO STATE OF 3
   1: OUTTEL('')
      OUTTEL('COBOL SUPPORT SYSTEM ACTIVE')
   2: OUTTEL('?')
   END

   STATE_3
   N_GD.CMND(MAIN.HD)
   IF END.LINE THEN DO N OF 12
   1: STATE_BUILD
   2: STATE_TRANSLATE
   3: STATE_CONSTD
   4: STATE_STDCON
   5:6:7:8: WRITE.TMP('CBA',PROGRAM,2)
            RUN(MAIN.LIST(N),0)
   9:10: STATE_-1
   11: NULL
      OUTTEL('')
      OUTTEL('BUILD:')
      OUTTEL('   THIS COMMAND ACTIVATES THE PROGRAM SKELETON BUILDER.')
      OUTTEL('   THERE ARE SIX FUNCTIONS THAT WILL AID THE PROGRAMMER')
      OUTTEL('   IN BUILDING A COBOL PROGRAM. THE FUNCTIONS ARE:')
      OUTTEL('   IDENTIFICATION, ENVIRONMENT, DATA, WORKING-STORAGE,')
      OUTTEL('   PROCEDURE AND MAKE.')
      OUTTEL('')
      OUTTEL('TRANSLATE:')
      OUTTEL('   ALLOWS USER TO TRANSLATE STANDARD OR USER DEFINED')
      OUTTEL('   ABREVIATIONS AND TO LIST ALL ABREVIATIONS. THE VALID')
      OUTTEL('   FUNCTIONS ARE STANDARD, DEFINE, SAVE, LIST AND EXPAND.')
      OUTTEL('')
      OUTTEL('CONSTD:')
      OUTTEL('   CONVERTS CONVENTIONAL FORMAT COBOL PROGRAMS TO STANDARD')
      OUTTEL('   FORMAT COBOL PROGRAMS.')
      OUTTEL('')
      OUTTEL('STDCON:')
      OUTTEL('   CONVERTS STANDARD FORMAT COBOL PROGRAMS TO CONVENTIONAL')
      OUTTEL('   FORMAT COBOL PROGRAMS.')
      OUTTEL('')
      OUTTEL('DETAP:')
      OUTTEL('   THIS COMMAND ACTIVATES THE DECISION TABLE PROCESSOR.')
      OUTTEL('')
      OUTTEL('IBMDEC:')
      OUTTEL('   AIDS IN THE TRANSLATION OF AN IBM COBOL PROGRAM TO DEC')
      OUTTEL('   COBOL.')
      OUTTEL('')
      OUTTEL('RCADEC:')
      OUTTEL('   AIDS IN THE TRANSLATION OF AN RCA COBOL PROGRAM TO DEC')
      OUTTEL('   COBOL.')
      OUTTEL('')
      OUTTEL('DECB35:')
      OUTTEL('   AIDS IN THE TRANSLATION OF A DEC COBOL PROGRAM TO')
      OUTTEL('   BURROUGHS COBOL.')
      OUTTEL('')
      OUTTEL('SEE COBAID MANUAL FOR A DETAILED EXPLANATION OF THE SUBSYSTEMS.')
   12: HELP(MAIN.HD)
   END ELSE STATE_2
END
RETURN IF STATE=0 THEN 1 ELSE -1

%MAIN.INIT
MAIN.HELP(1)_'ENTER PROGRAM BUILDER'
MAIN.HELP(2)_'ENTER ABREVIATION TRANSLATOR'
MAIN.HELP(3)_'CONVERT CONVENTIONAL TO STANDARD'
MAIN.HELP(4)_'CONVERT STANDARD TO CONVENTIONAL'
MAIN.HELP(5)_'DECISION TABLE PROCESSOR'
MAIN.HELP(6)_'IBM COBOL TO DEC'
MAIN.HELP(7)_'RCA 3301 COBOL TO DEC'
MAIN.HELP(8)_'DEC COBOL TO BURROUGHS 3500'
MAIN.HELP(9)_'RETURN TO TYMEX'
MAIN.HELP(10)_'RETURN TO TYMEX'
MAIN.HELP(11)_'EXPLANATION OF THE SUBSYSTEMS'
MAIN.HELP(12)_'PRINTS THIS LIST'

HELP.SIZE(MAIN.SIZE,MAIN.LIST)

MAIN.HD(1)_MAIN.LIST
MAIN.HD(2)_MAIN.SIZE
MAIN.HD(3)_MAIN.HELP
MAIN.HD(4)_'THE FOLLOWING SUBSYSTEMS ARE AVAILABLE:'
MAIN.HD(5)_'SUBSYSTEM? '

BLD.INIT
TRN.INIT

RETURN
END MAIN.INIT

!PROGRAM BUILDER.
!BUILD AND COMBINE SEPARATE SECTIONS OF COBOL PROGRAM EITHER BY
!PROMPTING FOR VALUES TO BE INSERTED IN SKELETON OR BY ENTERING IN
!EDITOR.
!
%BUILD
LOCAL BLD.HD(5),BLD.SIZE(9),BLD.HELP(9)
TABLE BLD.LIST(0:9)[9,'IDENTIFICATION','ENVIRONMENT','DATA' &
        ,'WORKING-STORAGE','PROCEDURE','MAKE','END','QUIT','HELP']
LOCAL %ENVIRONMENT,%DATA
LOCAL %ENV.INIT,%DATA.INIT
LOCAL STATE,N,DF

LOCAL %COBIN,%PERIOD,%CONCAT,%MARGINA,%MARGINB
LOCAL %COBCOPY,%DIVFILE,%EDIT.OLD,%EDIT

DEF NONE AS 1
DEF UCNAME AS 2
DEF FNAME AS 3

STATE_1
WHILE STATE>0 THEN DO
   DO STATE OF 3
   1: OUTTEL('')
      OUTTEL('COBOL PROGRAM BUILDER ACTIVE')
   2: OUTTEL('?')
   END

   STATE_3
   N_GD.CMND(BLD.HD)
   IF END.LINE THEN DO N OF 9
   1: IF OPEN.OUTFL(DIVFILE('IDD')) THEN DO
         MARGINA('IDENTIFICATION DIVISION.')
         OUTFLC('PROGRAM-ID. '); OUTFLC(PROGRAM); OUTFL('.')
         OUTTEL('')
         MARGINA(PERIOD(COBIN('AUTHOR. ',NONE)))
         MARGINA(PERIOD(COBIN('INSTALLATION. ',NONE)))
         MARGINA(PERIOD(COBIN('DATE-WRITTEN. ',NONE)))
         MARGINA(PERIOD(COBIN('DATE-COMPILED. ',NONE)))
         MARGINA(PERIOD(COBIN('SECURITY. ',NONE)))
         MARGINA(PERIOD(COBIN('REMARKS. ',NONE)))
         CLOSE.OUTFL
      END
   2: STATE_ENVIRONMENT
   3: STATE_DATA
   4: DF_DIVFILE('WKS')
      EIF EDIT.OLD(DF) THEN EDIT(DF)
      FIF OPEN.OUTFL(DF) THEN DO
         MARGINA('WORKING-STORAGE SECTION.')
         CLOSE.OUTFL
         EDIT(DF)
      END
   5: DF_DIVFILE('PRD')
      EIF EDIT.OLD(DF) THEN EDIT(DF)
      FIF OPEN.OUTFL(DF) THEN DO
         MARGINA('PROCEDURE DIVISION.')
         MARGINA('USER-FIRST-PARAGRAPH.')
         CLOSE.OUTFL
         EDIT(DF)
      END
   6: IF OPEN.OUTFL(DIVFILE('CBL')) THEN DO
         IF COBCOPY('IDD') AND &
            COBCOPY('ENV') AND &
            COBCOPY('DAD') AND &
            COBCOPY('WKS') AND &
            COBCOPY('PRD') THEN NULL
         CLOSE.OUTFL
      END
   7: STATE_0
   8: STATE_-1
   9: HELP(BLD.HD)
   END ELSE STATE_2
END
RETURN IF STATE=0 THEN 1 ELSE -1

%BLD.INIT
BLD.HELP(1)_'CONSTRUCT IDENTIFICATION DIVISION'
BLD.HELP(2)_'CONSTRUCT ENVIRONMENT DIVISION'
BLD.HELP(3)_'CONSTRUCT DATA DIVISION FILE SECTION'
BLD.HELP(4)_'CONSTRUCT WORKING-STORAGE SECTION'
BLD.HELP(5)_'CONSTRUCT PROCEDURE DIVISION'
BLD.HELP(6)_'COMBINE SEPARATE DIVISIONS'
BLD.HELP(7)_'RETURN TO SUPPORT COMMAND LEVEL'
BLD.HELP(8)_'RETURN TO TYMEX'
BLD.HELP(9)_'PRINTS THIS LIST'

HELP.SIZE(BLD.SIZE,BLD.LIST)

BLD.HD(1)_BLD.LIST
BLD.HD(2)_BLD.SIZE
BLD.HD(3)_BLD.HELP
BLD.HD(4)_'THE FOLLOWING FUNCTIONS ARE AVAILABLE:'
BLD.HD(5)_'FUNCTION? '

ENV.INIT
DATA.INIT

RETURN
END BLD.INIT

!CONSTRUCT ENVIRONMENT DIVSION.
!
%ENVIRONMENT
LOCAL ENV.HD(5),ENV.SIZE(6),ENV.HELP(6)
TABLE ENV.LIST(0:6)[6,'LIST','YES','NO','END','QUIT','HELP']
LOCAL STATE,N,DF

STATE_1
WHILE STATE>0 THEN DO
   DO STATE OF 3
   1: OUTTELC('IS THE STANDARD ENVIRONMENT DIVISION SUFFICIENT?')
   2: OUTTEL('?')
   END

   STATE_3
   N_GD.CMND(ENV.HD)
   IF END.LINE THEN DO N OF 6
   1: OUTTEL('')
      OUTTEL('ENVIRONMENT DIVISION.')
      OUTTEL('CONFIGURATION SECTION.')
      OUTTEL('SOURCE-COMPUTER. PDP-10.')
      OUTTEL('OBJECT-COMPUTER. PDP-10.')
      OUTTEL('INPUT-OUTPUT SECTION.')
      OUTTEL('FILE-CONTROL.')
      OUTTEL('        SELECT XXX ASSIGN TO DSK')
      OUTTEL('        RECORDING MODE IS ASCII.')
      OUTTEL('(WHERE XXX IS A NAME SUPPLIED BY THE USER)')
      OUTTEL('(ANY NUMBER OF SELECT STATEMENTS ARE ALLOWED.)')
      OUTTEL('')
   2: IF OPEN.OUTFL(DIVFILE('ENV')) THEN DO
         MARGINA('ENVIRONMENT DIVISION.')
         MARGINA('CONFIGURATION SECTION.')
         MARGINA('SOURCE-COMPUTER. PDP-10.')
         MARGINA('OBJECT-COMPUTER. PDP-10.')
         MARGINA('INPUT-OUTPUT SECTION.')
         MARGINA('FILE-CONTROL.')

         OUTTEL('')
         OUTTEL('TYPE <CR> WHEN DONE')
         OUTTEL('')

         WHILE MARGINB(CONCAT(COBIN('SELECT ',UCNAME),' ASSIGN TO DSK')) &
                  THEN MARGINB('RECORDING MODE IS ASCII.')

         CLOSE.OUTFL ; STATE_0
      END
   3: DF_DIVFILE('ENV')
      EIF EDIT.OLD(DF) THEN EDIT(DF)
      FIF OPEN.OUTFL(DF) THEN DO
         MARGINA('ENVIRONMENT DIVISION.')
         CLOSE.OUTFL
         EDIT(DF)
      END
   4: STATE_0
   5: STATE_-1
   6: HELP(ENV.HD)
   END ELSE STATE_2
END
RETURN IF STATE=0 THEN 1 ELSE -1

%ENV.INIT
ENV.HELP(1)_'LIST STANDARD ENVIRONMENT DIVISION'
ENV.HELP(2)_'USE STANDARD ENVIRONMENT DIVISION'
ENV.HELP(3)_'CREATE ENVIRONMENT DIVISION IN EDITOR'
ENV.HELP(4)_'RETURN TO PROGRAM BUILDER'
ENV.HELP(5)_'RETURN TO TYMEX'
ENV.HELP(6)_'PRINTS THIS LIST'

HELP.SIZE(ENV.SIZE,ENV.LIST)

ENV.HD(1)_ENV.LIST
ENV.HD(2)_ENV.SIZE
ENV.HD(3)_ENV.HELP
ENV.HD(4)_'CORRECT ANSWERS ARE:'
ENV.HD(5)_'? '

RETURN
END ENV.INIT

END ENVIRONMENT

!CONSTRUCT FILE SECTION OF DATA DIVISION
!
%DATA
LOCAL DATA.HD(5),DATA.SIZE(6),DATA.HELP(6)
TABLE DATA.LIST(0:6)[6,'BUILD','APPEND','EDIT','END','QUIT','HELP']
LOCAL STATE,N

LOCAL %DATA.DEF

STATE_1
WHILE STATE>0 THEN DO
   DO STATE OF 3
   1: OUTTEL('')
      OUTTEL('DATA DIVISION BUILDER ACTIVE')
   2: OUTTEL('?')
   END

   STATE_3
   N_GD.CMND(DATA.HD)
   IF END.LINE THEN DO N OF 6
   1: IF OPEN.OUTFL(DIVFILE('DAD')) THEN DATA.DEF
   2: IF UPD.OUTFL(DIVFILE('DAD')) THEN DATA.DEF
   3: EDIT(DIVFILE('DAD'))
   4: STATE_0
   5: STATE_-1
   6: HELP(DATA.HD)
   END ELSE STATE_2
END
RETURN IF STATE=0 THEN 1 ELSE -1

%DATA.INIT
DATA.HELP(1)_'CONSTRUCT DATA DIVISION FILE SECTION'
DATA.HELP(2)_'APPEND TO DATA DIVISION FILE SECTION'
DATA.HELP(3)_'EDIT DATA DIVISION FILE SECTION'
DATA.HELP(4)_'RETURN TO PROGRAM BUILDER'
DATA.HELP(5)_'RETURN TO TYMEX'
DATA.HELP(6)_'PRINTS THIS LIST'

HELP.SIZE(DATA.SIZE,DATA.LIST)

DATA.HD(1)_DATA.LIST
DATA.HD(2)_DATA.SIZE
DATA.HD(3)_DATA.HELP
DATA.HD(4)_'THE FOLLOWING COMMANDS ARE AVAILABLE:'
DATA.HD(5)_'COMMAND? '

RETURN
END DATA.INIT

!PROMPT FOR 'FD' SPECIFICATION FOR FILE SECTION OF DATA DIVISION
!AND PUT TO OUTPUT FILE. EXIT ON NULL 'FD' NAME.
!
%DATA.DEF
MARGINA('DATA DIVISION.')
MARGINA('FILE SECTION.')
LOOP DO
   OUTTEL('')
   WHILE MARGINA(COBIN('FD ',UCNAME))
   MARGINB(COBIN('BLOCK CONTAINS ',NONE))
   MARGINB(COBIN('RECORD CONTAINS ',NONE))
   MARGINB(COBIN('LABEL RECORDS ARE ',NONE))
   MARGINB(COBIN('VALUE OF IDENTIFICATION IS ',FNAME))
   MARGINB(COBIN('VALUE OF DATE-WRITTEN IS ',NONE))
   MARGINB(PERIOD(COBIN('DATA RECORDS ARE ',NONE)))
   OUTTEL('ENTER YOUR RECORD DESCRIPTIONS HERE (<CR> WHEN DONE):')
   LOOP DO
      OUTTELC('? ')
      WHILE LINE.GET
      REMOVE.CR(IMAGE)
      EIF NCHV COMLINE=$- OR CHV COMLINE=$* OR &
            (CHV COMLINE=$0 AND NCHV COMLINE=$1) THEN &
            MARGINA(IMAGE)
      ELSE MARGINB(IMAGE)
   END
END
CLOSE.OUTFL
RETURN
END DATA.DEF

END DATA

!PROMPT FOR SKELETON VALUE. IF NULL STRING, RETURN 0. OTHERWISE,
!CHECK FOR USER CREATED NAME OR FILE NAME. IF OK, RETURN
!PROMPT CONCATENATED WITH VALUE. ELSE REPROMPT.
!
%COBIN(KEY,CHECK)
LOCAL %UCNCHK,%FNCHK,C,VALUE(0:10)

VALUE(0)_2
VALUE(1)_KEY

LOOP DO
   OUTTELC(KEY)
   IF NOT LINE.GET THEN RETURN 0
   REMOVE.CR(IMAGE)
   C_NCHV COMLINE
   DO CHECK OF NONE:FNAME
   NONE: VALUE(2)_IMAGE ; RETURN VALUE
   UCNAME: IF UCNCHK THEN RETURN VALUE
   FNAME: EIF C=$" THEN IF FNCHK THEN RETURN VALUE
          FIF UCNCHK THEN RETURN VALUE
   END
   OUTTEL('')
END

!CHECK FOR VALID USER CREATED NAME.
!
%UCNCHK
LOCAL %UCNC
IF UCNC THEN RETURN 1
OUTTELC(IMAGE) ; OUTTEL(' IS NOT A LEGAL NAME')
RETURN 0

%UCNC
LOCAL LETTER,PC
IF C=$- THEN RETURN 0
LETTER_0
WHILE C#EOLIT AND C#$. THEN DO
   EIF $A<=C<=$Z OR C=$- THEN INC LETTER
   FIF NOT $0<=C<=$9 THEN RETURN 0
   PC_C<==NCHV COMLINE
END
IF C=$. AND NCHV COMLINE#EOLIT THEN RETURN 0
VALUE(2)_IMAGE
RETURN [LETTER AND PC#$-]
END UCNC
END UCNCHK

!CHECK FOR VALID FILE NAME. ACCEPT NAME AS <FILE>.<EXT> OR AS
!<FILE BLANK PADDED TO 6 CHARACTERS><EXTENSION BLANK PADDED TO 3> .
!CONVERT FIRST FORMAT TO SECOND.
!
%FNCHK
LOCAL %FNC
IF FNC THEN RETURN 1
OUTTELC(IMAGE) ; OUTTEL(' IS NOT A FILE NAME')
RETURN 0

%FNC
LOCAL NF,NE,FP,FILE(0:2)

NF_6 ; NE_3 ; FP_CHPT(FILE,-1) ; NCHV FP_$"

WHILE C_NCHV COMLINE#EOLIT THEN DO
   EIF $A<=C<=$Z OR $0<=C<=$9 THEN DO
      EIF NF>0 THEN DEC NF
      ORIF NE>0 THEN DEC NE
      ELSE RETURN 0
      NCHV FP_C
   END
   ORIF C=$. THEN DO
      IF NE#3 THEN RETURN 0
      IF NF>0 THEN LOOP [NCHV FP_$ ; WHILE DEC NF>0]
   END
   ORIF C=$  THEN DO
      EIF NF>0 THEN LOOP [NCHV FP_C ; WHILE DEC NF>0 ; IF C_NCHV COMLINE#$  THEN RETURN 0]
      FIF NE>0 THEN LOOP [NCHV FP_C ; WHILE DEC NE>0 ; IF C_NCHV COMLINE#$  THEN RETURN 0]
   END
   ORIF C=$" THEN DO
      IF NF>0 OR NE>0 THEN REPEAT NF+NE NCHV FP_$ 
      NCHV FP_$"
      IF NCHV COMLINE#EOLIT THEN DO
         IF CHV COMLINE#$. OR NCHV COMLINE#EOLIT THEN RETURN 0
         NCHV FP_$.
      END
      NCHV FP_EOLIT
      VALUE(2)_FILE
      RETURN 1
   END
   ELSE RETURN 0
END
RETURN 0
END FNC
END FNCHK

END COBIN

%PERIOD(STRING())
LOCAL P
IF STRING THEN DO
   P_STRING(STRING(0))
   IF ADDRESS(P) THEN P_CHPT(P,-1)
   WHILE NCHV P#EOLIT THEN NULL
   IF PCHV P#$. THEN CONCAT(STRING,'.')
END
RETURN STRING
END PERIOD

%CONCAT(STRING(),ADDITION)
IF STRING THEN STRING(INC STRING(0))_ADDITION
RETURN STRING
END CONCAT

!OUTPUT STRING IN COBOL MARGIN A
!
%MARGINA(STRING)
IF STRING THEN OUTFL(STRING)
RETURN STRING
END MARGINA

!OUTPUT STRING IN COBOL MARGIB B
!
%MARGINB(STRING)
IF STRING THEN [OUTFLC('        ') ; OUTFL(STRING)]
RETURN STRING
END MARGINB

!COPY DIVISION FILE WITH EXTENSION 'EXT' TO 'OUTFILE'. IF FILE
!NOT CREATED, RETURN FALSE, ELSE TRUE.
!
%COBCOPY(EXT)
LOCAL EOF:
IF OPEN.INFL(DIVFILE(EXT)) THEN DO
   SET.RWE(IN.FILE,EOF)
   LOOP WX(OUT.FILE,R(IN.FILE))
   EOF: RETURN EOF.CHECK
END
RETURN 0
END COBCOPY

!GENERATE DIVISION FILE FROM NAME IN 'PROGRAM' AND 'EXT'
!
%DIVFILE(EXT)
LOCAL BUFF(0:2)
MOVE 2 FROM PROGRAM TO BUFF
ADD.EXT(BUFF,EXT)
RETURN BUFF
END DIVFILE

!CHECK IF FILE 'FILE' EXISTS AND IF THE USER WISHES TO EDITED IT
!RATHER THAN CREATING A NEW FILE. RETURN TRUE TO RETAIN OLD AND FALSE
!TO CREATE NEW.
!
%EDIT.OLD(FILE)
LOCAL I,NEW.FILE:
TABLE YES.NO(0:2)[2,'NO','YES']
CLOSE(OPEN(FILE,SEQUEN+INPUT+CHARACTER,NEW.FILE,2))
OUTTELC(FILE) ; OUTTELC(' EXISTS. DO YOU WANT TO ADD TO IT? ')
WHILE NOT(LINE.GET AND I_COMAND(YES.NO) AND END.LINE) &
         THEN OUTTELC('TYPE YES OR NO: ')
RETURN I-1
NEW.FILE: ON.ALT.C ; RETURN 0
END EDIT.OLD

!RUN EDITOR ON FILE 'FILE'.
!SAVE PROGRAM ID ON TMPCORE FILE 'CBA'
!INSTRUCT TYMEX TO RETURN TO COBAID WITH TMPCOR FILE 'SVC'
!INSTRUCT EDITOR TO EDIT FILE WITH TMPCORE FILE 'EDT'
!
%EDIT(FILE)
LOCAL BUFF(0:10),P,PB,N

WRITE.TMP('CBA',PROGRAM,2)

PB_CHPT(BUFF,-1) ; P_CHPT('LOAD/RUN SYS:COBAID',-1) ; N_0
WHILE NCHV PB_NCHV P#EOLIT THEN INC N
CHV PB_CARRET ; NCHV PB_LNFEED ; NCHV PB_EOLIT
WRITE.TMP('SVC',BUFF,((N+2)/CPW+1))

PB_CHPT(BUFF,-1) ; P_CHPT(FILE,-1)
NCHV PB_$  ; N_1
WHILE NCHV PB_NCHV P#EOLIT THEN INC N
CHV PB_CARRET ; NCHV PB_LNFEED ; NCHV PB_EOLIT
WRITE.TMP('EDT',BUFF,((N+2)/CPW+1))

RUN('EDITOR',1)

END EDIT

END BUILD

!ABREVIATION TRANSLATOR.
!
%TRANSLATE
LOCAL TRN.HD(5),TRN.SIZE(8),TRN.HELP(8)
TABLE TRN.LIST(0:8)[8,'STANDARD','DEFINE','SAVE','LIST','EXPAND' &
        ,'END','QUIT','HELP']
LOCAL STATE,N,P.FILE,SETERR:,%EXPAND,%CLEAR.SYM.BUF

LOCAL %READ.ABREV,%WRITE.ABREV

DEF SYM.BUF.LEN AS 64
FIND %SYMPOS,%GETSYM,%NEW.SYM.TBL,%R.LEAS.SYM.TBL,SYMBUF(0:SYM.BUF.LEN)
FIND %ENT.SYM,%STORE.TEXT,%DMP,%D.NXT.SYM,%INIT.SYM.PAK

LOCAL SYM.BUF.POS(0:100),T.SYM.BUF(0:SYM.BUF.LEN)
LOCAL ABREV

DEF SYM.BUF.COUNT(I) AS SYMBUF(0)_((I+1)/CPW)+1

STATE_1
WHILE STATE>0 THEN DO
   DO STATE OF 3
   1: OUTTEL('')
      OUTTEL('COBOL ABREVIATION TRANSLATOR ACTIVE')
      P.FILE_GET.FILE('PROGRAM FILE: ',CBL.EXT)
      ABREV_NEW.SYM.TBL(2,0)
   2: OUTTEL('?')
   END

   STATE_3
   DO N_GD.CMND(TRN.HD) OF 8
   1: EIF NOT END.LINE THEN STATE_2
      FIF OPEN.INFL('SYS:ABREV.STD') THEN READ.ABREV
   2: EIF END.LINE THEN [IN.FILE_TEL ; READ.ABREV]
      FIF OPEN.INFL(COMLINE) THEN READ.ABREV
   3: WHILE END.LINE OR NOT OPEN.OUTFL(COMLINE) &
            THEN [OUTTELC('TO: ') ; LINE.GET]
      WRITE.ABREV
   4: EIF END.LINE THEN [OUTTEL('') ; OUT.FILE_TEL; WRITE.ABREV]
      ELSE STATE_2
   5: IF OPEN.INFL(P.FILE) THEN DO
         EIF END.LINE THEN IF OPEN.OUTFL(P.FILE) THEN EXPAND
         FIF OPEN.OUTFL(COMLINE) THEN EXPAND
      END6: STATE_0
   7: STATE_-1
   8: HELP(TRN.HD)
   END
END
R.LEAS.SYM.TBL(ABREV)
RETURN IF STATE=0 THEN 1 ELSE -1

%TRN.INIT
TRN.HELP(1)_'USE STANDARD ABREVIATIONS'
TRN.HELP(2)_'DEFINE ABREVIATIONS'
TRN.HELP(3)_'SAVE ABREVIATIONS ON FILE'
TRN.HELP(4)_'LIST CURRENT ABREVIATIONS'
TRN.HELP(5)_'EXPAND ABREVIATIONS'
TRN.HELP(6)_'RETURN TO SUPPORT COMMAND LEVEL'
TRN.HELP(7)_'RETURN TO TYMEX'
TRN.HELP(8)_'PRINTS THIS LIST'

HELP.SIZE(TRN.SIZE,TRN.LIST)

TRN.HD(1)_TRN.LIST
TRN.HD(2)_TRN.SIZE
TRN.HD(3)_TRN.HELP
TRN.HD(4)_'THE FOLLOWING FUNCTIONS ARE AVAILABLE:'
TRN.HD(5)_'FUNCTION? '

INIT.SYM.PAK

RETURN
END TRN.INIT

!READ ABREVIATIONS FROM TERMINAL OR FILE AND STORE IN SYMBOL TABLE 'ABREV'
!
%READ.ABREV
LOCAL EOF:,P,C,S,NS,N,I,%ABVEND
IF IN.FILE=TEL THEN OUTTEL('') ELSE SETRWE(IN.FILE,EOF)
LOOP DO
!
!READ A LINE PROMPT WITH '?' IF FROM TERMINAL. IF EMPTY LINE
! AND FROM TERMINAL THEN EXIT.
!
   IF IN.FILE=TEL THEN OUTTELC('? ')
   P_GETLINE(IN.FILE)
   EIF GLCNT<2 THEN WHILE IN.FILE#TEL
   ELSE DO
      N_0
!
!READ ABREVIATION AND PUT IN SYMBOL TABLE SAVING TABLE POSITION
!
      LOOP DO
         S_CLEAR.SYM.BUF
         NS_SYM.BUF.LEN*CPW-1
         WHILE NOT ABVEND(C_NCHV P) THEN [WHILE DEC NS>=0 ; NCHV S_C]
         SYM.BUF.COUNT(SYM.BUF.LEN*CPW-NS-1)
         IF NOT SYM.BUF.POS(INC N)_SYM.POS(ABREV) THEN SYM.BUF.POS(N)_ENT.SYM
         WHILE C=$!
      END
!
!ERROR, IF ABREVIATION TOO LONG OR DOES NOT CONTAIN AN EXPANSION
!
      IF C=CARRET OR NS<0 THEN DO
         OUTTEL('ILLEGAL ABREVIATION')
         IF IN.FILE#TEL THEN OUTTEL(FREE)
      END ELSE DO
!
!READ EXPANSION.
!
         S_CLEAR.SYM.BUF
         NS_SYM.BUF.LEN*CPW-1
         EIF C=$: THEN WHILE NCHV S_NCHV P#CARRET AND DEC NS>=0 THEN NULL
         ELSE LOOP DO
            WHILE NCHV S_NCHV P#CARRET THEN WHILE DEC NS>=0
            INC NS ; WHILE PCHV S#$_
            DEC NS ; NCHV S
            WHILE DEC NS>=0
            IF IN.FILE=TEL THEN OUTTELC('_ ')
            P_GETLINE(IN.FILE)
         END
         IF NS>=0 THEN DO
!
!STORE EXPANSION AND PUT ADDRESS OF TEXT IN SYMBOL TABLE FOR EACH ABREVIATION.
!
            CHV S_EOLIT
            NS_SYM.BUF.COUNT(SYM.BUF.LEN*CPW-NS-1)
            C_STORE.TEXT
            FOR I_1 TO N ^SYM.BUF.POS(I)_C
         END ELSE DO
!
!ERROR. EXPANSION TOO LONG. IF FROM FILE, RPINT DEFINITION.
!
            OUTTEL('ABREVIATION TOO LONG')
            IF IN.FILE#TEL THEN DO
               MOVE SYM.BUF.LEN FROM SYM.BUF+1 TO T.SYM.BUF
               FOR I_1 TO N DO
                  GET.SYM(SYM.BUF.POS(I))
                  OUTTELC(@SYM.BUF(1))
                  W(TEL,IF I=N THEN C ELSE $!)
               END
               OUTTEL(T.SYM.BUF)
            END
         END
      END
   END
END
EOF: EOF.CHECK
RETURN

%ABVEND(C)
RETURN [C=$! OR C=$: OR C=$_ OR C=CARRET]
END ABVEND
END READ.ABREV

!WRITE ABREVIATION DEFINITIONS ON A FILE OR THE TERMINAL
!
%WRITE.ABREV
LOCAL EOL:,I,P,C
DMP(ABREV,EOL)
LOOP DO
   IF ^(I_D.NXT.SYM) THEN DO
      GET.SYM(I)
      OUTFLC(@SYM.BUF(1))
      P_CHPT(^I,-1)
      WHILE C_NCHV P#EOLIT AND C#CARRET THEN NULL
      EIF C=EOLIT THEN [OUTFLC(':') ; OUTFL(^I)]
      ELSE [OUTFLC('_') ; OUTFLC(^I) ; OUTFL('_')]
   END
END
EOL: CLOSE.OUTFL
RETURN
END WRITE.ABREV

!SCAN FILE FOR ABREVIATIONS AND REPLACE WITH EXPANSION.
!ONLY ALLOW EXPANSION TO A DEPTH OF 10.
!
%EXPAND
LOCAL TEXT,C,T.STK(10),C.STK(10),S,NS,%BREAK,EOF:

SETRWE(IN.FILE,EOF)
LOOP DO
!
!GET NEXT LINE OF TEXT FROM FILE
!
   TEXT_GETLINE(INFILE)
   N_0
   C_NCHV TEXT
   LOOP DO
!
!SCAN TO FIRSTS NONBREAK CHARACTER
!
      WHILE BREAK(C) THEN [W(OUT.FILE,C) ; C_NCHV TEXT]
      IF C=EOLIT THEN DO
!
!END OF LINE. GET NEXT LINE UNLESS ONE IS ON STACK.
!
         WHILE N>0
         TEXT_T.STK(N) ; C_C.STK(N) ; DEC N
      END ELSE DO
!
!READ POSSIBLE ABREVIATION
!
         S_CLEAR.SYM.BUF
         NS_SYM.BUF.LEN*CPW-1
         LOOP DO
            WHILE DEC NS>=0
            NCHV S_C
            WHILE C_NCHV TEXT#EOLIT AND NOT BREAK(C)
         END
         IF NS<0 THEN DO
!
!CANNOT BE AN ABREVIATION SINCE IT IS TOO LONG. SCAN TO BREAK
!
            OUTFLC(@SYM.BUF(1))
            LOOP DO
               W(OUT.FILE,C)
               WHILE C_NCHV TEXT#EOLIT AND NOT BREAK(C)
            END
         END ELSE DO
            SYM.BUF.COUNT(SYM.BUF.LEN*CPW-NS-1)
            IF S_SYMPOS(ABREV) THEN DO
!
!ABREVIATION IN TABLE. STACK CURRENT SOURCE AND START SCANNING EXPANSION
!
               IF N>=10 THEN DO
                  OUTTEL('MORE THAN 10 SUBSTITUTIONS')
                  OUTFLC(@SYM.BUF(1))
               END ELSE DO
                  T.STK(INC N)_TEXT ; C.STK(N)_C
                  TEXT_CHPT(^S,-1) ; C_NCHV TEXT
               END
            END ELSE OUTFLC(@SYM.BUF(1))
         END
      END
   END
END
EOF: EOF.CHECK ; CLOSE.OUTFL
RETURN

%BREAK(C)
TABLE BC(9)[$ ,$.,$,,CARRET,LNFEED,$;,$(,$),OCT 11]
LOCAL I
FOR I_1 TO 9 IF C=BC(I) THEN RETURN 1
RETURN 0
END BREAK
END EXPAND

%CLEAR.SYM.BUF
MOVE SYM.BUF.LEN FROM ALL 0 TO @SYM.BUF(1)
RETURN CHPT(@SYM.BUF(1),-1)
END CLEAR.SYM.BUF

END TRANSLATE

%STDCON
LOCAL IDENT(0:1),P,PID,N,C,QUOTE,COMMENT,LINE.NO,EOF:,%W.SEQ,%W.ID
LOCAL %INIT.NEXT.CHAR,%NEXT.CHAR

WHILE NOT OPEN.INFL(GET.FILE('INPUT FILE(STANDARD): ',CBL.EXT)) THEN NULL
WHILE NOT OPEN.OUTFL(GET.FILE('OUTPUT FILE(CONVENTIONAL): ',CBL.EXT)) THEN NULL
MOVE 2 FROM IMAGE TO IDENT
OUTTEL('') ; OUTTELC('DECK-ID: ')
IF LINE.GET THEN MOVE 2 FROM IMAGE TO IDENT
N_8 ; P_PID_CHPT(IDENT,-1)
WHILE C_NCHV P#CARRET AND DEC N>=0 THEN NULL
IF N>0 THEN [PCHV P; REPEAT N NCHV P_$ ]

QUOTE_0 ; LINE.NO_0 ; COMMENT_0
INIT.NEXT.CHAR
SETRWE(IN.FILE,EOF)
LOOP DO
   C_NEXT.CHAR
   IF C=$- AND (COMMENT OR LINE.NO=0) THEN DO
      OUTTELC('CONTINUATION LINE CANNOT ')
      EIF COMMENT THEN OUTTELC('FOLLOW COMMENT')
      ELSE OUTTELC('BE FIRST LINE OF FILE')
      OUTTEL('. LINE IGNORED')
      WHILE NEXT.CHAR#LNFEED THEN NULL
   END ELSE DO
      IF QUOTE AND (C=$* OR C=$ ) THEN OUTTEL('LITERAL NOT CONTINUED')
      COMMENT_[C=$*] ; QUOTE_0
      W.SEQ
      N_66
      IF C#$  AND C#$- AND C#$* THEN [W(OUT.FILE,$ ) ; DEC N]
      WHILE N>0 THEN DO
         WHILE C#CARRET AND DEC N>=0 THEN DO
            W(OUT.FILE,C)
            IF NOT COMMENT AND C=$" THEN QUOTE BXOR_1
            C_NEXT.CHAR
         END
         EIF N>0 THEN DO
            EIF QUOTE THEN [WHILE NEXT.CHAR#$" THEN NULL ; C_NEXT.CHAR]
            ELSE [REPEAT N W(OUT.FILE,$ ) ; N_0]
         END
         FIF N<0 THEN DO
            W.ID ; W.SEQ ; N_66
            EIF COMMENT THEN [W(OUT.FILE,$*) ; DEC N]
            ELSE DO
               W(OUT.FILE,$-) ; DEC N
               REPEAT 4 [W(OUT.FILE,$ ) ; DEC N]
               IF QUOTE THEN [W(OUT.FILE,$") ; DEC N]
            END
         END
      END
      NEXT.CHAR ! IGNORE LINE FEED
      W.ID
   END
END
EOF: EOF.CHECK ; CLOSE.OUTFL
RETURN 1

%INIT.NEXT.CHAR
LOCAL SAVE,C,SP.CNT
SAVE_RETURN
NEXT.CHAR

LOOP DO
   WHILE C_R(IN.FILE)=EOLIT THEN NULL
   IF C=$  AND NOT QUOTE THEN DO
      SP.CNT_1
      WHILE C_R(IN.FILE)=$  THEN INC SP.CNT
      IF C#CARRET THEN REPEAT SP.CNT NEXT.CHAR($ )
   END
   NEXT.CHAR(C)
END

%%NEXT.CHAR(VAL)
SAVE<=>RETURN
RETURN VAL

END INIT.NEXT.CHAR

%W.SEQ
LOCAL I,L,D
I_100000 ; L_INC LINE.NO
WHILE I>0 THEN DO
   [D;L]_L DIVMOD I
   I/_10
   W(OUT.FILE,D+$0)
END
RETURN
END W.SEQ

%W.ID
LOCAL P
P_PID
REPEAT 8 W(OUT.FILE,NCHV P)
W(OUT.FILE,CARRET)
RETURN
END W.ID

END STDCON

!CONVENTIONAL TO STANDARD FORMAT CONVERTER.
!REMOVE TRAILING BLANKS EXCEPT FROM CONTINUED QUOTED STRINGS.
!
%CONSTD
LOCAL C,EOF:,COMMENT,QUOTE,SP.CNT
WHILE NOT OPEN.INFL(GET.FILE('INPUT FILE(CONVENTIONAL): ',CBL.EXT)) THEN NULL
WHILE NOT OPEN.OUTFL(GET.FILE('OUTPUT FILE(STANDARD): ',CBL.EXT)) THEN NULL
SETRWE(IN.FILE,EOF)
LOOP DO
   REPEAT 6 R(IN.FILE)  ! IGNORE SEQUENCE NUMBER
   IF C_R(IN.FILE)#CARRET THEN DO
      W(OUT.FILE,C) ! WRITE CONTINUATION FIELD
      COMMENT_[C=$*] ; QUOTE_0 ; SP.CNT_0
      LOOP DO
         REPEAT 65
         WHILE C_R(IN.FILE)#CARRET
         EIF C=$  AND (COMMENT OR NOT QUOTE) THEN INC SP.CNT
         ELSE DO
            IF SP.CNT>0 THEN [REPEAT SP.CNT W(OUT.FILE,$ ) ; SP.CNT_0]
            W(OUT.FILE,C)
            IF C=$" THEN QUOTE BXOR_1
         END
      END
   END
   WHILE R(IN.FILE)#LNFEED THEN NULL
   W(OUT.FILE,CARRET)
END
EOF: EOF.CHECK ; CLOSE.OUTFL
RETURN 1
END CONSTD

END MAIN

!ADD EXTENSION 'EXT' TO FILE NAME IN 'BUFF'
!
%ADD.EXT(BUFF,EXT)
LOCAL PB,PE
PB_CHPT(BUFF,-1)
PE_CHPT(EXT,-1)
WHILE NCHV PB#EOLIT THEN NULL
CHV PB_$.
WHILE NCHV PB_NCHV PE#EOLIT THEN NULL
RETURN
END ADD.EXT

!OUTPUT TO TERMINAL (OUTTEL,OUTTELC) OR OUTPUT TO FILE 'OUTFL'
!(OUTFL,OUTFLC). APPEND CR TO OUTPUT (OUTTEL,OUTFL) OR NOT
!(OUTTELC,OUTFLC). ARGUMENT IS EITHER A STRING POINTER, THE ADDRESS
!OF THE FIRST WORD OF TEXT OR A FLOATING ARRAY 'S()'
!WHERE S(0) CONTAINS THE NUMBER OF WORDS IN THE ARRAY. THE ARRAY
!ELEMENTS ARE EITHER STRING POINTERS OR ADDRESSES OF TEXT.
!
%OUTTEL(S())
LOCAL %OUT1
OUT1(TEL,1)
RETURN

%%OUTTELC(S())
OUT1(TEL,0)
RETURN

%%OUTFL(S())
OUT1(OUT.FILE,1)
RETURN

%%OUTFLC(S())
OUT1(OUT.FILE,0)
RETURN

%OUT1(F,CR)
LOCAL I,%OUT2
EIF S=0 THEN RETURN
ORIF ADDRESS(S) AND 0<S(0)<=10 THEN FOR I_1 TO S(0) OUT2(S(I))
ELSE OUT2(S)
IF CR THEN W(F,CARRET)
RETURN

%OUT2(S)
LOCAL C
IF ADDRESS(S) THEN S_CHPT(S,-1)
WHILE C_NCHV S#EOLIT THEN W(F,C)
RETURN
END OUT2
END OUT1

END OUTTEL

!FILE OPENING ROUTINES. ARGUMENT IS EITHER A STRING POINTER, THE
!ADDRESS OF THE FILE NAME TEXT OR THE NEGATIVE OF THE ADDRESS
!OF AN IOCS FILE TABLE.
!
%OPEN.OUTFL(FILE)
LOCAL %FSCAN,OPNERR:
OUT.FILE_OPEN(FSCAN,SEQUEN+OUTPUT+CHARACTER,OPNERR,2)
RETURN 1

%%UPD.OUTFL(FILE)
OUT.FILE_OPEN(FSCAN,DIRECT+UPDATE+OLD+CHARACTER,OPNERR)
SET.CP(OUT.FILE,SIZE(OUT.FILE))
RETURN 1

%%OPEN.INFL(FILE)
IN.FILE_OPEN(FSCAN,SEQUEN+INPUT+CHARACTER,OPNERR,2)
RETURN 1

OPNERR: ON.ALT.C
DO ERRNUM OF FNFERR:FBSERR
FNFERR: OUTTELC('FILE NOT FOUND')
IUSERR: OUTTELC('INVALID USER NAME')
PRTERR: OUTTELC('PROTECTION VIOLATION ATTEMPT')
FBSERR: OUTTELC('FILE BUSY')
END
OUTTELC('. FILE: ') ; WFID(FIDP) ; OUTTEL('')
RETURN 0

%FSCAN
LOCAL FID.TBL(0:WPF)
IF ADDRESS(-FILE) THEN RETURN FILE
IF ADDRESS(FILE) THEN FILE_CHPT(FILE,-1)
SETFID(FID.TBL,@FILE,0,OPNERR)
RETURN -FID.TBL
END FSCAN
END OPEN.OUTFL

!FILE CLOSING ROUTINES
!
%CLOSE.OUTFL
RETURN CLOSE(OUT.FILE)
END CLOSE.OUTFL

%CLOSE.INFL
RETURN CLOSE(IN.FILE)
END CLOSE.INFL

!CLOSE INFILE AND CLEAR ANY DISABLED ALTMODE.
!
%EOF.CHECK
CLOSE.INFL
ON.ALT.C
RETURN 1
END EOF.CHECK

!READ LINE FROM TERMINAL, REMOVE LEADING SPACES AND STORE STRING POINTER
!IN 'COMLINE'. RETURN FALSE IF EMPTY LINE, ELSE TRUE.
!
%LINE.GET
COMLINE_GETLINE(TEL)
REMOVE.SP(COMLINE)
RETURN [NOT END.LINE]
END LINE.GET

!RETURN TRUE IF 'COMLINE' IS EMPTY, ELSE FALSE.
!
%END.LINE
LOCAL P
P_COMLINE
RETURN [NCHV P=CARRET]
END END.LINE

!SCAN COMMAND LIST 'LIST' FOR A MATCH FROM 'COMLINE'. RETURN INDEX IN
!LIST IF FOUND, ELSE 0. IF FOUND, 'COMLINE' POINTS TO CHARACTER BEFORE
!FIRST NONBLANK AFTER COMMAND.
!
%COMAND(LIST())
LOCAL MATCH,I,PL,PC,N,MATN
MATCH_0
FOR I_1 TO LIST(0) DO
   PC_CHPT(LIST(I),-1)
   PL_COMLINE
   N_0
   WHILE NCHV PL=NCHV PC THEN INC N
   IF N>0 THEN IF NOT MATCH OR N>MATN THEN [MATCH_I ; MATN_N] &
                  ELSE IF N=MATN THEN MATCH_0
END
IF MATCH THEN DO
   REPEAT MATN NCHV COMLINE
   REMOVE.SP(COMLINE)
END
RETURN MATCH
END COMAND

%ALPHA.NUM(C)
RETURN [$A<=C<=$Z OR $0<=C<=$9]
END ALPHA.NUM

!SCAN 'COMLINE' FOR FILE NAME
!
%FILE.SCAN(FID.TBL,EXT)
LOCAL SETERR:
SETFID(FID.TBL,@COMLINE,EXT,SETERR)
REMOVE.SP(COMLINE)
RETURN 1
SETERR: RETURN 0
END FILE.SCAN

!PROMPT FOR VALID COMMAND AND RETURN INDEX OF COMMAND ONLY
!WHEN A CORRECT COMMAND IS TYPED.
!
%GD.CMND(HD())
LOCAL N
LOOP DO
   OUTTEL('')
   OUTTELC(HD(5))
   IF LINE.GET THEN DO
      N_COMAND(HD(1))
      IF N>0 THEN RETURN N
      OUTTEL('?')
   END
END
END GD.CMND

!PROMPT FOR FILE NAME AND RETURN WITH NEGATIVE OF THE ADDRESS OF
!AN IOCS FILE TABLE. ONLY RETURN WHEN LEGAL FILE NAME TERMINATED
!WITH A CARRIAGE RETURN IS TYPED.
!
%GET.FILE(PROMPT,EXT)
LOCAL FID.TBL(0:WPF)
LOOP DO
   OUTTEL('')
   OUTTELC(PROMPT)
   IF LINE.GET THEN DO
      WHILE NOT (FILE.SCAN(FID.TBL,EXT) AND END.LINE)
      OUTTEL('NOT A LEGAL FILE NAME')
   END
END
RETURN -FID.TBL
END GET.FILE

!PRINT HELP MESSAGE
!
%HELP(C.HD())
LOCAL C.LIST(),C.SIZE(),C.HELP(),I
C.LIST_C.HD(1)
C.SIZE_C.HD(2)
C.HELP_C.HD(3)

OUTTEL('')
OUTTEL(C.HD(4))
OUTTEL('')

FOR I_1 TO C.LIST(0) DO
   OUTTELC(C.LIST(I))
   REPEAT C.SIZE(I) OUTTELC(' ')
   OUTTEL(C.HELP(I))
END

OUTTEL('')
RETURN

%HELP.SIZE(SIZE(),LIST())
LOCAL I,M,S,P
M_0
FOR I_1 TO LIST(0) DO
   S_0 ; P_CHPT(LIST(I),-1)
   WHILE NCHV P#EOLIT THEN INC S
   M_M MAX S
   SIZE(I)_S
END
M+_3
FOR I_1 TO LIST(0) SIZE(I)_M-SIZE(I)
RETURN
END HELP.SIZE
END HELP

!READ TMPCORE FILE 'CODE' OR DISK FILE <JOB>'CODE'.TMP INTO 'BUFF'
!
%READ.TMP(CODE,BUFF,N)
LOCAL T.BLK(0:1),FILE(0:1),FID.TBL(0:WPF),F,%GET.NAME,TMPERR:
DEF IOWD(B,N) AS [18,18]*[-N,B-1]
LOCAL R.TMP.EXIT:

GET.NAME

^OCT 16_[18,18]*[2,T.BLK]
EXU(OCT 47,OCT 16,OCT 44,R.TMP.EXIT)

F_OPEN(-FID.TBL,SEQUEN+INPUT+WORD,TMPERR,2)
RB(F,N,BUFF)
CLOSE(F)
DELETE(-FID.TBL,TMPERR)

R.TMP.EXIT: RETURN

!WRITE TMPCORE FILE 'CODE' OR DISK FILE <JOB>'CODE'.TMP FROM 'BUFF'
!
%%WRITE.TMP(CODE,BUFF,N)
LOCAL W.TMP.EXIT:

GET.NAME

^OCT 16_[18,18]*[3,T.BLK]
EXU(OCT 47,OCT 16,OCT 44,W.TMP.EXIT)

F_OPEN(-FID.TBL,SEQUEN+OUTPUT+WORD,TMPERR,2)
WB(F,N,BUFF)
CLOSE(F)

W.TMP.EXIT: RETURN

%%DELETE.TMP(CODE)
LOCAL D.TMP.EXIT:,TBUFF
BUFF_@TBUFF
N_1

GET.NAME

^OCT 16_[18,18]*[2,T.BLK]
EXU(OCT 47,OCT 16,OCT 44,D.TMP.EXIT)

DELETE(-FID.TBL,D.TMP.EXIT)

D.TMP.EXIT: RETURN

TMPERR: OUTTEL('CANNOT READ/WRITE TEMPORARY FILE') ; EXIT

%GETNAME
LOCAL JOB,I,J,P
TABLE TMP.EXT[OCT 64.55.60.00.00.00]

EXU(OCT 47,OCT 16,OCT 30)
JOB_^OCT 16 ; P_CHPT(FILE,-1) ; I_100
WHILE I>0 THEN DO
   [J;JOB]_JOB DIVMOD I
   I/_10
   NCHV P_J+$0
END
I_CHPT(CODE,-1)
WHILE NCHV P_NCHV I#EOLIT THEN NULL
P_CHPT(FILE,-1)
SETFID(FID.TBL,@P,TMP.EXT,TMPERR)
T.BLK(0)_NAMARG(FID.TBL) SHL 18
T.BLK(1)_IOWD(BUFF,N)
RETURN
END GET.NAME
END READ.TMP

!EXECUTE RUN UUO ON FILE 'NAME'
!
%RUN(NAME,START)
LOCAL RUN.BLK(0:5),FID.TBL(0:WPF),P,RUNERR:
RUN.BLK(0)_OCT 63.71.63.00.00.00  ! 'SYS' IN SIXBIT
P_CHPT(NAME,-1)
SETFID(FID.TBL,@P,0,RUNERR)
RUN.BLK(1)_NAMARG(FID.TBL)
MOVE 4 FROM ALL 0 TO @RUN.BLK(2)
^OCT 16_[18,18]*[START,RUN.BLK]
EXU(OCT 47,OCT 16,OCT 35)
RUNERR: OUTTELC('CANNOT RUN ') ; OUTTELC(NAME) ; EXIT
END RUN
   Q@F³