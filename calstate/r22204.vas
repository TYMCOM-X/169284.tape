VERSION	E	22204		222.04
*
*	* * * * * R E M O T E   C O D E * * * * *
*	**A S S E M B L Y   P A R A M E T E R S**
*
*
TICKSPS		E		1200D	CLOCK TICKS/SEC.
*
DEBUG	E	0		FLAG TO IMPLEMENT DEBUGGER ON PORT 0
*
	IF	V73
IDA	E	27		INTERUPT DEVICE ADDRESS
	ELSE
IDA	E	77		INTERUPT DEVICE ADDRESS
	ENDIF
*
MACHSIZE	E	8D-4*MACH12K
*
NODETYPE	E	0
*
CRASHC	E	100026		BASIC CRASH CODE
*
*
*
* BUFFER PARAMETERS
NBUF	E	254
*
* "201" LINE PARAMETERS
RESET1	E	5253		NORMAL RESET PATTERN
RESET2	E	6527		ALTERNATE RESET PATTERN
PADAPT	E	RESET1^RESET2	PRIMATIVE ADAPTOR
MAXLINES	E	7
MAXGROUPS	E	7
NUMGROUPS	E	NGRPS0+NGRPS1+NGRPS2
*
* PORT PARAMETERS
NUMPORTS	E	20-20*(#ONLY16)
NUMPGRP		E		NUMPORTS/20	NUMBER OF PORT GROUPS
*
* RING PARAMETERS
RINGSIZE	E	1000*NUMPGRP  (MUST BE MULTIPLE OF 1000)
RINGMASK	E	776*NUMPGRP
SAMPLESIZE	E	2*NUMPGRP
*
* CORE ALLOCATION PARAMETERS.  DEPENDENT ON THE MACHINE SIZE
*	AND THE SIZE OF THE RING DRIVER BUFFER (HOW MANY
*	TERMINALS WE ARE DRIVING).
*
BOOTSTRAP	E	17733
SECTORSIZE	E	200
STBUFS	E	20000*(MACHSIZE>8D)+(16000-(RINGSIZE+2*(NLINES*SECTORSIZE)))*(MACHSIZE=8D)
ENDCODE	E	(MACHSIZE>8D)*BOOTSTRAP+(MACHSIZE=8D)*STBUFS
RING	E	STBUFS+2*(NLINES*SECTORSIZE)
RINGEND	E	RING+RINGSIZE
BUFADD	E	2*RINGEND
BUFEND	E	(BUFADD+4000)*(MACHSIZE>8D)+2*BOOTSTRAP*(MACHSIZE=8D)
	IF	QUASISBOD
*
* QUASISBOD PARAMETERS
SBODTEST	E	7*SAMPLESIZE	(MUST BE (2**I-1)*SAMPLESIZE)
SBRINGSZ	E	2*NUMPORTS	(MUST BE A POWER OF 2)
SBODMASK	E	SBRINGSZ-1
	ENDIF
*
* 2741 PARAMETERS
BAUDWIDTH	E	11*SAMPLESIZE
M8THBAUD	E	115*SAMPLESIZE
E9THBAUD	E	126*SAMPLESIZE
SBODFLAG	E	100*SAMPLESIZE
EBCDTEST	E	-2*(EBCD2741)-40*(#EBCD2741)
*
* PREPARE SWITCH WORD
SWORD	E	(-CARD201)_17+(-MARKXV)_16+(MACHSIZE/4-2)_14
SWORD	E	SWORD+(-ONLY16)_13+(-PRINTER-DPRINTER)_11
SWORD	E	SWORD+(-QUASISBOD)_10+(-EBCD2741)_7+(-NOPASSTHRU)_6
*
* CHECKSUM PARAMETER
CHECKSUM E	-1		ALWAYS GENERATE CHECKSUM
TRACE	E	0		SET IF TRACE CODE IMPLEMENTED
*	**LOW CORE -  LOCATIONS 0-77**
*
*
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
* **LOCATION ZERO**
*	BOOT WILL BRANCH TO HERE AFTER LOAD IS COMPLETE.
*	IT WILL SIT HERE UNTIL SENSE SWITCH #1 IS RESET.
*
	R	0
	JSS1	*
	JMPM	CRASH
*
*
* **LOCATION 4**
* 'REMOTE' ASSEMBLY SWITCH WORD.
*
* BITS ARE ASSIGNED AS FOLLOWS:
*
*	MASK		MEANING
*	1B5	NODE HAS A 201 CARD INSTALLED
*	4B4	NODE HAS A MARK XV INSTALLED
*	3B4	# OF 4K MEMORY MODULES OVER 8K
*	4B3	NODE MAY HAVE ONLY 16 TERMINALS
*	3B3	# OF PRINTERS INSTALLED
*	4B2	ASSEMBLED WITH THE NEW 'SBOD' CODE
*	2B2	ASSEMBLED FOR 'EBCD' 2741'S
*	1B2	ASSEMBLED FOR NO PASSTHROUGH BUFFERS
*
	R	4
SWITCHS	+SWORD			ASSEMBLY SWITCHES USED FOR THIS CODE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*
*
* **LOCATION 5**
* PLACING A VALID BUFFER NUMBER IN THIS LOCATION WILL
*	CAUSE THE LEPRECHAUN TO PLACE A CIRCUIT ZAPPER
*	IN THAT BUFFER.
*
	R	5
ZAPCIR	-1			PLEASE PLACE A ZAPPER IN THIS BUFFER (IF NON-NEG)
*
*
* **LOCATION 6 AND 7**
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*
* 'NODE TYPE' CELL AND ADDRESS OF NODE INFORMATION TABLE.
*
NTYPE	+NODETYPE
ITABLE	+INFOTABLE
*
*
* **LOCATION 10**
*	POWER FAILSAFE INTERRUPT LOCATION
*
	R	10
	JMPM	POWFAL+1	POWER FAILURE
	JMP	POWER		POWER RESTORATION
*
	IF	CARD201
*
* THESE CELLS ARE USED IN ZERO-DETECT MODE ON THE 201 LINES.
*
*
ZDET	21; 23; 25
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*
*
* **LOCATIONS 36-77**
*	***INTERRUPT LOCATIONS***
*
	R	36
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*
* RING DRIVER INTERRUPT.
*
	JMPM	RNG
*
*
* 201 CARD INTERRUPTS.
*
	JMPM	OUT0
	JMPM	IN0
	IF	NLINES>1
	JMPM	OUT1
	JMPM	IN1
	IF	NLINES>2
	JMPM	OUT2
	JMPM	IN2
	ENDIF; ENDIF
*
	ELSE
*
* **LOCATIONS 20-77**
*	***INTERRUPT LOCATIONS***
*
* WE MUST RUN BOTH THE RING DRIVER AND THE 201 LINE OFF THIS ONE INTERRUPT.
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	R	20
INT20	JMPM	JTAB,I
INT22	JMPM	IN0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ENDIF
	RPT1	(76-*)/2
	JMPM	CRASH
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	R	77
CRASHWORD	+WCI		POINTER TO LOCATION TO SAVE IN CRASH
*	**THESE LOCATIONS ARE READ BY THE SUPERVISOR**
*
*
	R	100
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
MACHNO	+MACHNUM		NODE NUMBER
INFOTABLE E	MACHNO
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
VERNO	+VERSION		VERSION NUMBER
DLOCK	0			DEBUGGER LOCK
DSWICH	0			DOWNSTREAM SWITCH
CRSHCT	0			CRASH COUNT
SWTCHO	0			CURRENT STATE OF THE 201 LINES
	0
	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
MACH	+NEIGH0			NEIGHBORS
	+NEIGH1
	+NEIGH2
IOTA	+IOTAB0			ADDRESS OF IO TABLES
	+IOTAB1
	+IOTAB2
IOTABS	-2*NGRPS0		-2*NUMBER OF GROUPS
	-2*NGRPS1
	-2*NGRPS2
GROUPN	+NGRPS0			NUMBER OF GROUPS
	+NGRPS1
	+NGRPS2
GROUPI	0			NUMBER OF GROUPS BEFORE THIS LINE
	0+NGRPS0
	0+NGRPS0+NGRPS1
BORO	10000			BEGINNING OF RECORD OUTPUT
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
BORI	10000				BEGINNING OF RECORD INPUT
	10000
	10000
RESETO	+RESET1			OUTPUT RESET PATTERN
	+RESET1
	+RESET1
RESETI	+RESET1			INPUT RESET PATTERN
	+RESET1
	+RESET1
LERLIM	+LERTRESH		LINE-ERROR-REPORT THRESHOLD CONSTANT
LOVLIM	+LOVTRESH		LINE-OVERLOAD-ERROR-REPORT THRESHOLD CONSTANT
CRPNT	+CRSAVE			POINTER TO CRASH-SAVE TABLE
	IF	CHECKSUM
CKFLAG	-1			FLAG TO CAUSE CHECKSUM REPORTING (UNLESS = 0)
	ENDIF
FRECOR	+SLACK			AMOUNT OF FREE CODE SPACE IN THIS NODE
*	**FLAGS AND TEMP CELLS**
*
*
*	* * * * I N I T 0   B L O C K   S E T   =   0   B Y   C R A S H * * * *
INIT0	E	*		START OF BLOCK 'CRASH' INITS TO 0
FLAG	E	*
* GENBUF MUST BE FIRST...UNASSIGNED BUFFERS USE BIT 0 OF GENBUF
	IF	DEBUG
* DEBUGGER USES BIT 17 OF GENBUF
	ENDIF
GENBUF	0			FLAG FOR CHARACTER IN SUPERVISORY CHANNEL
TCW	R	*+2		TERMINAL CHARACTER WAITING
LOGIN	R	*+2		ARRAY FOR LOGIN MODE
LOGF	E	20*(LOGIN-FLAG)
* RT7 REQUIRES CFOB TO BE LAST GROUP OF FLAGS
CFOB	R	*+NUMGROUPS	CANDIDATES FOR OUTPUT BUFFER
PCFOB	R	*+NUMGROUPS	PROCESSED CANDIDATES FOR OUTPUT BUFFER
RSBF	R	*+NUMGROUPS	RESTRICTED BUFFER FLAGS
CPS	R	*+10		CARRIER DETECT, LAST FOUR CHANNELS
ACK	R	*+2		ACKNOWLEDGE...BITS SPECIFY PORTS ACTIVE
*				SET...WHEN TERMINAL IS IDENTIFIED
*				RESET...WHEN TERMINAL IS HUNG UP
DTR	R	*+2		DATA TERMINAL READY
DSR	R	*+2		DATA SET READY
CP	R	*+2		CARRIER DETECT, AVERAGED OVER LAST FOUR SAMPLES
HANG	R	*+2		BITS SPECIFY PHONES TO HANG UP
	IF	MARKXV		MARK XV PARAMETER
SPACE	R	*+2		BITS SPECIFY ALL TERMINALS IN SPACING MODE
	ENDIF
XFLAG	R	*+2		PSEUDO INTERRUPT FLAG FOR TRAN (XON/XOFF)
XNEW	R	*+2		NEW CHARACTER FLAG FOR TRAN (XON/XOFF)
XSTATE	R	*+2		CURRENT CHARACTER FLAG FOR TRAN (XON/XOFF)
DEM	R	*+2		DEFERRED ECHO MODE
NBO	R	*+2		NO BALL OUT
RGX	R	*+1		RING INDEX (INTERRUPT)
SBX	R	*+1		START BAUD INDEX
SBA	R	*+2		START BAUD ACTIVE (1 WORD/GROUP)
	IF	QUASISBOD
QRGX	R	*+1		QUASI-START-BAUD RING INDEX
QSBX	R	*+1		QUASI-START-BAUD INDEX
SBODCNT	R	*+1		START BAUD COUNT---HOW MANY CHARS IN RING
SBODLOCK R	*+1		QUASI-SBOD LOCK
RINGZAP	R	*+1
SBODA	R	*+1		SAVE LOCATIONS FOR QUASI-START-BAUD REGISTERS
SBODB	R	*+1
SBODX	R	*+1
SBODRT	R	*+1		RETURN FOR QUASI-BAUD ROUTINE
	ENDIF
LRESET	R	*+NLINES
LINER	R	*+NLINES	LINE ERROR COUNTS
TIME1	R	*+NLINES	TIME SINCE LAST RECORD MADE
*	FOR SECTOR N, N = 0, 1, 2, 3...THE CORRESPONDING BITS...
*	0, 1, 2, 3	SECTOR HAS RECORD MADE, READY TO GO
*	4, 5, 6, 7	SECTOR IS BEING OUTPUT
*	ZERO	JUST GOT A RESET PATTERN, WILL LOOK FOR A RECORD TO TRANSMIT
OSF	R	*+NLINES	OUTPUT SECTOR FLAGS
*	FOR SECTOR N, N = 0, 1, 2, 3...BIT 0, 1, 2, 3 RESPECTIVELY SET MEAN
*	SECTOR HAS BEEN READ IN, READY TO DISASSEMBLE
*	ZERO	NOT IN USE
ISF	R	*+NLINES	INPUT SECTOR FLAGS
CAOS	R	*+NLINES	CURRENT ASSEMBLING OUTPUT SECTOR
COS	R	*+NLINES	CURRENT OUTPUT SECTOR
CDIS	R	*+NLINES	CURRENT DISASSEMBLING INPUT SECTOR
CIS	R	*+NLINES	CURRENT INPUT SECTOR
LRR	R	*+NLINES	LAST RECORD RECEIVED
ASDW	R	*+NLINES	ASSEMBLED WORD
NDASW	R	*+NLINES	NEXT DISASSEMBLING WORD
TSLR	R	*+NLINES	TIME SINCE LAST RESET
QOVERT	R	*+NLINES	OUTPUT VERTICAL CHECKSUM
QODIAG	R	*+NLINES	OUTPUT DIAGONAL CHECKSUM
QIFRST	R	*+NLINES	FIRST WORD OF RECORD
QIVERT	R	*+NLINES	INPUT VERTICAL CHECKSUM
QIDIAG	R	*+NLINES	INPUT DIAGONAL CHECKSUM
IRC	R	*+NLINES	INPUT RECORD COUNT
ORC	R	*+NLINES	OUTPUT RECORD COUNT
SWTCHI	R	*+NLINES	SWITCH FOR INPUT CLEANUP
LINSAT	R	*+NLINES	LINE SATURATION COUNTER
INDATA	R	*+NLINES	INCOMING DATA FLAG FOR DIAGNOSTICS
SNIPE	R	*+NLINES	SNIPPED LINES FLAG FOR DIAGNOSTIC
ORA	R	*+NLINES	OUTPUT RECORD ADDRESS
IRA	R	*+NLINES	INPUT RECORD ADDRESS
	IF	#CARD201
INFLAG	R	*+1		FLAG FOR LINE INTERRUPT
INA	R	*+1		A REGISTER SAVE LOCATION FOR INTERRUPT ROUTINES
INB	R	*+1
ASW	R	*+1		ASSEMBLING WORD
DASW	R	*+1		DISASSEMBLING WORD
	ENDIF
PLI	R	*+2		PLEASE LOG IN ARRAY
NPID	R	*+2		FLAGS TO TYPE NODE-PORT IDENTIFICATION
LOGGER	R	*+2		PORTS IN LOGIN MODE
LOGTOA	R	*+2		LOGGER TIME-OUT A
LOGTOB	R	*+2		LOGGER TIME-OUT B
SORRY	R	*+2		FLAGS FOR APPOLOGY
	IF	TRACE
TRSWCH	R	*+1		TRACE SWITCH
	ENDIF
NINIT0	E	*-INIT0		END OF BLOCK INITIALIZED TO 0
*
*
*	* * * * I N I T 1   B L O C K   S E T   =   - 1   B Y   C R A S H * * * *
INIT1	E	*		START OF BLOCK 'CRASH' INITS TO -1
RNG1	R	*+2		OUTPUT BITS FOR RINGDRIVER
	IF	CARD201
RNG2	R	*+2		INPUT BITS FOR RINGDRIVER
	ENDIF
TA	R	*+2		SIXTEEN SECOND TIMEOUTS (1 WORD/GROUP)
TB	R	*+2
TBOA	R	*+2		TIME SINCE LAST BALL WENT OUT
TBOB	R	*+2
RLA	R	*+2		RECEIVER LINES ACTIVE (1 WORD/GROUP)
ORLA	R	*+2		OLD RECEIVER LINES ACTIVE (1 WORD/GROUP)
TAM	R	*+2		TRANSMIT ACTIVE (1 WORD/GROUP, USAGE LIKE 'SBA')
PNCIB	R	*+2		PREVIOUSLY PROCESSED 'NCIB'
	IF	QUASISBOD
NCIB	R	*+2		NO CHARACTER IN TRANSMITTER BUFFER
	ELSE
NCIB	E	TAM		NO CHARACTER IN TRANSMIT BUFFER
	ENDIF
	IF	PRINTER
PRINT0	R	*+1		0=PORT 0 IS RUNNING PRINTER
PRINR0	R	*+1		-1=PRINTER READY
	IF	DPRINTER
PRINT1	R	*+1		0=PORT 1 IS RUNNING A PRINTER
PRINR1	R	*+1		-1=PRINTER ON PORT 1 IS READY
	ENDIF
	ENDIF
NINIT1	E	*-INIT1		END OF BLOCK INITIALIZED TO -1
*
*
ADAPT	R	*+NLINES	RESET ADAPTOR CELL FOR 201 LINES
*
IOAD1	E	40-20*(#MARKXV)
IOAD2	E	IOAD1+1-(#MARKXV)
SWI	R	*+1		INDIRECT POINTER FOR ZAP-LINE LOGIC
DUMMY	R	*+1		LOCATION TO BUILD INSTRUCTIONS AND BRANCHES IN
MW1	R	*+1		POINTER STORAGE FOR "MESAGE" ROUTINE
	IF	CHECKSUM
CKPNT	0			MEMORY WORD POINTER FOR CHECKSUM ROUTINE
QUIKCK	0			FLAG TO PERFORM QUICK-CHECKSUM (TESTED BY SEC, RESET BY CKSUM)
USLINE	-1			FLAG TO UNSNIP LINE SPECIFIED IF NOT NEGATIVE
	ENDIF
CRSHCD	0			CRASH CODE
CRSHLC	R	*+1		CRASH LOCATION
PTEPNT	R	*+1		PERMUTER TABLE POINTER
W1	R	*+1
W2	R	*+1
W3	R	*+1
W4	R	*+1
W5	R	*+1
W6	R	*+1
W7	R	*+1
W8	R	*+1
W9	R	*+1
W10	R	*+1
W11	R	*+1
W12	R	*+1
W13	R	*+1
	IF	QUASISBOD
QW1	R	*+1
QW2	R	*+1
QW3	R	*+1
QW4	R	*+1
QW5	R	*+1
QW6	R	*+1
	ELSE
QW1	E	W1
QW3	E	W3
QW4	E	W4
	ENDIF
*
*
* INDIRECT POOL
*
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
INDPOOL	I	*+4
*	**TABLES**
*
MASK	1;2;4;10;20;40;100;200;400;1000;2000;4000
	10000;20000;40000;100000
CMSK	177776;177775;177773;177767;177757;177737;177677;177577;177377
	176777;175777;173777;167777;157777;137777;77777
RSF	21;42;104;210;231;63;146;314;335;273;167;356
*	CARRIAGE RETURN DELAY PARAMETERS
CPARAM	0;1;2;3;4;5;7;10D;14D;19D;26D;36D;50D;69D;95D;131D
*	USER NAME BIT FOR MESSAGES
FCHAR	0;20;20;0;20;0;0;20
X	E	SAMPLESIZE (DEFINED FOR SHORT EXPRESSIONS)
*	NUMBER OF WORDS (EFFECTIVELY, SAMPLES) TO NEXT BAUD
BAUD	13*X;	10*X;	4*X;	3*X;	2*X;	1*X;	1*X;	11*X
*	RECEIVER CHARACTER LENGTH (IN WORDS)
RCHAR	135*X;	103*X;	35*X;	23*X;	12*X;	0*X;	135*X;	104*X
*	TRANSMITTER CHARACTER LENGTH (IN WORDS)
TCHAR	170*X;	120*X;	50*X;	36*X;	24*X;	12*X;	170*X;	122*X
*
* OUTPUT SECTOR ADDRESSES.
*
X	E	STBUFS
OSEC	+X
	IF	NLINES>1
X	E	X+SECTORSIZE
	+X
	IF	NLINES>2
X	E	X+SECTORSIZE
	+X
	ENDIF; ENDIF
*
* INPUT SECTOR ADDRESSES.
*
X	E	X+SECTORSIZE
ISEC	+X
	IF	NLINES>1
X	E	X+SECTORSIZE
	+X
	IF	NLINES>2
X	E	X+SECTORSIZE
	+X
	ENDIF; ENDIF
*
*
* THESE ADDRESS TABLES ARE USED BY THE CLEANUP CODE TO ADDRESS
*	AND MODIFY THE INTERRUPT LOCATIONS.
*
	IF	CARD201
*
* JUMP ADDRESSES FOR ZERO DETECT
INZD	+IN0+7
	IF	NLINES>1
	+IN1+7
	IF	NLINES>2
	+IN2+7
	ENDIF; ENDIF
*
* NORMAL JUMP ADDRESSES
INNORM	+IN0+.
	IF	NLINES>1
	+IN1+.
	IF	NLINES>2
	+IN2+.
	ENDIF; ENDIF
*
* ADDRESS OF ADDRESS OF JUMP INSTRUCTION
INAD	+IN0+6
	IF	NLINES>1
	+IN1+6
	IF	NLINES>2
	+IN2+6
	ENDIF; ENDIF
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ELSE
INZD	+IN0
INNORM	+IN0B
INAD	+INS
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
INS	+IN0
	ENDIF
*		T E R M I N A L   F L A G S
*	A S C I I				2 7 4 1
*
*	TF:
*  17	\					\
*  16	 = OUTPUT BAUD RATE			\
*  15	/					\
*  14	= REQUIRES PARITY			 = BOX
*  13	= XENABLE (XON/XOFF)			/
*  12	= ECHO ON (USED ONLY IN TRN0)		/
*  11	= ECHO CONTROL-I			/
*  10	= ECHO LF WITH C/R-RUBOUT
*  7	= ECHO CR WITH L/F			= C/R FLAG
*  6	= ECHO OFF				= KEYBOARD LOCKED
*  5	= BALL FLAG GREEN
*  4	= USER NAME (USED IN LOGIN MOOE)
*  3	\
*  2	\
*  1	 = TERMINAL TYPE
*  0	/
TF	112
	R	*+(NUMPORTS-1)
*
*	TF1:
*  17	\					\
*  16	 = PARAMETER D				\
*  15	/					\
*  14	/					\
*  13	\					\
*  12	 = PARAMETER A				\
*  11	/					 = UNUSED
*  10	/					/
*  7	\					/
*  6	 = PARAMETER B				/
*  5	/					/
*  4	/					/
*  3	\					/
*  2	 = PARAMETER C				/
*  1	/					/
*  0	/					/
TF1	1006			SET FOR TYPE 'D'
	R	*+(NUMPORTS-1)
*
*	TF2:
*  17	\					\
*  16	\					\
*  15	\					\
*  14	\					 = BALL POSITION
*  13	\					   AND DELAY COUNT
*  12	\					/
*  11	 = CARRIAGE POSITION			/
*  10	   AND DELAY COUNTER			/
*  7	/					/
*  6	/					\
*  5	/					 = LITTLE DELAY FOR L/F, TWIDDLES, AND EOTS
*  4	/					/
*  3	/					= LONG SPACE STATE
*  2	/					= EOA STATE
*  1	/					= UPPER CASE FLAG
*  0	/					= PLUSMINUS FLAG
TF2	R	*+NUMPORTS
*
*	TF3:
*  17\	/ = "10"B....PORT IN TERMINAL IDENTIFICATION STATE
*  16/	= "00"B....PORT IS ASCII		= "11"B...PORT IS 2741
*  15	\					\
*  14	 = UNUSED				\
*  13	= HALF DUPLEX				\
*  12	\					\
*  11	\					\
*  10	\					 = UNUSED
*  7	 = UNUSED				/
*  6	/					/
*  5	/					/
*  4	/					/
*  3	 = C/R DELAY ENABLE			/
*  2	\					/
*  1	 = INPUT BAUD RATE			/
*  0	/					/
TF3	10
	R	*+(NUMPORTS-1)
*
*
BSLACK	E	1000-*		BASE(INDIRECT OR INDEX) ADDRESSABLE SLACK
*
*
RNGA	R	*+1		SAVE LOCATIONS FOR RINGDRIVER
RNGX	R	*+1
CLNLOK	R	*+1		CLEANUP LOCK
CLENRT	R	*+1		RETURN ADDRESS FOR CLEANUP ROUTINE
CNA	R	*+1		SAVE LOCATIONS FOR CLEANUP ROUTINE
CNB	R	*+1
CNX	R	*+1
*
TIMSEC	R	*+1		TIME SINCE LAST ONE HALF SECOND
TIMMIN	R	*+1		TIME SINCE LAST MINUTE
TIMEL	R	*+1		LOW ORDER REAL TIME
IDX	R	*+1		INDEX COUNTER USED IN 'SECE'
NODOVL	R	*+1		NODE-OVERLOAD COUNTER
USWICH	R	*+1		UPSTREAM SWITCH...0 IF NO UPSTREAM, ELSE = BUFFER INDEX
NOISE	0			COUNTER OF INVALID ID CHARACTERS
BUFSTF	0			COUNTER FOR CHARACTERS IN BUFFERS
*
*
* LITERAL POOL
*
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
LITPOOL	L	*+240-(PRINTER)*3-(TRACE)*2
LSLACK	E	4000-*		LITERAL ADDRESS-SPACE SLACK
*
*	THIS ROUTINE IS PROCESSED WHEN POWER INTERRUPT OCCURS
POWER	EXC	IDA		INSURE INTERRUPTS ARE OFF
	IF	V73
	LDX	=TICKSPS	=1200
POW1	STX	W12		GENERATE LONG DELAY FOR V73
	LDX	=TICKSPS
POW2	LLRL	20
	LLRL	20		7 US.
	DEC	X,AX
	JAP	POW2		POW2 LOOP = 8.5 US
	LDA	W12
	DEC	A,AX
	JAP	POW1		APPROX. 10 SECOND DELAY
	ENDIF
	JMPM	CRASH		GO CRASH WHEN POWER COMES BACK
POWFAL	+CRASHC			POWER FAILURE CRASH CODE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	0			POWER FAILURE BRINGS US HERE
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	EXC	IDA		INSURE INTERRUPTS ARE OFF
	HLT			HANG HERE WHEN POWER FAILS
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
* A FATAL ERROR HAS OCCURRED
*
*	CRASH SAVE TABLE....RING OF LAST 4 CRASHES
CRSAVE	R	*+4		4 WORDS CONTAIN CRASH LOCATION
	R	*+4		4 WORDS CONTAIN CRASH LOCATION CONTENTS
	R	*+4		4 WORDS CONTAIN (A)
	R	*+4		4 WORDS CONTAIN (B)
	R	*+4		4 WORDS CONTAIN (X)
	R	*+4		4 WORDS CONTAIN CONTENTS OF CRASHWORD LOCATION
*	SAVE ERROR NUMBER AND (SOMETIMES) MARK LOCATION
*	OF ROUTINE IN WHICH ERROR WAS DETECTED
*
CRASH	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	EXC	IDA		TURN OFF ALL INTERRUPTS
	STA	W12		SAVE (A)
	STX	W13		SAVE (X)
	LDA	CRSHCT		GET AND BUMP CRASH COUNTER
	INR	CRSHCT
	ANA	=3
	ADD	CRPNT		COMPUTE TABLE ENTRY ADDRESS
	TAX
	LDA	W12		SAVE (A)
	STA	10,X
	STB	14,X		SAVE (B)
	LDA	W13		SAVE (X)
	STA	20,X
	LDA	CRASHWORD,I	SAVE LOCATION SPECIFIED BY CRASHWORD
	STA	24,X
	LDB	CRASH
	STB	0,X		SAVE CRASH LOCATION
	TBA
	ERA	MASK+2		 =4...KLUDGE FOR MANUAL RESTART
	JAZ	CRASH1		SKIP IF SO
	LDA	1,B
	STA	4,X		SAVE CRASH LOCATION CONTENTS
	STA	CRSHLC
	LDA	0,B
	TAB
	ERA	POWFAL		VERIFY KNOWN CRASH TYPE
	ANA	=100077
	JAZ	CRASH2		SKIP IF OK
	LDB	=(CRASHC+1000)	ELSE SET UNKNOWN CRASH TYPE
	JMP	CRASH2		AND SKIP
CRASH1	STA	4,X		SAVE NULL CRASH LOCATION CONTENTS
	STA	CRSHLC
	LDB	=(CRASHC+100)	SET MANUAL RESTART CRASH CODE
CRASH2	STB	CRSHCD		SAVE CRASH CODE
*
*
* REINITIALIZE EVERYTHING.
*
	IF	MARKXV
	EXC	707
	ENDIF
	TZB			CLEAR B
	STB	TIMEL		CLEAR DATA ITEMS
	STB	TIMSEC
	STB	TIMMIN
	STB	NODOVL
	STB	CLNLOK
	STB	USWICH
	LDX	=BUFCNT+NBUF	BUFFER-COUNT ARRAY END ADDRESS
	LDA	=NBUF		BUFFER-COUNT ARRAY SIZE
CR1	DAR
	DXR
	STB	0,X		CLEAR BUFFER-COUNT ARRAY
	JAP	CR1
	LDA	=RINGSIZE-1	ALLOWS FOR MULTIPLES OF 16 PORTS.
	LDX	=RINGEND	CLEAR RING
CR2	DAR
	DXR
	STB	0,X
	JAP	CR2
	LDX	=INIT0+NINIT0	CLEAR FLAGS AND TRAP CELLS
	LDA	=NINIT0-1
CR3	DXR
	DAR
	STB	0,X
	JAP	CR3
	LDX	=NLINES-1	SET UP LINE PROCESSES
CR4	LDA	MASK+16		SET BIT 16 ON LINE-ERROR FOR REPORTING
	ORA	LINER,X
	STA	LINER,X
	LDA	=PADAPT		SET ADAPTOR CELLS FOR LINE
	STA	ADAPT,X
	DEC	X,AX
	JAP	CR4
	STB	SWTCHO		CLEAR 201 LINES STATUS
	STB	SWTCHO+1
	STB	SWTCHO+2
	LDX	IOTA
	LDA	=NIOTAB-AR BUFFER RESTRICTIONS
CR5	STB	NIOTAB,X
	IXR
	DAR
	JAP	CR5
	STA	P201NUM		NEXT 201 LINE TO PROCESS
	IF	QUASISBOD
	LDX	=TRANBUF
	LDA	=2*NUMPORTS-1
CR6	STB	0,X
	DAR
	IXR
	JAP	CR6
	ENDIF
	LDX	=INIT1+NINIT1	SET APPROPRIATE FLAG CELLS
	LDA	=NINIT1-1
	COM	,B
CR7	DAR
	DXR
	STB	0,X
	JAP	CR7
	IF	DEBUG
	LDA	MASK		INITIALIZE DEBUGGER PORT
	STA	ACK		ACKNOWLEDGE
	STA	NBO		NO BALL OUT
	LDA	CMSK
	STA	ORLA		OLD RECEIVER LINE ACTIVE
	STA	DSR		DATA-SET-READY
	STA	CPS		CARRIER-PRESENT-SAMPLE
	STA	CP		CARRIER-PRESENT
	ENDIF
	IF	CARD201
	LDA	=17
CR8	OAR	IDA		CLEAR 201 LINES
	DAR
	JAP	CR8
	LDB	=NLINES-1	ENABLE ALL LINES USED
EN	TBA
	LRLA	1		 *2
	ORA	MASK+4
	OAR	IDA
	DEC	B,AB		REPEAT FOR ALL LINES
	JAP	EN
* EXC IDA-1 RESETS OVERFLOW FLIPFLOP, EXC 177+IDA ENSURES THAT CLOCK IS WORKING
	EXC	IDA-1		RESET OVERFLOW
	EXC	177+IDA
	LDA	EN3		SET 'ENABLE' TO TURN ON INTERRUPT
	STA	ENABLE
	ENDIF
EN3	EXC	300+IDA		TURN ON INTERRUPTS
*	**MAIN CONTROL LOOP**
*
*
EXEC	JMPM	SBOD		START-BAUD SCANNER
	LDA	P201NUM		NEXT 201 LINE TO PROCESS
	INC	A,AB		TO B REGISTER
	SUB	=NLINES		HAVE WE DONE THEM ALL?
	XAP	P201TZB		IF SO,  GO BACK TO LINE ZERO.
	STB	P201NUM		SAVE LINE NUMBER
	JMPM	RTD		'RTD' FIRST
	LDB	P201NUM
	JMPM	RMAKE		THEN 'RMAKE'
	JMPM	SBOD		START-BAUD SCANNER
	JMPM	SEC		NETWORK COMMUNICATIONS PROCESSING
	JMP	EXEC		AND REPEAT ENTIRE LOOP
*
*
P201TZB	TZB			GO BACK TO LINE ZERO
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
P201NUM	-1			LAST 201 LINE PROCESSED.
*	**201 INTERRUPT ROUTINES**
*
ENABLE	EXC	300+IDA
*
*
*	ONE PAIR FOR EACH 201 LINE
*
	IF	CARD201
OUT0	0			LINE 0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	IDA-1,NDASW
	XEC	ENABLE
	JMP	OUT0,I
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
IN0	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	IME	IDA-1,ASDW
	XEC	ENABLE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	JMP	IN0,I
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	IDA,ZDET
	JMP	IN0,I
*
	IF	NLINES>1
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
OUT1	0			LINE 1
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	IDA-1,NDASW+1
	XEC	ENABLE
	JMP	OUT1,I
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
IN1	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	IME	IDA-1,ASDW+1
	XEC	ENABLE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	JMP	IN1,I
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	IDA,ZDET+1
	JMP	IN1,I
*
	IF	NLINES>2
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
OUT2	0			LINE 2
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	IDA-1,NDASW+2
	XEC	ENABLE
	JMP	OUT2,I
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
IN2	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	IME	IDA-1,ASDW+2
	XEC	ENABLE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	JMP	IN2,I
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	IDA,ZDET+2
	JMP	IN2,I
*
	ENDIF; ENDIF
*
	ELSE
*		NO 201 CARD
IN0	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STA	INA
	CIA	61
	JAP	IN0A
	LDA	INA
	EXC	100+IDA
	JMP	IN0,I
IN0A	LDA	MASK+1
	STA	ASW
	LDA	INNORM
	STA	INT22+1
	LDA	INA
	EXC	100+IDA
	JMP	IN0,I
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
IN0B	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STB	INB
	CIB	61
	STA	INA
	LDA	ASW
	JAN	IN0C
	LLRL	1
	STA	ASW
	LDA	INA
	LDB	INB
	EXC	100+IDA
	JMP	IN0B,I
IN0C	LLRL	1
	STA	ASDW
	LDA	INS
	STA	INT22+1
	INC	,A
	STA	ASW
	INR	INFLAG
	LDA	INA
	LDB	INB
	EXC	100+IDA
	JMP	IN0B,I
JTAB	+RNG
	+N201
	+RNG
	+N201
	+RNG
	+N201
	+RNG
	+N201
	+RNG
	+N201
	+RNG
	+N201
	+RNG
	+N201
	+RNG
	+S201
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
S201	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	OME	61,DASW
	STA	INA
	LDA	=JTAB+.
	STA	INT20+1
	LDA	NDASW
	STA	DASW
	LDA	INA
	EXC	100+IDA
	JMP	S201,I
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
N201	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STA	INA
	LDA	DASW
	OAR	61
	LRLA	1
	STA	DASW
	LDA	INA
	INR	INT20+1
	EXC	100+IDA
	JMP	N201,I
	ENDIF
*	**RING DRIVER INTERRUPT**
* SERIALIZES AND DESERIALIZES CHARACTERS FOR 103 DATA SETS
*
*
	IF	#QUASISBOD
RNGH	JMPM	CRASH		START BAUD SCANNER BEHIND
	+200+CRASHC		START-BAUD CRASH CODE
*
	ENDIF
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
RNG	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*
	IF	CARD201
*
	OME	IOAD1,RNG1	OUTPUT THE LAST SAMPLE, GROUP 1
	IME	IOAD1,RNG2	INPUT THE NEW SAMPLE, GROUP 1
	IF	#ONLY16
	OME	IOAD2,RNG1+1	OUTPUT THE LAST SAMPLE, GROUP 2
	IME	IOAD2,RNG2+1	INPUT THE NEW SAMPLE, GROUP 2
	ENDIF
	STA	RNGA		SAVE (A)
	LDA	EN2
EN2	EXC	200+IDA
	STA	ENABLE
	STX	RNGX		SAVE (X)
	LDA	RGX
	ADD	=SAMPLESIZE
	ANA	=RINGMASK
	STA	RGX		COMPUTE INDEX FOR NEXT SAMPLE
	IF	#QUASISBOD
	SUB	SBX
	JAZ	RNGH		CRASH IF CAUGHT UP TO START-BAUD SCANNER
	LDA	RGX
	ENDIF
	ADD	=RING		COMPUTE SAMPLE ADDRESS
	TAX
	LDA	RNG1		GET THE CURRENT BITS
	ERA	0,X
	STA	RNG1		SAVE CHANGES TO CURRENT STATE
	LDA	RNG2
	STA	0,X		PUT NEW BITS INTO RING
	IF	MARKXV
	ORA	SPACE
	STA	SPACE
	ENDIF
	IF	#ONLY16
	LDA	RNG1+1		SAME GAME FOR SECOND LINE
	ERA	2,X
	STA	RNG1+1
	LDA	RNG2+1
	ENDIF
*
	ELSE
*
	STA	RNGA		SAVE (A)
	LDA	DASW		GET CURRENT WORD
	OAR	61		OUTPUT BIT
	LRLA	1
	STA	DASW		MOVE LEFT AND SAVE FOR NEXT TIME
	INR	INT20+1		BUMP ADDRESS FOR CALL
	STX	RNGX		SAVE (X)
	LDA	RGX
	ADD	=SAMPLESIZE
	ANA	=RINGMASK
	STA	RGX		COMPUTE INDEX OF NEXT SAMPLE
	IF	#QUASISBOD
	TAX
	SUB	SBX
	JAZ	RNGH		CRASH IF CAUGHT UP TO START-BAUD SCANNER
	TXA
	ENDIF
	ADD	=RING		COMPUTE SAMPLE ADDRESS
	TAX
	LDA	RNG1
	ERA	0,X
	OAR	IOAD1		OUTPUT CURRENT WORD
	STA	RNG1		AND SAVE FOR NEXT TIME
	CIA	IOAD1		GET NEW SAMPLE
	STA	0,X		PLUG INTO BUFFER
	IF	MARKXV
	ORA	SPACE
	STA	SPACE
	ENDIF
	IF	#ONLY16
	LDA	RNG1+1		SAME GAME FOR SECOND LINE
	ERA	2,X
	OAR	IOAD2
	STA	RNG1+1
	CIA	IOAD2
	ENDIF
	ENDIF
	IF	#ONLY16
	STA	2,X
	IF	MARKXV
	ORA	SPACE+1
	STA	SPACE+1
	ENDIF
	ENDIF
	LDA	TAM		COPY CONTROL BITS INTO TAM
	ORA	1,X
	STA	TAM
	IF	#ONLY16
	LDA	TAM+1
	ORA	3,X
	STA	TAM+1
	ENDIF
	TZA
	STA	1,X		CLEAR CONTROL BITS
	IF	#ONLY16
	STA	3,X
	ENDIF
	IF	V73
	OME	77,RNG		DRIVE THE FRONT PANEL LIGHTS
	ENDIF
	INR	TIMEL		COUNT REAL TIME
	COP	X,A
	ANA	=SAMPLESIZE	BIT IS ALTERNATELY 0 AND 1
	ORA	CLNLOK		CLEANUP LOCK
	LDX	RNGX		RESTORE XR
	JAZ	RINGA		IF CLEANUP LOCK NOT SET, MAY GO TO 201 PROCESSING
	IF	CARD201
	LDA	EN3
	EXC	IDA
	STA	ENABLE		SET 'ENABLE' TO TURN ON INTERRUPTS
	ENDIF
	LDA	RNGA		RESTORE A
	EXC	300+IDA		ENABLE INTERRUPTS
	JMP	RNG,I		AND EXIT INTERRUPT
RINGA	COM	,A
	STA	CLNLOK		SET CLEANUP LOCK
	LDA	RNG
	STA	CLENRT		SAVE INTERRUPT RETURN ADDRESS
	IF	CARD201
	LDA	EN3
	EXC	IDA
	STA	ENABLE
	ENDIF
	LDA	RNGA		RESTORE AC
	EXC	300+IDA		TURN INTERRUPT BACK ON..LOCK SET, RNG CAN BE EXECUTED, BUT
*				RINGA CANNOT BE TIL LOCK CLOSED
*	**CLEANUP FOR 201 INTERRUPTS**
*	QUASI-INTERRUPT...ENTERED FROM INTERRUPT, BUT MAKES ITSELF INTERRUPTABLE
*
	STA	CNA		SAVE THE REGISTERS
	STB	CNB
	STX	CNX
CLNOUT	E	*		OUTPUT CLEAN-UP
	IF	CARD201
	LDA	OUT0		TEST LINES
	IF	NLINES>1
	ANA	OUT1
	IF	NLINES>2
	ANA	OUT2
	ENDIF; ENDIF
	JAN	CLENIN		NONE THERE...EXIT
	COM	,B		GOT ONE...CLEAN IT UP
	IF	NLINES>1
	LDA	OUT0		TEST IF ON LINE 0
	JAN	*+6		SKIP IF NOT
	ENDIF
	STB	OUT0		RESET FLAG ON LINE 0
	TZX			SET LINE 0 INDEX
	IF	NLINES>1
	JMP	QIO		AND SKIP
	IF	NLINES>2
	LDA	OUT1		NOT LINE 0...TEST LINE 1
	JAN	*+6		SKIP IF NOT
	ENDIF
	STB	OUT1		RESET LINE 1 FLAG
	INC	,X		SET LINE 1 INDEX
	IF	NLINES>2
	JMP	QIO		AND SKIP
	STB	OUT2		RESET LINE 2
	LDX	MASK+1		 =2...INDEX FOR LINE 2
	ENDIF; ENDIF
	ELSE
	LDA	S201		TEST THE LINE
	JAN	CLENIN		SKIP IF NO DATA
	TZX			ELSE SET LINE INDEX
	COM	,B
	STB	S201		AND RESET FLAG
	ENDIF
* OUTPUT INTERRUPT CLEANUP ROUTINE	LINE NUMBER IN X
*	PROCESS IS CONTROLED BY A WORD OF SWITCH BITS FOR EACH LINE
*	THE SWITCH BITS AND THEIR USAGE ARE...
*	BIT	USAGE
*	17	OUTPUT NEXT WORD OF RECORD
*	16	HAVE FINISHED RECORD, LOOK FOR A NEW RECORD TO OUTPUT
*	15	SEND RESET PATTERN, SECOND HALF
*	14	AFTER OUTPUTTING ONES, SET-RETRANSMIT, RESET-SEND RESET
*	13	LOOK FOR NEW RECORD AFTER RESET
*	ALL ZERO...OUTPUT ONES
*
QIO	LDA	SWTCHO,X	GET SWITCH WORD(LINE)
	JAN	QOG		BIT 17 SET...OUTPUTING RECORD
	LRLA	1
	JAN	QOD		BIT 16 SET...LOOK FOR NEW RECORD TO OUTPUT
	LRLA	1
	JAN	QOC		BIT 15 SET...SEND RESET PATTERN
* OUTPUT ONES, AFTER WHICH CHECK BIT 3 OF SWITCH
* TO SEE WHETHER TO OUTPUT RESET PATTERN OR RETRANSMIT
	LDB	ORC,X		GET OUTPUT RECORD COUNT
	JBZ	QOB		DONE...SEE WHAT TO DO NEXT
	DBR
	STB	ORC,X		ELSE DECREMENT IT
QOA	COM	,A
	STA	NDASW,X		OUTPUT A ONE
	JMP	CLNOUT		AND RESCAN
QOB	LRLA	1		HAVE OUTPUT ENOUGH -1'S...TEST BIT 14
	JAN	QOL		SET...CHECK FOR RE-TRANSMIT
	LSRA	3		NOT SET...RESTORE WORD
	ORA	MASK+15		SET BIT 15...SEND RESET PATTERN
	STA	SWTCHO,X
	LDA	RESETO,X
	STA	NDASW,X		SEND RESET PATTERN
	JMP	CLNOUT		THEN RESCAN
* TRANSMIT SECOND HALF OF RESET PATTERN, THEN CHECK BIT 4 OF SWITCH
* TO SEE WHETHER TO OUTPUT ONES OR LOOK FOR NEW RECORD
QOC	LDB	MACHNO		SEND MACHINE (NODE) NUMBER AS SECOND WORD OF RESET
	STB	NDASW,X
	LRLA	2		TAKING INTO ACCOUNT THAT WE GOT HERE WITH A SHIFT OF 2
	JAN	QOK		NEW RECORD BIT ON...GO SET UP TO TRANSMIT RECORD
	TZA
	STA	SWTCHO,X	CLEAR SWITCH WORD TO TRANSMIT EMPTY RECORD
	LDA	=41
	STA	ORC,X		SET TO TRANSMIT 33D WORDS
	JMP	CLNOUT		AND RESCAN
* LOOK FOR NEW RECORD TO OUTPUT
QOD	LDA	COS,X		GET CURRENT OUTPUT SECTOR
	ANA	=3
	TAB
	LDA	OSF,X		GET OUTPUT SECTOR FLAG FOR LINE
	ANA	RSF,B		MASK "OUTPUTTING RECORD" AND "RECORD MADE" FOR SECTOR
	SUB	MASK,B		TEST FOR "RECORD MADE"
	JAZ	QOE		SKIP IF A NEW RECORD EXISTS
	JAN	QOA		WE ARE MARKING..NOTHING TO DO
	LDA	MASK+5		NOTHING TO DO..MARK TIME
	STA	ORC,X		RECORD COUNT = 32D
	LDA	MASK+14
	STA	SWTCHO,X	SET BIT 14, OUTPUT A MARKING RECORD
	JMP	QOA
* NEW RECORD FOUND	SEND IT OUT
QOE	INR	COS,X		SET NEXT SECTOR FOR OUTPUT
	LDA	OSF,X
	ORA	MASK+4,B	SET NEW SECTOR-BEING-OUTPUT FLAG BIT IN SECTOR FLAGS
	STA	OSF,X
	TBA
QOF	LRLA	5		COMPUTE NEW SECTOR ADDRESS (SECTOR NO. * 32D)
	ADD	OSEC,X
	TAB
	IAR
	STA	ORA,X		SET NEW OUTPUT RECORD ADDRESS = SECTOR START + 1
	LDA	0,B
	ORA	LRR,X		GET HEADER FOR THIS RECORD, ACKNOWLEDGE LAST RECORD RECEIVED
	STA	NDASW,X		OUTPUT THIS WORD
	STA	QOVERT,X	INITIALIZE VERTICAL CHECKSUM
	STA	QODIAG,X	INITIALIZE DIAGONAL CHECKSUM
	LSRA	6
	ANA	=37
	STA	ORC,X		EXTRACT AND SAVE RECORD COUNT
	LDA	MASK+17
	STA	SWTCHO,X	SET SWITCHES TO OUTPUT RECORD
	JMP	CLNOUT		AND RESCAN LINES
* OUTPUT NEXT WORD OF RECORD
QOG	LDA	ORC,X		TEST RECORD COUNT
	JAZ	QOJ		LAST WORD IF = 0
	DAR
	STA	ORC,X		ELSE DECREMENT RECORD COUNT
	JAZ	QOI		SKIP TO OUTPUT VERTICAL CHECKSUM IF NEXT TO LAST WORD
	LDB	ORA,X		GET OUTPUT WORD ADDRESS AND BUMP IT
	INR	ORA,X
	LDA	0,B
	STA	NDASW,X		SEND THE CURRENT WORD
	ERA	QOVERT,X
	STA	QOVERT,X	VERTICAL CHECKSUM CALCULATION
QOH	LDA	QODIAG,X	COMPUTE DIAGONAL CHECKSUM
	LRLA	1
	ERA	NDASW,X
	STA	QODIAG,X
	JMP	CLNOUT		GO RESCAN LINES
* SECOND TO LAST WORD OF RECORD
QOI	LDA	QOVERT,X	OUTPUT VERTICAL CHECKSUM
	STA	NDASW,X
	JMP	QOH		AND GO FOLD IT INTO DIAGONAL
* LAST WORD OF RECORD
QOJ	LDA	QODIAG,X	OUTPUT DIAGONAL CHECKSUM
	STA	NDASW,X
QOK	LDA	MASK+16		SET BIT 16 TO GO PROCESS NEW RECORD NEXT TIME
	STA	SWTCHO,X
	JMP	CLNOUT		RESCAN LINES
* CHECK FOR RETRANSMIT
QOL	LDA	MASK+16
	STA	SWTCHO,X	SET BIT TO PROCESS NEW RECORD
	LDA	OSF,X
	ERA	=377		TEST ALL SECTOR FLAGS
	DAR
	JAP	QOD		FLAGS WERE NOT ALL SET...GO LOOK FOR NEW RECORD
	LDA	COS,X		ONE OR MORE SET...RETRANSMIT..PUT OUT SECTOR INDEX
	ANA	=3
	JMP	QOF		GO RETRANSMIT
*
*
*
* 201 INPUT INTERRUPT CLEANUP
*	HERE AFTER ALL OUTPUTS PROCESSED
CLENIN	E	*		INPUT CLEAN-UP
	IF	CARD201
	LDA	IN0		TEST LINES
	IF	NLINES>1
	ANA	IN1
	IF	NLINES>2
	ANA	IN2
	ENDIF; ENDIF
	JAN	CLENDN		NONE THERE...EXIT
	COM	,B		GOT ONE...CLEAN IT UP
	IF	NLINES>1
	LDA	IN0		TEST IF ON LINE 0
	JAN	*+6		SKIP IF NOT
	ENDIF
	STB	IN0		RESET FLAG ON LINE 0
	TZX			SET LINE 0 INDEX
	IF	NLINES>1
	JMP	QII		AND SKIP
	IF	NLINES>2
	LDA	IN1		NOT LINE 0...TEST LINE 1
	JAN	*+6		SKIP IF NOT
	ENDIF
	STB	IN1		RESET LINE 1 FLAG
	INC	,X		SET LINE 1 INDEX
	IF	NLINES>2
	JMP	QII		AND SKIP
	STB	IN2		RESET LINE 2
	LDX	MASK+1		 =2...INDEX FOR LINE 2
	ENDIF; ENDIF
	ELSE
	LDA	INFLAG		TEST THE LINE
	JAN	CLENDN		SKIP IF NO DATA
	TZX			ELSE SET LINE INDEX
	COM	,B
	STB	INFLAG		AND RESET FLAG
	ENDIF
*	INPUT INTERRUPT CLEANUP ROUTINE	HAS LINE NUMBER IN X
*	PROCESS IS CONTROLED BY A SWITCH WORD
*	THE SWITCH BITS AND THEIR USAGE ARE...
*	BIT	USAGE
*	17	INPUT NEXT WORD OF RECORD
*	16	(IF 17) SET-INPUT RECORD AND SAVE
*			RESET-INPUT RECORD AND IGNORE
*	15	SECOND HALF OF RESET PATTERN
QII	LDA	SWTCHI,X	GET AND TEST SWITCH WORD
	JAN	QID		INPUT NEXT WORD
	LRLA	1
	JAN	QIC		LOOK FOR START OF RECORD
	LRLA	1
	JAN	QIB		LOOK FOR SECOND HALF OF RESET PATTERN
* SWITCH A IS SET BY INIT
* LOOK FOR FIRST HALF OF RESET PATTERN
QIA	LDA	ASDW,X		GET IT
	ERA	RESETI,X	VERIFY IT
	JAZ	QIA1		SUCCESS
	LDA	ADAPT,X		FAIL...ADAPT RESET EXPECTED
	JAZ	QIA3		NO ADAPTER...SKIP
	ERA	MASK+17		ELSE TOGGLE HIGH BIT
	STA	ADAPT,X		AND SAVE IT
	JAN	QIRZ		ONLY ADAPT ON ALTERNATE WORDS INPUT
	ERA	RESETI,X
	STA	RESETI,X
	JMP	QIRZ		GO INTO ZERO-DETECT MODE
QIA1	STA	ADAPT,X		SUCCESS IN RESET...CLEAR ADAPTER
	LDA	RESETI,X	SET OUTPUT RESET SAME AS INPUT RESET
	STA	RESETO,X
	LDA	TIMEL		TIMEOUT..MUST BE 17 SECONDS
	SUB	TSLR,X
	JAN	QIA2		SKIP IF NOT YET
	SUB	=2*TICKSPS
	JAN	QIRZ		OTHERWISE GO INTO ZERO DETECT
* SET B SWITCH
QIA2	LDA	MASK+15		SET SWITCH FOR SECOND HALF OF RESET PATTERN
	STA	SWTCHI,X
	JMP	QIRZ
QIA3	LDA	ASDW,X		TEST IF POSSIBLE ALTERNATE RESET
	ERA	RESETI,X
	ERA	=PADAPT
	JAZ	QIA4		SKIP IF SO
	JMP	QIRZ		ELSE GO TO ZERO-DETECT
QIA4	INR	SNIPE,X		GOT THE ALTERNATE RESET...COUNT IT
	JMP	QIRZ		AND GO TO ZERO DETECT
* LOOK FOR SECOND HALF OF RESET PATTERN
* SET C SWITCH
QIB	LDA	MASK+16		SET SWITCH TO LOOK FOR START OF RECORD
	STA	SWTCHI,X
	LDA	ASDW,X
	ERA	MACH,X		VERIFY ORIGINATING NODE
	JAZ	QIB1		SUCCESS
	JMP	QIRZ		ELSE GO INTO ZERO DETECT
QIB1	LDB	=7		REINITIALIZE LINE
	STB	LRR,X		LAST RECORD RECEIVED = 7
	STA	ISF,X		INPUT SECTOR FLAG = 0
	STA	CDIS,X		CURRENT DISASSEMBLY INPUT SECTOR = 0
	INR	LRESET,X	INCREMENT RESET LINE
	STA	OSF,X		OUTPUT SECTOR FLAG = 0
	STA	COS,X		CURRENT OUTPUT SECTOR = 0
	STA	CAOS,X		CURRENT ASSEMBLY OUTPUT SECTOR = 0
	LDA	TIMEL		RESET TIME SINCE LAST RESET
	STA	TSLR,X
	LDA	MASK+13
	STA	SWTCHO,X	OUTPUT ONES ON THIS LINE
	LDA	=41
	STA	ORC,X
	JMP	QIRN
* LOOK FOR FIRST WORD OF RECORD
QIC	LDA	ASDW,X		GET WORD AND SAVE
	STA	QIFRST,X
	ANA	=74000		BITS 16-13 SHOULD BE EQUAL TO BORI
	ERA	BORI,X
	DAR
	JAP	QIA		LOOK FOR RESET IF NOT
	LDA	QIFRST,X	RETRIEVE WORD
	STA	QIVERT,X
	STA	QIDIAG,X
	LSRA	3
	TAB			SAVE SECTOR NUMBER
	LSRA	3
	ANA	=37
	STA	IRC,X		SAVE RECORD SIZE
	DEC	B,A
	SUB	LRR,X		IS THIS THE NEXT RECORD
	ANA	MASK+2
	JAZ	QICC1		NO..SKIP
* SET D SWITCH
QICC	LDA	MASK+17		YES..SET SWITCH TO INPUT NEXT WORD OF RECORD AND
	STA	SWTCHI,X		GET IN SYNC MODE ON THIS LINE
	JMP	QIRN
QICC1	TBA
	ANA	=3
	TAB
	LDA	ISF,X		GET INPUT SECTOR FLAG FOR LINE
	ANA	MASK,B		MASK WITH NEW SECTOR BIT
	DAR
	JAP	QICC		FLAG SET...SET UP TO GET NEXT RECORD
* SET E SWITCH
	LDA	=140000		CAN'T ACCEPT RECORD..SET SWITCHES TO INPUT AND IGNOR
	STA	SWTCHI,X	WE WANT TO PICK UP THE LATEST ACKNOWLEDGEMENT
	STB	CIS,X		SET CURRENT INPUT SECTOR
	TBA
	LRLA	5
	ADD	ISEC,X
	STA	IRA,X		COMPUTE SECTOR ADDRESS
	TAB
	LDA	QIFRST,X
	STA	0,B		MOVE WORD INTO SECTOR
	JMP	QIRN
QID	LRLA	1		INPUTTING RECORD...TEST IF WE USE IT
	JAN	QIE		SKIP IF SO
* INPUT RECORD WITHOUT STORING IT IN SECTOR
	LDA	IRC,X		TEST IF LAST WORD OF RECORD
	JAZ	QIDD		SKIP IF SO
	DEC	A,AB		ELSE REDUCE COUNT AND SAVE
	STA	IRC,X
	LDA	ASDW,X		GET WORD AND PROCESS CHECKSUMS
	ERA	QIVERT,X
	STA	QIVERT,X
	LDA	QIDIAG,X
	LRLA	1
	ERA	ASDW,X
	STA	QIDIAG,X
	JBZ	QIRZ		ZERO DETECT IF NEXT TO LAST WORD
	JMP	QIRN		ELSE GO ON
* LAST WORD OF RECORD	SET C SWITCH
QIDD	LDA	MASK+16		SET "LOOK FOR NEW RECORD" SWITCH
	STA	SWTCHI,X
	LDA	ASDW,X
	ERA	QIDIAG,X	COMPUTE DIAGONAL CHECKSUM
	ORA	QIVERT,X	VERIFY BOTH CHECKSUMS
	JAZ	QIF		SUCCESS
	JMP	QIRN		ELSE GO ON
* INPUT RECORD AND STORE IN SECTOR
QIE	LDA	IRC,X		GET RECORD COUNT
	JAZ	QIEE		LAST WORD...SKIP
	DAR
	STA	IRC,X		DECREMENT COUNT AND SAVE IT
	INR	IRA,X		BUMP ADDRESS
	LDB	IRA,X
	LDA	ASDW,X
	STA	0,B		SAVE VALUE
	ERA	QIVERT,X	PERFORM CHECKSUMS
	STA	QIVERT,X
	LDA	QIDIAG,X
	LRLA	1
	ERA	0,B
	STA	QIDIAG,X
	LDA	IRC,X		TEST IF THIS WAS NEXT TO LAST WORD
	JAZ	QIRZ		YES
	JMP	QIRN		NO
* LAST WORD OF RECORD	SET C SWITCH
QIEE	LDA	MASK+16		SET LOOK-FOR-NEW-RECORD SWITCH
	STA	SWTCHI,X
	LDA	ASDW,X		VERIFY CHECKSUM
	ERA	QIDIAG,X
	ORA	QIVERT,X
	JAZ	QIEE1		SKIP IF CHECKSUM OK
	INR	LINER,X		ELSE COUNT LINE ERROR
	JMP	QIRN		AND SKIP
QIEE1	LDB	CIS,X		ALL OK
	LDA	ISF,X		GET CURRENT INPUT SECTOR FOR INDEX
	ORA	MASK,B
	STA	ISF,X		SET APPROPRIATE SECTOR FLAG
* PHYSICAL RECORD HAS GOOD CHECKSUMS
* CHECK ACKNOWLEDGEMENT AND SEE WHICH OUTPUT SECTORS CAN BE CLEARED
QIF	LDA	CAOS,X		CURRENT ASSEMBLY SECTOR
	DEC	A,AB		LESS 1
	SUB	QIFRST,X	TEST
	ANA	=7
	JAZ	QIG		0--SKIP
	STA	QIVERT,X	ELSE SAVE IT
	SUB	MASK+2
	JAP	QIRN		SECOND GO ROUND..SKIP
	TBA
	LLSR	2		ELSE PACK UP NEW VALUE
	LDA	QIVERT,X
	LLRL	2
	TAB
	LDA	OSF,X		RESET OUTPUT SECTOR FLAG
	ANA	RSF-4,B
QIG	STA	OSF,X		RESTORE OUTPUT SECTOR FLAGS
QIRN	LDA	INNORM,X	GET IN SYNC
	JMP	QIRZ1
QIRZ	LDA	INZD,X		GET IN ZERO-DETECT MODE
QIRZ1	LDB	INAD,X
	STA	0,B
	JMP	CLENIN
*
*
*	CLEANUP DONE
CLENDN	LDX	CNX		RESTORE THE REGISTERS
	LDB	CNB
	IF	QUASISBOD
	LDA	SBODLOCK	GO PROCESS QUASI-STARTBAUD IF LOCK NOT SET
	JAZ	QSBOD
CLNDN1	E	*
	ENDIF
	LDA	CNA
	EXC	IDA		TURN INTERRUPTS OFF
	INR	CLNLOK		CLEAR CLEANUP LOCK
	EXC	300+IDA		TURN INTERUPTS BACK ON
	JMP	CLENRT,I	AND EXIT BACK TO WHERE EVER WE CAME FROM
	IF	QUASISBOD
*	**QUASISBOD CODE**
*	QUASI-INTERRUPT FOR START BAUD CODE
*
QSBOD	LDA	RGX		QUICK TEST TO SEE IF NECESSARY TO EXECUTE
	ANA	=SBODTEST
	DAR
	JAP	CLNDN1		ABORT PROCESSING IF NOT
	STA	SBODLOCK	ELSE SET QUASISBOD LOCK
	STB	SBODB		SAVE REGISTERS
	STX	SBODX
	LDA	CNA
	STA	SBODA
	LDA	CLENRT		SAVE RETURN ADDRESS
	STA	SBODRT
	INR	CLNLOK		CLEAR CLEANUP LOCK
QSBOD0	LDA	RGX		TEST HOW MANY SAMPLES EXIST
	SUB	SBX
	LRLA	7-(NUMPGRP/2)	DETERMINE NUMBER OF SAMPLES INPUT, NOT YET SCANNED
	JAN	QSBOD1
	SUB	=56400
	JAN	QSBOD4
*
QSBOD1	LDA	SBX
	ADD	=RING
	TAX			COMPUTE RING ADDRESS
	LDA	SBX
	ADD	=SAMPLESIZE
	ANA	=RINGMASK
	STA	QW1		COMPUTE INDEX OF NEXT SAMPLE
	ADD	=RING
	TAB			COMPUTE ADDRESS OF NEXT SAMPLE
	LDA	SBA		START-BAUD-ACTIVE
	ORA	RLA		RECEIVER LINES ACTIVE
	ORA	0,X		THIS SAMPLE
	ORA	0,B		NEXT SAMPLE
	COM	A,A
	IF	ONLY16
	JAZ	QSBOD3		SKIP IF NO START BAUDS
	ELSE
	JAZ	QSBOD2		SKIP IF NO START BAUDS
	ENDIF
	JMPM	QBID		ELSE IDENTIFY BIT
	LDA	MASK,X
	STA	QW1		GET AND SAVE MASK FOR THIS PORT
	ORA	SBA
	STA	SBA		SET START-BAUD-ACTIVE FOR THIS PORT
	LDA	=RING		SET BASE ADDRESS
	JMP	QRECEVR		GO GET THE BAUD
	IF	#ONLY16
QSBOD2	LDA	SBA+1		SAME GAME FOR SECOND PORT GROUP
	ORA	RLA+1
	ORA	2,X
	ORA	2,B
	COM	A,A
	JAZ	QSBOD3
	JMPM	QBID
	LDA	MASK,X
	STA	QW1
	ORA	SBA+1
	STA	SBA+1
	LDA	MASK+4		=16D
	COP	AX,X		SET BIT FOR SECOND WORD
	LDA	=RING+2
	JMP	QRECEVR
	ENDIF
QSBOD3	STA	0,X		DONE WITH SAMPLE...CLEAR IT
	IF	#ONLY16
	STA	2,X		CLEAR SECOND PORT-GROUP SAMPLE
	ENDIF
	LDA	QW1
	STA	SBX		BUMP INDEX TO NEXT SAMPLE
	SUB	=11*SAMPLESIZE	SKEW FACTOR
	ANA	=RINGMASK
	ADD	=RING
	TAX			COMPUTE ADDRESS OF 8D BAUDS BACK FROM ONE JUST PROCESSED
	LDA	SBA
	ERA	1,X
	STA	SBA		MOVE CONTROL BITS INTO START-BAUD ACTIVE
	IF	#ONLY16
	LDA	SBA+1		SAME GAME FOR SECOND PORT-GROUP
	ERA	3,X
	STA	SBA+1
	ENDIF
	TZA
	STA	1,X		CLEAR THE OLD CONTROL BITS
	IF	#ONLY16
	STA	3,X
	ENDIF
	JMP	QSBOD0		GO ON AND SEARCH AGAIN
*
*
QSBOD4	LDA	NCIB		(NO CHARACTER IN BUFFER)
	COM	A,A		(CHARACTER IN BUFFER)
	ANA	TAM		CAN WE USE IT?
	IF	ONLY16
	JAZ	QSBODEXIT	NO...EXIT
	ELSE
	JAZ	QSBOD5		NO...SKIP
	ENDIF
	JMPM	QBID		YES..GET BIT ADDRESS
	TXB			CALCULATE PORT NUMBER
	LDA	=RING		RING BASE ADDRESS
	IF	#ONLY16
	JMP	QTRAN		GO TO TRANSMITTER
*
QSBOD5	LDA	NCIB+1		SAME GAME FOR SECOND PORT GROUP
	COM	A,A
	ANA	TAM+1
	JAZ	QSBODEXIT
	JMPM	QBID
	LDA	MASK+4		 =20..CALCULATE PORT NUMBER
	COP	AX,B
	LDA	=RING+2
	ENDIF
*
*
*	TRANSMIT A CHARACTER
*	QW1	BIT MASK
*	QW2	RING BASE ADDRESS
*	QW3	PORT NUMBER
*	QW4	BAUD WIDTH
*	QW5	CHARACTER WIDTH
QTRAN	STA	QW2		SAVE RING BASE ADDRESS
	STB	QW3		PORT NUMBER
	LDA	MASK,X		BIT MASK
	STA	QW1
	LDA	TF3,X		TEST IF 2741
	LSRA	16
	SUB	=3
	JAZ	QTRAN1		SKIP IF 2741
	LDA	TF,B		GET BAUD RATE INDEX
	TZB
	LLRL	3
	LDA	BAUD,B		GET BAUD WIDTH
	STA	QW4
	LDA	TCHAR,B		GET CHARACTER WIDTH
	JMP	QTRAN2		AND SKIP
QTRAN1	LDA	=BAUDWIDTH	2741...GET BAUD WIDTH
	STA	QW4
	LDA	=E9THBAUD	CHARACTER WIDTH
QTRAN2	STA	QW5
	LDA	QW3		PORT INDEX
	ADD	=TRANBUF	COMPUTE BUFFER ADDRESS
	TAX
	LDA	QDELAY,X	TEST IF DELAY
	JAP	QTRAN3		SKIP IF NO DELAY YET
	IAR
	STA	QDELAY,X
	JAN	QTEXIT		SKIP IF ON-GOING DELAY
	LDA	QW1		LAST DELAY...SET NCIB
	LDB	QW3
	LSRB	4
	ORA	NCIB,B
	STA	NCIB,B
	JMP	QTEXIT		AND GO CLEAN UP
QTRAN3	ANA	MASK		TEST FOR PRE-CHARACTER DELAY
	JAZ	QTRAN4		SKIP IF NO DELAY
	ERA	QDELAY,X	ELSE CLEAR FLAG
	STA	QDELAY,X
	JMP	QTEXIT		AND GENERATE ONE CHARACTER DELAY
QTRAN4	LDA	QDELAY,X	SET POST-CHARACTER DELAY
	LSRA	1
	JAZ	QTRAN5		SKIP IF NO DELAY AFTER CHARACTER
	COM	A,A
	IAR
	STA	QDELAY,X	ELSE SET UP DELAY COUNTER
	JMP	QTRAN6		AND SKIP
QTRAN5	LDB	QW3		NO POST-DELAY...GET FLAG INDEX
	LSRB	4
	LDA	QW1		SET NO-CHARACTER-IN-BUFFER
	ORA	NCIB,B
	STA	NCIB,B
QTRAN6	LDA	QBUFER,X	NOW GET CHARACTER
	ORA	=177400		SET HIGH BITS
*	CODE TO INSERT A CHARACTER INTO THE RING
*	EXPECTS:
* (A) = FORMED CHARACTER (INCLUDING STOP BAUD AND ALL HIGHER BITS SET)
* QW1 MASK
* QW2 RING BASE ADDRESS
* QW4 BAUD SIZE
* QW6 CURRENT CHARACTER INDEX (AND TEMP)
	STA	QW6		SAVE THE CHAR
	ASLA	1		JUSTIFY IT
	ERA	QW6		COMPUTE CHANGES
	TAB			PUT INTO B
	LDA	RGX		GET RING OUTPUT INDEX AND SAVE
	STA	QW6
	ADD	=3*SAMPLESIZE	START THREE SAMPLES AHEAD OF INTERRUPT
	ANA	=RINGMASK
	ADD	QW2		COMPUTE BAUD ADDRESS
	TAX
	JMP	QTRAN8		AND SKIP TO INSERT START BAUD
QTRAN7	TBA			EXTRACT CURRENT BIT FOR OUTPUT
	LSRB	1		SET UP NEXT BIT
	ANA	MASK
	JAZ	QTRAN9		SAME AS LAST BIT...SKIP
QTRAN8	LDA	0,X		PUT A TOGGLE BIT INTO RING
	ORA	QW1
	STA	0,X
QTRAN9	JBZ	QTEXIT1		EXIT IF DONE
	TXA			COMPUTE ADDRESS OF NEXT BAUD
	ADD	QW4
	TAX
	SUB	=RINGEND	TEST IF FOLDED RING
	JAN	QTRAN7		NO..CONTINUE
	ADD	=RING		YES..CYCLE RING
	TAX
	JMP	QTRAN7		AND CONTINUE
* TRANSMITTER CLEANUP
* CLEARS TAM, SETS CONTROL BIT
*	EXPECTS:
* QW3 UNIT NUMBER
* QW5 CHARACTER WIDTH
* QW6 CURRENT CHARACTER INDEX
QTEXIT	LDA	RGX		COPY THE INDEX TO TEMP
	STA	QW6
QTEXIT1	LDB	QW3		COMPUTE THE PORT NUMBER
	LSRB	4
	LDA	QW1		GET THE *NOT* MASK
	COM	A,A
	EXC	IDA
	ANA	TAM,B		CLEAR THE TRANSMITTER ACTIVE BIT
	EXC	300+IDA
	STA	TAM,B
	LDA	QW6		COMPUTE THE CHARACTER END ADDRESS
	ADD	QW5
	ANA	=RINGMASK
	ADD	QW2
	TAB
	LDA	1,B		SET THE BIT IN THE CONTROL WORD
	ORA	QW1
	STA	1,B
	JMP	QSBOD0		GO DO IT OVER
*
*
* RECIEVER FOR ASCII TYPE TERMINALS
* QW1 MASK
* QW2 UNIT OR PORT NUMBER
* QW3 RING BASE ADDRESS
* QW4 BAUD SIZE
QRECA	LRLA	1		HERE FOR SPECIAL HANDLING
	JAN	QR2741		3...TERMINAL IS 2741
	JMP	QTID		2...NEW TERMINAL...GET TERMINAL ID
QRECEVR	STX	QW2		(X) = BIT NUMBER
	STA	QW3		(A) = RING BASE ADDRESS
	LDA	TF3,X		GET PORT CODE
	JAN	QRECA		SPECIAL CASE FOR 2741 OR TID
	ANA	=7		EXTRACT BAUD RATE
	TAB
	LDA	RCHAR,B		RECEIVER CHARACTER WIDTH FOR CHANNEL
	ADD	SBX
	ANA	=RINGMASK	COMPUTE INDEX OF CHARACTER END
	ADD	QW3		ADDRESS OF THAT SAMPLE
	TAX
	LDA	1,X
	ORA	QW1
	STA	1,X		SET APPROPRIATE BIT IN CONTROL RING
	LDA	BAUD,B		BAUD WIDTH
	LDB	MASK+10		SET MASK FOR GETTING 7 CHARS
	JMPM	GETCAR		GET THE CHARACTER
Q1RECEV	LDA	QW2		GET THE PORT NUMBER
	LLSR	10		PACK <PORT-NUMBER,CHARACTER) IN (B)
	LDA	QRGX		FIND PLACE TO PUT NEW ITEM INTO QUASI-RING
	IAR
	ANA	=SBODMASK
	STA	QRGX
	SUB	QSBX
	JAZ	QSBODH
	LDA	QRGX		CALCULATE ADDRESS OF NEW CHARACTER
	ADD	=SBODRING
	TAX
	STB	0,X		AND SAVE CHARACTER
	LDA	SBODCNT		DECREMENT CHARACTER COUNT
	DAR
	STA	SBODCNT
	JMP	QSBOD1		GO LOOK FOR MORE START BAUDS.
*
QSBODH	INR	RINGZAP
	STA	SBODCNT
	JMP	QSBOD1
*
*
* 2741 READER
QR2741	LDB	QW2		CHAR POSITION
	LDA	SBX		START BAUD INDEX
	ADD	=M8THBAUD	MIDDLE OF 8TH INFO BAUD
	ANA	=RINGMASK
	ADD	QW3		RING INDEX
	TAX
	LDA	0,X
	ANA	QW1		MASK FOR CHAR POSITION
	JAZ	QR41A
	LDA	TF2,B
	ANA	MASK+3		TEST LONG SPACE CONDITION FLAG
	JAZ	QR41C
	ERA	TF2,B		TURN OFF LONG SPACE FLAG
	ORA	MASK+2		TURN ON EOA FLAG
	STA	TF2,B
	LDA	TF,B
	ANA	CMSK+6		KEYBOARD SWITCH TO UNLOCK
	STA	TF,B
	JMP	QR41B
QR41A	LDA	SBX
	ADD	=SBODFLAG	MAKE SURE SBA GETS TURNED ON IN TIME
	ANA	=RINGMASK
	ADD	QW3
	TAX
	LDA	TF2,B
	ORA	MASK+3		LONG SPACE CONDITION FLAG TURN ON
	STA	TF2,B
QR41B	LDA	1,X
	ORA	QW1		PUT MARK IN CONTROL RING
	STA	1,X
	JMP	QSBOD1
QR41C	LDB	MASK+7		SET CODE FOR GETTING 7 BITS
	LDA	=BAUDWIDTH
	JMPM	GETCAR
	LDA	1,X		SET CONTROL RING BIT FOR SBA
	ORA	QW1
	STA	1,X
	LLRL	7
	ANA	=77		TRUNCATE CHARACTER TO 6-BITS
	LLSR	10
	JMP	Q1RECEV
*
*
*	TERMINAL ID SCANNER
QTID	LDB	=-36D		SEARCH NEXT 36D SAMPLES
	LDA	SBX		START AT START-BAUD INDEX
	ADD	QW3		BIAS IT AROUND
	JMP	QTIDA1		SKIP
QTIDA	TXA			UPDATE SAMPLE INDEX
	ADD	=SAMPLESIZE
	TAX
	SUB	=RINGEND	TEST IF TO FOLD IT BACK
	JAN	QTIDA2		SKIP IF NOT
	ADD	=RING		ELSE RECYCLE RING
QTIDA1	TAX
QTIDA2	LDA	0,X
	ANA	QW1
	DAR
	JAP	QTIDC
	INC	B,AB
	JAN	QTIDA
QTIDB	INR	NOISE		NOT A VALID START-BAUD...COUNT THE RECORD AS NOISE
	LDA	RGX
	ADD	QW3		SET THE CONTROL BIT
	TAX
	LDA	1,X
	ORA	QW1
	STA	1,X
	JMP	QSBOD1
QTIDC	TBA			HERE WITH NON-NOISE RECORD...DETERMINE BAUD RATE
	ADD	=30D		DETERMINE IF LESS THAN 6 SAMPLES OF 1
	JAN	QTIDD3
	SUB	MASK+1		 =2
	JAN	QTIDB
	SUB	=3
	JAN	QTIDD1
	SUB	MASK+2		=4
	JAN	QTIDB
	SUB	=3
	JAN	QTIDD2
	SUB	=14
	JAN	QTIDB
	ADD	MASK+10		 =400
QTIDD1	ADD	MASK+7		 =200
QTIDD2	ADD	MASK+11		 =1000
QTIDD3	ADD	=1020
	LSRA	7-NUMPGRP
	LDB	MASK+5		SET CODE FOR GETTING 5 BITS
	JMPM	GETCAR
	LDA	QW4
	LRLA	2-NUMPGRP
	LLRL	5
	LDX	=TRMTYP
QTIDE	SUB	0,X
	JAN	QTIDB
	JAZ	QTIDF
	IXR
	JMP	QTIDE
QTIDF	TXA			GOT A MATCH...COMPUTE INDEX
	SUB	=TRMTYP
	LLSR	10		JUSTIFY INDEX AS CHARACTER RECEIVED
	LDA	TRMF3-TRMTYP,X	GET INPUT CHARACTER RATE
	ANA	=7
	TAX
	LDA	RCHAR,X
	ADD	SBX
	ANA	=RINGMASK	COMPUTE WHERE THE CHARACTER ENDS
	ADD	QW3		SET THE CONTROL BIT
	TAX
	LDA	1,X
	ORA	QW1
	STA	1,X
	JMP	Q1RECEV		GO PUT THE CHARACTER OUT TO QUASI-RING FOR SBOD
*
QSBODEXIT	E	*
	LDA	SBODA		RESTORE THE REGISTERS
	LDB	SBODB
	LDX	SBODX
	EXC	IDA
	INR	SBODLOCK	TURN OFF THE LOCK
	EXC	300+IDA
	JMP	SBODRT,I	AND EXIT
*
*	QUASI-BAUD BIT IDENTIFIER
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
QBID	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDX	=17
	JAN	QBID,I
QBID1	LRLA	1
	DXR
	JAP	QBID1
	JMP	QBID,I
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
SBODRING	R	*+SBRINGSZ
*
TRANBUF	R	*+NUMPORTS
QBUFER	E	0		RELATIVE ADDRESSING
QDELAY	E	*-TRANBUF
	R	*+NUMPORTS
	ELSE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ENDIF			ENDING THE QUASISBOD CONDITIONAL BEGUN AT QSBOD
* RECORD TEARDOWN...PROCESSES PHYSICAL RECORDS FROM 201 LINES
* USES SPECIAL WORKING CELLS TO AVOID CONFLICT WITH SBOD
* AND DEVICE DRIVERS WHICH MAY RUN CONCURRENTLY TO PREVENT
* SBOD FROM GETTING BEHIND (APPLIES TO REMOTES ONLY).
* EXPECTS (B) = LINE NUMBER
RTD	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDA	CDIS,B
	ANA	=3		MASK CURRENT SECTOR NUMBER TO SECTOR
	TAX
	LDA	ISF,B		GET CURRENT SECTOR FLAG
	ANA	MASK,X		HAS SECTOR BEEN READ IN?
	JAZ	RTD,I		NO...EXIT.....NOTHING TO DO
* RECORD FOUND..GET SECTOR ADDRESS
	STB	R1		SAVE LINE NUMBER
	TXA
	LRLA	5		SECTOR NUMBER * 32D
	ADD	ISEC,B		COMPUTE SECTOR START ADDRESS FOR THIS LINE
	TAX
	IAR
	LRLA	1		2*(ADDR+1)
	STA	R3		CHARACTER START (CHARACTER ADDRESS..C.A.)
	LDA	0,X
	LSRA	5		GET FIRST WORD OF RECORD, EXTRACT 2*RECORD SIZE
	ANA	=76
	COM	A,A		-2*RECORD SIZE - 1
	ADD	MASK+2		-2*RECORD SIZE + 3
	STA	R2		SAVE APPROXIMATE CHARACTER COUNT
	LDA	0,X
	LSRA	3
	ANA	=7
	STA	LRR,B		EXTRACT AND SAVE SECTOR ADDRESS OF LAST RECORD RECEIVED
* PROCESS LOGICAL RECORD
RT1	JMPM	RTGC		GET FIRST CHAR FROM RECORD...LOGICAL RECORD COUNT
	LRLA	10		HIGH BIT OF COUNT TO SIGN
	STA	R5		SET NO-EXCEPTION FLAG
	LSRA	10		RESTORE COUNT
	ANA	=77		MASK COUNT TO 6-BIT NUMBER (0-63D)
	JAZ	RTERR		ERROR TYPE 0 IF COUNT = 0
	COM	A,A
	STA	R4		COMPLEMENT AND SAVE COUNT
	JMPM	RTGC		GET SECOND CHARACTER..CHANNEL NUMBER
	DEC	A,B
	JBZ	RT10		SKIP IF RESTRICTION CHANNEL
	STA	R6		SAVE CHANNEL NUMBER
	LDB	R1		GET LINE NUMBER
	ADD	IOTA,B
	STA	PTEPNT		COMPUTE ADDRESS OF I/O TABLES
	LDA	PTEPNT,I	GET POINTER FROM TABLE
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS
	ANA	CMSK+17		CLEAR HIGH-ORDER BIT
	TAX			(X) POINTS TO BUFFER ADDRESS FOR DATA
	LDA	R6		TEST IF CHANNEL 0 (SUPERVISOR)
	JAZ	RT00		GO PROCESS IF SO
* COPY OUT CHARACTERS FROM LOGICAL RECORD TO BUFFER
RT2	JMPM	RTGC		GET A CHARACTER
	TAB
	LSRB	2
	JBZ	RT5		SKIP FOR SPECIAL PROCESSING IF CHAR = 0, 1, 2, 3
RT3	JMPM	WCI		PUT THE CHARACTER INTO THE BUFFER
	LDA	R4
	JAN	RT2		TEST COUNT...CONTINUE IF NOT YET DONE
* DONE WITH LOGICAL RECORD
RT4	E	*
	IF	QUASISBOD
	JMPM	SBOD		START-BAUD SCANNER
	ENDIF
	LDA	R2		TEST RECORD SIZE
	JAN	RT1		NOT YET DONE...DO NEXT LOGICAL RECORD IN SECTOR
* DONE WITH SECTOR
	LDB	R1		GET BACK LINE NUMBER
	LDA	CDIS,B
	INR	CDIS,B		GET CURRENT SECTOR, BUMP TO NEXT
	ANA	=3
	TAX
	LDA	CMSK,X		GET THE MASK FOR THIS SECTOR
* DISABLE INTERRUPTS TO PREVENT INTERFERENCE FROM QII
	EXC	IDA
	ANA	ISF,B
	EXC	300+IDA
	STA	ISF,B		REMOVE BIT FROM INPUT SECTOR FLAG...SECTOR NOW FREE
	INR	INDATA,B	BUMP INCOMING RECORD RECEIVED COUNTER
	JMP	RTD,I		AND EXIT
*	HERE WITH CHAR 0, 1, 2, 3.....SPECIAL PROCESSING
RT5	TAB			SAVE CHARACTER
	LDA	R5
	JAN	RT6		SKIP IF NO EXCEPTIONS EXPECTED
	TBA
	SUB	=2		RESTORE CHARACTER AND TEST
	JAZ	RT7		CHAR = 2...CHARACTER GOBBLER
	JAP	RT8		CHAR = 3...CIRCUIT ZAPPER
* CHARACTER PAIR	MUST NOT BE SPLIT UP
	STB	R6		SAVE THE FIRST CHARACTER OF PAIR
	TBA
	JMPM	WCI		SEND THE FIRST CHARACTER ON
	JMPM	RTGC		GET SECOND
	LDB	R6		TEST IF FIRST = EXCAPE
	JBZ	RT3		SEND SECOND IF SO
	TAB			SAVE SECOND
* CHECK FOR CIRCUIT GOUGER
	JMPM	GOUGE		DO GOUGER PROCESS IF REQUIRED
RT6	TBA			OUTPUT SECOND CHARACTER
	JMP	RT3
* CHARACTER GOBBLER
RT7	TXA			CHARACTER = 2
	SUB	=BUFERS		IS THIS FALSE BUFFER
	JAN	RT3		YES..PASS IT THROUGH
	JMPM	SPEED		ELSE SPEED IT ON
	LDA	=2
	JMP	RT3		AND SEND GOBBLER TO NEXT NODE
* CIRCUIT ZAPPER	CHAR = 3
RT8	LDA	PTEPNT,I	GET I/O TABLE ADDRESS
	IAR
	JAZ	RT3		SEND A 0 IF TABLE SET -1
	DAR
	ERA	MASK		ELSE TOGGLE BIT 0
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS
	ANA	CMSK+17
	STX	W1		CLEAR HIGH-ORDER BIT AND SAVE
	TAX
	COM	,A
	STA	PTEPNT,I	SET BUFFER = -1 (NOT IN USE)
	JMPM	EMPTY		EMPTY BUFFER
	TZA
	STA	BF,X		CLEAR BUFFER FLAGS
	LDX	W1
	JMPM	SPEED		CLEAN OUT THE BUFFER
	LDA	=3
	JMP	RT3		AND PASS THROUGH THE ZAPPER
*	SUPERVISOR RECORD STRING
*	R6 = MESSAGE CHARACTER COUNTER
RT00	LDA	=-6		SET MESSAGE CHAR COUNTER
	STA	R6
RT01	JMPM	RTGC		GET A CHAR
	JMPM	WCI		PUT IT INTO THE BUFFER
	INR	R6		COUNT CHAR
	LDA	R6		TEST
	JAN	RT01		REPEAT FOR 1 MESSAGE
	LDA	R4		TEST IF DONE WITH RECORD
	JAZ	RT4		YES..QUIT
	JAN	RT00		MORE CHARS...DO ANOTHER MESSAGE
	JMPM	EMPTY		NOT MULTIPLE OF 6 CHARS...TOSS ALL IN BUFFER
	LDA	MASK+6		ERROR TYPE 1
	JMP	RTERR		GO ERROR OUT LINE
*	RESTRICTED BUFFER DESTINATION
*	FOR EACH ONE BIT, RESET RESTRICTED BUFFER COUNT
*	ALSO SET ALL RESTRICTED BUFFER FLAGS
*	PTEPNT = IOTAB ENTRY
*	R6 = COUNTER OF BYTES TO PROCESS
RT10	LDB	R1		GET THE LINE NUMBER
	LDA	IOTA,B
	STA	PTEPNT		SAVE I/O TABLE ADDRESS
	LDA	IOTABS,B
	STA	R6		SAVE RESTRICTION BYTE-COUNTER
	LDX	GROUPI,B	NUMBER OF GROUPS BEFORE THIS LINE
	LDA	GROUPN,B
	DAR			NUMBER OF GROUPS-1
	COM	,B
RT11	STB	RSBF,X		SET ALL RESTRICTED BUFFER FLAGS
	IXR
	DAR
	JAP	RT11
RT12	JMPM	RTGC		GET A CHARACTER
	TAB			MOVE CHARACTER TO B
	LDA	PTEPNT		GET THE TABLE ENTRY POINTER
	ADD	MASK+3		 =10..COMPUTE ENTRY FOR NEXT BYTE
	STA	PTEPNT
	TAX			SAVE POINTER
RT13	JBZ	RT17		ABORT REST OF GROUP IF NO MORE BITS SET
	DXR			BACK UP THE POINTER
	TBA			COPY THE VALUE
	ANA	MASK		 =1..TEST THE BIT
	JAZ	RT16		BIT NOT SET...SKIP
	LDA	0,X		TEST IF HIGH SPEED
	JAP	RT14		NO....SKIP
	LDA	MASK+7		 =200..YES...SET HIGH-SPEED BUFFER SIZE AND SKIP
	JMP	RT15
RT14	LDA	MASK+5		 =40..LOW-SPEED....SET LOW-SPEED BUFFER SIZE
RT15	STA	NIOTAB,X	SAVE NEW BACK-PRESSURE COUNT
RT16	LSRB	1		MOVE NEXT BIT
	JMP	RT13		REPEAT FOR NEXT BIT
RT17	INR	R6		TEST IF DONE WITH ALL
	LDA	R6
	JAN	RT12		NO...CONTINUE FOR ALL BYTES
	LDA	R4		TEST IF WE GOT THE NUMBER EXPECTED
	JAZ	RT4		CONTINUE IF SO
	LDA	MASK+7		ERROR IN LINE SIZE...SET ERROR TYPE 2 AND FALL THROUGH
*	RECORD TEARDOWN ERROR
*	(A) = CODE TO SEND
RTERR	ORA	=100024		SET ERROR REPORT 24...LINE SHUT DUE TO INVALID SIZES
	LDX	R1		LINE NUMBER
	JMPM	ZAPLIN		ZAP THE LINE
	LDX	R1		LINE NUMBER
	LDA	=PADAPT		SET ALTERNATE RESET EXPECTED
	ERA	RESETI,X
	STA	RESETI,X
	TZA			RESET THE LINE
	STA	SWTCHO,X
	JMP	RTD,I		AND EXIT
*	RTGC BUMPS R2, R3, AND R4 AND RETURNS CHARACTER FROM SECTOR IN (A)
*	IN REMOTES, CALL SBOD TO MAKE SURE IT DOES NOT GET BEHIND
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
RTGC	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	INR	R2		BUMP CHARACTER/RECORD COUNTER
	INR	R4		BUMP CHARACTER/LOGICAL RECORD COUNTER
	LDA	R3		GET ADDRESS
	ANA	MASK
	JAZ	RTGCA		SKIP IF EVEN
	LDB	R3		GET ADDRESS AND BUMP IT
	INR	R3
	LSRB	1		COMPUTE WORD ADDRESS
	LDA	0,B
	ANA	=377		GET SECOND CHAR IN WORD AND MASK
	JMP	RTGC,I		THEN RETURN
RTGCA	E	*		HERE IF EVEN CHAR (LEFT HALF)
	IF	#QUASISBOD
	JMPM	SBODCHK		DETERMINE IF CALL TO 'SBOD' IS NECESSARY, DO SO IF SO
	ENDIF
	LDB	R3		GET AND BUMP ADDRESS, COMPUTE WORD ADDRESS
	INR	R3
	LSRB	1
	LDA	0,B		GET CHARACTER AND RIGHT JUSTIFY IT
	LSRA	10
	JMP	RTGC,I
*	STORAGE FOR RECORD TEARDOWN
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
R1	0			LINE NUMBER
R2	0			APPROXIMATE NUMBER OF CHARACTERS IN PHYSICAL RECORD
R3	0			CHARACTER ADDRESS IN SECTOR
R4	0			COUNT DOWN FOR LOGICAL RECORD
R5	0			NO-EXCEPTION SWITCH..ABORT CHECK FOR EXCEPTION CHARS IF NEGATIVE
R6	0			FIRST HALF OF CHARACTER PAIR
* RECORD MAKER...MAKES PHYSICAL RECORDS FOR 201 LINES
* W1 LINE NUMBER
* W2 NUMBER OF CHARACTERS IN PHYSICAL RECORD
* W3 CHARACTER ADDRESS IN SECTOR
* W4 GROUP INDEX
* W5 NUMBER OF GROUPS
* W6 BUFFER NUMBER	ALSO ACCUMULATOR FOR RMTEST
* W7 LOGICAL RECORD SIZE
* W8 ADDRESS OF BEGINNING OF LOGICAL RECORD
* W9 COUNT DOWN FOR LOGICAL RECORD
* W10 BIT POSITION NUMBER
* W11 CHANNEL NUMBER
* PTEPNT ADDRESS OF IOTAB ENTRY
RMAKE	0			EXPECT (B) = LINE NUMBER
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDA	CAOS,B		CURRENT ASSEMBLY OUTPUT SECTOR
	SUB	COS,B		CURRENT OUTPUT SECTOR
	SUB	MASK+1		=2
	JAP	RMAKE,I		QUIT IF MORE THAN TWO SECTORS ASSEMBLED AHEAD OF OUTPUT
	LDA	CAOS,B		GET THE CURRENT SECTOR ADDRESS
	ANA	=3
	TAX
	LDA	OSF,B		GET THE SECTOR FLAGS
	ANA	MASK,X		MASK FOR THIS SECTOR AND SAVE
	STA	W2
	DAR
	JAP	RMAKE,I		EXIT IF THE CURRENT SECTOR IS STILL IN USE
	STB	W1		SAVE LINE NUMBER
	TXA
	LRLA	5
	ADD	OSEC,B		ELSE COMPUTE SECTOR START ADDRESS+1
	IAR
	LRLA	1
	STA	W3		MAKE CURRENT CHARACTER ADDRESS (CCA) AND SAVE
	JMPM	RMTEST		TEST IF THERE IS ANY OUTPUT FOR THIS LINE
	JAZ	RMAKE,I		NONE...EXIT
*	GIVE PRIORITY TO SUPERVISOR MESSAGES
	LDB	W4		GET GROUP INDEX
	LDA	CFOB,B		CANDIDATE-FOR-OUTPUT-BUFFER
	ANA	RSBF,B		RESTRICTED-BUFFER-FLAGS
	ANA	MASK		SEE IF WE CAN SEND ANY DATA FOR CHANNEL 0
	JAZ	RM1		NO..SKIP
	INR	W4		YES...BUMP GROUP INDEX
	LDA	W5		DECREMENT NUMBER OF GROUPS
	DAR			(FAKING EFFECTS OF RM1)
	STA	W5
	INC	,X		SET BIT NUMBER FOR LATER
	JMP	RM2A		AND SKIP
* PROCEED TO BUILD RECORD
RM1	LDA	W5		DECREMENT GROUP COUNTER
	DAR
	JAN	RM15		ONLY ONE...SKIP
	STA	W5
	LDB	W4		ELSE GET AND BUMP GROUP INDEX
	INR	W4
* ANY LIVE ONES IN THIS GROUP?
RM2	LDA	CFOB,B		CANDIDATES FOR OUTPUT
	ANA	PCFOB,B		PROCESSED CANDIDATES FOR OUTPUT
	ANA	RSBF,B		RESTRICTED BUFFER FLAGS
	JAZ	RM1		DIDN'T GET ONE...TEST FOR NEXT GROUP
	JMPM	BID		IDENTIFY BIT SET
RM2A	STX	W10		AND SAVE NUMBER
	LDA	PCFOB,B		CLEAR APPROPRIATE BIT IN PROCESSED-CANDIDATES-FOR-OUTPUT
	ANA	CMSK,X
	STA	PCFOB,B
* COMPUTE CHANNEL NUMBER
	TBA
	LDB	W1		GROUP INDEX - GROUP INDEX FOR LINE
	SUB	GROUPI,B
	LRLA	4		*16D
	COP	AX,A		.OR. WITH CHANNEL INDEX FOR LINE
	STA	W11		SAVE OUTPUT CHANNEL NUMBER
* LOOK UP BUFFER NUMBER
	ADD	IOTA,B
	STA	PTEPNT		COMPUTE AND SAVE I/O TABLE ENTRY ADDRESS
	TAX
	LDA	0,X		GET INDEX OF INPUT BUFFER
	ERA	MASK		CONVERT TO OUTPUT BUFFER
	ADD	=BUFERS
	ANA	CMSK+17
	STA	W6		SAVE BUFFER POINTER ADDRESS
	LDA	0,X
	IAR			SKIP IF ADDRESS = -1...UNUSED CHANNEL
	JAZ	RM21
	LDA	NIOTAB,X	GET BUFFER RESTRICTION COUNT FOR CHANNEL
	TAB			AND SAVE...(B) IS NUMBER OF CHARACTERS WHICH MAY BE SENT
	SUB	=6
	JAN	RM9		SKIP IF LESS THAN 6 CHARACTERS CAN BE SENT ON CHANNEL
	SUB	=52D		ELSE COMPUTE SPACE REMAINING IN SECTOR (ALLOW FOR LOG. HEADER)
	ADD	W2
	JAN	RM3		ENOUGH SPACE REMAINS FOR ALL CHARS...SKIP
	COM	A,A		NOT ENOUGH SPACE FOR ALL...HOW MANY CAN BE SENT?
	ADD	NIOTAB,X
	INC	A,B		(B) = NUMBER OF CHARACTERS WHICH WILL FIT IN BUFFER
RM3	LDX	W6		GET BUFFER ADDRESS
	TBA			TEST IF ALL CHARACTERS IN BUFFER CAN GO OUT
	SUB	BC,X
	JAN	RM4		NO...SKIP (TRANSMIT ALL CHARACTERS POSSIBLE)
	LDB	BC,X		YES..SET (B) TO TRANSMIT ALL CHARACTERS IN BUFFER
* TEST FOR SUPERVISORY OR FLOW RESTRICTION CHANNEL
RM4	LDX	W11		GET CHANNEL NUMBER
	JXZ	RM17		0...SUPERVISOR
	DEC	X,A
	JAZ	RM18		1...FLOW RESTRICTIONS
RM5	STB	W7		SAVE COUNT OF CHARS TO TRANSMIT...LOGICAL RECORD SIZE
	COM	B,B
	INC	B,B
	STB	W9		SAVE COUNTER FOR LOGICAL RECORD
* BUILD LOGICAL RECORD
	LDA	W3		SAVE ADDRESS OF LOGICAL RECORD BEGINNING (WHERE COUNT GOES)
	STA	W8
	IAR
	STA	W3		BUMP CHARACTER ADDRESS
	JMPM	RMSTC		STORE CHANNEL NUMBER
* COPY CHARACTERS INTO SECTOR
RM6	LDX	W6		GET SOURCE CHARACTER ADDRESS
	JMPM	GCI		GET THE CHARACTER FROM BUFFER
	TAX			SAVE THE CHARACTER IN (X)
	LSRA	2
	JAZ	RM12		SPECIAL CASE FOR CHARACTER = 0, 1, 2, 3
RM7	INR	W3		BUMP AND GET SECTOR CHARACTER POINTER
	LDA	W3
	JMPM	RMSTC		PUT CHARACTER IN SECTOR
	INR	W9		BUMP COUNTER
	LDA	W9
	JAN	RM6		LOOP IF ANY MORE CHARACTERS TO OUTPUT
RM8	LDX	W7		GET LOGICAL RECORD CHARACTER COUNT
RM8A	INR	W3
	LDA	W8		GET LOGICAL RECORD START ADDRESS
	JMPM	RMSTC		PUT SIZE AT START OF LOGICAL RECORD
	LDX	PTEPNT		REDUCE BUFFER RESTRICTION BY NUMBER OF CHARACTERS SENT
	LDA	NIOTAB,X
	SUB	W7
	STA	NIOTAB,X
	SUB	=6		COMPUTE CHARACTERS REMAINING IN BUFFER
* RM9 IS ENTERED FROM MIDDLE OF RM2 SECTION
* ALSO ENTERED FROM RM22
RM9	LDB	W4		GET GROUP INDEX - 1
	DBR
	JAP	RM10		SKIP IF MORE THAN 6 CHARACTERS LEFT IN BUFFER
*	THE NUMBER 6 IS SELECTED FOR EFFICIENCY AND TO AVOID BUG IN RM17
	LDX	W10		LESS THAN 6 REMAIN...
	LDA	RSBF,B
	ANA	CMSK,X		TURN OFF RSBF FOR BUFFER
	STA	RSBF,B
* NOTE: SUBTLE INEFFICIENCY BUG CAUSED BY RM12
* IF 54D IS CHANGED TO 55D
RM10	LDA	=54D		IS THERE ROOM IN SECTOR FOR AT LEAST 2 CHARS AND HEADER?
	SUB	W2
	JAP	RM2		YES...GO FIND NEXT
RM11	LDB	W1		DONE WITH SECTOR...MAKE HEADER
	LDA	CAOS,B		GET SECTOR NUMBER
	ANA	=3
	LRLA	5		*32B
	ADD	OSEC,B		 + OUTPUT SECTOR ADDRESS
	TAX
	LDA	CAOS,B		CURRENT ASSEMBLY OUTPUT SECTOR
	LLSR	3		MOVE SECTOR NUMBER INTO (B)
	LDA	W2		GET COUNT OF CHARACTERS IN SECTOR
* NOTE: RSBF MAY HAVE BEEN TURNED ON WHEN INAPPROPRIATE,
* POSSIBLY RESULTING IN NO LOGICAL RECORDS BEING BUILT.
* IF SO, WE ABORT THIS PHYSICAL RECORD
	JAZ	RMAKE,I		ABORT IF NO RECORD THERE
	ADD	=3		FORCE TO NEXT WORD BOUNDARY, MAKE WORD COUNT + 1
	LSRA	1
	LLRL	6		PACK IN SECTOR NUMBER
	LDB	W1
	ORA	BORO		SET BEGINNING-OF-RECORD-OUTPUT FLAG
	STA	0,X		SET HEADER...FORM(5/1, 5/N WORDS, 3/SECTOR NUMBER, 3/0)
	LDA	CAOS,B		DONE WITH SECTOR (PHYSICAL RECORD)
	INR	CAOS,B		GET AND BUMP CURRENT SECTOR NUMBER
	ANA	=3
	TAX
	LDA	MASK,X		GET BIT FOR SECTOR
	EXC	IDA		DISABLE INTERRUPTS TO PREVENT INTERFERENCE FROM QII AND QIO
	ORA	OSF,B		SET BIT THAT SECTOR IS READY TO GO
	EXC	300+IDA
	STA	OSF,B
	LDA	TIMEL		SAVE CURRENT TIME
	STA	TIME1,B
	JMP	RMAKE,I		AND EXIT
* SPECIAL CHARACTER PAIR
* THE FIRST CHARACTER MAY NOT GO IF THERE IS NOT ROOM
* FOR THE SECOND TO GO WITH IT. THIS PAIR OF CHARACTERS
* MUST NOT BE SPLIT UP
* THE FIRST 2 CHANNELS DO NOT HAVE THESE CHARACTER PAIRS
RM12	LDA	W11
	SUB	=2
	JAN	RM7		ABORT THIS SECTION FOR FIRST TWO CHANNELS
	TXA			COPY CHARACTER
	SUB	=2
	JAZ	RM7		2...(CHARACTER GOBBLER) PASS IT ON
	JAP	RM20		3...(ZAPPER)
	INR	W9		COUNT LOGICAL RECORD AND TEST
	LDA	W9
	JAP	RM14		SKIP IF NO ROOM FOR SECOND CHARACTER
	INR	W3		ELSE OUTPUT FIRST CHARACTER
	LDA	W3
	JMPM	RMSTC
	LDX	W6
	JMPM	GCI		GET NEXT CHARACTER
	TAX
	JMPM	GOUGE		TEST FOR CIRCUIT GOUGER
	JMP	RM7		AND PASS CHARACTER ON
* NO ROOM FOR SECOND CHARACTER
* PUT THE FIRST ONE BACK
RM14	LDX	W6
	JMPM	WCD		PUT THE CHARACTER BACK
	LDX	W7		BUMP BACK LOGICAL RECORD SIZE
	DXR
	JMP	RM8A		AND GO CLEAN UP LOGICAL RECORD
* GO AROUND AGAIN IF ANY BUSINESS LEFT
RM15	LDB	W1		GET LINE NUMBER
	JMPM	RMTEST		GO SETUP FOR NEW LOGICAL RECORD
	LDB	W4		GET GROUP INDEX
	COM	,AX
	ADD	W5		NUMBER OF GROUPS - 1
RM16	STX	PCFOB,B		SET ALL BITS IN PROCESSED-CANDIDATES-FOR-OUTPUT
	IBR
	DAR
	JAP	RM16		DO FOR ALL GROUPS
	LDA	W6		ARE THERE ANY MORE CANDIDATES?
	JAZ	RM11		QUIT IF = 0
	JMP	RM1		ELSE GO BUILD A NEW RECORD
* SUPERVISORY CHANNEL MAY SEND ONLY MULTIPLE OF 6 CHARACTER RECORDS
RM17	STB	W7		SAVE LOGICAL RECORD SIZE
	COM	B,A
	ADD	=6		COMPUTE -REMAINDER (MODULO 6)
	JAN	*-1
	SUB	=5
	ADD	W7
	JAZ	RM11		END RECORD IF LESS THAN 6 CHARACTERS
	TAB
	JMP	RM5		ELSE CONTINUE, (B) = LOGICAL RECORD SIZE, MULTIPLE OF 6
* RESTRICTION CHANNEL MAY SEND ONLY FIXED LENGTH RECORD
RM18	TBA
	LDX	W1		GET THE LINE NUMBER
	ADD	IOTABS,X	WILL EXACT NUMBER FIT?
	JAZ	RM19		YES..SKIP
	JMP	RM11		NO...TERMINATE RECORD
RM19	INC	,X		SET TO TRANSMIT 1 WORD
	JMP	RM5
* CIRCUIT ZAPPER
RM20	LDX	W6
	JMPM	ZBF		EMPTY THE BUFFER AND CLEAR THE BUFFER FLAGS
	LDA	W9
	IAR			REMOVE PRECEEDING CHARS FROM SECTOR FOR THIS LOGICAL RECORD
	ADD	W7
	STA	W7
	LDA	PTEPNT,I	GET OLD I/O ADDRESS, MAKE IT NULL
	COM	,B
	STB	PTEPNT,I
	ADD	=BUFERS
	ANA	CMSK+17		CLEAR HIGH-ORDER BIT FROM APPROPRIATE BUFFER POINTER
	TAX
	JMPM	EMPTY		EMPTY THE OTHER BUFFER OF THE PAIR
	INR	W3
	LDA	W3
	LDX	=3
	JMPM	RMSTC		PUT A ZAPPER IN THE LOGICAL RECORD
	JMP	RM8		AND GO TERMINATE LOGICAL RECORD
* A POINTER TO A NULL ENTRY HAS BEEN FOUND
* DEASSIGN ALL BUFFERS WITH SUCH A POINTER
RM21	LDA	W4		GROUP INDEX
	ADD	=CFOB-FLAG-1
	LRLA	4		*16D
	ORA	W10
	STA	W10		COMPUTE BUFFER FLAG INDEX
	LDX	=BUFERS
RM22	LDA	BF,X		REMOVE ALL BUFFERS FOR SUCH INDEX
	SUB	W10
	JAZ	RM23		FOUND ONE
	INC	X,AX
	SUB	=BUFERS+NBUF
	JAN	RM22		DO FOR ALL
	JMP	RM9		THEN ABORT THE LOGICAL RECORD
RM23	INR	RMERR		FOUND ONE...COUNT THE ERROR
	JMPM	ZBF		PURGE THE BUFFER, CLEAR THE FLAG
	JMP	RM22		SEARCH FOR MORE
* INITIALIZE W4 AND W5
* ALSO SEE IF THERE ARE ANY POSSIBILITIES FOR BUILDING LOGICAL RECORDS
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
RMTEST	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TZA
	STA	W6		CLEAR ACCUMULATOR
	LDX	GROUPN,B
	STX	W5		INITIALIZE GROUP NUMBER
	LDB	GROUPI,B
	STB	W4		INITIALIZE GROUP INDEX
RMTESTA	LDA	CFOB,B		CANDIDATE-FOR-OUTPUT-BUFFER
	ANA	RSBF,B		RESTRICTED-BUFFER-FLAGS
	ORA	W6
	STA	W6
	DXR
	JXZ	RMTEST,I	RETURN AFTER DOING ALL GROUPS, (A) = ACCUMULATED BITS
	IBR
	JMP	RMTESTA		DO FOR ALL GROUPS
* STORE THE CHARACTER IN THE X BOX AT THE CHARACTER ADDRESS
* IN THE A BOX	ALSO BUMP W2
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
RMSTC	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	INR	W2		COUNT THE CHARACTER IN THE RECORD
	TAB
	LSRB	1
	ANA	MASK
	JAZ	RMSTCA		SKIP IF THIS IS EVEN (TO LEFT IN WORD) CHARACTER
	LDA	0,B		RIGHT HALF...CLEAR RIGHT BITS THERE
	ANA	=177400
	COP	AX,A		SET NEW CHARACTER IN
	STA	0,B
	JMP	RMSTC,I		SAVE PACKED WORD AND EXIT
RMSTCA	TXA			CHARACTER GOES IN LEFT HALF...JUSTIFY IT
	LRLA	10
	TAX
	LDA	0,B
	ANA	=377		MASK SPACE IN BUFFER
	COP	AX,A		MERGE IN NEW CHARACTER
	STA	0,B
	JMP	RMSTC,I		RESTORE AND EXIT
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
RMERR	0
*	START-BAUD SCANNER
SBOD	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	IF	QUASISBOD
*
*
	LDX	=SBT8		ADDRESS STATISTICS COUNT
	TZA
	SUB	SBODCNT		CALCULATE STATISTICS- PLATEAUS ARE
SBODL	SUB	MASK+3		 =10..IN GROUPS OF 8.
	JAN	SBOD1
	INR	0,X		INCREMENT COUNT
	IXR			MOVE TO NEXT CELL
	JMP	SBODL		AND LOOP
*
*
SBOD1	LDA	SBODCNT		ANY CHARACTERS?
	JAZ	SBOD4		NO.
	LDA	QSBX		GET THE INDEX
	IAR			AND INCREMENT
	ANA	=SBODMASK
	TAB			SAVE VALUE
	ADD	=SBODRING	GET ADDRESS OF CHARACTER
	TAX
	LDA	0,X		THEN CHARACTER
	EXC	IDA
	STB	QSBX		SAVE NEW INDEX
	EXC	300+IDA
	INR	SBODCNT		ALTER COUNT
	LLSR	10		SEPERATE PORT NUMBER FROM CHARACTER
	LSRB	10
	JMP	RECEVR		NOW PUT IT AWAY
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
SBT8	0
SBT16	0
SBT24	0
SBT32	0
SBT40	0
SBT48	0
SBT56	0
SBT64	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*
*
SBOD4	E	*
	ELSE
	LDA	RGX
	SUB	SBX
	LRLA	7-(NUMPGRP/2)	DETERMINE NUMBER OF SAMPLES INPUT, NOT YET SCANNED
	JAN	SBOD1		N > 200..GO PROCESS CHARACTER (WE'RE WAY BEHIND)
	SUB	=56400		(=135 UNSHIFTED)
	JAP	SBOD1		ENOUGH SAMPLES EXIST FOR CHARACTER..GO PROCESS IT
	ENDIF
	LDA	TCW		TERMINAL CHARACTER WAITING
	ORA	XFLAG		 .OR. X-FLAG
	ANA	NCIB
	ANA	PNCIB		PREVIOUSLY PROCESSED 'NCIB'
	IF	ONLY16
	JAZ	SBOD6
	ELSE
	JAZ	SBOD5
	ENDIF
	JMPM	BID		BIT IDENTIFIER
	LDA	PNCIB		WE HAVE NOW PROCESSED HIM
	ANA	CMSK,X
	STA	PNCIB
	TXB
	LDA	=RING
	JMP	TRAN
	IF	#ONLY16
SBOD5	LDA	TCW+1
	ORA	XFLAG+1
	ANA	NCIB+1
	ANA	PNCIB+1
	JAZ	SBOD6
	JMPM	BID
	LDA	PNCIB+1
	ANA	CMSK,X
	STA	PNCIB+1
	LDA	MASK+4
	COP	AX,B
	LDA	=RING+2
	JMP	TRAN
	ENDIF
*
*  WE GOT THRU THEM ALL.  REINITIALIZE 'PNCIB'.
*
SBOD6	COM	,A		NO ONE PROCESSED YET
	STA	PNCIB
	STA	PNCIB+1
	JMP	SBOD,I
	IF	#QUASISBOD
SBOD1	LDA	SBX		NEXT CHARACTER MAY EXIST IN STRING
	ADD	=RING		COMPUTE CURRENT SAMPLE POSITION IN RING
	TAX
	LDA	SBX
	ADD	=SAMPLESIZE
	ANA	=RINGMASK
	STA	W1		COMPUTE INDEX OF NEXT BAUD
	ADD	=RING		COMPUTE ADDRESS OF NEXT BAUD IN RING
	TAB
	LDA	SBA		START BAUD ACTIVE
	ORA	RLA		RECEIVER LINE ACTIVE
	ORA	0,X		THIS SAMPLE
	ORA	0,B		NEXT SAMPLE
	COM	A,A		TOGGLE BITS
	IF	ONLY16
	JAZ	SBOD3		ALL WERE ON...SKIP
	ELSE
	JAZ	SBOD2		ALL WERE ON...SKIP
	ENDIF
	JMPM	BID		ONE OR MORE BITS WERE OFF..GET THE NUMBER OF FIRST ONE
	LDA	MASK,X		(X) = BIT NUMBER, GET BACK THAT BIT
	STA	W1		AND SAVE IT
	ORA	SBA
	STA	SBA		SET START BAUD ACTIVE FOR THIS LINE
	LDA	=RING
	JMP	RECEVR		GO GET THE CHARACTER
	IF	#ONLY16
SBOD2	LDA	SBA+1		SAME GAME FOR SECOND GROUP
	ORA	RLA+1
	ORA	2,X
	ORA	2,B
	COM	A,A
	JAZ	SBOD3
	JMPM	BID
	LDA	MASK,X
	STA	W1
	ORA	SBA+1
	STA	SBA+1
	LDA	MASK+4
	COP	AX,X
	LDA	=RING+2
	JMP	RECEVR
	ENDIF
SBOD3	STA	0,X		HERE WHEN ALL PORTS EXAMINED...CLEAR INPUT BITS
	IF	#ONLY16
	STA	2,X
	ENDIF
	LDA	W1
	STA	SBX		UPDATE START-BAUD INDEX
	SUB	=11*SAMPLESIZE	SKEW FACTOR
	ANA	=RINGMASK
	ADD	=RING
	TAX			COMPUTE ADDRESS OF 8D BAUDS BACK FROM ONE JUST PROCESSED
	LDA	SBA
	ERA	1,X
	STA	SBA		MOVE CONTROL BITS INTO START-BAUD-ACTIVE
	IF	#ONLY16
	LDA	SBA+1		SAME FOR SECOND PORT GROUP
	ERA	3,X
	STA	SBA+1
	ENDIF
	TZA			CLEAR THE OLD CONTROL BITS
	STA	1,X
	IF	#ONLY16
	STA	3,X
	ENDIF
	JMP	SBOD+1		GO SCAN NEXT BAUD
	ENDIF
* RECIEVER FOR ASCII TYPE TERMINALS
	IF	QUASISBOD
* W1 CHARACTER INPUT
* W2 PORT NUMBER
	ELSE
* W1 MASK
* W2 UNIT OR PORT NUMBER
* W3 RING BASE ADDRESS
* W4 BAUD SIZE
	ENDIF
RECA	LRLA	1
	JAN	R2741		3: TERMINAL IS 2741
	JMP	TID		2: NEW TERMINAL...GET TERMINAL ID
RECEVR	E	*
	IF	QUASISBOD
	STB	W1		SAVE INPUT CHARACTER
	STA	W2		SAVE PORT NUMBER
	TAX
	ELSE
	STX	W2		(X) IS PORT NUMBER
	STA	W3		SAVE RING BASE ADDRESS
	ENDIF
	LDA	TF3,X		GET PORT CODE
	JAN	RECA		SPECIAL CASE FOR 2741 OR TERMINAL ID
	IF	#QUASISBOD
	ANA	=7		EXTRACT BAUD RATE
	TAB
	LDA	RCHAR,B		RECEIVER CHARACTER WIDTH FOR CHANNEL
	ADD	SBX
	ANA	=RINGMASK	COMPUTE INDEX OF BAUD END
	ADD	W3		ADDRESS OF THAT SAMPLE
	TAX
	LDA	1,X		SET THE APPROPRIATE BIT IN CONTROL RING
	ORA	W1
	STA	1,X
	LDA	BAUD,B		BAUD WIDTH
	LDB	MASK+10		SET MASK FOR GETTING 8 BITS
	JMPM	GETCAR		GET THE CHARACTER INPUT
	LSRB	10		RIGHT JUSTIFY CHARACTER IN B
	STB	W1		AND SAVE THE CHARACTER
	ENDIF
* ECHO LOGIC
* W1 INPUT CHARACTER
* W2 620 PORT NUMBER
* W3 INPUT BUFFER NUMBER
* W4 OUTPUT BUFFER NUMBER
	LDA	W2		GET THE PORT NUMBER
	TAX
	LRLA	1
	ADD	=BUFERS		COMPUTE THE INPUT BUFFER AND SAVE
	STA	W3
	IAR
	STA	W4		COMPUTE THE ECHO BUFFER AND SAVE
* TEST FOR ECHO OFF OR DEFERRED ECHO
	LDA	TF,X
	ANA	MASK+6		TEST IF NO ECHO
	JAZ	EC2		SKIP IF SO
	LDA	TF,X		TEST IF BALL FLAG GREEN
	ANA	MASK+5
	JAZ	EC1		SKIP IF NOT
	ERA	TF,X		ELSE CLEAR CONDITION
	STA	TF,X
	COP	X,AB
	LSRB	4
	ANA	=17
	TAX			COMPUTE BIT (B) AND WORD (X) INDEX
	LDA	TBOB,B
	ANA	CMSK,X
	STA	TBOB,B		CLEAR TIME-SINCE-LAST-BALL-WENT-OUT
	ANA	TBOA,B
	STA	TBOA,B
	LDX	W3
	LDA	=6
	JMPM	WCI		TRANSMIT A RED BALL
* TEST IF CHARACTER NEEDS AN ESCAPE AND SEND IT IN
EC1	LDX	W3
	LDA	W1		TEST IF CHARACTER = 0-7
	ANA	=370
	JAZM	WCI		YES...TRANSMIT AN ESCAPE (=0)
	LDA	W1
	JMPM	WCI		TRANSMIT THE CHARACTER
	JMP	SBOD1		GO BACK INTO START-BAUD SCANNER
* CHECK FOR HALF DUPLEX
EC2	LDA	TF3,X
	ANA	MASK+13		TEST IF HALF-DUPLEX
	DAR
	JAP	EC5		SKIP IF SO
	LDA	W1		NOT HALF-DUPLEX...IS CHARACTER PRINTABLE
	ADD	=3
	ANA	=177
	SUB	=43
	JAN	EC6		CHAR = 0-40 & 175-177
EC3	LDX	W4		CHARACTER IS PRINTABLE...IS OUTPUT BUFFER EMPTY?
	LDA	BC,X
	DAR
	JAP	EC7		JUMP IF OUTPUT BUFFER NOT EMPTY
* ECHO CHARACTER
	IF	QUASISBOD
* CAN WE PUT IT DIRECTLY INTO THE TRANSMITTER BUFFER?
	LDA	W2		PORT NUMBER
	JMPM	BITADD
	ANA	NCIB,B		IS THERE A CHARACTER IN THE BUFFER NOW?
	JAZ	EC4
* PUT ECHO DIRECTLY INTO THE TRANSMITTER BUFFER.
	LDA	CMSK,X		WE'LL NEED THIS MASK LATER TO TURN NCIB OFF
	STA	W4		WE DON'T NEED THE OUTPUT BUFFER NUMBER
	LDA	W2		PORT NUMBER
	ADD	=TRANBUF
	TAX			ADDRESS CHARACTER BUFFER
	LDA	W1		CHARACTER
	STA	0,X		STORE CHARACTER
	LDA	W4		CMSK
	EXC	IDA
	ANA	NCIB,B
	EXC	300+IDA
	STA	NCIB,B		WE NOW HAVE A CHARACTER IN THE BUFFER
	JMP	EC1
*
EC4	LDX	W4		RESTORE THE ECHO BUFFER POINTER
	ENDIF
	LDA	W1		ECHO THIS CHARACTER
	JMPM	WCI
	JMP	EC1		THEN GO BACK AND TRANSMIT THE CHARACTER
* CHECK FOR CARRIAGE RETURN AND LINE FEED FOR HALF DUPLEX
EC5	LDA	W1		HALF-DUPLEX...GET THE CHARACTER INPUT
	ANA	=177		TEST IT
	SUB	=12
	JAZ	EC10		12: CARRIAGE RETURN
	SUB	=3
	JAZ	EC9		15: LINE FEED
	JMP	EC1		NEITHER...GO TRANSMIT THE CHARACTER
* SPECIAL CHARACTER
* CHECK FOR BELL, TAB, LINE FEED, AND CARRIAGE RETURN
EC6	ADD	=23		(A) = CODE - 40
	JAZ	EC9		15: LINE FEED
	ADD	=3
	JAZ	EC10		12: CARRIAGE RETURN
	ADD	=3
	JAZ	EC3		7: BELL
	SUB	=2
	JAZ	EC8		11: TAB
* ENTER DEFERRED ECHO MODE
EC7	LDX	W2		NONE OF THESE...GET PORT NUMBER
	LDA	TF,X
	ORA	MASK+6
	STA	TF,X		SET DEFERED ECHO MODE
	TXA
	JMPM	BITADD		GET THE BIT AND INDEX FOR THIS PORT
	ORA	DEM,B		DEFERED-ECHO-MODE
	STA	DEM,B
	LDX	W3
	LDA	=7
	JMPM	WCI		TRANSMIT A BELL
	JMP	EC1		THEN GO TRANSMIT THE CHARACTER
* HERE IF WE GOT A TAB
EC8	LDA	TF,X		TEST IF TO ECHO
	ANA	MASK+11
	JAZ	EC7		NO...SKIP TO ENTER DEFERED ECHO
	JMP	EC3		YES...ECHO IT
* GOT A LINE FEED, MUST ECHO A CARRIAGE RETURN
EC9	LDA	MASK+7
	JMPM	EC11
	JAN	SBOD1
	LDA	=212		ECHO THE CARRIAGE RETURN
	JMPM	WCI
	JMP	SBOD1		GO BACK INTO START-BAUD SCANNER
*GOT A CARRIAGE RETURN, MUST ECHO A LINE FEED
EC10	LDA	MASK+10
	JMPM	EC11
	JAN	SBOD1
	LDA	=215		ECHO A LINE-FEED
	JMPM	WCI
	LDA	=377
	JMPM	WCI		ECHO A RUBOUT TOO
	JMP	SBOD1		GO REENTER START-BAUD SCANNER
* ROUTINE TO
* (A) = CONTROL MASK
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
EC11	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STA	W5		SAVE THE MASK
	LDA	TF3,X
	ANA	MASK+13		TEST FOR HALF-DUPLEX
	DAR
	JAP	EC12		YES...SKIP
	LDX	W4		NO...TEST IF ECHO BUFFER EMPTY
	LDA	BC,X
	DAR
	JAP	EC7		YES...ENTER DEFERED ECHO MODE
	LDA	W1		NO...ECHO THE CHARACTER
	JMPM	WCI
EC12	LDX	W3		TRANSMIT THE CHARACTER FOUND
	LDA	W1
	JMPM	WCI
* TEST FOR PAPER TAPE MODE
	LDX	W2		GET PORT NUMBER
	LDA	TF,X		TEST AGAINST MASK ARGUMENT
	ANA	W5
	DAR
	JAN	EC11,I		NO...RETURN
* MAKE SURE OUTPUT BUFFER NOT TOO FULL (APPLIES TO HALF DUPLEX ONLY)
	LDX	W4		YES...TEST ECHO BUFFER SIZE
	LDA	MASK+5		 =40
	SUB	BC,X
	JMP	EC11,I		AND RETURN RESULT
*	TERMINAL ID SCANNER
	IF	QUASISBOD
TID	LDA	W1		GET INPUT CHAR...TABLE INDEX
	ADD	=TRMTYP		MAKE POINTER INTO TABLE
	TAX
	ELSE
TID	LDB	=-36D		SEARCH NEXT 36D SAMPLES
	LDA	SBX		START AT START-BAUD INDEX
	ADD	W3		BIAS IT AROUND
	JMP	TIDA1		SKIP
TIDA	TXA			UPDATE SAMPLE INDEX
	ADD	=SAMPLESIZE
	TAX
	SUB	=RINGEND	TEST IF TO FOLD IT BACK
	JAN	TIDA2		SKIP IF NOT
	ADD	=RING		ELSE RECYCLE RING
TIDA1	TAX
TIDA2	LDA	0,X
	ANA	W1
	DAR
	JAP	TIDC
	INC	B,AB
	JAN	TIDA
TIDB	INR	NOISE		NOT A VALID START-BAUD...COUNT THE RECORD AS NOISE
	LDA	RGX
TIDB2	ADD	W3		SET THE CONTROL BIT
	TAX
	LDA	1,X
	ORA	W1
	STA	1,X
	JMP	SBOD1
TIDC	TBA			HERE WITH NON-NOISE RECORD...DETERMINE BAUD RATE
	ADD	=30D		DETERMINE IF LESS THAN 6 SAMPLES OF 1
	JAN	TIDD3
	SUB	MASK+1		=2
	JAN	TIDB
	SUB	=3
	JAN	TIDD1
	SUB	MASK+2		=4
	JAN	TIDB
	SUB	=3
	JAN	TIDD2
	SUB	=14
	JAN	TIDB
	ADD	MASK+10		 =400
TIDD1	ADD	MASK+7		 =200
TIDD2	ADD	MASK+11		 =1000
TIDD3	ADD	=1020
	LSRA	7-NUMPGRP
	LDB	MASK+5		SET CODE FOR GETTING 5 BITS
	JMPM	GETCAR
	LDA	W4
	LRLA	2-NUMPGRP
	LLRL	5
	LDX	=TRMTYP
TIDE	SUB	0,X
	JAN	TIDB
	JAZ	TIDF
	IXR
	JMP	TIDE
	ENDIF
TIDF	LDB	W2
	LDA	TRMF-TRMTYP,X	SET THE TERMINAL PARAMETERS
	STA	TF,B
	ANA	=17
	STA	W4		SAVE THE TERMINAL TYPE
	LDA	TRMF1-TRMTYP,X
	STA	TF1,B
	LDA	MASK+6		=64D
	STA	TF2,B
	LDA	TRMF3-TRMTYP,X
	STA	TF3,B
	IF	QUASISBOD
	TBA
	JMPM	BITADD		COMPUTE INDICIES
	STA	W1
	ELSE
	LSRB	4
	LDA	W1
	ENDIF
	ORA	LOGGER,B	SET LOGGER BIT FOR PORT
	STA	LOGGER,B
	LDA	W1
	ORA	ACK,B		SET ACKNOWLEDGE FOR PORT
	STA	ACK,B
	LDA	W1
	ORA	PLI,B		SET PLEASE-LOG-IN FLAG FOR PORT
	STA	PLI,B
	LDA	W1
	ORA	NPID,B		SET NODE-PORT IDENTIFICATION FLAG FOR PORT
	STA	NPID,B
	LDA	W1
	COM	A,A
	ANA	TCW,B		CLEAR TERMINAL-CHARACTER-WAITING FOR PORT
	STA	TCW,B
	LDA	W1
	ORA	NBO,B		SET NO-BALL-OUT FOR PORT
	STA	NBO,B
	LDA	W2
	LRLA	1
	ADD	=BUFERS
	TAX
	TZA
	STA	BC+1,X		CLEAR THE PORT OUTPUT BUFFER
	JMPM	EMPTY		EMPTY THE PORT INPUT BUFFER
	LDA	=LOGF
	ADD	W2
	STA	BF,X
	LDA	W4
	ORA	=300
	JMPM	WCI		PUT THE TERMINAL TYPE INTO THE PORT INPUT BUFFER FOR SUPER
	IF	QUASISBOD
	JMP	SBOD1		GO DO ANOTHER CHARACTER
	ELSE
	LDB	W2
	LDA	TF3,B		GET THE INPUT BAUD RATE
	ANA	=7
	TAB
	LDA	RCHAR,B
	ADD	SBX
	ANA	=RINGMASK	COMPUTE WHERE THE CHARACTER ENDS
	JMP	TIDB2
	ENDIF
*	TERMINAL TYPES (BY CHAR)
* CHAR:	A,	C,	E,	G,	B,	F,	J,	CR,	D
TRMTYP	1001;	2;	2;	2;	773;	4;	4;	203;	367
	7777			THIS MUST END TRMTYP LIST
TRMF	42621;	42622;	42623;	42624;	22625;	42626;	32627;	11;	2632
TRMF1	0;	112004;	12146;	1132;	3002;	112004;	3002;	0;	0
TRMF3	12;	12;	12;	2;	11;	11;	11;	140001;	10
* 2741 READER
R2741	E	*
	IF	#QUASISBOD
	LDB	W2		CHAR POSITION
	LDA	SBX		START BAUD INDEX
	ADD	=M8THBAUD	MIDDLE OF 8TH INFO BAUD
	ANA	=RINGMASK
	ADD	W3		RING INDEX
	TAX
	LDA	0,X
	ANA	W1		MASK FOR CHAR POSITION
	JAZ	R41A
	LDA	TF2,B
	ANA	MASK+3		TEST LONG SPACE CONDITION FLAG
	JAZ	R41D
	ERA	TF2,B		TURN OFF LONG SPACE FLAG
	ORA	MASK+2		TURN ON EOA FLAG
	STA	TF2,B
	LDA	TF,B
	ANA	CMSK+6		KEYBOARD SWITCH TO UNLOCK
	STA	TF,B
	JMP	R41B
R41A	LDA	SBX
	ADD	=SBODFLAG	MAKE SURE SBA GETS TURNED ON IN TIME
	ANA	=RINGMASK
	ADD	W3
	TAX
	LDA	TF2,B
	ORA	MASK+3		LONG SPACE CONDITION FLAG TURN ON
	STA	TF2,B
R41B	LDA	1,X
	ORA	W1		PUT MARK IN CONTROL RING
	STA	1,X
	JMP	SBOD1
R41D	LDB	MASK+7		SET CODE FOR GETTING 7 BITS
	LDA	=BAUDWIDTH
	JMPM	GETCAR
	LDA	1,X		SET CONTROL RING BIT FOR SBA
	ORA	W1
	STA	1,X
	LLRL	7
	ANA	=77		TRUNCATE CHARACTER TO 6-BITS
	STA	W4		SAVE THE CHARACTER INPUT
	ELSE
	STB	W4		SAVE THE CHARACTER INPUT
	ENDIF
	LDB	W2		GET PORT NUMBER
	LDA	TF2,B
	ANA	MASK+2		EOA FLAG CHECK
	JAZ	R41C
	IF	QUASISBOD; EXC IDA; ENDIF
	ERA	TF2,B
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF2,B
	LDA	W4
	SUB	=74		EOT CHECK
	JAZ	R41T
R41Q	LDA	CMSK+1		LOWER CASE
	IF	QUASISBOD; EXC IDA; ENDIF
	ANA	TF2,B
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF2,B
	JMP	SBOD1
R41P	LDA	MASK+1		UPPER CASE
	IF	QUASISBOD; EXC IDA; ENDIF
	ORA	TF2,B
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF2,B
	JMP	SBOD1
R41C	LDA	W4
	SUB	=34		UPPER CASE CHANGE CHAR
	JAZ	R41P
	SUB	=3		LOWER CASE CHANGE CHAR
	JAZ	R41Q
	SUB	=16		CARRIAGE RETURN
	JAZ	R41R
	SUB	=17		EOT
	JAZ	R41T
	LDA	MASK+7
	IF	QUASISBOD; EXC IDA; ENDIF
	ADD	TF2,B
	ANA	CMSK+17		BUMP BALL COUNT
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF2,B
	ANA	MASK		PLUSMINUS FLAG
	JAZ	R41J		OFF
	IF	QUASISBOD
	LDA	CMSK
	EXC	IDA
	ANA	TF2,B
	EXC	300+IDA
	ELSE
	ERA	TF2,B
	ENDIF
	STA	TF2,B
	LDA	W4
	ADD	=SCT41		SPECIAL CHAR TABLE
	JMP	R41Z
R41J	LDA	TF2,B
	ANA	MASK+1
	JAZ	R41K		LOWER CASE
	LDA	W4
* TEST FOR SPECIAL CHARACTER.
*	CENT SIGN IF EBCD 2741
*	PLUSMINUS IF CORR 2741
	ERA	=EBCDTEST
	DAR
	JAP	R41L		UPPER CASE
	INR	TF2,B		TURN ON PLUS MINUS FLAG
	JMP	SBOD1
R41K	LDA	W4
	ADD	=CT41
	JMP	R41Z
R41L	LDA	W4
	ADD	=CT41+100
R41Z	TAB
	LDA	W2
	LRLA	1
	ADD	=BUFERS
	TAX
	LDA	0,B
	ORA	MASK+7
	JMPM	WCI
	JMP	SBOD1
R41R	LDA	TF2,B
	LSRA	13
	STA	W1
	LSRA	1
	ADD	W1		CALCULATION COMPLETE FOR DELAY
	COM	A,A
	ASLA	7
	STA	W1
	LDA	W2
	LRLA	1
	ADD	=BUFERS
	TAX
	LDA	=215
	JMPM	WCI
	LDA	W1
	LDB	W2
	JMP	R41U1
R41T	LDA	CMSK+1
	IF	QUASISBOD; EXC IDA; ENDIF
	ANA	TF2,B		TURN ON LOWER CASE
	STA	TF2,B
	LDA	=777
	ANA	TF,B
* PUT EOA IN BOX AND SET KEYBOARD LOCKED
	ORA	=64100
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF,B
	TBA			:TURN ON DEFERRED ECHO FLAG
	JMPM	BITADD
	ORA	DEM,B
	STA	DEM,B
	LDB	W2		TEST STARTUP MODE
	LDA	TF,B
	ANA	MASK+10
	JAZ	R41U
	JMP	SBOD1
R41U	LDA	MASK+10
	IF	QUASISBOD; EXC IDA; ENDIF
	ORA	TF,B		TURN OFF STARTUP MODE
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF,B
	LDA	=-4000		MAX DELAY COUNT
R41U1	STA	W4
	LDA	=17
	IF	QUASISBOD; EXC IDA; ENDIF
	ANA	TF2,B
	ORA	W4		SET DELAY COUNT
	IF	QUASISBOD; EXC 300+IDA; ENDIF
	STA	TF2,B
	JMPM	T41DM
	JMP	SBOD1
* ROUTINE TO EXTRACT A CHARACTER FROM THE RING
* CALLED FROM RECEVR, TID, AND R41D
*	A = BAUD SIZE IN WORDS
*	B = CHARACTER SIZE FLAG (WHEN ALL BITS IN (B)HIGH, B0 IS SET)
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
GETCAR	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STA	QW4
	LSRA	1		SIZE/2
	ADD	SBX		INDEX OF START OF FIRST BAUD
	ANA	=RINGMASK	FOLD TO RANGE, INSURE WILL LOOK AT SAMPLES, NOT CONTROL
	ADD	QW3		ADDRESS OF CENTER OF FIRST BAUD
	TAX			COMPUTE POINTER TO CENTER OF FIRST BAUD
GETC	TXA			UPDATE THE POINTER
	ADD	QW4
	TAX			COMPUTE CENTER OF NEXT BAUD
	SUB	=RINGEND	TEST IF TO CYCLE POINTER
	JAN	GETC1		SKIP IF NOT
	ADD	=RING		YES...DO IT
	TAX
GETC1	LDA	0,X		GET NEXT BAUD
	ANA	QW1		MASK FOR THIS PORT
	JAZ	GETC2		SKIP IF BIT IS RESET
	COM	,A		ELSE SET A BIT IN A
GETC2	LLSR	1		BUILD NEW BIT INTO DATA IN (B) LEFT
	TBA
	ANA	MASK		TEST IF DONE
	JAZ	GETC		CONTINUE IF NOT
	JMP	GETCAR,I	ELSE RETURN, (A) = 1, (B) = DATA INPUT, LEFT JUSTIFIED
* 2741 TRANSMITTER
* W1 MASK
* W2 RING BASE ADDRESS
* W3 PORT NUMBER
* W4 BAUD SIZE
* W5 INPUT BUFFER ADDRESS, ADDRESS OF CHAR IN TRANSLATION TABLE
* W6 CURRENT CHARACTER
* W10 CHARACTER WIDTH
T2741	E	*
	IF	#QUASISBOD
	LDA	=BAUDWIDTH	SET BAUD WIDTH
	STA	W4
	LDA	=E9THBAUD	SET CHARACTER WIDTH
	STA	W10
	ENDIF
	LDA	TF,B
	LSRA	11
	JAZ	T41A		NO CHAR IN BOX
	STA	W6
	LRLA	11
	ERA	TF,B		CLEAR BOX
	STA	TF,B
	LDA	W6
	JMP	T41K
	IF	QUASISBOD
T41A	E	*
	ELSE
T41A	LDA	TF2,B
	JAP	T41B		SKIP IF DELAY COUNT NOT ON
	ADD	MASK+7		BUMP DELAY
	STA	TF2,B
	JMP	TEXIT
T41B	ANA	=160		CHECK LITTLE DELAY
	JAZ	T41C
	LDA	TF2,B
	SUB	MASK+4
	STA	TF2,B
	JMP	TEXIT
T41C	E	*
	ENDIF
	LDA	TF2,B
	ANA	MASK+2		EOA FLAG CHECK
	JAZ	T41D
	IF	QUASISBOD
	LDA	=374
	STA	W2,I
	LDA	=16		SET POST-DELAY
	JMP	PUTC1		AND GO DO IT
	ELSE
	LDA	TF2,B		DELAY 7 CHARACTER TIMES AFTER EOT
	ORA	=160
	STA	TF2,B
	JMPM	T41DM
	LDA	=174		SET UP EOT
	JMP	T41K
	ENDIF
T41D	LDA	W3
	LRLA	1
	ADD	=BUFERS
	STA	W5
	INC	A,X
	LDA	BC,X
	JAZ	TEXIT		NO CHARACTER IN BUFFER...WAIT 1 CHAR TIME
	JMPM	GCI
	STA	W6
* CHECK FOR CONTROL CHARACTER
	LDB	W3
	SUB	MASK+3		 =10
	JAN	T41S
* CHECK OUTPUT MODE
	LDA	TF,B		TEST IF KEYBOARD IS LOCKED
	ANA	MASK+6
	DAR
	JAP	T41F
	JMPM	WCD
	JMP	TEXIT		KEYBOARD IS LOCKED...PUT THE CHAR BACK
T41F	LDA	W6
	ANA	=177
	ADD	=CT41
	STA	W5		PUT CHAR AWAY
	SUB	=CT41+1
	JAZ	T41P		TWIDDLE ON
	SUB	=11
	JAZ	T41R		LINE FEED
	SUB	=3
	JAZ	T41Z		CARRIAGE RETURN
* TURN OFF CR FLAG
	LDA	TF,B
	ANA	CMSK+7
	STA	TF,B
	LDA	TF2,B
	ADD	MASK+7
	ANA	CMSK+17		BUMP BALL COUNT
	STA	TF2,B
	LDX	W5
	LDA	0,X		PICKUP CHAR
	LRLA	2
	ANA	=3
	ADD	=JT41+.
	STA	DUMMY
	JMP	DUMMY,I
T41G	LDA	TF2,B		LOWER CASE CHAR
	ANA	MASK+1
	JAZ	T41J		LOWER CASE ON
	ERA	TF2,B		TURN OFF UPPER CASE
	STA	TF2,B
	LDA	=37		LOWER CASE CHANGE CHAR
	JMP	T41I
T41H	LDA	TF2,B		UPPER CASE
	ANA	MASK+1
	ERA	MASK+1
	JAZ	T41J		UPPER CASE ON
	ORA	TF2,B
	STA	TF2,B		TURN ON UPPER CASE
	LDA	=34		UPPER CASE CHANGE CHAR
T41I	STA	W6
	LDA	0,X		PICK UP CHAR
	LRLA	2
	ANA	=177000
	ORA	TF,B		PUT IN BOX
	STA	TF,B
	JMPM	T41DM
	LDA	W6
	JMP	T41K
T41J	LDA	0,X		EITHER CASE CHAR
	LSRA	7		SET UP CHAR
	IF	QUASISBOD
T41K	ORA	MASK+7		SET HIGH BIT OF CHAR
	STA	W2,I		PUT INTO QUASI-RING
	JMP	TEXIT		AND QUIT
	ELSE
T41K	ORA	=177600		STOP BAUD AND ALL HIGHER BITS
	JMP	PUTC1		PUT THE CHARACTER INTO THE RING AND EXIT
	ENDIF
T41P	LDA	TF2,B		TWIDDLE BALL
	ORA	MASK+4		DELAY ONE CHARACTER TIME BEFORE AND AFTER
	ERA	MASK+1
	STA	TF2,B
	ANA	MASK+1
	JAZ	T41P1
	IF	QUASISBOD
	LDA	=-3
T41P1	ADD	=237		BUILD UPPER OR LOWER CASE CHANGE CHAR
	STA	W2,I		AND PUT IT DOWN
	LDA	=5		SET ONE DELAY BEFORE, 2 AFTER
	JMP	PUTC1		GO SET IT UP
	ELSE
	LDA	=-3000
T41P1	ADD	=37000		SET UP BOX..= UPPER OR LOWER CASE CHANGE CHAR
	JMP	T41R2		AND SKIP
	ENDIF
T41R	LDA	TF,B		LINE-FEED
	ANA	MASK+7		CHECK CR FLAG
	JAZ	T41R1
	ERA	TF,B		TURN OFF
	STA	TF,B
	JMP	T41D
T41R1	LDA	TF2,B
	ORA	MASK+5
	STA	TF2,B
	IF	QUASISBOD
	LDA	=355		CARRIAGE RETURN
	STA	W2,I
	LDA	=5		SET 1 DELAY BEFORE, 2 AFTER
	JMP	PUTC1
	ELSE
	LDA	=156000		DELAY ONE CHARACTER TIME BEFORE AND TWO AFTER
T41R2	ORA	TF,B
	STA	TF,B		INTO BOX
	JMPM	T41DM
	JMP	TEXIT
	ENDIF
T41Z	LDA	TF,B		CARRIAGE RETURN
	ORA	MASK+7		TURN ON CR FLAG
	STA	TF,B
	LDA	TF2,B
	LSRA	13		BALL POSITION/16
	STA	W6
	LSRA	1		BALL POSITION/32
	ADD	W6
	IF	QUASISBOD
	ADD	MASK+1		=2
	LRLA	1		POST-DELAY
	LDB	=355		CARRIAGE RETURN
	STB	W2,I
	JMP	PUTC1		GO CLEAN UP
	ELSE
	COM	A,A		-32*BALL POSITION/3
	SUB	MASK+1		=2...CALCULATION FOR DELAY
	ASLA	7
	STA	W6
	LDA	TF2,B
	ANA	=37
	ORA	W6		SET DELAY COUNT
	STA	TF2,B
	JMPM	T41DM
	LDA	=155		SET UP CHAR
	JMP	T41K
	ENDIF
*	HERE FOR SPECIAL TYMNET CHARACTER
T41S	LDA	W6
	ADD	=T4TAB+.
	STA	DUMMY
	JMP	DUMMY,I
* ESCAPE
T41S0	JMPM	GCI
	LRLA	10
	JAP	T41D
	JMP	TRN17A
* CONDITIONS
T41S1	JMPM	GCI
	STA	W6
	LLSR	4		GET PRIMARY SUBTYPE.
	SUB	=16		TYPE 16 (GLASS CHARACTER) OR TYPE 17?
	JAN	T41D		NO,  MUST BE TERMINAL CHARACTERISTIC- IGNORE.
	JAZ	TRN16		GLASS CHARACTER
	TBA			TEST IF POSSIBLE UNCONDITIONAL HANG-UP
	LSRA	12D
	DAR
	JAZ	TRN17A		SKIP IF SO
	JMP	TRN17		ELSE NORMAL TYPE 17...GO PROCESS IT
* GREEN BALL
T41S5	LDA	TF,B
	ANA	MASK+5
	JAZ	T41D
	LDA	MASK+2
	ORA	TF2,B
	STA	TF2,B
	IF	QUASISBOD
	LSRB	4
	LDA	W1
	COM	A,A
	EXC	IDA
	ANA	NCIB,B
	EXC	300+IDA
	STA	NCIB,B
	ELSE
	JMPM	T41DM
	ENDIF
	JMP	TRANS5
* PUT DUMMY CHARACTER INTO OUTPUT BUFFER TO CAUSE SBOD
* TO CALL THIS ROUTINE UNTIL SOME ACTION (LIKE TIMEOUT) IS COMPLETED
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
T41DM	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TBA
	LRLA	1
	ADD	=BUFERS+1
	TAX
	LDA	BC,X
	DAR
	JAP	T41DM,I
	LDA	MASK+2
	JMPM	WCI
	JMP	T41DM,I
JT41	+T41D
	+T41G
	+T41H
	+T41J
T4TAB	+T41S0
	+T41S1
	+TRANS2
	+TRANS3
	+T41D
	+T41S5
	+TRANS6
	+T41D
* TRANSMITTER FOR ASCII TYPE TERMINALS
* W1 MASK
	IF	QUASISBOD
* W2 BUFFER ADDRESS
	ELSE
* W2 RING BASE ADDRESS
	ENDIF
* W3 UNIT NUMBER
* W4 BAUD SIZE
* W5 INPUT BUFFER NUMBER (ALSO BIT TOGGLE)
* W6 CHARACTER TO SEND
* W7 CURRENT CHARACTER INDEX
* W10 CHARACTER WIDTH
*	EXPECTS (A) = RING BASE ADDRESS
*		(B) = PORT NUMBER
*		(X) = PORT GROUP NUMBER
TRAN	STB	W3		SAVE PORT NUMBER
	IF	#QUASISBOD
	STA	W2		SAVE RING BASE ADDRESS
	ELSE
	TBA
	ADD	=TRANBUF	COMPUTE BUFFER ADDRESS
	STA	W2
	ENDIF
	LDA	MASK,X		GET THE MASK BIT FOR THE PORT WITHIN THE GROUP
	STA	W1		SAVE MASK
	LDA	TF3,B		DETERMINE IF 2741'S
	LSRA	16		FIRST 2 BITS SET IF 2741
	SUB	=3
	JAZ	T2741
	IF	QUASISBOD
	LDA	TF2,B		COUNT THE CHARACTER IN THE LINE
	IAR
	ANA	=1777		TRUNCATE IT
	STA	TF2,B
	TBA
	ELSE
	TBX
	TZB
	LDA	TF,X		GET THE PORT BAUD SIZE
	LLRL	3
	LDA	BAUD,B
	STA	W4		AND SAVE
	LDA	TCHAR,B
	STA	W10		GET THE TRANSMITER CHARACTER WIDTH AND SAVE
	INR	TF2,X
	LDA	TF2,X		BUMP AND TEST DELAY
	JAN	TEXIT		DELAY ON...SKIP
	ANA	=1777		NOT DELAY...TRUNCATE IT AND SAVE
	STA	TF2,X
	COP	X,AB		COPY BACK THE PORT NUMBER
	ENDIF
	LRLA	1
	ADD	=BUFERS
	STA	W5		COMPUTE INPUT BUFFER NUMBER
	INC	A,X
	LDA	TF,B		TEST IF XENABLED
	LRLA	4
	JAP	TRAN0		SKIP IF NOT
	LSRB	4		GOT A POSSIBLE...CHECK XFLAG
	LDA	W1
	ANA	XFLAG,B
	JAZ	TRAN0		SKIP IF NOT SET
	ERA	XFLAG,B		ELSE CLEAR FLAG BIT
	STA	XFLAG,B
	LDA	XNEW,B		COPY NEW BIT VALUE
	ERA	XSTATE,B
	ANA	W1
	ERA	XSTATE,B
	STA	XSTATE,B
	ANA	W1		DETERMINE IF TO SET X-ON OR X-OFF
	JAZ	*+3		SKIP IF X-OFF
	LDA	MASK+1		=2
	ADD	=221		FORCE X-ON/X-OFF
	STA	W6		SAVE THE CHARACTER
	LDX	W3		GET THE PORT NUMBER
	JMP	TRAN2		AND SKIP TO SET UP FOR OUTPUT
TRAN0	JMPM	GCI		GET THE CHARACTER TO OUTPUT
	STA	W6		SAVE IT
	SUB	MASK+3		 =10
	JAN	TRANS		SKIP IF SPECIAL CHARACTER
TRAN1	LDX	W3		GET THE PORT NUMBER
	IF	PRINTER
	IF	DPRINTER
	DEC	X,B		TEST IF PORT 1
	JBZ	TRP1		GO HANDLE IF SO
	ENDIF
	JXZ	TRP0		TEST IF PORT 0...GO HANDLE IF SO
	ENDIF
TRAN2	LDA	TF,X
	ANA	MASK+14		TEST IF REQUIRES PARITY
	JAZ	TRAN3		SKIP IF NOT
	LDA	W6		ELSE COMPUTE PARITY
	LSRA	4
	ERA	W6		FOLD THE CHARACTER
	ANA	=17		MAKE 4 BITS
	TAX
	LDA	=64626		PARITY BIT MASK
	ANA	MASK,X		TEST IF PARITY BIT IS TO BE SET ON
	JAZ	TRAN3		NO..SKIP
	LDA	W6		YES...SET THE BIT
	ERA	MASK+7
	STA	W6
TRAN3	LDA	W6		GET THE CHARACTER
	IF	QUASISBOD
	STA	W2,I		PUT THE CHARACTER INTO THE RING
	ENDIF
	ANA	=177		MASK THE CHARACTER TO 7 BITS
	SUB	=22
	IF	QUASISBOD
	JAP	TEXIT		.GT. 21:  NO CHANCE OF BEING SPECIAL, SO SKIP
	ELSE
	JAP	TRAN4		.GT. 21:  NO CHANCE OF BEING SPECIAL, SO SKIP
	ENDIF
	IAR
	JAZ	TRAN13		21:  SKIP IF X-ON
	ADD	MASK+2		=4
	JAZ	TRAN10		15:  SKIP IF CARRIAGE RETURN
	ADD	=3
	JAZ	TRAN6		12:  SKIP IF LINE-FEED
	IF	QUASISBOD
	JAP	TEXIT		SKIP IF NOT TAB
	ELSE
	JAP	TRAN4		SKIP IF NOT TAB
	ENDIF
	LDA	TF2,X		HERE WITH HORIZONTAL TAB...SET CHAR. COUNT
	ADD	MASK+3		=8
	ANA	=1770		FORCE TO MULTIPLE OF 8 CHARACTERS
	STA	TF2,X
	IF	QUASISBOD
	JMP	TEXIT		AND QUIT
	ELSE
TRAN4	LDA	=177400		STOP BAUD AND ALL HIGHER BITS
	ORA	W6		AND THE CHARACTER IT SELF
	JMP	PUTC1		GO PUT THE CHARACTER INTO THE RING
	ENDIF
TRAN6	LDA	TF3,X		HERE WITH A LINE-FEED
	LRLA	14
	JAN	TRAN12		IF NOT L/F DELAY, TEST IF ALTERNATE L/F DELAY
	LDA	TF2,X		GET COUNT OF CHARS IN LINE (N)
	IF	QUASISBOD
	JAZ	TEXIT		N = 0..TRANSMIT CHAR
	ELSE
	JAZ	TRAN4		N=0..SEND CHARACTER
	ENDIF
	DAR
	JAZ	TRAN8		SKIP IF N = 1
	LDA	TF1,X
	LLSR	4		NO..GET PARAMETER B AND SAVE
	ANA	=17
	STA	W8
	LSRB	14		EXTRACT PARAMETER C...CARRIAGE RETURN DELAY INDEX
	LDA	CPARAM,B	GET THE CARRIAGE-RETURN-DELAY-PARAMETER(C)
	SUB	TF2,X		- N
	JAP	TRAN7		COMPARE WITH COUNT...USE MINIMUM
	TZA			NOT GREATER...USE PARAMETER B ONLY
TRAN7	ADD	W8		+ PARAMETER B
	JMP	TRAN9		AND SKIP
TRAN8	LDA	TF1,X		N = 1...DELAY IS PARAMETER C
	ANA	=17		EXTRACT PARAMETER C
	IF	QUASISBOD
TRAN9	TZB
	STB	TF2,X		RESET COUNTER
	JAZ	TEXIT		TRANSMIT CHAR IF COUNT = 0
	LRLA	1		ELSE COMPUTE DELAY
	IAR
	JMP	PUTC1		AND PUT DELAY INTO RING
	ELSE
TRAN9	DAR			MAKE NEGATIVE
	COM	A,A
	STA	TF2,X		SET DELAY COUNT
	JAZ	TRAN4		TRANSMIT LINE-FEED IF DELAY NOW = 0
	LDX	W5		ELSE PUT THE LINE-FEED BACK IN BUFFER
	IXR
	JMPM	WCD
	JMP	TEXIT		AND GO SKIP FOR 1 CHARACTER DELAY
	ENDIF
TRAN10	LDA	TF3,X		HERE WITH A CARRIAGE RETURN
	ANA	MASK+3
	JAZ	TRAN12		IF NOT C/R DELAY, TEST IF ALTERNATE C/R DELAY
	LDA	TF1,X		ELSE GET PARAMETER B, C
	LLSR	4
	ANA	=17
	STA	W8		AND SAVE PARAMETER B
	LSRB	14		EXTRACT PARAMETER C
	LDA	TF1,X		EXTRACT PARAMETER A
	LRLA	10
	ANA	=7
	ORA	=4340		BUILD A SHIFT INSTRUCTION
	STA	DUMMY
	LDA	TF2,X		GET THE NUMBER OF CHARACTERS OUTPUT (N)
	XEC	DUMMY		N/(2**A)
	ADD	W8		+B
	SUB	CPARAM,B	TEST AGAINST CARRIAGE RETURN DELAY..USE MINIMUM
	JAN	TRAN11		LESS..SKIP TO USE COMPUTED VALUE
	TZA			GREATER OR EQUAL..USE PARAMETER ONLY
TRAN11	ADD	CPARAM,B	COMPUTE VALUE TO USE
	IF	QUASISBOD
	TZB
	STB	TF2,X		RESET COUNTER
	LRLA	1		*2
	JMP	PUTC1		AND GO DO IT
	ELSE
	COM	A,A		SET COUNT NEGATIVE
	STA	TF2,X
	JMP	TRAN4		AND GO TRANSMIT IT
	ENDIF
*	HERE WITH NON-DELAY C/R OR L/F...DETERMINE ALTERNATE DELAY
TRAN12	LDA	TF1,X		GET PARAMETER "D" FOR ALTERNATE DELAY
	ANA	=170000		TEST IF IN USE
	IF	QUASISBOD
	JAZ	TEXIT		TRANSMIT CHARACTER IF NOT
	ELSE
	JAZ	TRAN4		TRANSMIT CHARACTER IF NOT
	ENDIF
	LRLA	4		ELSE JUSTIFY IT
	TAB
	LDA	CPARAM,B	GET VALUE
	IF	QUASISBOD
	JMP	PUTC1		GO DO DELAY
	ELSE
	COM	A,A		MAKE NEGATIVE
	STA	TF2,X		SET DELAY COUNTER
	JMP	TRAN4		AND GO SEND CHARACTER
	ENDIF
*	HERE WITH X-ON
TRAN13	COP	X,B		SET FLAG IN XSTART FOR PORT
	LSRB	4
	LDA	W1		GET MASK
	COM	A,A		AND COMPLEMENT IT
	ANA	XSTATE,B
	STA	XSTATE,B
	IF	QUASISBOD
	JMP	TEXIT		GO CLEAN UP
	ELSE
	JMP	TRAN4		AND GO ENTER NORMAL SEQUENCE
	ENDIF
*
TRANS	ADD	=TRANT+.+10	SPECIAL CHARACTER 0-7
	STA	DUMMY
	JMP	DUMMY,I
* TRANSFER TABLE..USED TO PROCESS CHARACTERS 0-7
TRANT	+TRANS0			0-ESCAPE
	+TRANS1			1-PREFIX CHARACTER
	+TRANS2			2-CHARACTER GOBBLER
	+TRANS3			3-CIRCUIT ZAPPER
	+SBEXIT			4-LEAVING DEFERED ECHO MODE...NOT RECEIVED BY REMOTES
	+TRANS5			5-GREEN BALL
	+TRANS6			6-RED BALL
	+SBEXIT			7-ENTERING DEFERED ECHO MODE...NOT RECEIVED BY REMOTES
*
TRANS0	JMPM	GCI		0 - ESCAPE...GET THE SECOND CHARACTER
	STA	W6		SAVE IT
	JMP	TRAN1		AND CONTINUE
TRANS1	JMPM	GCI		1 - PREFIX...GET THE SECOND CHARACTER
	STA	W6		SAVE IT
	LLSR	4		EXTRACT HIGH 4 BITS (LOW IN B)
	LDX	W3		UNIT NUMBER
	ADD	=TRANC+.	COMPUTE TRANSFER ADDRESS
	STA	DUMMY
	JMP	DUMMY,I
* TRANSFER TABLE FOR PREFIX CODES
*	!!!!!!!!	SCHEDULED FOR ELIMINATION!!!!!!!!
TRANC	+TRN0			0 - SET ECHO CONTROL			!!!!!!!!
	+TRN1			1 - SET C/R DELAY AND INPUT BAUD RATE	!!!!!!!!
	+TRN2			2 - SET OUTPUT BAUD RATE AND PARITY	!!!!!!!!
	+TRN3			3 - SET PARAMETER A AND HALF-DUPLEX	!!!!!!!!
	+TRN4			4 - SET PARAMETER B			!!!!!!!!
	+TRN			5 - SET PARAMETER C			!!!!!!!!
	+TRN			6 - SET PARAMETER B (ONLY)
	+TRN			7 - SET PARAMETER A (ONLY)
	+TRN			10 - SET OUTPUT BAUD RATE (ONLY)
	+TRN11			11 - QUERY FIELD PARAMETERS
	+TRN12			12 - QUERY BIT PARAMETER
	+TRN12			13 - QUERY BIT PARAMETER
	+TRN14			14 - SET BIT PARAMETER
	+TRN14			15 - SET BIT PARAMETER
	+TRN16			16 - ENTER OR LEAVE 2741 TRANSPARENCY	!!!!!!!!!
	+TRN17			17 - ORANGE(16) OR YELLOW(17) BALL, HANG(0) OR SUPER-HANG(1)
*
*
*		OLD-STYLE PARAMETER PROCESSES---TO BE PHASED OUT
TRN0	LLRL	13		SET ECHO CONTROL
	ERA	TF,X
	ANA	=3600
TRN0A	ERA	TF,X
	STA	TF,X
	LRLA	5
	JAP	TRN0B		TEST FOR ECHO ON
* ECHO-ON COMMAND
	LRLA	4
	JAP	SBEXIT
	TXA
	JMPM	BITADD
	ORA	DEM,B
	STA	DEM,B
	JMP	SBEXIT
* ECHO-OFF COMMAND
TRN0B	LRLA	4
	JAN	TRN0C
	LDA	MASK+6
	ORA	TF,X
	STA	TF,X
	LDX	W5
	LDA	=7
	JMPM	WCI		SEND ENTER-DEFERED-ECHO-MODE
TRN0C	LDA	W3
	JMPM	BITADD
	COM	A,A
	ANA	DEM,B
	STA	DEM,B
	JMP	SBEXIT
TRN1	LLRL	4		SET TERMINAL TYPE
	ERA	TF3,X
	ANA	=17
	ERA	TF3,X
	STA	TF3,X
	JMP	SBEXIT
TRN2	TBA			SET PARITY AND BAUD RATE
	ERA	TF,X
	ANA	=170000
	JMP	TRN0A
TRN3	TBA			SET HALF DUPLEX
	LSRA	1
	ERA	TF3,X
	ANA	MASK+13		 =4000
	ERA	TF3,X
	STA	TF3,X
	LLRL	13		SET PARAMETER A
	ERA	TF1
	ANA	=7400
	JMP	TRN4A
TRN4	LLRL	7		SET PARAMETER B
	ERA	TF1,X
	ANA	=160
TRN4A	ERA	TF1,X
	STA	TF1,X
	JMP	SBEXIT
*	PUT A FIELD VALUE INTO THE TABLES
TRN	LDA	W6		DETERMINE PARAMETER
	TAB			SAVE IT
	LSRA	4
	STA	W6		SAVE PARAMETER NUMBER FOR ACKNOWLEDGEMENT
	ADD	=TFMASK
	TAX
	LDA	0,X		COPY THE MASK
	JAZ	SBEXIT		ABORT IF NULL MASK (NOT IMPLEMENTED)
	STA	W1
	LDA	TFSHIF,X	COPY THE SHIFT
	STA	DUMMY
	LDA	TFPNT,X		BUILD THE POINTER
	ADD	W3
	TAX
	TBA			COPY THE VALUE BACK TO (A)
	XEC	DUMMY		SHIFT IT
	ERA	0,X		SET THE BITS INTO THE TF TABLE
	ANA	W1
	ERA	0,X
	STA	0,X		AND PUT IT BACK
	JMP	TRN11A		SKIP TO REPORT BACK
*	GET A FIELD VALUE FROM TABLES
TRN11	LDA	W6		EXTRACT THE PARAMETER NUMBER
	ANA	=17
	STA	W6
	SUB	=NTFMSK		VERIFY IT
	JAP	SBEXIT		QUIT IF NOT VALID
TRN11A	LDX	W5		GET THE BUFFER ADDRESS
	INC	,A
	JMPM	WCI		TRANSMIT A PREFIX
	LDA	W6		GET BACK THE PARAMETER CODE
	ADD	=TFMASK		COMPUTE TYPE ADDRESS
	TAB
	LDA	0,B		COPY THE MASK
	JAZ	TRNS5A		TRANSMIT A NULL IF NOT IMPLEMENTED
	STA	W1
	LDA	TFSHIF,B	COPY THE SHIFT
	ORA	MASK+6		 =100...MAKE A RIGHT SHIFT
	STA	DUMMY
	LDA	TFPNT,B		COMPUTE THE POINTER
	ADD	W3
	TAB
	LDA	0,B		GET THE VALUE
	ANA	W1		MASK IT OUT
	XEC	DUMMY		JUSTIFY IT
	LLSR	4
	LDA	W6		BUILD REPORT VALUE
	LLRL	4
	JMP	TRNS5A		SKIP TO SEND IT
*	FIELD TABLES
TFMASK	0			0:  NOT USED
	0			1:  NOT USED
	0			2:  NOT USED
	0			3:  NOT USED
	0			4:  NOT USED
	000017			5:  PARAMETER C
	000360			6:  PARAMETER B
	003400			7:  PARAMETER A
	160000			10: OUTPUT BAUD RATE
NTFMSK	E	*-TFMASK
*
TFSHIF	E	*-TFMASK
	LRLA	0		0:
	LRLA	0		1:
	LRLA	0		2:
	LRLA	0		3:
	LRLA	0		4:
	LRLA	0		5:
	LRLA	4		6:
	LRLA	10		7:
	LRLA	15		10:
*
TFPNT	E	*-TFMASK
	+TF			0:
	+TF			1:
	+TF			2:
	+TF			3:
	+TF			4:
	+TF1			5:
	+TF1			6:
	+TF1			7:
	+TF			10:
*
*	GET A SINGLE BIT FROM TABLES
TRN12	LDA	W6		VERIFY THE REQUEST
	ANA	=36
	SUB	=2*NTBITS
	JAP	SBEXIT		IGNORE IF NOT VALID REQUEST
TRN12A	LDX	W5		GET THE BUFFER ADDRESS
	INC	,A		TRANSMIT PREFIX
	JMPM	WCI
	LDA	W6		GET THE CHARACTER SPECIFIED
	ANA	=36		MASK IT OFF
	STA	W6		SAVE IT FOR LATER
	LSRA	1		FORM INDEX
	ADD	=TBITS		MAKE ADDRESS
	TAB			COPY TO B
	LDA	TBSHIF,B	GET THE APPROPRIATE SHIFT
	ORA	MASK+6		 =100...MAKE ROTATE TO RIGHT SHIFT
	STA	DUMMY
	LDA	TBPNT,B		GET THE TABLE BASE POINTER FOR BIT
	ADD	W3		 + PORT NUMBER
	TAB
	LDA	0,B		GET THE APPROPRIATE WORD
	XEC	DUMMY		JUSTIFY THE BIT
	ANA	MASK		MASK OFF THE VALUE
	ORA	W6		PUT IN THE CODE
	ORA	=300		MAKE THE PROPER RESPONSE
	JMP	TRNS5A		AND SKIP TO SEND IT
*	SET A SINGLE BIT IN TABLES
TRN14	LDA	W6		GET THE CODE
	LLSR	1		JUSTIFY THE CODE INDEX
	ANA	=17		MASK IT
	JAZ	TRN14A		SKIP IF CODE = 0
	SUB	=NTBITS		VERIFY IT
	JAP	SBEXIT		IGNORE IF NOT VALID
	ADD	=TBITS+NTBITS	MAKE IT AN ADDRESS
	TAB
	LDA	0,B		COPY THE MASK
	STA	W1
	LDA	TBSHIF,B	COPY THE SHIFT OPERATION
	STA	DUMMY
	LDA	TBPNT,B		COPY AND BUILD THE POINTER
	ADD	W3		PORT NUMBER + BASE ADDRESS
	TAB
	LDA	W6		GET THE CHARACTER AGAIN
	XEC	DUMMY		JUSTIFY THE VALUE
	ERA	0,B		GET THE APPROPRIATE WORD
	ANA	W1		MASK IT OFF
	ERA	0,B
	STA	0,B		PUT IT BACK
	JMP	TRN12A		GO SEND RESPONSE
TRN14A	LLRL	13		ECHO-CONTROL...ADJUST THE BIT
	LDB	W3		GET PORT NUMBER
	ERA	TF,B
	ANA	MASK+12
	ERA	TF,B
	STA	TF,B
	LRLA	5		TEST IF BIT WAS SET
	JAP	TRN14B		SKIP IF BIT IS NOW OFF
	LRLA	4		ECHO-OFF COMMAND...TEST ECHO STATE
	JAP	TRN12A		ABORT IF OFF
	LDA	W3		ELSE TURN OFF
	JMPM	BITADD
	ORA	DEM,B
	STA	DEM,B
	JMP	TRN12A		AND CONTINUE
TRN14B	LRLA	4		TEST STATE
	JAN	TRN14C		SKIP IF OFF
	LDA	MASK+6		ELSE SET BIT
	ORA	TF,B
	STA	TF,B
	LDA	=7
	LDX	W5
	JMPM	WCI		SEND ENTER-DEFERED-ECHO-MODE
TRN14C	LDA	W3		SET DEM
	JMPM	BITADD
	COM	A,A
	ANA	DEM,B
	STA	DEM,B
	JMP	TRN12A		AND GO SEND BACK RESPONSE TO REQUEST
*	SINGLE BIT TABLES
TBITS	002000			0:  ECHO CONTROL
	001000			1:  ECHO CONTROL-I
	000400			2:  ECHO CR-LF
	000200			3:  ECHO LF-CR
	004000			4:  HALF DUPLEX
	010000			5:  PARITY
	004000			6:  XON/XOFF ENABLE
	000010			7:  C/R DELAY ENABLE
NTBITS	E	*-TBITS		NUMBER OF ENTRIES IN TABLE
*
TBSHIF	E	*-TBITS
	LRLA	12		0:
	LRLA	11		1:
	LRLA	10		2:
	LRLA	7		3:
	LRLA	13		4:
	LRLA	14		5:
	LRLA	13		6:
	LRLA	3		7:
*
TBPNT	E	*-TBITS
	+TF			0:
	+TF			1:
	+TF			2:
	+TF			3:
	+TF3			4:
	+TF			5:
	+TF			6:
	+TF3			7:
*
*  GLASS CHARACTER:  ENTER OR LEAVE 2741 TRANSPARENCY MODE.
*
TRN16	LDX	W3
	LSRB	12D
	JBZ	TRN17C		ENTER OF LEAVE?
	JMP	TRN17D		LEAVE..SKIP
* YELLOW BALL OR HANG CHARACTER
* ALSO ENTERED FROM T41S1
TRN17	TZA			17: GET DATA
	LLRL	4
	JAZ	TRN17A		SKIP IF = 0 (HANG CHARACTER)
	SUB	=2
	JAZ	TRN17C		ENTER 2741 TRANSPARENCY MODE
	DAR
	JAZ	TRN17D		LEAVE 2741 TRANSPARENCY MODE
	SUB	=11		TEST IF COLORED BALL
	JAN	SBEXIT		UNRECOGNIZED...SWALLOW
	ANA	MASK		GOT A BALL...TEST COLOR
	JAZ	SBEXIT		GREY OR ORANGE...SWALLOW
	LDX	W5		YELLOW OR BLACK BALL...GET THE INPUT BUFFER NUMBER
	INC	,A
	JMPM	WCI		SEND A PREFIX
	LDA	W6		SEND BACK AN ORANGE OR GREY BALL, RESPECTIVELY
	DAR
	JMP	TRNS5A		AND SKIP TO SEND BACK IN
* ALSO ENTERED FROM T41S0
TRN17A	LDA	W3		GET THE PORT NUMBER
	JMPM	BITADD		COMPUTE MASK AND WORD INDEX
	ORA	HANG,B		SET THE BIT FOR HANG UP
	STA	HANG,B
	JMP	SBEXIT		AND EXIT
*
TRN17C	LDA	TF3,X		ENTER TRANSPARENCY MODE,
	JAP	SBEXIT		IS THIS NOW A 2741?
	LDA	=40007		YES,  RESET TF3...SET TRANSPARENCY BIT
	STA	TF3,X
	JMP	SBEXIT
TRN17D	LDA	=140001		LEAVE TRANSPARENCY MODE.
	STA	TF3,X		RESET TF3 TO  '2741'
	JMP	SBEXIT
* CHARACTER GOBBLER
* ALSO ENTERED FROM T41S
TRANS2	LDA	W3		GET PORT NUMBER
	JMPM	BITADD		GET MASK AND WORD
	ORA	TBOA,B		SET THE BITS IN TIME-SINCE-LAST-BALL
	STA	TBOA,B
	ORA	TBOB,B
	STA	TBOB,B
	JMP	SBEXIT
* ZAPPER
* ALSO ENTERED FROM T41S
TRANS3	LDA	W3
	IF	PRINTER
	DAR
	IF	DPRINTER
	JAP	TRANS3A
	ELSE
	JAP	TRANS3C
	ENDIF
	LDA	PRINT0
	JAN	TRANS3C
	LDA	MASK
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	COM	,A
	STA	PRINT0
	IF	DPRINTER
	JMP	TRANS3C
TRANS3A	DAR
	JAP	TRANS3B
	LDA	PRINT1
	JAN	TRANS3B
	LDA	MASK+1
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	COM	,A
	STA	PRINT1
TRANS3B	IAR
	ENDIF
TRANS3C	IAR
	ENDIF
	JMPM	BITADD
	ORA	LOGGER,B
	STA	LOGGER,B
	LDA	PLI,B
	ORA	MASK,X
	STA	PLI,B
	ORA	NBO,B
	STA	NBO,B
	LDA	CMSK,X		CLEAR LOGGER TIME-OUT
	ANA	LOGTOB,B
	STA	LOGTOB,B
	LDA	CMSK,X
	ANA	LOGTOA,B
	STA	LOGTOA,B
	LDX	W5
	JMPM	EMPTY		EMPTY THE BUFFER
	LDB	W3
	TBA
	ADD	=LOGF
	STA	BF,X
	LDA	TF3,B
	JAP	TRANS3D
	LDA	TF,B
	JMP	TRANS3F
TRANS3D	LRLA	1		ASCII TERMINAL...TEST TRANSPARENCY
	JAP	TRANS3E		NOT TRANSPARENCY...SKIP
	LDA	=140001		TRANSPARENCY...RESET TO 2741
	STA	TF3,B
TRANS3E	LDA	=2620
	ORA	TF,B
	ANA	CMSK+6
	STA	TF,B
TRANS3F	ANA	=17
	ORA	=300
	JMPM	WCI
	JMP	SBEXIT
* GREEN BALL
* ALSO ENTERED FROM T41S5
TRANS5	LDB	W3
	LDA	TF,B
	ANA	MASK+5
	JAZ	SBEXIT
	ERA	TF,B
	STA	TF,B
	TBA
	JMPM	BITADD
	ORA	NBO,B
	STA	NBO,B
	LDA	DEM,B
	ANA	MASK,X
	JAZ	SBEXIT
	ERA	DEM,B
	STA	DEM,B
	LDB	W3
	LDA	CMSK+6
	ANA	TF,B
	STA	TF,B
	LDA	=4		SEND LEAVE-DEFERED-ECHO-MODE
	LDX	W5
TRNS5A	JMPM	WCI
	JMP	SBEXIT
* RED BALL
* ALSO CALLED FROM T41S
TRANS6	LDA	W3
	JMPM	BITADD
	ORA	NBO,B
	STA	NBO,B
	JMP	SBEXIT
	IF	PRINTER
*	PRINTER DRIVER
TRP0	LDA	W6
	LDB	PRINT0
	JBZ	TRP0B		IS PRINTER ON PORT 0 TURNED ON?
	SUB	=202		NO
	JAZ	TRP0A		SHALL WE TURN IT ON ?
	JMP	TRAN2		LETS OUT PUT IT TO THE TERMINAL
TRP0A	STA	PRINT0		FLAG THE PRINTER AS ON
	JMP	SBEXIT		GET OUT
TRP0B	SUB	=203
	JAZ	TRP0E		SHALL WE TURN THE PRINTER OFF ?
	SEN	770,TRP0H	IS PRINTER BUFFER READY ?
	ADD	=3		NO
	JAN	TRP0C		IS THIS A BLANK COMPRESSION CHAR. ?
	SUB	=14		NO
	JAZ	TRP0F		IS IT A FORM ?
	DAR			NO
	JAZ	TRP0G		IS IT A PRINT COMMAND ?
	OME	70,W6		NO...OUTPUT IT TO THE PRINT BUFFER.
	JMP	SBEXIT		GET OUT
TRP0C	LDB	MASK+5		 =40..MULTIPLE BLANKS.
	ADD	=167		SET UP COUNT
TRP0D	JAN	SBEXIT		ARE WE DONE ?
	OBR	70		NOT YET !  DO IT.
	DAR			COUNT
	JMP	TRP0D		LOOP
TRP0E	COM	,A		TURN THE PRINTER OFF
	STA	PRINT0
	LDA	MASK		RESET NCIB
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	JMP	SBEXIT		AND EXIT
TRP0F	EXC	270		COMMAND PRINTER TO FORM
	OME	70,W6		SHIP THE CHARACTER OUT
	JMP	TRP0I		SET CHARACTER IN BUFFER UNTIL DONE
TRP0G	EXC	170		COMMAND PRINTER TO PRINT
	JMP	TRP0I		GET OUT
TRP0H	LDX	W5		PUT THE CHARACTER
	IXR			BACK AND WAIT UNTIL ANOTHER GO ROUND.
	LDA	W6		GET THE CHARACTER AND TEST
	SUB	MASK+3		 =10
	JANM	WCD		RESTORE ESCAPE CHAR IF NECESSARY
	LDX	W5
	IXR
	JMPM	WCD		RESTORE CHARACTER
TRP0I	LDA	CMSK		SET CHARACTER-IN-BUFFER FLAG
	EXC	IDA
	ANA	NCIB		GO SET CHARACTER-IN-BUFFER UNTIL READY AGAIN
	EXC	300+IDA
	STA	NCIB
	TZA
	STA	PRINR0
	JMP	SBEXIT		GET OUT
	IF	DPRINTER
*	SECOND PRINTER DRIVER
TRP1	LDA	W6
	LDB	PRINT1
	JBZ	TRP1B		IS PRINTER ON PORT 1 TURNED ON?
	SUB	=202		NO
	JAZ	TRP1A		SHALL WE TURN IT ON ?
	JMP	TRAN2		LETS OUT PUT IT TO THE TERMINAL
TRP1A	STA	PRINT1		FLAG THE PRINTER AS ON
	JMP	SBEXIT		GET OUT
TRP1B	SUB	=203
	JAZ	TRP1E		SHALL WE TURN THE PRINTER OFF ?
	SEN	771,TRP1H	IS PRINTER BUFFER READY ?
	ADD	=3		NO
	JAN	TRP1C		IS THIS A BLANK COMPRESSION CHAR. ?
	SUB	=14		NO
	JAZ	TRP1F		IS IT A FORM ?
	DAR			NO
	JAZ	TRP1G		IS IT A PRINT COMMAND ?
	OME	71,W6		NO...OUTPUT IT TO THE PRINT BUFFER.
	JMP	SBEXIT		GET OUT
TRP1C	LDB	MASK+5		 =40..MULTIPLE BLANKS.
	ADD	=167		SET UP COUNT
TRP1D	JAN	SBEXIT		ARE WE DONE ?
	OBR	71		NOT YET !  DO IT.
	DAR			COUNT
	JMP	TRP1D		LOOP
TRP1E	COM	,A		TURN THE PRINTER OFF
	STA	PRINT1
	LDA	MASK+1		RESET NCIB
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	JMP	SBEXIT		AND EXIT
TRP1F	EXC	271		COMMAND PRINTER TO FORM
	OME	71,W6		SHIP THE CHARACTER OUT
	JMP	TRP1I		SET CHARACTER IN BUFFER UNTIL DONE
TRP1G	EXC	171		COMMAND PRINTER TO PRINT
	JMP	TRP1I		GET OUT
TRP1H	LDX	W5		PUT THE CHARACTER
	IXR			BACK AND WAIT UNTIL ANOTHER GO ROUND.
	LDA	W6		GET THE CHARACTER AND TEST
	SUB	MASK+3		 =10
	JANM	WCD		RESTORE ESCAPE CHAR IF NECESSARY
	LDX	W5
	IXR
	JMPM	WCD		RESTORE CHARACTER
TRP1I	LDA	CMSK+1		SET CHARACTER-IN-BUFFER FLAG
	EXC	IDA
	ANA	NCIB		GO SET CHARACTER-IN-BUFFER UNTIL READY AGAIN
	EXC	300+IDA
	STA	NCIB
	TZA
	STA	PRINR1
	JMP	SBEXIT		GET OUT
	ENDIF
	ENDIF
*
	IF	QUASISBOD
*	TRANSMIT A CHARACTER
*	EXPECTS:
*	W2 = POINTER TO BUFFER
*	(A) = DELAY TO USE
PUTC1	LDX	W2		GET BUFFER POINTER
	STA	QDELAY,X	SET UP DELAY
*	TRANSMITTER CLEANUP
*	EXPECTS:
*	W1 = MASK
*	W3 = PORT NUMBER
TEXIT	LDA	W1		GET COMPLEMENT MASK
	COM	A,A
	LDB	W3		GET PORT NUMBER, CONVERT TO WORD INDEX
	LSRB	4
	EXC	IDA
	ANA	NCIB,B
	EXC	300+IDA
	STA	NCIB,B		CLEAR BIT FOR NO-CHARACTER-IN-BUFFER
	ELSE
* ROUTINE TO INSERT A CHARACTER INTO THE RING
*	EXPECTS:
* (A) = FORMED CHARACTER (INCLUDING STOP BAUD AND ALL HIGHER BITS SET)
* W1 MASK
* W2 RING BASE ADDRESS
* W4 BAUD SIZE
* W7 CURRENT CHARACTER INDEX (AND TEMP)
PUTC1	STA	W7		SAVE THE CHAR
	ASLA	1		JUSTIFY IT
	ERA	W7		COMPUTE CHANGES
	TAB			PUT INTO B
PUTC2	LDA	RGX		GET RING OUTPUT INDEX AND SAVE
	STA	W7
	ADD	=4*SAMPLESIZE	START FOUR SAMPLES AHEAD OF INTERRUPT
	ANA	=RINGMASK
	ADD	W2		COMPUTE BAUD ADDRESS
	TAX
	JMP	PUTC4		AND SKIP TO INSERT START BAUD
PUTC3	TBA			EXTRACT CURRENT BIT FOR OUTPUT
	LSRB	1		SET UP NEXT BIT
	ANA	MASK
	JAZ	PUTC5		SAME AS LAST BIT...SKIP
PUTC4	LDA	0,X		PUT A TOGGLE BIT INTO RING
	ORA	W1
	STA	0,X
PUTC5	JBZ	TEXIT1		EXIT IF DONE
	TXA			COMPUTE ADDRESS OF NEXT BAUD
	ADD	W4
	TAX
	SUB	=RINGEND	TEST IF FOLDED RING
	JAN	PUTC3		NO..CONTINUE
	ADD	=RING		YES..CYCLE RING
	TAX
	JMP	PUTC3		AND CONTINUE
* TRANSMITTER CLEANUP
* CLEARS TAM, SETS CONTROL BIT
*	EXPECTS:
* W3 UNIT NUMBER
* W7 CURRENT CHARACTER INDEX
* W10 CHARACTER WIDTH
TEXIT	LDA	RGX		COPY THE INDEX TO TEMP
	STA	W7
TEXIT1	LDB	W3		COMPUTE THE PORT NUMBER
	LSRB	4
	LDA	W1		GET THE *NOT* MASK
	COM	A,A
	EXC	IDA
	ANA	TAM,B		CLEAR THE TRANSMITTER ACTIVE BIT
	EXC	300+IDA
	STA	TAM,B
	LDA	W7		COMPUTE THE CHARACTER END ADDRESS
	ADD	W10
	ANA	=RINGMASK
	ADD	W2
	TAB
	LDA	1,B		SET THE BIT IN THE CONTROL WORD
	ORA	W1
	STA	1,B		AND FALL THROUGH TO EXIT
	ENDIF
*
*
*  THAT'S IT.
*
SBEXIT	JMP	SBOD,I
*	NETWORK COMMUNICATIONS PROCESSING
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
SEC	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
* GREEN BALLS SENT FROM HERE ONLY
	IF	ONLY16
	TZB			SET PORTS 0-15D
	ELSE
	INC	,B		SET PORTS 16D-31D
	ENDIF
SECA	LDA	TCW,B		TERMINAL CHARACTER WAITING
	COM	A,A
	ANA	ACK,B		ACKNOWLEDGE
	ANA	NBO,B		NO BALL OUT
	ANA	DEM,B		DEFERED ECHO MODE
	JAZ	SECA1		SKIP IF NONE OF THESE APPLY
	JMPM	BID		BIT IDENTIFIER
	LDA	NBO,B
	ANA	CMSK,X
	STA	NBO,B		CLEAR NO-BALL-OUT FOR PORT
	LDA	TBOB,B
	ANA	CMSK,X
	STA	TBOB,B		CLEAR TIME-SINCE-LAST-BALL-WENT-OUT BIT FOR PORT
	ANA	TBOA,B
	STA	TBOA,B
	LRLB	4
	COP	BX,X		COMPUTE PORT NUMBER
	LDA	TF,X		SET BALL FLAG GREEN BIT IN TERMINAL
	ORA	MASK+5
	STA	TF,X
	TXA
	LRLA	1
	ADD	=BUFERS		COMPUTE PORT INPUT BUFFER
	TAX
	LDA	=5		SEND A GREEN BALL UPSTREAM
	JMPM	WCI
	TZB			SET NO ITTERATION WHEN WE HAVE ONE ITEM
SECA1	DEC	B,AB
	JAP	SECA		REPEAT SCAN FOR ALL PORT-GROUPS TILL WE FIND ONE
	IF	PRINTER
	LDA	PRINT0		PORT 0 RUNNING PRINTER
	ORA	PRINR0		PRINTER READY?
	IF	DPRINTER
	JAN	PRS		NO...GO CHECK PORT 1 PRINTER
	ELSE
	JAN	LEP		NO...GO PROCESS SUPERVISOR MESSAGES
	ENDIF
	SEN	770,PRTS2	YES...TEST PRINTER
	COM	,A
PRTS1	STA	PRINR0		PRINTER NOW READY
	LDA	MASK		SO CHANGE NCIB
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	IF	DPRINTER
	JMP	PRS		GO PROCESS SECOND PRINTER
	ELSE
	JMP	LEP		GO PROCESS SUPERVISOR MESSAGES
	ENDIF
PRTS2	LDX	=BUFERS+1	HERE IF PRINTER MAY ACCEPT DATA
	LDA	BC,X		GET COUNT
	IF	DPRINTER
	JAZ	PRS		NOTHING TO PRINT
	ELSE
	JAZ	LEP		NOTHING TO PRINT
	ENDIF
	JMPM	GCI		SOMETHING IN BUFFER...GET THE CHAR
	STA	W1		SAVE IT
	JMPM	WCD		RESTORE IT
	LDA	W1		TEST CHARACTER
	SUB	=4
	IF	DPRINTER
	JAP	PRS		SKIP IF VALID CHARACTER
	ELSE
	JAP	LEP		SKIP IF VALID CHARACTER
	ENDIF
	ADD	=2		IS THIS PRINTER DISCONNECT?
	IF	DPRINTER
	JAN	PRS
	ELSE
	JAN	LEP
	ENDIF
	COM	,A		ELSE TURN PRINTER ON
	STA	PRINT0
	JMP	PRTS1		AND GO SET UP
	ENDIF
	IF	DPRINTER
PRS	LDA	PRINT1		SAME GAME FOR SECOND PRINTER
	ORA	PRINR1
	JAN	LEP
	SEN	771,PRS2
	COM	,A
PRS1	STA	PRINR1
	LDA	MASK+1
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	JMP	LEP
PRS2	LDX	=BUFERS+3
	LDA	BC,X
	JAZ	LEP
	JMPM	GCI
	STA	W1
	JMPM	WCD
	LDA	W1
	SUB	=4
	JAP	LEP
	ADD	=2
	JAN	LEP
	COM	,A
	STA	PRINT1
	JMP	PRS1
	ENDIF
* LEPRECHAUN INPUT PROCESSOR
LEP	JMPM	SBOD		START-BAUD SCANNER
	LDA	ZAPCIR		ANY CIRCUIT TO ZAP?
	JAN	LEPB		NO
	SUB	=NBUF		'ZAPCIR' SHOULD CONTAIN A BUFFER NUMBER
	JAP	LEPA		NOT THIS TIME
	ADD	=BUFERS+NBUF	ADDRESS BUFFER
	TAX
	JMPM	EMPTY		PUT A ZAPPER IN THAT BUFFER
	LDA	=3
	JMPM	WCI
LEPA	COM	,A		CLEAR THE REQUEST
	STA	ZAPCIR
*	W1 INPUT BUFFER NUMBER
*	W2 WORD 1 OF MESSAGE
*	W3 WORD 2
*	W4 WORD 3
LEPB	LDB	=BUFCNT		ADDRESS OF BUFFER COUNTS
	LDA	SUPBUFFERS,B	TOTAL SUPERVISOR INPUT BUFFER COUNTS
	ADD	SUPBUFFERS+2,B
	ADD	SUPBUFFERS+4,B
	COM	,B		SET MASK FOR ALL BITS
	SUB	MASK+10		 =400
	JAN	LEPB1		ARE WE FALLING BEHIND
	LDA	USWICH		NO..TEST UPSTREAM SWITCH
	SUB	=BUFERS+SUPBUFFERS
	JAN	LEPB1		SKIP IF UPSTREAM DOES NOT EXIST
	LSRA	1		SET BIT ADDRESS FOR SUPERVISOR LINE
	TAX
	LDB	CMSK,X		GET NOT MASK CORRESPONDING TO BUFFER
LEPB1	STB	W10		SAVE MASK
	LDA	GENBUF		GET SUPERVISOR CHANNEL FLAGS
	ANA	=16
	ANA	W10
	JAZ	LEPEND		SKIP IF SHOULD NOT TRANSMIT
	JMPM	BID		ELSE IDENTIFY BIT
	TXA			IDENTIFY BUFFER
	LRLA	1
	ADD	=BUFERS+77
	STA	W1		SAVE BUFFER POINTER
	TAX
	LDA	=W2
	STA	W10		SAVE BUFFER POINTER FOR LOOP
LEPB2	JMPM	GCI		GET A CHARACTER
	LRLA	10		JUSTIFY IT AND SAVE
	STA	W5
	JMPM	GCI		GET SECOND HALF AND BUILD A WORD
	ORA	W5
	STA	W10,I		SAVE IN BUFFER
	LDA	W10		GET AND BUMP POINTER
	INR	W10
	SUB	=W4		TEST
	JAN	LEPB2		CONTINUE FOR 6 CHARACTERS...3 WORDS IN BUFFER
*	NOW HAVE 3 WORDS IN THE BUFFER...
*	FIRST WORD HAS SIGN BIT SET IF GOING UPSTREAM, THEN WE JUST PASS IT ON
*			(UNLESS WE HAVE NO DOWN-STREAM....THEN WE RETURN IT)
*	ELSE WE HAVE TO LOOK AT IT...LOW ORDER 12 BITS SPECIFY DESTINATION
*	BITS 14D-12D CONTAIN CODE FOR OPERATION TO PERFORM
	LDA	W2		GET WORD1, TEST IF GOING UPSTREAM OR DOWN
	JAP	LEPB3
	LDX	USWICH		GOING UPSTREAM...IS THERE SUCH A DIRECTION?
	JXZ	LEP		NO...FORGET IT AND CONTINUE
	LDA	DSWICH		YES...DO WE HAVE A DOWN-STREAM TO RECEIVE FROM?
	JAZ	LEPRET		NO...REPORT UNEXPECTED MESSAGE BY RETURNING IT
	JMPM	LEPSN		YES...SEND THE RECORD ON
	JMP	LEP		AND CONTINUE
* DOWNSTREAM RECORD
LEPB3	ANA	=7777		MASK OFF MACHINE (DESTINATION) NUMBER
	ERA	MACHNO
	JAZ	LEPDIS		IT IS FOR US...GO PROCESS IT
	LDA	DSWICH		FOR SOMEONE ELSE...TEST DOWNSTREAM
	JAZ	LEPRET		NULL...SEND IT BACK
	SUB	=NLINES+1	TEST IF VALID
	JAP	LEPRET		NO...SEND IT BACK
	ASLA	1		VALID...COMPUTE BUFFER ADDRESS
	ADD	=BUFERS+NLINES+NLINES+SUPBUFFERS
	TAX
	LDA	USWICH		VERIFY THAT THIS CAME FROM VALID UPSTREAM DIRECTION
	IAR
	ERA	W1		COMPARE SOURCE BUFFER WITH UPSTREAM
	DAR
	JAP	LEPRET		RETURN MESSAGE IF NO MATCH
	JMPM	LEPSN		SEND IT ON
	JMP	LEP		AND GO FOR ANOTHER RECORD
* RETURN ILLEGAL DOWNSTREAM RECORD
LEPRET	LDA	W2		MOVE OLD DESTINATION INTO DATA
	STA	W4
	LDA	MASK+15		 =20000	SET CODE 2...UNEXECUTABLE COMMAND
	JMPM	LEPSEN		AND SEND IT BACK TO SUPERVISOR
	JMP	LEP		AND GO FOR NEXT RECORD
* LEPRECHAUN DISPATCHER TO PROCESS SUPERVISOR COMMANDS
LEPDIS	LDA	W2		EXTRACT OP-CODE (HIGH BIT = 0 SINCE GOING TO US)
	LSRA	14
	JAZ	LEP0		SKIP IF TAKE-OVER
	ADD	=LEPTAB+.	MAKE A TRANSFER ADDRESS
	STA	DUMMY
	LDA	USWICH		VERIFY THIS CAME FROM KNOWN UPSTREAM
	IAR
	ERA	W1
	JAZ	DUMMY,I		GO TO APPROPRIATE HANDLER IF SO
	JMP	LEPRET		ELSE RETURN MESSAGE
* TAKEOVER COMMAND	CODE = 0
*	WORD2 SHOULD BE 555B2+SUPER I.D., WORD3 NOT USED
LEP0	LDA	W3		VERIFY VALID TAKEOVER
	LSRA	6		STRIP OFF SUPER ID
	ERA	=555
	DAR
	JAP	LEPRET		GO REPORT INVALID MESSAGE TO REAL SUPERVISOR
	TZA
	JMPM	LEPSEN		SEND A 0-CODE TO OLD SUPERVISOR
	LDX	W1		GET BUFFER INDEX WE GOT THIS COMMAND FROM
	DXR			COMPUTE INDEX OF OTHER BUFFER POINTER OF PAIR
	STX	USWICH		SET NEW UPSTREAM SWITCH POINTING TO BUFFER
	TZA
	STA	DSWICH		CLEAR DOWN-STREAM SWITCH
	STA	BC,X		PURGE BUFFER FOR UPSTREAM
	LDA	=NLINES+100	NOW TELL ABOUT OURSELF
	STA	W3		NUMBER OF LINES WE HAVE
	LDA	VERNO		VERSION NUMBER
	STA	W4
	TZA			CODE = 0...SEND ACKNOWLEDGEMENT WITH THIS INFORMATION TO NEW SUPER
	JMPM	LEPSEN
	LDA	CRSHCD		DETERMINE IF CRASH SINCE LAST TAKEOVER
	JAZ	LEP0A		SKIP IF NOT
	STA	W3		ELSE REPORT IT TO SUPERVISOR
	LDA	CRSHLC		REPORT ADDRESS
	STA	W4
	LDA	=30000
	JMPM	LEPSEN
	TZA
	STA	CRSHCD
LEP0A	LDX	=BUFERS+36	SEARCH THE BUFFERS FOR ALL PORTS LOGGING IN
LEP0B	LDA	BF,X		FIND ALL PORTS LOGGING IN
	SUB	=20*(CFOB-FLAG)
	LLRL	1
	DXR
	DEC	X,AX
	SUB	=BUFERS
	JAP	LEP0B
	LDA	HANG		SET FLAGS TO HANG UP THESE PHONES
	COP	AB,A
	STA	HANG
	IF	#ONLY16
	LDX	=BUFERS+76	SAME FOR SECOND GROUP OF PORTS
LEP0C	LDA	BF,X
	SUB	=20*(CFOB-FLAG)
	LLRL	1
	DXR
	DEC	X,AX
	SUB	=BUFERS+40
	JAP	LEP0C
	LDA	HANG+1
	COP	AB,A
	STA	HANG+1
	ENDIF
	JMP	LEP		AND GO LOOK FOR ANOTHER MESSAGE
* PLACE 2 CHARACTERS INTO A BUFFER	CODE = 1
*	WORD2	DESTINATION BUFFER INDEX
*	WORD3	TWO CHARACTERS TO BE PUT INTO THAT BUFFER
LEP1	LDA	W3		GET THE BUFFER NUMBER
	ADD	=BUFERS		COMPUTE THE BUFFER INDEX
	TAX
	LDA	W4		GET AND SEND FIRST CHARACTER
	LSRA	10
	JMPM	WCI
	LDA	W4		GET AND SEND SECOND CHARACTER
	JMPM	WCI
	JMP	LEP		AND GO PROCESS NEXT COMMAND
* CHANGE TABLE ENTRY	CODE = 2
*	WORD2	BITS 15D-10D	LINE NUMBER
*		BITS 9D-0	TABLE ENTRY NUMBER
*	WORD3	VALUE TO PUT IN THAT ENTRY
LEP2	LDA	W3		GET LINE NUMBER
	LSRA	12
	TAB
	SUB	=NLINES		TEST IF VALID
	JAP	LEPRET		SEND IT BACK IF NOT VALID
	LDA	W3		GET TABLE INDEX
	ANA	=1776
	JAZ	LEPRET		SEND IT BACK IF NOT VALID
	LSRA	3
	ADD	IOTABS,B	COMPUTE TABLE ENTRY ADDRESS
	JAP	LEPRET		SEND IT BACK IF NOT VALID
* COMPUTE ENTRY ADDRESS
	LDA	W3		EXTRACT TABLE INDEX
	ANA	=1777
	STA	W3		AND SAVE
	ADD	IOTA,B		COMPUTE I/O TABLE ADDRESS FOR LINE
	TAX
	STX	W7		COPY AND SAVE CIRCUIT TABLE ADDRESS
	LDA	W4
	ANA	CMSK+17		REMOVE SIGN BIT
	SUB	=NBUF		TEST
	JAP	LEPRET		EXIT IF OUTSIDE RANGE OF BUFFERS
	LDA	0,X
	IAR			GET AND TEST I/O TABLE ENTRY
	JAZ	LEP2D		SKIP IF NOT IN USE
	DAR
	ANA	CMSK+17		ELSE COMPUTE OTHER BUFFER FOR CIRCUIT PAIR
	ERA	MASK		=1
	ADD	=BUFERS
	TAX
	STB	W8		SAVE BUFFER INDEX
	JMPM	ZBF		PURGE AND FREE THAT BUFFER
	LDB	W8
LEP2D	LDX	W7		ASSIGN BUFFER TO CIRCUIT
	LDA	W4
	STA	0,X
	ERA	MASK		GET THE BUFFER NUMBER
	ADD	=BUFERS
	STA	W6
* COMPUTE NEW BF
	LDA	GROUPI,B	COMPUTE NEW FLAG ADDRESS
	ADD	=CFOB-FLAG
	LRLA	4
	ADD	W3
	STA	W7		AND SAVE IT
	LDB	W6
	LDA	BC,B
	JAZ	LEP2A		SKIP IF BUFFER IS EMPTY
	LDA	BF,B		MOT EMPTY...TURN OFF OLD BIT
	JMPM	BITADD
	COM	A,A
	ANA	FLAG,B
	STA	FLAG,B
	LDA	W7
	JMPM	BITADD		SET NEW BIT
	ORA	FLAG,B
	STA	FLAG,B
	LDB	W6
LEP2A	LDA	W7		SET BUFFER FLAG FOR CIRCUIT
	STA	BF,B
	LDA	=100001		SEND A MESSAGE TO SUPERVISOR
	STA	W3
	LDA	=30000		CODE = 3
	JMPM	LEPSEN
	JMP	LEP		AND GO PROCESS MORE DATA
* CHANGE CELL OR SPECIAL MESSAGE	CODE = 3
*	WORD2	BIT 15D	SET IF SPECIAL MESSAGE PROCESS
*			IF NOT SET, ADDRESS TO CHANGE
*	WORD3		VALUE TO PUT IN THAT ADDRESS
LEP3	LDA	W3		SPECIAL MESSAGE IF SIGN BIT SET
	JAN	LEPS
	SUB	=DLOCK		TEST IF DEBUGGER LOCKED
	LSRA	6		(LOCKS 64 WORDS)
	JAZ	LEP3A		NOT LOCKED...SKIP
	LDA	DLOCK		TEST LOCK
	JAP	LEP		SET...IGNOR OPERATION
LEP3A	LDA	W4		SET THE CELL TO THE VALUE
	STA	W3,I		AND GO LOOK FOR ANOTHER RECORD
	JMP	LEP
* SPECIAL MESSAGE PROCESSOR
* TYPE 3, SUBTYPE 'SPECIAL'
* ONLY SUPTYPE 0, 1 IMPLEMENTED
LEPS	ANA	=77		EXTRACT MESSAGE NUMBER
	DAR
	JAP	LEPS10		SKIP IF NOT MESSAGE TYPE 0
	LDA	W4		ELSE GET VALUE
	LSRA	3
	ANA	=37		EXTRACT PORT-GROUP NUMBER AND SAVE
	TAB
* SET ECHO STATUS
	LRLA	1
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS AND SAVE
	STA	W6
	LDA	TF3,B
	JAP	LEPS01		SKIP IF NORMAL CHAR
	TBA			SPECIAL CASE...LOGIN OR 2741
	JMPM	BITADD		GET BIT ADDRESS
	JMP	LEPS02		AND SKIP
LEPS01	LDA	W4		EXTRACT MESSAGE NUMBER
	ANA	=7
	TAX
	LDA	W4
	LSRA	10		EXTRACT CONTROL BIT (BIT 14D)
	COM	A,A		COMPLEMENT
	ERA	TF,B
	ANA	MASK+6
	ERA	TF,B		TURN ECHO ON, UNLOCK KEYBOARD IF CONTROL BIT IS SET
	ANA	CMSK+4
	ORA	FCHAR,X
	STA	TF,B		SET USER-NAME BIT
	TBA
	JMPM	BITADD		COMPUTE PORT-GROUP ADDRESS
	LDA	DEM,B		CLEAR DEFERED-ECHO-MODE BIT
	ANA	CMSK,X
	STA	DEM,B
LEPS02	LDA	ACK,B		TEST ACKNOWLEDGEMENT
	ANA	MASK,X
	JAZ	LEPS04		SKIP IF NOT SET
	LDA	LOGGER,B	ELSE SET THIS BIT IN LOGGER
	ORA	MASK,X
	STA	LOGGER,B
	LDA	CMSK,X		CLEAR LOGGER TIME-OUT
	ANA	LOGTOA,B
	STA	LOGTOA,B
	LDA	CMSK,X
	ANA	LOGTOA,B
	STA	LOGTOA,B
	LDX	W6
	LDA	W4		SIGN BIT DETERMINES IF TO EMPTY BUFFER
	JANM	EMPTY		SIGN SET...EMPTY PORT-INPUT BUFFER
	IXR			SET PORT-OUTPUT BUFFER
	LDA	W4		TEST BIT 13D
	LRLA	2
	JANM	EMPTY		IF THIS BIT IS SET, EMPTY THE PORT-OUTPUT BUFFER
	LDA	W4
	ANA	=7
	JAZ	LEP		EXIT IF MESSAGE 0 FOR PORT GROUP
	ADD	=TMES-1		ELSE COMPUTE MESSAGE ADDRESS
	TAB
	LDA	0,B
	JMPM	MESAGE		OUTPUT MESSAGE
	JMP	LEP		AND GO ON
LEPS04	LDX	W6		ACKNOWLEDGE NOT SET
	LDA	=3
	JMPM	WCI		SEND A ZAPPER
	JMP	LEP		AND GO PROCESS NEXT RECORD
LEPS10	DAR			TEST IF MESSAGE TYPE 1
	JAP	LEPS30		SKIP IF NOT
	LDA	W4		MESSAGE TYPE 1...
	LSRA	3
	ANA	=37		EXTRACT PORT-GROUP NUMBER AND SAVE
	TAB
	LRLA	1		SET ECHO STATUS
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS AND SAVE
	STA	W6
	LDA	TF3,B
	JAN	LEPS11		SKIP IF LOGIN OR 2741
	LDA	W4
	LSRA	10		EXTRACT CONTROL BIT (BIT 14D)
	COM	A,A		COMPLEMENT
	ERA	TF,B
	ANA	MASK+6
	ERA	TF,B		TURN ECHO ON, UNLOCK KEYBOARD IF CONTROL BIT IS SET
	STA	TF,B
LEPS11	TBA
	JMPM	BITADD		COMPUTE PORT-GROUP ADDRESS
	LDA	ACK,B		TEST ACKNOWLEDGEMENT
	ANA	MASK,X
	JAZ	LEPS04		SKIP IF NOT SET
	LDX	W6
	LDA	W4		SIGN BIT DETERMINES IF TO EMPTY BUFFER
	JANM	EMPTY		SIGN SET...EMPTY PORT-INPUT BUFFER
	IXR			SET PORT-OUTPUT BUFFER
	LDA	W4		TEST BIT 13D
	LRLA	2
	JANM	EMPTY		IF THIS BIT IS SET, EMPTY THE PORT-OUTPUT BUFFER
	LDA	W4
	ANA	=7
	STA	W4		SAVE MESSAGE NUMBER
	SUB	MASK+2		=4
	JAP	LEP		IGNOR IF OUT OF RANGE
	ADD	MASK+1		=2
	JAP	LEPS12		SKIP IF NOT SPECIAL HANDLING
	INC	,A		ELSE SEND A PREFIX
	JMPM	WCI
	LDA	=361		2741 HANG CHARACTER
	JMPM	WCI
LEPS12	LDA	W4
	ADD	=TMES1		COMPUTE MESSAGE POINTER ADDRESS
	TAB
	LDA	0,B
	JMPM	MESAGE		OUTPUT MESSAGE
	JMP	LEP		AND GO ON
LEPS30	DAR			TEST IF MESSAGE TYPE 3
	JAZ	*+4		SKIP IF SO
	JMP	LEPRET		RETURN IT IF NOT
	LDX	W4		HERE TO ADAPT A LINE
	JMPM	UNSNIP		GO UNSNIP THE LINE
	JMP	LEP		AND GO ON TO NEXT COMMAND
* REQUEST 2 CELLS
*	W3, W4 = POINTERS
*	W5 = TEMP
LEP4	LDA	W4
	STA	W5		SAVE SECOND WORD POINTER
	LDA	W3,I		GET FIRST WORD
	STA	W4		PUT INTO BUFFER
	LDA	=30000
	JMPM	LEPSEN		AND SEND IT
	LDA	W5		MOVE SECOND WORD POINTER INTO RECORD
	STA	W3
	LDA	W3,I		GET CONTENTS
	STA	W4		PUT INTO RECORD
	LDA	=30000
	JMPM	LEPSEN		AND SEND IT TOO
	JMP	LEP		THEN EXIT
TMES	+TM1
	+TM2
	+TM3
	+TM4
	+TM5
	+TM6
	+TM7
TMES1	+TM10
	+TM11
	+TM12
	+TM13
LEPTAB	+LEP0			0 - TAKEOVER
	+LEP1			1 - PUT 2 CHARACTERS IN A BUFFER
	+LEP2			2 - CHANGE TABLE ENTRY
	+LEP3			3 - CHANGE CELL OR SPECIAL MESSAGE
	+LEP4			4 - REQUEST TWO CELLS
	+LEPRET			5 - UNIMPLEMENTED...TOSS IT BACK
	+LEPRET			6 - UNIMPLEMENTED...TOSS IT BACK
	+LEPRET			7 - UNIMPLEMENTED...TOSS IT BACK
LEPEND	E	*		HERE WHEN DONE WITH LEPRECHAN
	IF	DEBUG
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*	LOCAL DEBUGGER
	LDA	DBGRA		RESTORE REGISTERS
	LDB	DBGRB
	LDX	DBGRX
	JMP	DBGWAIT,I	GO REENTER DEBUGGER
DBGWAIT	+DBG1			INITIALIZED FOR FIRST PASS
	STA	DBGRA		SAVE REGISTERS
	STB	DBGRB
	STX	DBGRX
	JMP	DBGEND		AND CONTINUE IN NORMAL STREAM
*
*
DBGERR	LDA	DBGEH		OUTPUT ERROR FLAG
	JMPM	DBGOCH
DBG1	JMPM	DBGOCR		OUTPUT CARRIAGE-RETURN/LINE-FEED
DBG2	JMPM	DBGICH		GET A CHARACTER
	LDB	=DBGBASE	SEARCH FOR CHARACTER
DBG3	LDA	0,B		TEST FOR CHARACTER
	JAN	DBGERR		INVALID...ABORT
	ERA	DBGCH
	DAR
	IBR			ELSE SET NEXT ITEM
	JAP	DBG3		AND SEARCH MORE IF NOT MATCH
	LDA	DBGBOFF,B	GOT ONE...GO TO ROUTINE
	STA	DBG4+1
	JMPM	DBGIV		GET A VALUE
	STB	DBGAD1		SAVE FOR FIRST ADDRESS
DBG4	JMP	*
*
DBGBASE	303			"C"
	304			"D"
	311			"I"
	314			"L"
	323			"S"
	-1			END OF LIST
DBGBOFF	E	*-DBGBASE-1	OFFSET TO DBGBASE
	+DBGC			CHANGE
	+DBGD			DOUBLE CHANGE
	+DBGI			INITIALIZE
	+DBGL			LIST
	+DBGS			SEARCH
*
*
*		F U N C T I O N S
*
*	CHANGE
DBGC	JAP	DBGERR		BITCH IF NOT TERMINAL "C/R"
DBGC1	JMPM	DBGOADR		OUTPUT ADDRESS
	LDX	DBGAD1
	LDA	0,X
	JMPM	DBGOW		OUTPUT VALUE
	LDA	DBGBL		" "
	JMPM	DBGOCH
	JMPM	DBGIN		GET A NUMBER
	LDA	DBGCH
	ERA	DBGCR
	TAB			COPY "C/R" FLAG
	JBZ	DBGC3		AND SKIP IF IT WAS A "C/R"
	LDA	DBGCH
	ERA	DBGUA		"^"
	DAR
	JAP	DBGC2
	JMPM	DBGOCR		OUTPUT "C/R--L/F"
	DEC	,B
	JMP	DBGC3
DBGC2	LDA	DBGCH
	ERA	DBGLF		"L/F"
	DAR
	JAP	DBGERR		ERROR IF NONE OF THESE
	INC	,B
DBGC3	LDA	DBGT2		TEST IF NUMBER ENTERED
	JAN	DBGC5		SKIP IF NOT
	LDX	DBGAD1		ELSE SET VALUE
	LDA	DBGT1
	STA	0,X
DBGC5	JBZ	DBG2		QUIT IF "C/R"
	TBA
	ADD	DBGAD1		UPDATE ADDRESS
	STA	DBGAD1
	JMP	DBGC1		AND PROCESS NEXT LOCATION
*
*	DOUBLE CHANGE
DBGD	JAP	DBGERR		ERROR IF NOT "C/R"
	JMPM	DBGOADR		OUTPUT ADDRESS
	LDX	DBGAD1		OUTPUT "VALUE,VALUE "
	LDA	0,X
	JMPM	DBGOW
	LDA	DBGCOM
	JMPM	DBGOCH
	LDX	DBGAD1
	LDA	1,X
	JMPM	DBGOW
	LDA	DBGBL		" "
	JMPM	DBGOCH
	JMPM	DBGIN		GET THE RESPONSE
	LDA	DBGCH		TEST FOR "C/R"
	ERA	DBGCR
	ADD	DBGT2		TEST IF ANY DIGITS ENTERED
	JAN	DBG2		QUIT IF BOTH 'DIGITS NOT ENTERED' AND 'NOT C/R'
	LDA	DBGT2
	JAN	DBGERR		ERROR IF NO DIGITS
	LDA	DBGCH		TEST FOR ","
	ERA	DBGCOM
	DAR
	JAP	DBGERR
	LDA	DBGT1		OK...SAVE VALUE
	STA	DBGT3
	JMPM	DBGIV		GET SECOND VALUE
	JAP	DBGERR		ERROR IF NOT "C/R"
	LDA	DBGT3		GET FIRST WORD AGAIN
	LDX	DBGAD1		AND ADDRESS
	STA	0,X		SET DOUBLE WORD
	STB	1,X
	JMP	DBG2		AND QUIT
*
*	INITIALIZE
DBGI	JAN	DBGERR		BITCH IF NOT ","
	JMPM	DBGIV		GET END ADDRESS
	STB	DBGAD2		SAVE END ADDRESS
	TZB			SET DEFAULT
	JAN	DBGI1		SKIP IF NOT ","
	JMPM	DBGIV		ELSE GET VALUE
	JAP	DBGERR		BITCH IF NOT "C/R"
DBGI1	LDX	DBGAD1		SET ADDRESS
DBGI2	STB	0,X
	TXA			COPY ADDRESS
	IXR			BUMP ADDRESS
	SUB	DBGAD2		TEST IF DONE
	JAN	DBGI2		CONTINUE IF NOT
	JMP	DBG2		ELSE QUIT
*
*	OUTPUT LIST
DBGL	JAN	DBGERR		BITCH IF NOT ","
	JMPM	DBGIV		GET END ADDRESS
	JAP	DBGERR		BITCH IF NOT "C/R"
	STB	DBGAD2		OK...SAVE END ADDRESS
DBGL1	JMPM	DBGOADR		OUTPUT THE ADDRESS
DBGL2	LDX	DBGAD1
	LDA	0,X		GET THE VALUE
	JMPM	DBGOW		OUTPUT IT
	LDA	DBGAD1
	INR	DBGAD1		BUMP THE ADDRESS
	SUB	DBGAD2		TEST IF DONE
	JAP	DBG1		QUIT IF SO
	LDA	DBGAD1		NOT DONE...TEST IF AT END OF LINE
	ANA	=7
	JAZ	DBGL3		SKIP IF SO
	LDA	DBGBL		" "
	JMPM	DBGOCH		OUTPUT " "
	JMP	DBGL2		AND CONTINUE
DBGL3	JMPM	DBGOCR		END OF LINE...OUTPUT CR/LF
	JMP	DBGL1		AND CONTINUE
*
*	SEARCH
DBGS	JAN	DBGERR		BITCH IF NOT ","
	JMPM	DBGIV
	JAN	DBGERR		BITCH IF NOT ","
	STB	DBGAD2
	JMPM	DBGIV		GET VALUE
	STB	DBGT3		SAVE VALUE
	COM	,B		SET DEFAULT VALUE
	JAN	DBGS1		SKIP IF NO MASK COMING
	JMPM	DBGIV		GET MASK
	JAP	DBGERR		BITCH IF NOT "C/R"
DBGS1	STB	DBGT4		SAVE MASK
DBGS2	LDX	DBGAD1		GET VALUE
	LDA	0,X
	ERA	DBGT3		TEST AGAINST VALUE
	ANA	DBGT4		AND MASK
	JAZ	DBGS4		SKIP IF HIT
DBGS3	LDA	DBGAD1
	INR	DBGAD1		GET AND BUMP ADDRESS
	SUB	DBGAD2		TEST IF DONE
	JAN	DBGS2		CONTINUE IF NOT
	JMP	DBG2		ELSE QUIT
DBGS4	JMPM	DBGOADR		OUTPUT ADDRESS
	LDX	DBGAD1
	LDA	0,X
	JMPM	DBGOW		OUTPUT VALUE
	JMPM	DBGOCR
	JMP	DBGS3		AND CONTINUE
*
*
*		R O U T I N E S
*
*	INPUT A VALUE
*	RETURN (B) = VALUE, (A)<0 IF TERMINAL C/R, =0 IF ","
DBGIV	0
	JMPM	DBGIN		GET THE NUMBER
	LDA	DBGT2		VERIFY NUMBER ENTERED
	JAN	DBGERR		ELSE BITCH
	LDB	DBGT1		GET VALUE, AND TEST TERMINAL CHAR
	LDA	DBGCH
	ERA	DBGCR
	DAR
	JAN	DBGIV,I
	LDA	DBGCH
	ERA	DBGCOM
	JAZ	DBGIV,I
	JMP	DBGERR		ELSE BITCH IF NEITHER "C/R" OR ","
*
*	INPUT A NUMBER
*	RETURN DBGT1 = VALUE, DBGT2<0 IF NO DIGITS ENTERED
DBGIN	0
	COM	,A
	STA	DBGT2		SET NO-CHAR FLAG
	TZA
DBGIN1	STA	DBGT1		SAVE ACCUMULATED VALUE
	JMPM	DBGICH		GET ANOTHER CHARACTER
	LDA	DBGCH
	SUB	DBGZR		TEST IF DIGIT
	JAN	DBGIN,I		RETURN IF NOT
	TZB
	LLSR	3		EXTRACT DIGIT
	DAR
	JAP	DBGIN,I		RETURN IF NOT AN OCTAL DIGIT
	INR	DBGT2		CLEAR FLAG
	LDA	DBGT1		ELSE BUILD NUMBER
	LLRL	3
	JBZ	DBGIN1		CONTINUE IF NO OVERFLOW
	JMP	DBGERR		ELSE BITCH
*
*	INPUT A CHARACTER (AND ECHO IT)
DBGICH	0
	LDX	=DBGBUF
DBGICH1	LDA	BC,X		TEST IF ANY CHARACTERS THERE
	JAZM	DBGWAIT		WAIT IF NOT
	JAZ	DBGICH1
	JMPM	GCI		GOT ONE...GET IT
	STA	DBGCH
	SUB	MASK+3		 =10
	JAN	DBGICH1		TOSS ALL CONTROL CHARS
	LDA	DBGCH
	ERA	DBGLF		TEST CHARACTER
	JAZ	DBGICH2		SKIP IF L/F
	LDA	DBGCH
	ERA	DBGCR
	JAZ	DBGICH2		SKIP IF C/R
	LDA	DBGCH
	JMPM	DBGOCH		ELSE ECHO IT
	JMP	DBGICH,I	AND EXIT, CHAR IN 'DBGCH'
DBGICH2	JMPM	DBGOCR		HERE WITH C/R OR L/F...DO IT
	JMP	DBGICH,I	AND EXIT
*
*	OUTPUT ADDRESS
DBGOADR	0
	LDA	DBGLP		"("
	JMPM	DBGOCH
	LDA	DBGAD1		THE ADDRESS
	JMPM	DBGOW
	LDA	DBGRP
	JMPM	DBGOCH		")"
	LDA	DBGBL
	JMPM	DBGOCH		" "
	JMP	DBGOADR,I	AND RETURN
*
DBGOW	0			OUTPUT WORD (IN A)
	LLSR	17		SAVE WORD
	LDX	=-6		SET CHARACTER COUNTER
DBGOW1	STX	DBGT1		SAVE COUNTER
	STB	DBGT2		SAVE REMAINDER
	ADD	DBGZR		MAKE A DIGIT
	JMPM	DBGOCH		OUTPUT CHARACTER
	LDX	DBGT1		UPDATE COUNTER
	IXR
	JXZ	DBGOW,I		EXIT IF DONE
	LDB	DBGT2		GET REMAINDER
	TZA
	LLRL	3		EXTRACT A DIGIT
	JMP	DBGOW1		AND DO ANOTHER CHARACTER
*
*	OUTPUT CARRIAGE-RETURN/LINE-FEED
DBGOCR	0
	LDA	DBGCR		OUTPUT CARRIAGE RETURN
	JMPM	DBGOCH
	LDA	DBGLF		OUTPUT LINE-FEED
	JMPM	DBGOCH
	JMP	DBGOCR,I
*
*	OUTPUT CHARACTER
DBGOCH	0
	LDX	=DBGBUF+1	PORT OUTPUT BUFFER
	JMPM	WCI		OUTPUT CHAR
	JMPM	DBGWAIT		WAIT A SPELL
	LDA	BC,X		INSURE BUFFER DOESN'T OVERFLOW
	SUB	MASK+5		 =32
	JAP	*-4
	JMP	DBGOCH,I	AND EXIT
*
DBGLF	212			LINE-FEED
DBGCR	215			CARRIAGE RETURN
DBGEH	277			QUESTION MARK
DBGBL	240			BLANK
DBGCOM	254			COMMA
DBGZR	260			ZERO
DBGLP	250			LEFT PARENTHESIS
DBGRP	251			RIGHT PARENTHESIS
DBGUA	336			UP ARROW
*
DBGCH	R	*+1		CURRENT CHARACTER
DBGAD1	R	*+1		CURRENT ADDRESS
DBGAD2	R	*+1		SECOND ADDRESS
DBGT1	R	*+1		TEMP STORE
DBGT2	R	*+1		TEMP STORE
DBGT3	R	*+1		TEMP STORE
DBGT4	R	*+1		TEMP STORE
DBGRA	R	*+1		REGISTER SAVE
DBGRB	R	*+1		REGISTER SAVE
DBGRX	R	*+1		REGISTER SAVE
DBGEND	E	*
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ENDIF
* PROCESS LOGINS
*	W1	PORT-GROUP COUNTER
*	W2	GROUP PORT NUMBER
*	W3	BUFFER INDEX
*	W4	CHARACTER INPUT
*	W5	PORT NUMBER
SECB	JMPM	SBOD		GO PROCESS START BAUDS
	IF	ONLY16
SECB0	TZB			DO FOR THE PORT-GROUP
	ELSE
SECB0	INC	,B		DO FOR BOTH PORT-GROUPS
	ENDIF
SECB1	STB	W1
	LDA	LOGIN,B
	ANA	LOGGER,B	PORTS IN LOGIN MODE
	JAZ	LOG4		NONE TO DO
	JMPM	BID		GOT ONE...WHICH ONE
	STX	W2		SAVE GROUP PORT NUMBER
	LDA	W1
	LRLA	4
	COP	AX,A		COMPUTE PORT NUMBER
	STA	W5
	LRLA	1		 *2
	STA	W3		SAVE THE BUFFER INDEX
	ADD	=BUFERS		COMPUTE BUFFER TABLE ENTRY
	TAX
	JMPM	GCI		GET THE CHARACTER INPUT
	STA	W4		SAVE IT
	SUB	MASK+3		 =10
	JAN	LOGTC		:<8D
	ANA	=177
	SUB	=5
	JAZ	LOGCR		:15
	SUB	=56
	JAZ	LOGCR		:71
	LDX	W5		GET THE PORT NUMBER
	LDA	TF,X		TEST IF IN USER-NAME MODE
	ANA	MASK+4
	JAZ	LOG1		SKIP IF NOT
	LDA	W4		ELSE TEST FOR TERMINAL CONTROL CHARACTERS
	ANA	=177
	SUB	MASK+3		 =10...CONTROL H
	JAZ	LOGHC
	SUB	MASK+3		 =10...CONTROL P
	JAZ	LOGPC
	SUB	MASK+3		 =10...CONTROL X
	JAZ	LOGXC
LOG1	LDA	W4		GET THE CHARACTER BACK
LOG2	ORA	MASK+7		 =200
	STA	W4
LOG3	LDA	MASK+14		 =10000
	JMPM	LEPSEN		SEND IT
	JMP	SECB		AND GO FOR ANOTHER
*	CONTROL H
LOGHC	LDA	TF3,X		SET HALF-DUPLEX MODE
	ORA	MASK+13
	STA	TF3,X
	JMP	LOG1		AND CONTINUE
*	CONTROL P
LOGPC	LDA	TF,X		SET PARITY
	ORA	MASK+14
	STA	TF,X
	JMP	LOG1
*	CONTROL X
LOGXC	LDA	TF,X		SET X-ENABLE
	ORA	MASK+13
	STA	TF,X
	JMP	LOG1
*	CARRIAGE RETURN OR SEMICOLON	TURN OFF LOGIN MODE AND ECHO
LOGCR	LDB	W1		GET PORT-GROUP NUMBER
	LDX	W2		GET GROUP-PORT INDEX
	LDA	LOGGER,B	CLEAR THIS PORT'S BIT IN LOGGER
	ANA	CMSK,X
	STA	LOGGER,B
	LDA	MASK,X		INITIATE TIME-OUT
	ORA	LOGTOA,B
	STA	LOGTOA,B
	LDX	W5
	LDA	TF,X		FOR PORT, SET ECHO OFF, KEYBOARD LOCKED
	ORA	MASK+6
	STA	TF,X
	JMP	LOG1		GO SEND CHARACTER ON
* TYMNET CONTROL CHARACTER
LOGTC	LDA	W4		RESTORE THE CHARACTER
	JAZ	LOGTC0		SKIP IF = 0
	DAR
	JAZ	LOGTC1		SKIP IF = 1
	SUB	MASK+1		 =2
	JAZ	LOG3		3(ZAPPER): SEND IT
	SUB	=2
	LSRA	1
	JAZ	LOGTC5		5,6: PASS IT ON
	JMP	SECB		ELSE TOSS IT
LOGTC0	JMPM	GCI		0(ESCAPE): GET AND SEND THE NEXT CHARACTER
	JAZ	SECB0		THROW AWAY ANY NULLS ENCOUNTERED
	JMP	LOG2
LOGTC1	JMPM	GCI		1(PREFIX): THROW AWAY THE NEXT CHARACTER
	JMP	SECB0
LOGTC5	IXR
	LDA	W4		5(OR 6): GREEN (OR RED) BALL...SEND IT BACK
	JMPM	WCI
	JMP	SECB
LOG4	DEC	B,AB		REPEAT FOR SECOND PORT GROUP
	JAP	SECB1
	IF	CHECKSUM
*
*	TEST FOR QUICK-CHECKSUM
	LDA	QUIKCK		GET FLAG
	JANM	CKSUM		DO IT IF FLAG SET
	ENDIF
*
*	TEST IF TO UNSNIP A LINE
	COM	,A
	LDX	USLINE		TEST
	STA	USLINE		AND CLEAR
	TXA
	JAPM	UNSNIP		GO DO IT IF NECESSARY
*
*	TIME-INTERVAL LOGIC
	LDA	TIMEL		GET CURRENT TIME
	SUB	=TICKSPS/2	TEST IF A HALF-SECOND HAS PASSED
	SUB	TIMSEC
	JAN	SEC,I		NOT YET
	SUB	=TICKSPS/2	TEST IF MORE THAN A SECOND HAS PASSED
	JAN	SECN		SKIP IF NOT
	INR	NODOVL		ELSE COUNT OCCURANCE
* HALF SECOND LOGIC STARTS HERE
SECN	LDA	TIMEL
	STA	TIMSEC
*
*	APOLOGY MESSAGE
	IF	ONLY16
	TZB			DO FOR THE PORT-GROUP
	ELSE
	INC	,B		DO FOR BOTH PORT GROUPS
	ENDIF
SECN1	LDA	SORRY,B		TEST IF MESSAGE NEEDED
	JAZ	SECN2		SKIP IF NOT
	JMPM	BID		GOT ONE...WHICH ONE
	LDA	CMSK,X		THAT ONE...CLEAR THE BIT
	ANA	SORRY,B
	STA	SORRY,B
	LRLB	4		MAKE PORT NUMBER
	COP	BX,A
	ADD	=BUFERS+1	COMPUTE PORT OUTPUT BUFFER ADDRESS
	TAX
	TZA			CLEAR THE OUTPUT BUFFER
	STA	BC,X
	INC	,A		SEND A SUPER-HANG IN CASE THIS IS A 2741
	JMPM	WCI
	LDA	=361
	JMPM	WCI
	LDA	=TOMES		SEND NORMAL TIME-OUT MESSAGE
	JMPM	MESAGE
	JMP	SECN3		SKIP OUT...DO FOR ONLY ONE PORT/LOOP
SECN2	DEC	B,AB		DO FOR NEXT PORT-GROUP
	JAP	SECN1
SECN3	E	*
*
	IF	QUASISBOD
	LDA	RINGZAP		HAVE WE LOST ANY CHARACTERS IN THE QUASI-SBOD LOGIC?
	JAZ	PLI0		NO.
	TZB			:YES,  ZERO COUNT AND
	STB	RINGZAP
	STA	W4		SEND IT TO THE SUPERVISOR.
	LDA	=100010		(SPECIAL TYPE 3 RECORD #10)
	STA	W3
	LDA	MASK+15		 =20000
	JMPM	LEPSEN		SEND IT
*
*
	ENDIF
	IF	ONLY16
PLI0	TZB			DO FOR THE PORT-GROUP
	ELSE
PLI0	INC	,B		DO FOR BOTH PORT GROUPS
	ENDIF
PLI1	LDA	PLI,B		PLEASE-LOG-IN ARRAY
	JAZ	PLI3		NONE...SKIP
	JMPM	BID		GOT ONE...WHICH ONE?
	LDA	MASK,X		CLEAR THE BIT
	STA	W1		SAVE THE BIT USED
	ERA	PLI,B
	STA	PLI,B
	LRLB	4
	COP	BX,AB		COMPUTE PORT NUMBER
	LRLA	1
	ADD	=BUFERS+1	COMPUTE PORT OUTPUT BUFFER ADDRESS
	TAX
	LDA	W1		GET BACK THE BIT
	STB	W1		SAVE THE PORT-NUMBER
	LSRB	4		RE-COMPUTE THE PORT-GROUP NUMBER
	ANA	NPID,B		TEST IF TO OUTPUT NODE-PORT IDENTIFIER
	JAZ	PLI2		NO...SKIP
	ERA	NPID,B		YES...CLEAR BIT
	STA	NPID,B
	LDA	W1		GET THE PORT-NUMBER
	LLSR	3		MAKE THE PORT NUMBER ASCII
	LRLA	5
	LLRL	3
	ADD	=130260		='00'
	STA	PNMES1		PLUG INTO PORT-NUMBER MESSAGE
	LDA	=PNMES		SEND THE PORT-NUMBER MESSAGE
	JMPM	MESAGE
PLI2	LDA	TMES		SEND THE MESSAGE..."PLEASE LOG IN"
	JMPM	MESAGE
	JMP	PLI0		GO BACK AND SEARCH AGAIN
PLI3	DEC	B,AB		REPEAT FOR SECOND PORT GROUP
	JAP	PLI1
	LDA	PW12		TEST IF ANY BUFFER ZAPPED
	JAZ	SECE		NO...SKIP
	SUB	=BUFERS		YES...COMPUTE ACTUAL BUFFER NUMBER
	STA	W4		AND SAVE IT TO SEND BACK TO SUPERVISOR
	TZA
	STA	PW12		CLEAR FLAG WORD
	LDA	=100003		BUFFER-ZAP REPORT CODE
	STA	W3
	LDA	=30000
	JMPM	LEPSEN		SEND IT
*	ANSWER AND HANG LOGIC
*
*		N O T I C E
*	IN THE FOLLOWING, A BIT IS .TRUE. IF = "0"
*
* CP GOES .TRUE. WHEN CARRIER-PRESENT-SAMPLE (CPS) IS TRUE FOR LAST
*	FOUR SAMPLES, THEN STAYS .TRUE.
*	CP GOES .FALSE. WHEN CPS IS FALSE FOR LAST FOUR SAMPLES, THEN STAYS FALSE.
*	(NOTE---LAST FOUR SAMPLES IS A TWO-SECOND PERIOD)
* RLA=CP+DTR+DSR
SECE	INR	IDX		BUMP AND GET CARRIER-PRESENT INDEX
	LDA	IDX
	ANA	=3		EXTRACT INDEX FOR RING OF 4 SAMPLES
	LRLA	1
	TAX			MAKE INDEX FOR DOUBLE-WORD AND SAVE
	IF	MARKXV
	EXC	07		GET MARK XV PORT-GROUP 0 CARRIER-PRESENT SAMPLE
	CIA	2
	IME	1,W1		GET PORT-GROUP 0 DATA-SET READY
	ELSE
	CIA	61		GET PORT-GROUP 0 CARRIER-PRESENT SAMPLE
	LRLA	1		JUSTIFY FOR FUNNY-FORMAT PLUG-BOARD
	ANA	CMSK		TURN OFF HARD-WIRED PORT BIT (=.TRUE.)
	IME	64,W1		GET PORT-GROUP 0 DATA-SET READY
	ENDIF
	STA	CPS,X		SAVE PORT-GROUP 0 CARRIER-PRESENT SAMPLE
	IF	#ONLY16
	IF	MARKXV
	CIA	12		GET PORT-GROUP 1 CARRIER-PRESENT SAMPLE
	STA	CPS+1,X		SAVE SAMPLE
	IME	11,W2		GET PORT-GROUP 1 DATA-SET READY
	ELSE
	CIA	65		GET PORT-GROUP 1 CARRIER-PRESENT SAMPLE
	STA	CPS+1,X		AND SAVE IT
	IME	66,W2		GET PORT-GROUP 1 DATA-SET READY
	ENDIF
	INC	,X		DO FOR BOTH PORT-GROUPS
	ELSE
	TZX			DO FOR THE SINGLE PORT-GROUP
	ENDIF
*	IF A PORT HAS BEEN IN A NEW STATE FOR 4 SAMPLES, PUT IT IN THAT STATE
SECE1	LDA	CPS,X
	ORA	CPS+2,X	
	ORA	CPS+4,X
	ORA	CPS+6,X		.TRUE. (=0) IF TRUE FOR ALL OF LAST 4 SAMPLES
	ANA	CP,X		.TRUE. IF CP IS TRUE, OR IF CP WILL BECOME TRUE THIS TIME
	TAB			TERM-1...TRUE IF CP TRUE OR IF ALL 4 SAMPLES TRUE
	LDA	CP,X		GET PREVIOUS AVERAGE OF LAST 4 SAMPLES (OLD-C-P=OCP)
	COM	A,A
	STA	W3		SAVE .NOT. OCP FOR LATER
	ANA	CPS,X
	ANA	CPS+2,X
	ANA	CPS+4,X		THIS SUB-TERM .TRUE. IF TRUE FOR ANY OF LAST 4 SAMPLES
	ANA	CPS+6,X		TERM-2...TRUE IF CP TRUE, UNLESS LAST 4 SAMPLES ALL FALSE
	COP	AB,A		TERM-1 .AND. TERM-2
	STA	CP,X		==>CP (NEW VALUE)
	ORA	W3		CP .AND. .NOT. OCP
	STA	W4		==>W4...TRUE UNLESS CP WENT FALSE THIS TIME (HE HUNG UP)
	LDA	DSR,X		OLD DATA-SET-READY (ODSR)
	LDB	W1,X		GET DSR INPUT VALUES
	STB	DSR,X		==>DSR (DATA-SET-READY)
	COM	A,A		.NOT. ODSR
	COP	AB,A		NEW- .AND. .NOT. OLD- DSR...TRUE IF JUST CAME TRUE
	COM	B,B		.NOT. NEW-DSR
	STB	W5		==>W5
*	IF DSR AND CP HAVE BOTH GONE FALSE SIMULTANEOUSLY, PUT THE PORT ON
*		16-SECOND TIMEOUT
	ANA	W4		.TRUE. UNLESS CP AND DSR BOTH JUST WENT FALSE
	ANA	TB,X		.OR. SIXTEEN-SECOND TIMEOUT
	STA	TB,X		==>TB
*	START TIMEOUT IF SPECIFIED BY TB
	ANA	TA,X		.OR. TA
	STA	TA,X		==>TA
*	IF A HANG HAS BEEN REQUESTED, OR IF WE TRIED TO HANG THE PORT UP LAST
*		TIME AND THE PORT IS STILL THERE, OR IF ZAPPER STILL AROUND, HANG IT
*	NOTE----HANG BIT IS SET = 1 IF TO HANG UP LINE...FOR THIS LOGIC IT
*		IS EFFECTIVELY A DON'T-HANG FLAG
	LDA	HANG,X		LINES TO NOT HANG UP
	ORA	DTR,X		.AND. DTR (DTR TRUE IF CONNECTED)
	ANA	W5		.OR. .NOT. DSR (DATA-SET-NOT-READY)
	STA	HANG,X		==>HANG
*	IF WE WANT TO HANG THE PORT UP, .OR. IF 'CP' JUST WENT FALSE,
*		.OR. IF (PORT HAS TIMED OUT WITHOUT ACKNOWLEDGEMENT AND IS STILL THERE),
*		THEN HANG THE PORT UP (SET THE BIT = 1....FALSE)
*		NOTE...'ACK' IS NORMAL LOGIC (1 = TRUE)...OUR USE IS .NOT. ACKNOWLEDGE
	TAB			(.NOT. HANG)
	LDA	ACK,X		.NOT. ACKNOWLEDGE
	COM	A,A		ACKNOWLEDGE
	ANA	TA,X		.OR. TIMEOUT
	ANA	W5		.OR. .NOT. DSR
	COP	AB,B		.AND. .NOT. HANG ==> TERM-1
	LDA	W3		.NOT. OCP
	ANA	CP,X		.OR. CP (TRUE IF CP WENT TRUE THIS TIME)
	COP	AB,A		.AND. TERM-1
	STA	DTR,X		==>DATA-TERMINAL-READY (NEW)
	ORA	CP,X		DTR .AND. CP
	ORA	DSR,X		.AND. DSR
	STA	RLA,X		==>RECEIVER-LINES-ACTIVE
	IF	#ONLY16
	DEC	X,AX
	JAP	SECE1		DO FOR BOTH PORT-GROUPS
	ENDIF
	IF	DEBUG
	IF	#ONLY16
	LDA	RLA
	ENDIF
	ANA	CMSK		FORCE RLA FOR DEBUGGER
	STA	RLA
	ENDIF
	IF	MARKXV
	OME	1,DTR		SEND MARK XV DATA-TERMINAL-READY
	IF	#ONLY16
	OME	11,DTR+1
	ENDIF
	ELSE
	OME	64,DTR		SEND DATA-TERMINAL-READY
	IF	#ONLY16
	OME	66,DTR+1
	ENDIF
	ENDIF
	IF	ONLY16
SECID	TZB			DO FOR THE ONLY PORT-GROUP
	ELSE
SECID	INC	,B		DO FOR BOTH PORT-GROUPS
	ENDIF
SECID1	LDA	RLA,B		RECEIVER-LINES-ACTIVE
	ERA	ORLA,B		OLD-RECEIVER-LINES-ACTIVE
	JAZ	SECID3		SKIP IF NO CHANGE IN LINE STATUS
	JMPM	BID		ELSE IDENTIFY WHICH LINE CHANGED
	LDA	MASK,X		UPDATE THE OLD BIT
	STA	W1		SAVE THE BIT USED
	ERA	ORLA,B
	STA	ORLA,B
	ANA	MASK,X		TEST IF NOW SET .TRUE. OR .FALSE.
	JAZ	SECID2		.TRUE.---GO SET UP FOR TERMINAL IDENTIFICATION
	ANA	ACK,B		.FALSE.---TEST IF ACKNOWLEDGE
	JAZ	SECID1		NO...GO FOR NEXT ONE
	ERA	ACK,B		ELSE CLEAR ACKNOWLEDGE STATE
	STA	ACK,B
* INITIATE CIRCUIT ZAPPER
	LRLB	4		COMPUTE PORT NUMBER
	COP	BX,A
	IF	PRINTER
	DAR
	IF	DPRINTER
	JAP	SECPD		SKIP IF NOT
	ELSE
	JAP	SECPD2		SKIP IF NOT PRINTER 1
	ENDIF
	LDA	PRINT0		FIRST PRINTER...TEST
	JAN	SECPD2
	LDA	MASK		RESET NCIB
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	COM	,A
	STA	PRINT0
	IF	DPRINTER
	JMP	SECPD2
SECPD	DAR
	JAP	SECPD1		SKIP IF NOT PRINTER 2
	LDA	PRINT1
	JAN	SECPD1		SECOND PRINTER...TEST
	LDA	MASK+1
	EXC	IDA
	ORA	NCIB
	EXC	300+IDA
	STA	NCIB
	COM	,A
	STA	PRINT1
SECPD1  IAR
	ENDIF
SECPD2	IAR
	ENDIF
	LRLA	1
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS
	TAX
	JMPM	SPEED		EXPEDITE THE TRANSMISSION
	LDA	=3
	JMPM	WCI		PUT THE ZAPPER IN THE BUFFER
	JMP	SECID
*	SET UP FOR 'TID'
SECID2	LDA	CMSK,X		CLEAR LOGGER TIME-OUT
	ANA	LOGTOA,B
	STA	LOGTOA,B
	LDA	CMSK,X
	ANA	LOGTOB,B
	STA	LOGTOB,B
	LRLB	4		COMPUTE PORT NUMBER
	COP	BX,AB
	LRLA	1
	ADD	=BUFERS+1	COMPUTE PORT OUTPUT BUFFER ADDRESS
	TAX
	TZA
	STA	BC,X		EMPTY THE BUFFER BEFORE SENDING MESSAGE
	STA	TF,B		CLEAR THE TERMINAL PARAMETERS FOR THIS PORT
	STA	TF2,B
	LDA	MASK+17
	STA	TF3,B		SET TID FLAG
	LDA	=IDM
	JMPM	MESAGE		OUTPUT THE MESSAGE 'PLEASE TYPE THE LETTER D'
	JMP	SECID		GO DO FOR ANY OTHER NEW PORTS
SECID3	DEC	B,AB
	JAP	SECID1
* RESTRICTED BUFFER SOURCE
* SEND A ONE BIT FOR EACH
* CHANNEL WHICH MAY RECEIVE
* MORE CHARACTERS
*	W1	LINE INDEX
*	W2	BACK-PRESSURE BUFFER ADDRESS
*	W3	I/O TABLE ADDRESS
*	W4	NUMBER OF BITS TO DESCRIBE TABLE
RBS	LDA	=NLINES		DO FOR ALL LINES
	STA	W1
RBS1	LDB	W1		TEST
	JBZ	SECX		DONE...SKIP
	DBR
	STB	W1		SOME MORE LINE TO DO...SET NEXT LINE
	LDX	IOTA,B		GET TABLE ADDRESS FOR THIS LINE
	LDA	1,X		GET POINTER TO BACK-PRESSURE BUFFER
	ANA	CMSK+17
	ADD	=BUFERS-1	SET ADDRESS OF BACK-PRESSURE BUFFER
	TAX
	LDA	BC,X		SEE IF OUTPUT BUFFER IS EMPTY
	DAR
	JAP	RBS6		NO...SKIP
	STX	W2		YES...SAVE ADDRESS OF BUFFER TO SEND BACK-PRESSURE ON
	LDA	IOTA,B
	STA	W3
	LDA	IOTABS,B
	STA	W4
RBS2	LDB	MASK+7		SET BYTE FLAG BIT
RBS3	LDA	W3,I		GET A TABLE ENTRY AND BUMP POINTER
	INR	W3
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS
	TAX
	JAN	RBS5		SKIP IF HIGH-SPEED CHANNEL
	LDA	BC,X		LOW SPEED...TEST IF BUFFER CONTAINS LESS THAN 40 CHARS
	SUB	MASK+5		 =40
*	NOTE THAT BUFFER NUMBER MINUS ONE IS ALWAYS EMPTY
RBS4	LLRL	1		IF LESS, SIGN BIT = 1...MOVE TO B
	TBA
	JAP	RBS3		TEST IF FLAG BIT CYCLED TO SIGN YET
	LDX	W2		YES...HAVE 8 BITS...SEND CHARACTER
	JMPM	WCI
	INR	W4		COUNT ANOTHER BYTE GONE
	LDA	W4
	JAN	RBS2		CONTINUE IF NOT YET DONE
	JMP	RBS1		ELSE GO ON TO NEXT LINE
RBS5	LDA	BC,X		HIGH-SPEED LINE...TEST IF LESS THAN 200 CHARACTERS
	SUB	MASK+7		 =200
	JMP	RBS4
RBS6	INR	LINSAT,B	LAST BACK-PRESSURE NOT SENT YET...COUNT LINE SATURATION
	JMP	RBS1		AND GO TEST NEXT LINE
*	PERFORM HALF-SECOND XON/XOFF TESTING
SECX	LDB	=NUMPORTS-1	SEARCH ALL PORTS
SECX1	LDA	TF3,B		TEST IF ASCII PORT
	JAN	SECX5		SKIP IF NOT
	LDA	TF,B		TEST IF XON/XOFF ENABLED
	ANA	MASK+13
	JAZ	SECX5		SKIP IF NOT
	STB	W1		GOT ONE...SAVE INDEX
	TBA
	LRLA	1		COMPUTE BUFFER ADDRESS
	ADD	=BUFERS
	TAX
	LDA	BC,X		GET THE COUNT OF CHARACTERS INPUT
	SUB	MASK+4		 =20...LOWER THRESHOLD
	JAN	SECX2		SKIP IF TIME TO SET XON
	SUB	MASK+3		=30(TOTAL)...UPPER THRESHOLD
	JAN	SECX5		SKIP IF NORMAL CASE
	TBA			SET X-OFF
	JMPM	BITADD
	ANA	ACK,B		VERIFY PORT IS REALLY ACTIVE
	JAZ	SECX4		SKIP IF NOT
	ORA	XNEW,B		SET THE BIT
	STA	XNEW,B
	JMP	SECX3		AND SKIP
SECX2	TBA			SET X-ON
	JMPM	BITADD
	ANA	ACK,B		VERIFY THAT THE PORT IS REALLY THERE
	ANA	XSTATE,B	TEST IF CURRENT STATE IS XOFF
	JAZ	SECX4		SKIP IF NOT
	LDA	CMSK,X		ELSE GET APPROPRIATE MASK
	ANA	XNEW,B		CLEAR THE BIT
	STA	XNEW,B
SECX3	LDA	MASK,X		SET THE X-FLAG
	ORA	XFLAG,B
	STA	XFLAG,B
SECX4	LDB	W1		RESTORE THE INDEX
SECX5	DEC	B,AB		TEST IF DONE
	JAP	SECX1		CONTINUE IF NOT
* 2 SECOND LOGIC
	INR	TIMMIN		COUNT THE HALF-SECOND CLOCK
	IF	MARKXV
	LDA	TIMMIN
	ANA	=3
	DAR
	JAP	SEC,I
	INC	,B		DO FOR BOTH PORT-GROUPS
SECU1	LDA	SPACE,B		USE THE SPACE BITS TO SET THE HANG BITS
	COM	A,A
	ORA	HANG,B
	STA	HANG,B
	TZA
	STA	SPACE,B		THEN CLEAR THE SPACE BITS
	DEC	B,AB
	JAP	SECU1
	ENDIF
*
*
*
* 8 SECOND LOGIC
	LDA	TIMMIN
	ANA	=17
	DAR
	JAP	SEC,I
	LDX	=NLINES-1	DO FOR EACH LINE
SECV1	LDB	IOTA,X		SET THE BACK-PRESSURE COUNT FOR BACK-PRESSURE LINE
	LDA	MASK+7		 =200
	STA	NIOTAB+1,B
	LDB	GROUPI,X	SET THE BIT IN RESTRICTED-BUFFER-FLAG
	LDA	RSBF,B
	ORA	MASK+1
	STA	RSBF,B
	DEC	X,AX		GO TO NEXT LINE
	JAP	SECV1		...IF THERE IS ANOTHER
	IF	ONLY16
	TZB			DO FOR THE ONLY PORT-GROUP
	ELSE
	INC	,B		DO FOR BOTH PORT GROUPS
	ENDIF
SECV2	LDA	NBO,B		NO-BALL-OUT
	ORA	TCW,B		TERMINAL-CHARACTER-WAITING
	COM	A,A		.NOT. A .AND. .NOT. B = .NOT. (A .OR. B)
	ANA	ACK,B		ACKNOWLEDGE
	ANA	DEM,B		DEFERED ECHO-MODE
	ANA	TBOA,B		TIME-SINCE-LAST-BALL-WENT-OUT
	JAZ	SECV3		NO LUCK...SKIP
	STB	W9		YES...SAVE PORT-GROUP INDEX
	JMPM	BID		IDENTIFY BIT
	LDA	TBOA,B		CLEAR TIME-SINCE-LAST-BALL-WENT-OUT BIT
	ANA	CMSK,X
	STA	TBOA,B
	LRLB	4		COMPUTE PORT NUMBER
	COP	BX,X
	LDA	TF,X		CLEAR BALL-FLAG-GREEN FOR PORT
	ANA	CMSK+5
	STA	TF,X
	TXA
	LRLA	1
	ADD	=BUFERS		COMPUTE BUFFER ADDRESS
	TAX
	LDA	=6		SEND A RED BALL
	JMPM	WCI
	LDB	W9
	JMP	SECV2		AND SEARCH FOR ANOTHER
SECV3	LDA	TBOB,B		ALL PORTS PROCESSED
	STA	TBOA,B		COPY CURRENT TBOA
	COM	,A
	STA	TBOB,B		SET UP NEXT TBOA
	DEC	B,AB
	JAP	SECV2		DO FOR ALL PORT-GROUPS
	IF	CHECKSUM
*PERFORM A CHECKSUM FOR ANOTHER TABLE ENTRY
	JMPM	CKSUM		DO A CHECKSUM
	ENDIF
* 16 SECOND LOGIC
	LDA	TIMMIN
	ANA	=37
	DAR
	JAP	SEC,I
	LDA	TB		COPY 16-SECOND TIME-OUTS
	STA	TA
	LDA	TB+1
	STA	TA+1
	COM	,A
	STA	TB		SET ALL BITS FOR NEXT LINE
	STA	TB+1
	LDX	=NLINES		DO FOR ALL LINES
SECW	DXR
	LDA	LRESET,X	GET LINE-RESET COUNTER
	JAZ	SECW2		SKIP IF = 0
	TZA			ELSE CLEAR LINE-RESET COUNTER
	STA	LRESET,X
	LDA	MASK+16		INSURE LINE-ERROR-COUNT IS REPORTED
	ORA	LINER,X
	STA	LINER,X
	LDA	=100004		REPORT LINE RESET COUNT
SECW1	JMPM	ZAPLIN		GO ZAP THE CIRCUITS ON THAT LINE
	JMP	SECW3		AND SKIP
SECW2	LDA	INDATA,X	HERE WITH LINE-RESET = 0...TEST INPUT DATA FLAG
	JAZ	SECW4		NONE IS COMING IN...GO REPORT AND PURGE THE LINE
	TZA
	STA	INDATA,X	ELSE RESET COUNTER
SECW3	JXZ	SECY		EXIT IF DONE
	JMP	SECW		REPEAT IF NOT
SECW4	STA	LINSAT,X
	STA	SWTCHO,X
	INR	INDATA,X
	LDA	=100005		REPORT CODE FOR INCOMING-DATA
	JMP	SECW1		GO REPORT IT AND ZAP THE LINE
* 256 SECOND LOGIC
SECY	LDA	TIMMIN
	ANA	=777		TEST IF TIME IS UP
	DAR
	JAP	SEC,I		EXIT IF SO
*	DELETE BUBBLES FROM BUFFER AREA
	LDX	=BUFERS+NBUF-2	DO FOR ALL BUFFERS
	LDA	BC+1,X		INITIALIZE COUNTER
	STA	BUFSTF
BUBBLE	LDA	BC,X		GET AND TEST COUNT
	JAZ	BUB1		SKIP IF COUNT = 0
	ADD	BUFSTF		ACCUMULATE IT
	STA	BUFSTF
	JMP	BUB2		AND SKIP
BUB1	LDA	BF,X		COUNT = 0...TEST FLAG
	DAR
	JAP	BUB2		SKIP IF FLAG IN USE
	LDA	BP+1,X		BUFFER NOT IN USE...DELETE POSSIBLE BUBBLE
	STA	BP,X
BUB2	DEC	X,AX		GO ON TO NEXT BUFFER
	SUB	=BUFERS
	JAP	BUBBLE
	LDA	BUFSTF		PICK UP ACCUMULATED SUM
	SUB	=(BUFEND-BUFADD)*3/4
	JAN	BUB3		SKIP IF LESS THAN 3/4 OF SPACE IN USE
	STA	W4
	LDA	=100077		SET SPECIAL REPORT
	STA	W3
	LDA	=30000
	JMPM	LEPSEN		AND TRANSMIT REPORT
BUB3	E	*
	TZB			SET UP TO CHECK NODE-OVERLOAD
	LDA	NODOVL
	STB	NODOVL		RESET VALUE
	STA	W4		SAVE IN CASE WE REPORT IT
	SUB	MASK+3		 =10..TEST IT
	JAN	SECY1		SKIP IF NO REPORT
	LDA	=100023		REPORT CODE-OUT-OF-NODE
	STA	W3
	LDA	=30000		SEND REPORT TO SUPERVISOR
	JMPM	LEPSEN
SECY1	LDX	=NLINES		TIME TO DO IT...SCAN ALL LINES
	TZB
SECY2	DXR
	LDA	LINER,X		GET AND CLEAR LINE ERROR COUNTS
	STB	LINER,X
	SUB	LERLIM
	JAP	SECY5		TEST IF EXCEEDED THRESHOLD LIMIT
	LDA	LINSAT,X	GET AND CLEAR LINE SATURATION LIMIT
	STB	LINSAT,X
	SUB	LOVLIM
	JAP	SECY4		SKIP IF EXCEEDED THRESHOLD
	LDA	SNIPE,X		TEST IF POSSIBLE LINE SNIP
	STB	SNIPE,X		CLEAR IT ANYWAY
	JAZ	SECY3		SKIP IF NOT
	STX	W4		SAVE LINE NUMBER
	LDA	=101024
	STA	W3		SET SNIPPED LINE REPORT 24
	LDA	=30000
	JMPM	LEPSEN		REPORT TO SUPERVISOR
	JMP	SECY1		AND REPEAT TESTS
SECY3	JXZ	SEC,I		EXIT IF DONE
	JMP	SECY2		ELSE REPEAT LOOP FOR ALL LINES
SECY4	ADD	LOVLIM		LINE SATURATION ERROR...RESTORE VALUE
	LDB	=100007		GET CODE
	JMP	SECY6		AND SKIP
SECY5	ADD	LERLIM		LINE ERROR...RESTORE VALUE
	LDB	=100006		GET CODE
SECY6	STB	W3		SAVE THE CODE
	ANA	=1777		TRUNCATE THE VALUE
	JAZ	SECY1		DON'T REPORT A ZERO VALUE
	LRLA	6		BUILD A DATA-WORD
	COP	AX,A
	STA	W4		SAVE
	LDA	=30000
	JMPM	LEPSEN		SEND A REPORT TO SUPERVISOR
	JMP	SECY1
*	SERVICE ROUTINES
* GET CHARACTER IN (FROM BUFFER)
* EXPECTS (X) = BUFFER ADDRESS
HLTG	JMPM	CRASH		GCI HALT	BAD BUFFER NUMBER OR EMPTY BUFER
	+300+CRASHC		GCI CRASH CODE
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
GCI	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TXA			VERIFY BUFFER NUMBER, ETC
	SUB	=BUFERS
	JAN	HLTG
	SUB	=NBUF
	JAP	HLTG
	LDA	BC,X
	JAZ	HLTG
	DAR
	STA	BC,X		REDUCE CHARACTER COUNT
	DAR
	JAP	GCI1		SKIP IF NOT LAST CHARACTER IN BUFFER
	STX	PW1		HERE IF LAST CHARACTER
	LDA	BF,X		GET BUFFER FLAG FOR BUFFER
	TAB
	LSRB	4		COMPUTE WORD ADDRESS OF FLAG
	ANA	=17
	TAX			COMPUTE BIT ADDRESS WITHIN FLAG
	LDA	FLAG,B
	ANA	CMSK,X		CLEAR THE BIT IN THE FLAG WORD
	STA	FLAG,B
	LDX	PW1		RESTORE INDEX
GCI1	LDA	BP,X		GET THE CHARACTER POINTER AND BUMP IT
	INR	BP,X
	TAB
	LSRB	1
	ANA	MASK		TEST IF HIGH OR LOW BYTE IN WORD
	JAZ	GCI2		HIGH...SKIP
	LDA	0,B		LOW...GET IT AND MASK IT
	ANA	=377
	JMP	GCI,I		AND RETURN
GCI2	LDA	0,B		HIGH BYTE...GET IT AND RIGHT JUSTIFY
	LSRA	10
	JMP	GCI,I		AND RETURN
* WRITE CHARACTER AND DECREMENT
* THIS ROUTINE MAY BE CALLED AFTER A CALL TO GCI FOR THE
* SAME BUFFER TO PUT THE CHARACTER BACK, PROVIDED THAT
* THERE HAVE BEEN NO INTERVENING CALLS TO WCI
* THE BUFFER NUMBER IS IN THE X BOX
* IT IS NOT NECCESSARY TO GIVE THE CHARACTER
WCDC	JMPM	CRASH
	+400+CRASHC		WCD CRASH CODE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
WCD	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TXA
	SUB	=BUFERS
	JAN	WCDC
	SUB	=NBUF
	JAP	WCDC		CRASH IF NOT A VALID BUFFER
	INR	BC,X		BUMP BUFFER COUNTER
	LDA	BP,X		DECREMENT BUFFER POINTER
	DAR
	STA	BP,X
	LDA	BF,X
	JMPM	BITADD		SEPERATE WORD AND BIT INDICIES
	ORA	FLAG,B		SET THE BIT TO INDICATE BUFFER NOT EMPTY
	STA	FLAG,B
	JMP	WCD,I		RESTORE FLAGS AND EXIT
* WRITE CHARACTER INTO BUFFER
* EXPECTS (A) = CHARACTER
*	(X) = BUFFER INDEX
HLTWT	IAR			BUFFER ERROR...TEST IF BUFFER = -1
	JAZ	WCI,I		EXIT IF SO
HLTW	JMPM	CRASH		WCI HALT	BAD BUFFER NUMBER
	+500+CRASHC		WCI CRASH CODE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
WCI	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ANA	=377		MASK AND SAVE THE CHARACTER
	STA	PW1
	TXA
	SUB	=BUFERS
	JAN	HLTWT		VERIFY THE BUFFER IS VALID
	SUB	=NBUF
	JAP	HLTW
	LDA	BC,X		GET THE BUFFER COUNT, COMPUTE THE CURRENT CHARACTER POSITION
	TAB
	ADD	BP,X
	STA	PW2
	SUB	BP+1,X		TEST IF BUFFER IS FULL
	JAZ	WCI5		YES...GARBAGE COLLECT
WCI1	JBZ	WCI2		SKIP IF BUFFER EMPTY
	JMP	WCI3		NOT EMPTY...SKIP
WCI2	STX	PW3		HERE IF BUFFER EMPTY
	LDA	BF,X		GET THE BUFFER FLAG
	JAZ	WCI,I		EXIT IF = 0
	TAB
	LSRB	4
	ANA	=17
	TAX
	LDA	FLAG,B
	ORA	MASK,X		ELSE SET APPROPRIATE BIT IN FLAG WORD...BUFFER NOT EMPTY
	STA	FLAG,B
	LDX	PW3
WCI3	INR	BC,X		HERE TO PUT CHAR INTO BUFFER...BUMP CHAR COUNT
	LDA	PW2		GET BACK DESTINATION CHARACTER ADDRESS
	TAB
	LSRB	1
	ANA	MASK
	JAZ	WCI4		SKIP IF FIRST BYTE IN WORD
	LDA	0,B		ELSE GET WORD
	ANA	=177400		MASK OUT ROOM
	ORA	PW1		ADD NEW BYTE
	STA	0,B
	JMP	WCI,I		AND EXIT
WCI4	LDA	PW1		HERE IF FIRST BYTE IN WORD...LEFT JUSTIFY BYTE
	LRLA	10
	STA	PW1
	LDA	0,B
	ANA	=377		GET WORD AND MASK
	ORA	PW1		ADD NEW BYTE
	STA	0,B		SAVE AND EXIT
	JMP	WCI,I
WCI5	STX	PW3		HERE IF WILL OVERFLOW BUFFER..SAVE BUFFER INDEX
WCI6	DXR			BACK UP ONE BUFFER
*
*	GARBAGE COLLECTION
GCOL1	LDA	BP+1,X
	SUB	BP,X
	SUB	BC,X		FIND SPACE IN BUFFER
	SUB	=7
	JAP	GCOL8		SKIP IF FOUND A BLOCK OF 7 OR MORE CHARACTERS
	DEC	X,AX		ELSE SCAN ALL PRECEEDING BUFFERS
	SUB	=BUFERS-1
	JAP	GCOL1
	LDB	=BUFERS+NBUF-1	HERE IF NO SUCCESS IN BACKWARD GARBAGE COLLECTION
GCOL2	LDA	BP+1,B		SEARCH FOR SOME SPACE IN BUFFER AHEAD OF THIS ONE
	SUB	BP,B
	SUB	BC,B
	SUB	=7
	JAP	GCOL12		SKIP IF FOUND MORE THAN 7 CHARACTERS OF SPACE
	DEC	B,AB
	SUB	PW3
	JAP	GCOL2		ELSE CONTINUE SEARCHING ALL BACK TO CURRENT BUFFER
*	NO MORE BUFFER SPACE BIG ENOUGH---ALL SPACE IS FRAGMENTED
*	FIND THE BIGGEST BUFFER AND ZAP IT
	STA	PW11+2		INITIALIZE SIZE SCANNER
	LDX	=BUFERS		START AT FIRST BUFFER
GCOL3	LDA	BC,X		SEARCH FOR MAXIMUM BUFFER SIZE
	SUB	PW11+2
	JAN	GCOL4
	TXA
	ERA	PW3		DON'T ZAP THE BUFFER WE'RE FILLING
	JAZ	GCOL4
	LDA	BC,X		GOT A NEW MAX...SAVE THE SIZE AND THE BUFFER INDEX
	STA	PW11+2
	STX	PW12
GCOL4	INC	X,AX
	SUB	=BUFERS+NBUF
	JAN	GCOL3		CONTINUE UNTIL SEARCHED ALL BUFFERS
	LDX	PW3		GET THE SOURCE BUFFER IN CASE WE HAVE TO CRASH
	LDA	PW11+2		GET THE COUNT OF LARGEST BUFFER
	JAZM	CRASH		ABORT IF ONLY BUFFER EXISTING IS BIGGEST
	LDX	PW12		GET INDEX OF BIGGEST BUFFER IN USE...ONE TO ZAP
	LDA	MASK+3		 =10
	STA	BC,X		SET THE BUFFER COUNT = 8D
	LDA	PW1
	STA	PW12		SAVE THE CURRENT CHARACTER
	INR	PW11		COUNT THE BUFFER ZAPPED
	LDA	=PW11+3
	STA	PW11+12		INITIALIZE THE CHARACTER SAVE POINTER
GCOL5	JMPM	GCI		COPY THE FIRST 8D CHARS FROM BUFFER TO TEMP STORE
	LDB	PW11+12
	INR	PW11+12
	STA	0,B
	LDA	BC,X
	DAR
	JAP	GCOL5		SAVE 8D CHARS IN PW11+3--PW11+11D
	TXA			DETERMINE IF SUPERVISOR OR BACK-PRESSURE BUFFER
	SUB	=BUFERS+SUPBUFFERS
	JAN	GCOL6		SKIP IF NOT SUPERVISOR BUFFER
	SUB	=11		MAYBE
	JAN	GCOL7		SKIP BLACK-BALL LOGIC IF SUPERVISOR OR BACK-PRESSURE
GCOL6	LDA	MASK+1		=2...PLACE A BLACK-BALL IN THE BUFFER
	STA	BC,X
	LDA	BP,X		BACK UP ON THE CHARACTER POINTER
	SUB	MASK+1		=2
	ANA	CMSK		FORCE TO WORD BOUNDARY
	STA	BP,X		AND RESTORE IT
	LSRA	1		MAKE A WORD INDEX
	TAB
	LDA	=775		PREFIXED 375...BLACK BALL
	STA	0,B
GCOL7	LDA	PW12
	STA	PW1		RESTORE CURRENT CHARACTER
	STX	PW12		SAVE POINTER TO ZAPPED BUFFER
	LDX	PW3		RESTORE REGISTER
	JMP	WCI6		AND TRY AGAIN
GCOL8	IXR			FOUND A PRECEEDING BUFFER WITH SPACE..SET INDEX TO NEXT BUFFER
	ANA	CMSK
	ADD	MASK+2		MAKE SIZE EVEN + 4
	STA	PW4		SAVE IT
	LDA	PW2
	IAR
	LSRA	1
	STA	PW5		COMPUTE AND SAVE WORD ADDRESS OF FIRST WORD OF NEXT BUFFER
	STX	PW6		SAVE INDEX FOR MOVE LIMIT BUFFER
	LDA	BP,X
	TAB
	SUB	PW4
	ANA	CMSK
	LLSR	1		COMPUTE WORD ADDRESS...DESTINATION (A), SOURCE (B)
	TAX			PUT DESTINATION ADDRESS IN (X)
	TBA
	SUB	PW5
	ADD	MASK+6		=64D
	JAP	GCOL9		SKIP IF WILL MOVE LESS THAN 64 WORDS
	INR	PW8		MORE THAN 64 WORDS TO MOVE...ACCUMULATE STATISTICS
	JMP	GCOL10
GCOL9	INR	PW7		LESS THAN 64 WORDS TO MOVE..ACCUMULATE THAT STATISTIC
GCOL10	LDA	0,B		MOVE THE SOURCE FORWARD TO DESTINATION
	STA	0,X
	IXR
	INC	B,AB		TEST IF TO END
	SUB	PW5
	JAN	GCOL10		CONTINUE
	LDX	PW3		ALL WORDS MOVED...UPDATE ALL POINTERS CORRESPONDING TO DATA MOVED
GCOL11	LDA	BP,X
	SUB	PW4
	STA	BP,X
	DEC	X,AX
	SUB	PW6
	JAP	GCOL11
	LDA	PW2		ALSO UPDATE CURRENT CHARACTER ADDRESS
	SUB	PW4
	STA	PW2
	JMP	GCOL16		AND SKIP TO CLEANUP
GCOL12	ANA	CMSK		HERE WITH SPACE FOUND AHEAD..(B) = BUFFER INDEX
	ADD	MASK+2
	STA	PW4		COMPUTE SIZE OF HOLE
	LDA	PW2
	LSRA	1
	STA	PW5		COMPUTE WORD ADDRESS OF CURRENT BYTE IN CURRENT BUFFER
	LDA	BP,B
	ADD	BC,B		COMPUTE BYTE ADDRESS OF FIRST FREE BYTE IN SPACIOUS BUFFER
	IBR
	STB	PW6		COMPUTE THE INDEX OF NEXT BUFFER AFTER FREE SPACE
	TAB
	ADD	PW4		COMPUTE DESTINATION BYTE
	ANA	CMSK
	LLSR	1		COMPUTE WORD ADDRESS...(A) = DESTINATION, (B) = SOURCE
	TAX
	TBA
	SUB	PW5		COMPUTE HOW MANY BYTES TO MOVE
	SUB	MASK+7		=128D
	JAP	GCOL13		MORE THAN 128
	INR	PW9		LESS THAN 128...COUNT IT AND SKIP
	JMP	GCOL14
GCOL13	INR	PW10		MORE THAN 128..COUNT THAT
GCOL14	LDA	0,B		MOVE SOURCE TO DESTINATION
	STA	0,X
	DXR
	DEC	B,AB
	SUB	PW5		TEST IF DONE
	JAP	GCOL14		NO..CONTINUE
	LDX	PW3		GET CURRENT BUFFER INDEX + 1
	IXR
GCOL15	LDA	BP,X		UPDATE ALL POINTERS CORRESPONDING TO MOVED BUFFERS
	ADD	PW4
	STA	BP,X
	INC	X,AX
	SUB	PW6
	JAN	GCOL15		DO FOR ALL
GCOL16	LDX	PW3		DONE...RESTORE REGISTERS
	LDB	BC,X
	JMP	WCI1		GO BACK AND INSERT CHARACTER IN BUFFER
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
PW1	0			CHARACTER TO BE INSERTED
PW2	0			CURRENT BUFFER CHARACTER POINTER
PW3	0			BUFFER INDEX
*		THE REST OF THESE LOCATIONS ARE USED IN GARBAGE COLLECTION
PW4	0			SIZE OF HOLE FOUND (BYTES)
PW5	0			WORD ADDRESS OF FIRST BYTE IN NEXT BUFFER
PW6	0			INDEX OF EXTREME BUFFER TO MOVE
PW7	0			STATISTICS...NUMBER OF TIMES MOVED BACK LESS THAN 64D WORDS
PW8	0			STATISTICS...NUMBER OF TIMES MOVED BACK MORE THAN 64D WORDS
PW9	0			STATISTICS...NUMBER OF TIMES MOVED FORWARD LESS THAN 128D WORDS
PW10	0			STATISTICS...NUMBER OF TIMES MOVED FORWARD MORE THAN 128D WORDS
PW11	0			STATISTICS...NUMBER OF TIMES BUFFER ZAPPED
PW12	0			INDEX OF LAST ZAPPED BUFFER
	R	*+1		ACCUMULATE MAX SPACE HERE
	R	*+10		SAVE FIRST 8D CHARS OF ZAPPED BUFFER HERE
*
*	ROUTINE TO ZAP A LINE
*	EXPECTS (A) = MESSAGE NUMBER
*		(X) = LINE NUMBER
ZAPLIN	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STA	W3
	STX	W4
	STX	ZLW1		SAVE LINE NUMBER
	LDA	=30000
	JMPM	LEPSEN
	LDX	ZLW1		RESTORE LINE NUMBER
	LDA	IOTA,X
	ADD	=2
	STA	SWI		SAVE POINTER TO FIRST NON-RESERVED ENTRY IN TABLES
	LDA	IOTABS,X	COMPUTE NUMBER OF NON-RESERVED TABLE ENTRIES
	LRLA	3
	ANA	=177770
	ADD	=2
	STA	ZLW2		SAVE THAT
	LDX	IOTA,X
	LDA	0,X
	ANA	CMSK+17
	ADD	=BUFERS-1
	TAX
	JMPM	EMPTY		EMPTY OUTBOUND SUPERVISOR BUFFER
ZAPL1	LDA	SWI,I		GET A TABLE ENTRY
	INC	A,B
	JBZ	ZAPL2		SKIP IF NOT IN USE
	ADD	=BUFERS		ELSE COMPUTE ADDRESS OF BUFFER
	ANA	CMSK+17		CANCEL POSSIBLE GOUGING
	TAX
	TZA
	STA	BC,X		EMPTY THAT BUFFER
	LDA	=3
	JMPM	WCI		SEND A ZAPPER
	LDA	SWI,I
	ERA	MASK		COMPUTE ADDRESS OF OTHER BUFFER
	ADD	=BUFERS
	ANA	CMSK+17
	TAX
	JMPM	ZBF		EMPTY THAT BUFFER AND CLEAR THE BUFFER FLAG
	COM	,B		FREE THAT BUFFER
	STB	SWI,I
	JMPM	SBOD		WE'VE SPENT SOME TIME HERE...PROCESS START BAUDS
ZAPL2	INR	SWI		REPEAT FOR ALL TABLE ENTRIES FOR THIS LINE
	INR	ZLW2
	LDA	ZLW2
	JAN	ZAPL1
	LDX	ZLW1		THEN RESTORE LINE INDEX
	JMP	ZAPLIN,I	AND EXIT
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
ZLW1	0
ZLW2	0
*
*	ROUTINE TO UNSNIP A LINE
*	EXPECTS (X) TO EQUAL LINE NUMBER
UNSNIP	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TXA
	JAN	UNSNIP,I	IGNOR IF OUT OF RANGE
	SUB	=NLINES
	JAP	UNSNIP,I
	LDA	RESETI,X	COMPUTE NEW ADAPTOR
	ERA	RESETO,X
	STA	ADAPT,X
	ERA	=PADAPT		CHANGE RESETS AS NECESSARY
	TAB
	ERA	RESETO,X
	STA	RESETO,X
	TBA
	ERA	RESETI,X
	STA	RESETI,X
	JMP	UNSNIP,I		AND RETURN
*	TEST FOR A GOUGER...EXPECT SECOND CHAR OF PAIR IN (A)
*	SAVES ALL REGISTERS...IF APPROPRIATE, SET OR RESET GOUGING
*	EXPECTS POINTER TO PERMUTER TABLE ENTRY IN CELL "PTEPNT"
	IF CHECKSUM; ECKSUM; ENDIF	* * * C H E C K S U M   L I M I T * * *
GOUGE	0
	IF CHECKSUM; SCKSUM; ENDIF	* * * C H E C K S U M   L I M I T * * *
	STB	GOUGEB		SAVE (B)
	TAB			SAVE CHAR
	LSRA	4
	ERA	MASK+1		 =2...TEST IF 'SET OUTPUT BAUD RATE'
	JAZ	GOUGE2		SKIP IF SO
	ERA	=12		TEST IF ALTERNATE  FORM
	DAR
	JAP	GOUGE4		EXIT IF NOT
	TBA			ELSE EXTRACT CODE
	ANA	=16		FORM (10,010XB)
	ERA	MASK+2
	JAZ	GOUGE3		SKIP IF GOUGER
GOUGE1	LDA	CMSK+17		NOT GOUGER...UNGOUGE CIRCUIT
	ANA	PTEPNT,I
	STA	PTEPNT,I
	JMP	GOUGE4		AND SKIP
GOUGE2	TBA			NORMAL FORM OF OUTPUT BAUD RATE (2,10XXB)
	ANA	=14		TEST IF GOUGING
	DAR
	JAP	GOUGE1		UNGOUGE IF NOT
GOUGE3	LDA	MASK+17		GOT A GOUGER...SET IT
	ORA	PTEPNT,I
	STA	PTEPNT,I
GOUGE4	TBA			DONE...RESTORE REGISTERS
	LDB	GOUGEB
	JMP	GOUGE,I		AND RETURN
	IF CHECKSUM; ECKSUM; ENDIF	* * * C H E C K S U M   L I M I T * * *
GOUGEB	R	*+1		TEMP STORE
	IF CHECKSUM; SCKSUM; ENDIF	* * * C H E C K S U M   L I M I T * * *
* SPEED ZAPPER OR GOBBLER ON ITS WAY
SPEEDA	JMPM	CRASH
	+700+CRASHC		SPEED CRASH CODE
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
SPEED	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TZA
	STA	BC,X		CLEAR BUFFER COUNT FOR CHANNEL
	STX	W4
	LDA	BF,X		GET BUFFER FLAG
	SUB	=20*(CFOB-FLAG)	IS THIS A CANDIDATE FOR OUTPUT BUFFER?
	JAN	SPEED,I		NO...EXIT
	TAB			YES...COMPUTE I/O TABLE ADDRESS
	ADD	=IOTAB0
	TAX
	SUB	=BR
	JAP	SPEEDA		CRASH IF INTO BUFFER RESTRICTIONS
	LDA	MASK+5		 =40
	STA	NIOTAB,X	ELSE SET NEW COND
	TBA
	JMPM	BITADD		COMPUTE BIT ADDRESS
	ORA	RSBF,B
	STA	RSBF,B		SET THAT BIT IN THE RESTRICTED BUFFER FLAGS
	LDX	W4
	JMP	SPEED,I		RESTORE X AND RETURN
* CONVERT (A) TO WORD ADDRESS IN (B), AND BIT IN (A)..X SMASHED
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
BITADD	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TAB
	LSRB	4
	ANA	=17
	TAX
	LDA	MASK,X
	JMP	BITADD,I
*	FIND NUMBER OF FIRST BIT SET IN (A), RETURN NUMBER IN (X)
*	A IS PARSED INTO FIELDS OF (7, 5, 4) RESPECTIVELY, LEFT TO RIGHT
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
BID	0			BIT IDENTIFIER
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	TAX			SAVE BITS
	ANA	=177000		MASK OFF LOW BITS
	JAZ	BID3		SKIP IF NO HIGH BITS
	LDX	=17		SET BIT 17 INDEX
BID1	JAN	BID,I		RETURN IF TRUE
BID2	LRLA	1		ELSE COUNT DOWN, TEST NEXT BIT
	DXR
	JAP	BID2
	JMP	BID,I		RETURN WHEN DONE
BID3	TXA			HERE IF BITS IN LOW HALF
	ANA	=760
	JAZ	BID4		SKIP IF BITS NOT IN MIDDLE
	LRLA	7
	LDX	MASK+3		 =10...ABORT SCAN OVER FIRST HALF OF WORD
	JMP	BID1		AND PICK UP AT SECOND HALF
BID4	TXA			BIT IN LOW END OF WORD
	LRLA	14
	LDX	=3
	JMP	BID1
* ZERO BUFFER FLAGS
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
ZBF	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	JMPM	EMPTY		EMPTY THE BUFFER
	TZA
	STA	BF,X		CLEAR THE BUFFER FLAGS
	JMP	ZBF,I		THEN EXIT
* REMOVE ANY EXISTING CHARACTERS IN BUFFER
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
EMPTY	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDA	BC,X
	JAZ	EMPTY,I		COUNT = 0...EXIT
	INC	,A
	STA	BC,X		ELSE SET COUNT = 1
	JMPM	GCI		GET THE CHAR (FOR CLEANUP)
	JMP	EMPTY,I		AND EXIT
* SEND RECORD UPSTREAM
*	(A) = CODE TO SEND
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
LEPSEN	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDX	USWICH		TEST UPSTREAM SWITCH
	JXZ	LEPSEN,I	ABORT IF = 0
	ORA	=MACHNUM+.	SET MACHINE NUMBER AND HIGH BIT
	STA	W2		PUT IN RECORD WORD 1
	JMPM	LEPSN		SEND RECORD
	JMP	LEPSEN,I	AND EXIT
* SEND A RECORD
*	OUTPUT 6 CONSECUTIVE BYTES FROM W2, W3, AND W4
*	USES W10 FOR TEMP
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
LEPSN	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDA	=W2
	STA	W10		SET POINTER
LEPSN1	LDA	W10,I		GET AND OUTPUT LEFT BYTE OF WORD
	LSRA	10
	JMPM	WCI
	LDA	W10,I
	JMPM	WCI		GET AND OUTPUT RIGHT BYTE OF WORD
	LDA	W10
	INR	W10		GET AND BUMP POINTER
	SUB	=W4		TEST
	JAN	LEPSN1		NOT DONE YET..CONTINUE
	JMP	LEPSN,I		THEN EXIT
* OUTPUT MESSAGE SPECIFIED BY (A)
* PREFIXED BY CARRIAGE RETURN/LINE FEED
*	EXPECTS (X) = BUFFER INDEX
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
MESAGE	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STA	MW1		SAVE MESSAGE ADDRESS
	LDA	=215		CARRIAGE RETURN
	JMPM	WCI		PUT INTO BUFFER
	LDA	=212		LINE-FEED
	JMPM	WCI		PUT INTO BUFFER
MESAG1	E	*
	IF	#QUASISBOD
	JMPM	SBODCHK
	ENDIF
	LDA	MW1,I
	JAZ	MESAGE,I
	LSRA	10
	JMPM	WCI
	LDA	MW1,I		GET SECOND CHARACTER OF MESSAGE
	JMPM	WCI
	INR	MW1
	JMP	MESAG1
	IF	#QUASISBOD
*
*  SHOULD WE CALL 'SBOD'
*
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
SBODCHK	0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	LDA	RGX
	SUB	SBX
	ANA	=200*SAMPLESIZE
	JAZ	SBODCHK,I
	STX	SBCHKT
	JMPM	SBOD
	LDX	SBCHKT
	JMP	SBODCHK,I
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
SBCHKT	0			TEMP STORE FOR SBODCHK
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ENDIF
	IF	TRACE
*	TRACE ROUTINE
	IF	CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
TRSUB	0
	IF	CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	STX	TRREG		SAVE REGISTER
	LDX	TRPNT		GET THE POINTER
	STA	0,X		SAVE (A)
	LDX	TRREG		RESTORE (X)
	STA	TRREG		SAVE (A)
	LDA	TRSWCH		TEST SWITCH
	JAZ	TRSUB1		SKIP IF NOT SET
	INR	TRPNT		ELSE UPDATE POINTER
	LDA	TRPNT
	SUB	=TREND
	JAN	TRSUB1		SKIP IF NO FOLDING
	LDA	=TRBEGN		ELSE CYCLE AROUND
	STA	TRPNT
TRSUB1	LDA	TRREG		RESTORE (A)
	JMP	TRSUB,I		AND RETURN....REGISTERS UNCHANGED
*
	IF	CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M  L I M I T * * *
TRREG	R	*+1		TEMP STORE FOR REGISTERS
TRPNT	+TRBEGN			POINTER TO NEXT WORD TO SAVE
TRBEGN	RPT1	200		THE TRACE TABLE
	0
TREND	E	*		END OF TRACE TABLE
	IF	CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ENDIF
	IF	CHECKSUM
*
*	CHECKSUM ROUTINE
	ECKSUM
CKSUM	0
	SCKSUM
	LDA	CKPNT		GET CURRENT WORD POINTER
	STA	W4		SAVE AS BLOCK START
	LDA	CKINX		GET TABLE INDEX
	TAX			COPY IT
	SUB	CKTABL+1	GET LIMIT OF CHECKSUM SPAN
	JAN	CKSUM1		SKIP IF SPAN LIMIT NOT EXCEEDED
	STA	QUIKCK		ELSE RESET QUICK-CHECKSUM FLAG
	LDA	CKTABL		RECYCLE MEMORY POINTER
	STA	CKPNT
	STA	W4
	LDX	=CKTABL+2	RECYCLE INDEX
	STX	CKINX
CKSUM1	LDB	0,X		GET THE PARAMETERS
	LSRB	8D		SPAN OF PURE CODE
	JBZ	CKSUM3		SKIP IF NO PURE CODE IN THIS BLOCK
	LDA	1,X		INITIALIZE CHECKSUM
CKSUM2	ERA	CKPNT,I		DO ANOTHER WORD
	INR	CKPNT		BUMP POINTER
	DBR			COUNT IT DONE
	JBZ	*+4		SKIP IF DONE
	JMP	CKSUM2		CONTINUE FOR ALL WORDS OF BLOCK
	ANA	CKFLAG		TEST IF TO REPORT ERROR
	JAZ	CKSUM3		SKIP IF NO ERROR OR NO REPORT
	STA	W9		YES...SAVE BAD BITS
	ANA	=177400		MASK OUT HIGH 8 BITS
	LSRA	2		JUSTIFY FOR REPORT
	ORA	=100020		SET TYPE 20 REPORT
	STA	W3
	LDA	=30000		CODE TO REPORT BAD CHECKSUM
	JMPM	LEPSEN		GO BITCH...8 BITS OF ERROR, BLOCK START ADDRESS
	LDA	W9		REPORT OTHER HALF
	ANA	=377
	LRLA	6
	ORA	=140020		SET ALTERNATE REPORT 20
	STA	W3
	LDA	CKPNT
	STA	W4
	LDA	=30000
	JMPM	LEPSEN		REPORT OTHER 8 BITS OF ERROR, BLOCK END ADDRESS
	LDX	CKINX		RESTORE INDEX
CKSUM3	LDA	0,X		NOW SPAN OVER IMPURE DATA
	ANA	=377
	ADD	CKPNT
	STA	CKPNT
	IXR
	IXR			BUMP INDEX FOR NEXT TIME
	STX	CKINX
	JMP	CKSUM,I		THEN EXIT
*THE CHECKSUM TABLE
	ECKSUM			* * * C H E C K S U M   L I M I T * * *
CKINX	77777			INDEX FOR CHECKSUM ROUTINE
CKTABL	C	*+170+10*NLINES
	SCKSUM			* * * C H E C K S U M   L I M I T * * *
	ENDIF
*	MESSAGE TEXTS
IDM	ASC	'PLEASE TYPE THE LETTER D'; 0
	IF	MACHNUM>777
X	E	(MACHNUM_-9D)&7
PNMES	255\X+260
X	E	(MACHNUM_-3)&77
	(X/10)+260\(X&7)+260
	ELSE
X	E	(MACHNUM_-3)&77
	IF	X>7
PNMES	ASC	'--'
	(X/10)+260\(X&7)+260
	ELSE
PNMES	255\X+260
	ENDIF
	ENDIF
	(MACHNUM&7)+260\255
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
PNMES1	ASC	'00'
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	ASC	'--'
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
	0				FILL WITH C/R--L/F TO ENABLE FOLLOWING MESSAGE AFTER PATCHING
	ASC	'THIS NODE WILL BE OUT FROM '
	ASC	'**00, '		FILL ** WITH START HOUR
	ASC	'****** TO '		FILL ****** WITH MONTH-DAY
	ASC	'**00, '		FILL ** WITH END HOUR
	ASC	'******'		FILL ****** WITH END MONTH-DAY
        RPT1    175D;     0
	IF CHECKSUM; SCKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
TOMES	ASC	'WE ARE EXPERIENCING TEMPORARY DIFFICULTIES'; 215\212
	ASC	'PLEASE TRY AGAIN IN A FEW MINUTES'; 215\212; 1\360; 0
* TM7 MUST PRECEDE TM1
TM7	ASC	'SYSTEM UNAVAILABLE'; 215\212
TM1	ASC	'PLEASE LOG IN: '; 240\5;0
TM2	ASC	'ERROR, TYPE '	MUST PRECEDE TM4
TM4	ASC	'USER NAME: '; 240\5;0
TM3	ASC	'ERROR, TYPE '	MUST PRECEDE TM5
TM5	ASC	'PASSWORD: ' ;240\5;0
TM6	207\207;0
TM10	ASC	'PLEASE SEE YOUR TIMESHARE REPRESENTATIVE'; 215\212
	ASC	'IF YOU ARE HAVING TROUBLE LOGGING IN'; 215\212; 1\360;0
TM11	ASC	'BAD MUD'; 215\212; 1\360;0
TM12	ASC	'OUT OF CHANNELS'; 0
TM13	ASC	'OUT OF PORTS'; 0
*	2741 CHARACTER TRANSLATION TABLES
	IF	EBCD2741
CT41	40;55;100;46;70;161;171;100550
	167264;153755;173565;144;0;173200;0;0
	62;153;163;142;60;0;0;0
	66;157;167;146;0;10;0;0
	160061;135352;115057;55141;75271;132162;60772;126151
	131065;125156;101166;120745;75400;40200;55612;70411
	65063;50154;44164;74143;42043;72044;66054;56056
	41067;71160;102170;134147;104000;110000;116000;130400
	40440;110737;104600;134653;102652;132721;126731;116710
	101672;131715;130325;124304;114200;122200;112200;106200
	136274;121313;111323;124502;114451;122400;112400;106400
	136447;121517;111527;131106;70400;125010;135400;100200
	126075;50712;44677;74701;42650;72722;66732;56711
	41645;71716;70326;64305;54200;62200;52212;46211
	76273;61314;51324;64503;54442;62441;52574;46536
	76476;61520;51530;131107;135400;125000;115600;157200
SCT41	0;176;0;37;175;21;31;10
	34;15;25;4;0;0;0;0
	133;13;23;2;135;0;0;0
	36;17;27;6;0;0;0;0
	173;136;134;1;133;22;32;11
	35;16;26;5;177;0;0;0
	33;14;24;3;140;136;177;134
	37;20;30;7;0;0;0;0
	ELSE
CT41	40;41;164;152;64;157;154;110057
	167265;153647;173545;160;0;173200;0;0
	62;56;156;75;172;0;0;0
	66;151;153;161;0;10;0;0
	160061;40355;122370;134147;101060;102163;132150;62371
	115067;131162;116144;104673;156600;55600;164212;41611
	71063;50166;44165;74146;41071;42167;66142;72055
	56070;55141;132743;72654;115000;44600;131000;101600
	104040;136335;135524;136512;112444;122517;134714;110677
	111445;106242;120705;106520;121400;130200;124400;121200
	102700;126656;112316;111253;100532;114400;114200;135200
	130533;131711;125113;126121;0;100210;40200;115600
	62200;76315;75530;76507;52451;62523;74710;50731
	51446;46322;60704;46472;61400;70200;64412;61211
	42643;66726;52325;51306;40450;54527;54302;75337
	70452;71701;65103;115054;0;131000;0;157200
SCT41	0;136;24;12;34;17;14;134;35;140;5;20;0;0;0;0
	0;174;16;173;32;0;0;0;36;11;13;21;0;0;0;0
	0;15;30;7;76;23;10;31;37;22;4;177;0;0;0;0
	33;26;25;6;74;27;2;176;175;1;3;0;0;0;0;0
	ENDIF
	IF CHECKSUM; ECKSUM; ENDIF		* * * C H E C K S U M   L I M I T * * *
*	**BUFFER ARRAYS**
*
*
*	BUFFER ADDRESSES
*
*
	+BUFADD			BUFFER BASE...BUFFER LOWER LIMIT POINTER
BUFERS	RPT1	NBUF-4
	+BUFADD
	RPT1	4
	+BUFEND
	+BUFEND			BUFFER HIGH LIMIT
*
*
*	BUFFER FLAGS
*
* LOW SPEED DEVICES	BUFERS 0 TO 77	(TWO WORDS/PORT--INPUT AND OUTPUT)
BUFFLAG	E	*
	IF	DEBUG
DBGBUF	E	BUFERS		PORT 0 USED FOR DEBUGGER
	17;	20
	ELSE
	0;	20		PORT 0
	ENDIF
	0;21;0;22;0;23;0;24;0;25;0;26;0;27
	0;30;0;31;0;32;0;33;0;34;0;35;0;36;0;37
	0;40;0;41;0;42;0;43;0;44;0;45;0;46;0;47
	0;50;0;51;0;52;0;53;0;54;0;55;0;56;0;57
*
* SUPERVISORY CHANNELS	100 TO 105
* FLOW CONTROL CHANNELS	106 TO 113
SUPBUFFERS	E	100
X	E	120
SUPFLAG	+X; 1
	(NLINES>1)*(X+20*NGRPS0); (NLINES>1)*2
	(NLINES>2)*(X+20*(NGRPS0+NGRPS1)); (NLINES>2)*3
X	E	X+1
	+X; 4
	(NLINES>1)*(X+20*NGRPS0); (NLINES>1)*5
	(NLINES>2)*(X+20*(NGRPS0+NGRPS1)); (NLINES>2)*6
*
* SPARES	114 TO 253
	RPT1	NBUF-(SUPBUFFERS+4*3)
	0
*
*
*	BUFFER COUNTS
*
	R	*+1		COUNT CORRESPONDING TO BUFFER BASE (ALWAYS = 0)
BUFCNT	R	*+NBUF
*
*
BP	E	0
BF	E	1+NBUF
BC	E	BF+NBUF+1
* WARNING! IOTABLES MUST BE MULTIPLES OF 16 IN LENGTH
IOTAB0	101+.; 107+.
	RPT1	20*NGRPS0-2
	-1
IOTAB1	IF	NLINES>1
	103+.; 111+.
	RPT1	20*NGRPS1-2
	-1
	ENDIF
IOTAB2	IF	NLINES>2
	105+.; 113+.
	RPT1	20*NGRPS2-2
	-1
	ENDIF
NIOTAB	E	*-IOTAB0	NUMBER OF IOTABLE WORDS
*
*	BUFFER RESTRICTIONS (TOTAL NUMBER OF CHARACTERS WE CAN SEND ON CHANNEL)
BR	R	*+NIOTAB
*
EPATCH	E	*		START OF PATCH SPACE AT END OF MEMORY
* THE FOLLOWING IS A DUMMY STATEMENT TO CAUSE
* THE ASSEMBLER TO ISSUE A MULTIPLY DEFINED CELL DIAGNOSTIC
* IF NOT ENOUGH ROOM HAS BEEN RESERVED FOR THE BUFFER
* RESTRICTION COUNTS BETWEEN BR AND THE START OF THE BUFFERS
	R	ENDCODE
SLACK	E	*-EPATCH	ROOM LEFT IN THIS ASSEMBLY
    +-8t