! TITLE: PAPER TAPE HACKAGE MODULE PTRTN.SIM - VER 6.00-0
! SUBTTL: PDP-10 ALL PURPOSE PAPER TAPE HACKAGE
!
! ALL PEOPLE/PERSONS WHO MODIFY THIS PROGRAM PLEASE PUT THE VERSION
! NUMBER(S) YOU RELEASE AND YOUR NAME AND THE DATE
! TO THE TOP OF THE FOLLOWING LIST
!
! 6.00 - GARY GERE - FIXED MOST BUGS - AUGUST 6, 1973
! 5.00 - GARY GERE - APRIL 10, 1973
! 4.01 - GARY GERE - MARCH 4, 1973
! 4.00 - GARY GERE - FEBRUARY, 1973
! INITIAL VERSION 3.00 BY GARY GERE - JANUARY, 1973
!

BASE 0          !EVERYTHING IS AT 0
!MISC. RAMBLINGS
!  THE FOLLOWING MACRO COMPUTES A GENERAL BYTE POINTER SO THAT NCHV ON
!  THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE.
DEF BYPT(Y,P,S) AS [6,6,6,18]*[IF P>=0 THEN 36-S*(P MOD(36/S)-1)&
        ELSE 36-S*(36/S-(-P)MOD(36/S)+1),S,0,&
        IF P>=0 THEN Y+P/(36/S) ELSE Y+(P+1)/(36/S)-1]
DEF NBYV AS NCHV
DEF BYV AS CHV

! THE FOLLOWING 'EXU' MACROS ARE COMPLETELY MACHINE DEPENDENT
! THE WORK ON THE FACT THAT THE PDP-10 SIMPL WILL PACK ARGUMENTS
! STARTING AT REGISTER 1 FOR ARGUMENT 1, 2 FOR 2 ETC.
! THEY CAUSE SIMPL TO GENERATE CODE WHICH POINTS TO A REGISTER
! FOR THE CODE'S ARGUMENT (IE- TTCALL 15,4   SLEEP 4,   ETC.)
!
DEF IONEOU(X) AS EXU(OCT 51,OCT 15,4,X) !TTCALL 15,4 OR  IONEOU 4
DEF SLEEP(X) AS EXU(OCT 47,4,OCT 31,X)  !SLEEP 4,
DEF MOUTSTR(X) AS EXU(OCT 51,OCT 3,X)    !TTCALL 3,M  OR  OUTSTR M

DEF ENDK AS OK; RETURN EMPTY
DEF C.MAX AS 100 !MAXIMUM SIZE OF CWORDS ARRAY
DEF S.MAX AS 130 ! MAXIMUM SIZE OF SWORDS ARRAY
DEF ENDR AS RETURN EMPTY
DEF TOKEN AS TOKBUF(0)
DEF SETIN AS CSTRING(POINTX(TOKBUF),POINTX(IFILS))
DEF SETOU AS CSTRING(POINTX(TOKBUF),POINTX(OFILS))
DEF MORE AS CKEOL(STR)=FALSE
DEF POINT(X) AS CHPT(X,-1)
DEF POINTX(X) AS CHPT(@X(0),-1)
DEF GIVEUP AS GO UNXERR
DEF ZILCH AS TERMCH=CARRET THEN
DEF CRLF AS PUT(CARRET) !C.R. AND L.F.

!MISC. NUMERIC RAMBLINGS
DEF CRASHER AS FALSE    !TRUE IF WE DO CRASH PROT, FALSE IF PTDATA DOES
DEF LNGTH AS 5          !LENGTH OF LEADER/TRAILER (INITIAL; SEE INIT)!
DEF NO.CMDF AS 10       !NUMBER OF COMMAND-FILES ALLOWED OPEN
DEF IORDX AS 10         !DEFAULT I-O RADIX (IT'S DECIMAL)
DEF NO.CHAR AS 250      !MULT. OF 5 - NO OF CHARACTER IN READ BUFFER
DEF MINS(X) AS X*1      !NUMBER OF IOCS BUFFERS PER MINUTE [==1]
DEF NO.CRAPS AS MINS(5) !NUMBER OF MINUTES BETWEEN CRASH PROTECTION
DEF NO.IOCB AS 10       !NUMBER OF DIRECT MODE IOCS BUFFERS
DEF SR.SIZE AS OCT 250  !MAX CHARACTER FOR 'SPLICE' COMMAND BUFFER
DEF NO.SPLI AS OCT 60   !# CHARACTERS TO USER IN SPLICE COMMAND
DEF PE.MAX AS 100       !MAX. NO. PARITY ERRORS PER IMAGE LINE (<NOCHAR)
DEF MAX.CHR AS OCT 177  !MAX. CHARACTER THIS PROGRAM CAN HANDLE
DEF MAX.DIG AS 11       !MAX. NO. OF DIGITS
DEF TCHR AS OCT 175     !CHARACTER WHICH TERMINATES TITLE STRING
DEF TRUE AS 1		!TRUE STATEMENT
DEF FALSE AS 0		!FALSE STATEMENT
DEF EMPTY AS -1         !EMPTY EXPRESSION

!DATA TYPES
DEF FIRK AS -2          !A FIRKED UP EXPRESSION
DEF STRING AS 1		!STRING EXPRESSION
DEF NUMBER AS 2		!NUMERIC EXPRESSION
DEF RESWRD AS 3		!RESERVED WORD
DEF DELIMT AS 4         !TERMINATOR

!DEFS FOR DO
DEF OFF AS 7
DEF EVEN AS 8
DEF ODD AS 9
DEF DATA AS 10
DEF PACKD AS 49

! GETOKEN DEFS
DEF NUMIN AS OCT 1
DEF STRIN AS OCT 2
DEF RESIN AS OCT 4

!TABLE OF RESERVED WORDS. INDEX IS RESERVED WORD NUMBER
!
! TABLE "SWORDS"
! CONTAINS ASCII CHARACTER NAMES FOR SUBSTITUTE COMMAND
!

DEF S.BUFF AS 100               !SUBSTITUTE BUFFER WORD SIZE

FIND SWORDS(0:400),HELPM(0),TWORDS(0:OCT 137),CWORDS(0:400)
FIND SEGB(0:10),C.SIZE,S.SIZE
FIND %FOO,%GOCMD
FIND YESNO(0),COMNDS(0),PRITY(0),TTLE(0),SYMBIN(0),REPIT(0),ECHIT(0),NOTBL(0),SUBIT(0),USETB(0),EDITB(0),RDXE(0),HLPR(0),EDITR(0)

FIND %SETTY,%RDTTY,%OPNPTP,%CLSPTP,%WRTPTP,%SETSEG,%RDFIL,%SETSCR
FIND %SETUP

FIND JOBFF,JOBDDT,JOBVER,JOBREN,JOBAPR         !!!JOBDAT, RAH!!!

GLOBAL ALTMOD:,ESCAPE:,BEGIN:,RESADR:

GLOBAL %NCHR,%GETOKEN,%CTOKEN,%STOKEN,%SINC,%INSC,%STRCOMP,%INDEX,%OK
GLOBAL %CSTRING,%FIRKIT,%NCHAR,%TYPCHR,%OUTNUM,%NXLIN,%ERR
GLOBAL %OUTSTR,%PRM,%FIGURE,%DOCMD,%INIT,%HELP,%READ,%PUNCH,%SUBGET
GLOBAL %COPYST,%SUBPUT,%SUBOUT,%OUTTIT,%LEDTRL,%CONFMP,%MAKPAR,%SUBCR
GLOBAL %SUBINI,%SUBPRC,%LEV7,%MAKTMP,%LEV8,%WSTR,%OUCH,%OUCS,%NXCHR
GLOBAL %SUBRD,%PARERR,%SUBWT,%SUBCLN,%WINT,%PAROUT,%CNTER,%SWSTR,%SWOUT
GLOBAL %SUBRED,%CRASHP,%NEWCMD,%OLDCMD,%STRIP,%SEARCH,%SERRD,%CHECK.ARRAY
GLOBAL %OUTIMG,%HELPER,%CKEOL,%NUMOUT,%COPYT,%CBHELP,%GPRM,%NULP

GLOBAL CHAR,TOKBUF(0:50),TERMCH,TYPE,SLEEPY,TITBUF(0:50),TITLE
GLOBAL ECHAR,ELINE,LENGTH,PARITY,STR,SVPLAC,FCORE()
GLOBAL ISUBTAB(0:MAX.CHR),ESUBTAB(0:MAX.CHR)
GLOBAL LASLIN,LASINP,TELFIL,LASPRM,RUNFLG,ECHO,RPTYPE,SYMBN,IFILE,OFILE
GLOBAL SUBPTR,SUBUFF(0:S.BUFF),OFILS(0:10),IFILS(0:10),MTOKS(0:20)
GLOBAL PARNAM(0:5),TAPNAM(0:5),PARTY,CMDFLS(0:NO.CMDF),CURCMD,LINFLG(0:NO.CMDF)
GLOBAL USEFLG,ALWP8T,LASFMP,CIORDX,IRECTAB(0:MAX.CHR),ERECTAB(0:MAX.CHR)
GLOBAL RECPTR,SCRNAM(0:5),MYFID(0:30),CMDNO,TORTBD

!**************************** MAIN PROGRAM ****************************!

BEGIN:  IOCS(NO.IOCB)           !GET IOCS MOVING
        INIT            ! INIT ALL VARIABLES
        SETSEG                  !SET UP SEGEMENT INFORMATION
        IF JOBDDT BAND OCT 777777 # 0 THEN MSG('LOADED WITH DDT$')
        MSG('YOUR JOB ID IS '); OUTNUM(EXU(OCT 47,OCT 1,OCT 30),8)
        CRLF
RESADR: NULL            !REENTRY ADDRESS FROM LINKUP
ESCAPE: LOOP DO
        IF FOO=FIRK THEN DEC CMDNO
        END
ALTMOD: OFF.ALT; CLOBUF; CLIBUF; MSG('$$<ESC>$'); DEC CMDNO
ALTSHT: CRLF; RUNFLG_0; OFILE_IFILE_TEL; NEWCMD(TEL)
        CLOSE.ALL; GO ESCAPE

!**************************** PROCEDURES ******************************!

! PROCEDURES
!

! PROCEDURE: OUTIMG
! IF GOING TO TERMINAL DO IONEOU(ARG1) ELSE DO WRTPTP(ARG1)
!
%OUTIMG(ARG1)

        IF USEFLG=FALSE THEN IONEOU(ARG1) ELSE WRTPTP(ARG1)

        RETURN

END OUTIMG

! PROCEDURE: NEWCMD
! TAKES ARGUMENT 1 AS A NEW COMMAND FILE NUMBER. STACKS UP OLD
! COMMAND FILE AND SETS LASLIN=0
! IF ARGUMENT IS 'TEL' THEN RESETS AND CLOSES ALL STACKED-UP
! COMMAND-FILES
!
%NEWCMD(ARG1)

        IF ARG1=TEL THEN DO
          CLOSE(TELFIL<==TEL)
          FOR ARG1_0 TO CURCMD BY 1 CLOSE(CMDFLS(ARG1))
          LASLIN_CURCMD_0
          RETURN
        END ELSE DO
          IF INC CURCMD>NO.CMDF THEN DO
          DEC CURCMD ! FOR SAKE OF A GOOD ERROR MESSAGE BEFORE GIVING UP
          ERR('SYSTEM ERROR: ATTEMPT TO OPEN TOO MANY COMMAND FILES$')
          MSG('THE MAX # OF ALLOWABLE COMMAND FILES IS CURRENTLY ')
          OUTNUM(NO.CMDF,CIORDX)
          GO ALTSHT     !!!GIVE UP THE SHIT!!!
          END
          LINFLG(CURCMD)_LASLIN<==0; CMDFLS(CURCMD)_TELFIL<==ARG1
          RETURN
          END

END NEWCMD

! PROCEDURE: OLDCMD
! CLOSES CURRENT COMMANDS-FROM FILE AND UNSTACKS DOWN TO NEXT
! STACKED UP COMMAND FILE.  IF NON STACKED UP, USES 'TEL'
!
%OLDCMD

        IF CURCMD=0 THEN [TELFIL_TEL; LASLIN_0; RETURN]
        LASLIN_LINFLG(CURCMD); CLOSE(TELFIL<==CMDFLS(CURCMD<==CURCMD-1))
        RETURN

END OLDCMD


! PROCEDURE: CTOKEN
! ONE ARGUMENT: STRING TO BE SCANNED
! USES RESERVED WORD TABLE "CWORDS" IN RESERVED WORD CHECK
!
%CTOKEN(@ARG1,ARG2(),ARG3)

        RETURN GETOKEN(@ARG1,CWORDS,C.SIZE,TRUE,ARG2,ARG3)

END CTOKEN
! PROCEDURE: STOKEN
! ONE ARGUMENT: STRING TO BE SCANNED
! USES RESERVED WORD TABLE "SWORDS" IN RESERVED WORD CHECK
!
%STOKEN(@ARG1,ARG2(),ARG3)

        RETURN GETOKEN(@ARG1,SWORDS,S.SIZE,FALSE,ARG2,ARG3)

END STOKEN

! PROCEDURE: GETOKEN
! FOUR ARGUMENTS: 1:BYTE POINTER, 2:RESERVED WORD TABLE, 3:LENGTH OF 2
! 4: TRUE IF LOWER TO UPPER, FALSE IF LOWER OK
! 5: ENTRY ARRAY FOR ARGUMENT(2), 6: SET UP AS FOLLOWS:
!    001 = NUMBER REQUIRED
!    010 = STRING REQUIRED
!    100 = RESERVED WORD REQUIRED
!
! SCANS ARGUMENT TO CALL AND SET UP AS FOLLOWS:
!
! RETURNS THE TYPE OF TOKEN RETURNED AS THE VALUE RETURNED
! TERMCH = CHARACTER TERMINATING THE TOKEN
! TOKBUF = THE TOKEN
!       : TOKEN= NUMBER IF TOKEN RETURNED IS NUMBER
!       : TOKEN= RESERVED WORD NUMBER IF RESERVED WORD
!       : TOKBUF = STRING RETURNED IF STRING TOKEN
!
%GETOKEN(@ARG,ARG2(),ARG3,ARG4,ARG5(),ARG6)

LOCAL PTR,CNTR,FOUND,PLACE,OPNERR:

        LOOP DO         !LOOP (SEE OPNERR:)
        WHILE TYPE_NXCHR(@ARG,ARG4)=DELIMT AND (CHAR=$  OR CHAR=LNFEED&
        OR CHAR BAND OCT 177=OCT 177) THEN NULL

! IF ? THEN TYPE VALID ARGUMENTS AND RETURN EMPTY
        EIF TYPE=DELIMT AND CHAR=$? AND ARG4=TRUE THEN DO
          MSG('$VALID ARGUMENTS ARE:$')
          IF ARG5#0 THEN DO
          FOR CNTR_0 TO ARG3 BY 1 &
          IF CHECK.ARRAY(CNTR,ARG5)=TRUE THEN [MSG(ARG2(CNTR));CRLF]
        END

          IF ARG6 BAND NUMIN = NUMIN THEN MSG('$NUMERIC INPUT')
          IF ARG6 BAND STRIN = STRIN THEN MSG('$QUOTED STRING')
!         IF ARG6 BAND RESIN = RESIN THEN MSG('$COMMAND WORD')
          CRLF; RETURN EMPTY
          END


!LOOP TO DECIPHER QUOTED STRING
        ORIF TYPE=DELIMT AND ($'=CHAR OR $"=CHAR) THEN DO
           PTR_POINTX(TOKBUF); CNTR_CHAR !SAVE END CHAR
           IF NCHAR(ARG)=CNTR THEN DO ! NULL STRING
            ERR('NULL STRING IS ILLEGAL$'); RETURN FIRK
            END
             LOOP DO
              EIF TYPE_NCHR(@ARG)=DELIMT AND CHAR=CARRET THEN DO

                ERR('IMPROPER TERMINATION: '); PUT(CNTR)
                NCHV PTR_EOLIT; MSG(@TOKEN); CRLF; RETURN FIRK
                END
              FIF  CHAR#CNTR AND CHAR#LNFEED THEN NCHV PTR_CHAR
              WHILE CHAR#CNTR
              END
           TYPE_NCHR(@ARG); TERMCH_CHAR; NCHV PTR_EOLIT
           IF TYPE#DELIMT THEN DO               !LITERAL ENDS WITH DELIMT
            ERR('STRING ERROR:$')
            PUT(CNTR); MSG(@TOKEN); PUT(CNTR); PUT(CHAR)
            MSG('$STRING ARGUMENT CANNOT END WITH "'); PUT(CHAR)
            MSG('"$'); RETURN FIRK
            END
           RETURN STRING
           END

!LOOP TO DECIPHER NUMERIC VALUE
        ORIF TYPE=NUMBER THEN DO
           PTR_POINTX(TOKBUF); NCHV PTR_CHAR
             WHILE TYPE_NCHR(@ARG)=NUMBER THEN NCHV PTR_CHAR
             NCHV PTR_EOLIT; PTR_POINTX(TOKBUF)
             TERMCH_CHAR
             EIF CHAR=$O OR CHAR=$B THEN TOKEN_SINC(@PTR,8)
             ORIF CHAR=$D THEN TOKEN_SINC(@PTR,10)
             ORIF TYPE=DELIMT THEN TOKEN_SINC(@PTR,CIORDX)
             ELSE DO
                ERR('INVALID CHARACTER "'); PUT(CHAR); MSG('" IN NUMBER:')
                MSG(@TOKEN); CRLF; RETURN FIRK
                END

! IF VALUE RETURNED IS NEG. NO THEN ITS THE ILLEGAL CHARACTER
! CAUGHT BY THE CONVERSION ROUTINE ..
          IF TOKEN<0 THEN DO
            MSG('$ILLEGAL CHARACTER "'); PUT(-TOKEN)
            MSG('" FOR INPUT RADIX$'); RETURN FIRK
            END

           IF TERMCH=$O OR TERMCH=$B OR TERMCH=$D OR TYPE#DELIMT THEN [TYPE_NCHR(@ARG);TERMCH_CHAR]
           IF TOKEN>MAX.CHR THEN DO
                ERR('NUMBER MUST BE LESS THAN '); OUTNUM(MAX.CHR,8)
                MSG(' - MAXIMUM VALUE ASSUMED: '); OUTNUM(TOKEN,8)
                CRLF; TOKEN_MAX.CHR; RETURN NUMBER
                END
           RETURN NUMBER
           END

!LOOP TO DECIPHER RESERVED WORD
        ORIF TYPE=STRING THEN DO
          FOR PTR_0 TO 20 MTOKS(PTR)_-1
          PTR_POINTX(TOKBUF); NCHV PTR_CHAR
            WHILE TYPE_NXCHR(@ARG,ARG4)=STRING OR TYPE=NUMBER THEN NCHV PTR_CHAR
          TERMCH_CHAR; NCHV PTR_EOLIT; CNTR_ARG3+1; FOUND_0

            WHILE DEC CNTR>=0 THEN DO
              EIF CHECK.ARRAY(CNTR,ARG5)=FALSE THEN NULL
              ORIF STRCOMP(POINTX(TOKBUF),POINT(ARG2(CNTR)))=TRUE&
              THEN [TOKEN_CNTR;RETURN RESWRD]
              FIF INDEX(POINTX(TOKBUF),POINT(ARG2(CNTR)))=TRUE&
              THEN [MTOKS(INC FOUND)_PLACE_CNTR]
            END

            EIF FOUND=0 THEN DO
                ERR('"'); MSG(@TOKEN); MSG('" NOT RECOGNIZED$')
                RETURN FIRK
                END
            ORIF FOUND=1 THEN [TOKEN_PLACE;RETURN RESWRD]
            ELSE DO
                ERR('"'); MSG(@TOKEN)
                MSG('" AMBIGUOUS$CANNOT DISTINGUISH AMONG: '); FOUND_0
                WHILE MTOKS(INC FOUND)#-1 THEN [MSG(ARG2(MTOKS(FOUND)));PUT($ )]
                CRLF; RETURN FIRK
                END
          END

! LOOP TO DECIPHER COMMANDS-FROM FILE
        ORIF TYPE=DELIMT AND CHAR=$@ THEN DO    !COMMAND-FILE
          CSTRING(ARG,POINTX(TOKBUF))          !COPY STRING TO WORD LIM
          NEWCMD(OPEN(@TOKEN,SEQUEN+INPUT+CHARACTER,OPNERR,1))
          ARG_NXLIN
          END

! UNKNOWN ENTITY - RETURN AS IS
        ELSE [TOKEN_TERMCH_CHAR;RETURN TYPE]

        END             !OF LOOP DO FOR THOSE WHO FALL THROUGH

! IOCS ERROR LABEL
OPNERR: ERR('$CANNOT OPEN '); OUTSTR(POINTX(TOKBUF))
        MSG(' - FILE NOT AVAILABLE$')
          NEWCMD(TEL); GO ESCAPE        !RESTART


END GETOKEN

! PROCEDURE: CHECK.ARRAY
! GIVEN ARG1=INDEX INTO TABLE ARG2 WILL RETURN 'TRUE'
! IF INDEX IS VALID ELSE WILL RETURN FALSE
! WILL ALWAYS RETURN TRUE IF 'ARG2'=0
!
%CHECK.ARRAY(ARG1,ARG2())

LOCAL I

        IF ARG2=0 THEN RETURN TRUE
        I_-1
        WHILE ARG2(INC I)#-1 THEN DO
           IF ARG2(I)=ARG1 THEN RETURN TRUE
           END
        RETURN FALSE

END CHECK.ARRAY

! PROCEDURE: COPYST
! COPY STRING ARG1 TO STRING ARG2 CHANGING ARG2
! ALSO DOESNT WRITE E.O.LIT CHARACTER AT END OF COPY
!
%COPYST(ARG1,@ARG2)

        WHILE E.O.LIT#CHAR_NCHV ARG1 THEN NCHV ARG2_CHAR
        RETURN

END COPYST

! PROCEDURE: CSTRING
! WILL COPY FIRST ARGUMENT TO SECOND ARGUMENT
! ALSO, REMOVES ALL CR'S AND LF'S (MAINLY FOR FILE OPEN/CLOSE)
!
%CSTRING(ARG1,ARG2)

LOCAL I

        LOOP DO
          IF I_NCHV ARG1#E.O.LIT AND I#LN.FEED THEN NCHV ARG2_I
          WHILE I#E.O.LIT
          END
        REPEAT 4  NCHV ARG2_EOLIT
        RETURN

END CSTRING

! PROCEDURE: STRCOMP
! COMPARES TWO STRING.  RETURNS "TRUE" IF MATCH OR "FALSE" IF
! NOT MATCH:  ARGUMENTS ARE POINTERS TO TWO STRING.
%STRCOMP(ARG1,ARG2)

LOCAL A,B

        WHILE A_NCHV(ARG1)=B_NCHV(ARG2)#EOLIT THEN NULL
        RETURN [A=B]

END STRCOMP

! PROCEDURE: INDEX
! COMPARES TWO STRINGS. RETURNS "TRUE" IF FIRST STRING IS A SUBSET
! OF THE SECOND STRING
%INDEX(ARG1,ARG2)

LOCAL A,B

        LOOP DO
           EIF A_NCHV(ARG1)=EOLIT OR CARRET=A THEN RETURN TRUE
           FIF B_NCHV(ARG2)=EOLIT THEN RETURN FALSE
           WHILE A=B
        END
        RETURN FALSE

END INDEX

! PROCEDURE: CKEOL
! ARGUMENT: BYTE STRING (TERMCH MUST = LAST TERMINATOR)
! IF THERE IS MORE ON INPUT LINE, RETURN FALSE AND PRINT
! MESSAGE ELSE RETURN TRUE IF END OF LINE
!
%CKEOL(ARG1)

LOCAL I1

        IF TERMCH=CAR.RET THEN RETURN TRUE
        IF I1_CBHELP(ARG1)=TRUE THEN DO
          MSG('$THE INPUT IS COMPLETE: NO FURTHER ARGUMENTS AVAILABLE$')
          RETURN FALSE
          END
        IF I1=EMPTY THEN RETURN FALSE
        ERR('"')
        WHILE CHAR_NCHV ARG1#E.O.LIT AND CHAR#CAR.RET THEN PUT(CHAR)
        PUT($"); PUT($?); CRLF
        RETURN FALSE

END CKEOL

! PROCEDURE: GPRM
! IN IOCS SET.PRMPT CALL GIVES PROMPT
!
%GPRM

LOCAL I,PBUFFR(0:2)

        I_POINTX(PBUFFR); NCHV I_$$; INSC(CMDNO,@I,10)
        CHV I_$:; NCHV I_$ ; NCHV I_E.O.LIT; NCHV I_E.O.LIT
        PRM(@PBUFFR(0))
        RETURN

END GPRM

! PROCEDURE: NULP
! RETURNS ALWAYS
!
%NULP

        RETURN

END NULP

! PROCEDURE: CBHELP
! GIVEN A STRING POINTER, WILL RETURN 
!  TRUE  IF THE NEXT (AND ONLY) ITEM ON THE LINE IS ? OR HELP
!  FALSE OTHERWISE
!  EMPTY IF NOT AND IN ADDITION AN ERROR MESSAGE WAS PRINTED
!
%CBHELP(ARG1)

! REMOVE THE LEADING SPACES (IF ANY)
        LOOP DO
          IF CHV ARG1 = $  THEN NCHV ARG1
          WHILE CHV ARG1 = $ 
          END
        IF CHV ARG1 = $? AND NCHV ARG1 = CARRET THEN RETURN TRUE
          PCHV ARG1; PCHV ARG1 ! BACK UP 2 CHARACTERS FOR GETOKEN
          IF TYPE_CTOKEN(@ARG1,HLPR,RESIN)=RESWRD AND&
          TOKEN=39 AND TERMCH=CAR.RET THEN RETURN TRUE&
          ELSE IF TYPE=FIRK OR TYPE=EMPTY THEN RETURN EMPTY
          RETURN FALSE

END CBHELP

! PROCEDURE: HELPER
! OPENS (SYS)TAPE.HLP AND TYPES HELP MESSAGE
! ARGUMENT IS BYTE POINTER OF STRING IN HELP TEXT
!
%HELPER(ARG1)

LOCAL TMP1,TMP2,TMP3,HLPERR:,HLPEF1:,HLPEF2:

        TMP1_OPEN("(SYS)TAPE.HLP",SEQUEN+INPUT+CHARACTER,HLPERR,2)
        TMP2_ARG1               !SAVE ARGUMENT
        SETRWE(TMP1,HLPEF1)
        LOOP DO
        WHILE TMP3_R(TMP1)#LN.FEED THEN NULL
        IF TMP3_R(TMP1)=$* THEN DO
          WHILE NCHV TMP2=TMP3_R(TMP1) THEN NULL
          IF TMP3=$* THEN DO
            SETRWE(TMP1,HLPEF2)
            R(TMP1 !RID OF CR!); R(TMP1 !RID OF LF!)
            LOOP DO
            PUTX(TMP3_R(TMP1))
            IF TMP3=LN.FEED  THEN IF TMP3_R(TMP1)=$* THEN [GO HLPEF2]&
            ELSE PUTX(TMP3)
            END
            END
          TMP2_ARG1
          END
          END


HLPEF1: ERR('SYSTEM ERROR: REQUIRED HELP MESSAGE NOT IN SYS:TAPE.HLP$')
        RETURN

HLPEF2: CLOSE(TMP1<==TEL)
        RETURN

HLPERR: ERR('CANNOT OPEN SYS:TAPE.HLP - SYSTEM ERROR, CANNOT COMPLETE COMMAND$')
        RETURN

END HELPER
! PROCEDURE: FIRKIT
! ARGUMENT= TYPE THAT IS WRONG
! WILL TYPE OUT MESSAGE SAYING TO THE EFFECT WHAT IS WRONG
! AND WILL RETURN
!
%FIRKIT(ARG1)

        EIF NOT 1<=ARG1<=4 THEN RETURN
        FIF TYPE=DELIMT AND TERMCH=CARRET THEN RETURN
        DO ARG1 OF 1:4
1:      ERR('STRING ARGUMENT ILLEGAL HERE$'); RETURN
2:      ERR('NUMERIC ARGUMENT ILLEGAL HERE$'); RETURN
3:      ERR('"'); MSG(CWORDS(TOKEN)); MSG('" NOT LEGAL HERE$')
        RETURN
4:      ERR('"'); PUT(TERMCH); MSG('" ('); OUTNUM(TERMCH,8)
        MSG(') IS AN UNRECOGNIZABLE DELIMETER OR TERMINATOR$')
        RETURN

        END

END FIRKIT

! PROCEDURE: DOCMD
! EXECUTES A COMMAND WHOSE COMMAND NUMBER IS THE ARGUMENT
!
%DOCMD(ARG1)


        TERMCH_CARRET
        LOOP DO
          TERMCH_CARRET
          WHILE TYPE_GOCMD(ARG1)=FIRK
        END

        RETURN

END DOCMD

! PROCEDURE: FIGURE
! TAKES A CHARACTER ARGUMENT AND DOES CORRESPONDING CARRIAGE CONTROL
!
! CHARACARE:
!       :  -  RETURN (DO NOTHING)
!       ;  -  DO A TAB
!       ,  -  TYPE RETURN
!
%FIGURE(ARG1)

        EIF ARG1=$; THEN PUT(9)         !TYPE TAB
        FIF ARG1=$, OR ARG1=CARRET THEN CRLF
        RETURN

END FIGURE

! PROCEDURE: TYPCHR
! GIVEN CHARACTER VALUE, PRINTS NAME OF CHARACTER AND IT'S
! CLOSES APPEARANCE
!
%TYPCHR(ARG1)

        EIF ARG1>S.SIZE THEN [OUTNUM(ARG1,CIORDX);RETURN]
        ORIF ARG1<0 THEN [MSG('(NOTHING)');RETURN]
        ELSE [MSG(SWORDS(ARG1));MSG(' (');OUTNUM(ARG1,CIORDX);PUT($));RETURN]

END TYPCHR


! PROCEDURE: NUMOUT
! PRINT THE NUMBER ARGUMENT OUT IN RADIX ARGUMENT TWO
!
%NUMOUT(ARG1,ARG2)

LOCAL STPT(0:MAX.DIG),STR1

        STR1_POINTX(STPT); INSC(ARG1,@STR1,ARG2)
        MSG(@STPT(0))
        RETURN

END NUMOUT

! PROCEDURE: OUTNUM
! ARG1=NUMBER ARG2=RADIX, TYPE NUMBER OUT
! IN ADDITION, TYPE B OR D IF NOT IN CURRENT RADIX
!
%OUTNUM(ARG1,ARG2)

        NUMOUT(ARG1,ARG2)
        IF ARG2#CIORDX THEN DO  !IF NOT CURRENT RADIX, D OR B SUF.
          IF ARG2=10 THEN PUT($D)       !TYPE 'D' IF IN DECIMAL MODE
          IF ARG2=8 THEN PUT($B)        !TYPE 'B' IF IN BINARY MODE
          END
        RETURN

END OUTNUM

! PROCEDURE: INIT
! INITIALIZE ALL VARIABLES
!
%INIT

LOCAL I,A1,A2,A3,A4


! SET UP TEMP FILES

        A1_POINTX(PARNAM); A2_POINTX(TAPNAM); A4_POINTX(SCRNAM)
        NCHV A1_$A; NCHV A2_$B; NCHV A4_$C
        I_EXU(OCT 47,OCT 1,OCT 30)      !GET JOB NO.!
        FOR A3_1 TO 0 BY -1 NCHV A1_NCHV A2_NCHV A4_((I SHR (A3*3)) BAND OCT 7)+$0
        CSTRING(CHPT("TAP.TMP",-1),A1); CSTRING(CHPT("TAP.TMP",-1),A2)
        CSTRING(CHPT("TAP.TMP",-1),A4)

        JOBREN_ESCAPE           !SET UP REENTER ADDRESS
        SUBPTR_POINTX(SUBUFF)   !INIT SUBSTITUTE STRING STORAGE

        ALTLOC_ALTMOD           !SET UP ESCAPE TRAPPING
        NEWCMD(TEL)                     !INIT COMMAND-FILE LOGIC
        IFILE_OFILE_TEL                 !INITIAL FILE NO.S IS 'TEL'
        FCORE_JOBFF              !ALLOCATE BUFFER SPACE

        FOR I_0 TO MAX.CHR ISUBTAB(I)_ESUBTAB(I)_IRECTAB(I)_ERECTAB(I)_0
        RECPTR_FALSE

        PARITY_7                !NO PARITY CURRENTLY ENABLED
        CIORDX_IORDX            !SET UP DEFAULT RADIX
        LENGTH_LNGTH            !LENGTH OF LEADER/TRAILER IN INCHES
        USEFLG_RPTYPE_ECHO_LASLIN_RUNFLG_SLEEPY_ECHAR_ELINE_TITLE_FALSE

        RETURN
END INIT

! PROCEDURE: OK
! TYPES 'OK' IF SLEEPY=0
%OK

        IF SLEEPY=FALSE AND RUNFLG=FALSE THEN PRM('OK$')
        RETURN

END OK

! PROCEDURE: NCHAR
! DOES AN NCHV WITHOUT RUINING PTR
!
%NCHAR(ARG1)

        RETURN NCHV ARG1

END NCHAR

! PROCEDURE: NXLIN
! READS NEXT LINE AND RETURN POINTER TO IT
!
%NXLIN

LOCAL NXERR:

        LOOP DO

        SETRWE(TELFIL,NXERR); INC LASLIN
        RETURN LASINP_STRIP(GETLINE(TELFIL))

NXERR:  OLDCMD
        IF TELFIL=TEL THEN [MSG('$COMMAND FILE EOF:$'); MSG(LASPRM)]
        END

END NXLIN

! PROCEDURE: SEARCH
! ARGUMENT IS FILE NUMBER, WILL READ CHARACTERS FROM TTY AND TRY AND
! MATCH THEM UP IN THE OUTPUT FILE. WILL THEN DO A SCP SO NEW
! INFORMATION WILL BE APPENDED AND RETURN
! TRUE = OK TO PROCEED
! FALSE = YOU BLEW IT
!
%SEARCH(ARG1)

LOCAL SRBUFF(0:SR.SIZE+1),SR.CNT,SR.PNT,S.ER1:,S.ER2:,S.ER3:

        TORTBD_FALSE
        SETTY(ESCAPE)                        ! SET UP 8-LEVEL TTY
        MSG('$READ IN ABOUT 10 INCHES OF TAPE$')
        IONEOU(OCT 21 !XON!)
        SR.CNT_0; SR.PNT_POINTX(SRBUFF)
        WHILE INC SR.CNT<SR.SIZE THEN DO
          NCHV SR.PNT_SERRD(S.ER1) BAND OCT 177
          IF ((SR.SIZE/2)-1)<SR.CNT<((SR.SIZE/2)+1) THEN IONEOU(OCT 23)
          END
        IONEOU(OCT 23 !XOFF!)
        LOOP SERRD(S.ER2)

! HERE WHEN BUFF GOT SOME CHARACTERS
S.ER1:  IONEOU(OCT 23 !XOFF!); NCHV SR.PNT _ E.O.LIT
        IF SR.CNT<10 THEN DO
          MSG('$YOU DIDNT READ IN ENOUGH OF THE TAPE!$')
          ENDR
          END ELSE DO
          SR.PNT_CHPT(@SRBUFF(0),0)
          SETCP(ARG1,1 MAX (SIZE(ARG1)-(SR.CNT*10)))

        SETRWE(ARG1,S.ER3)

          LOOP DO

          IF R(ARG1)=CHV SR.PNT THEN DO
          SR.CNT_CP(ARG1)
          WHILE R(ARG1)=NCHV SR.PNT AND CHV SR.PNT#E.O.LIT THEN NULL
          IF CHV SR.PNT=E.O.LIT THEN DO
            MSG('$FOUND MATCH$')
            ERASE(ARG1,CP(ARG1)-1,SIZE(ARG1)+1)
            RETURN TRUE
            END
          SETCP(ARG1,SR.CNT); SR.PNT_CHPT(@SRBUFF(0),0)
          END
          END
          END

! IOCS ERR LABELS
S.ER2:  ERR('$YOU READ IN MORE THAN 20 INCHES OF TAPE!$')
        ENDR

S.ER3:  ERR('$NO MATCH FOUND$'); ENDR

END SEARCH
! PROCEDURE: STRIP
! ARGUMENT IS BYTE POINTER TERMINATED BY E.O.LIT
! WILL REMOVE TRAILING BLANKS
!
%STRIP(ARG1)

LOCAL ARG2

        ARG2_ARG1

        WHILE NCHV ARG1#E.O.LIT THEN NULL
        IF PCHV ARG1#CARRET THEN RETURN ARG2
        WHILE PCHV ARG1=$  THEN NULL
        NCHV ARG1_CAR.RET; NCHV ARG1_E.O.LIT
        RETURN ARG2

END STRIP

! PROCEDURE: ERR
! WILL TYPE OUT LAST LINE AND LINE NO. IF NOT FROM TEL
!
%ERR(ARG1)

        IF TELFIL#TEL AND TELFIL#-1 THEN DO

        MSG("$COMMAND FILE TERMINATED AT FOLLOWING POINT$")
        MSG('$IN LINE '); OUTNUM(LASLIN,CIORDX)
        MSG(' COMMANDS-FILE # '); OUTNUM(CURCMD,CIORDX)
        END
        IF TELFIL#TEL THEN DO
        CRLF; OUTSTR(LASINP)
        CRLF; MSG(ARG1)
        IF TELFIL#-1 THEN NEWCMD(TEL)
        END ELSE MSG(ARG1)
        RETURN

END ERR

! PROCEDURE: HELP
! ARGUMENT IS A HELP NUMBER AND IT WILL TYPE THE HELP 
! MESSAGE ASSOCIATED WITH THE NUMBER
!
%HELP(ARG1)

        MOUTSTR(HELPM(ARG1)); RETURN

END HELP

! PROCEDURE: PRM
! IF TELFIL=TEL (NOT COMMAND-FILE) THEN PRINT PROMPT
!
%PRM(ARG1)

        LASPRM_ARG1                     !SAVE LAST PROMPT LOCATION
        IF TELFIL=TEL AND SLEEPY=FALSE THEN MSG(ARG1)
        RETURN

END PRM

! PROCEDURE: OUTSTR
! GIVEN BYTE POINTER, OUTPUT UNTIL AN EOLIT
!
%OUTSTR(ARG1)

        WHILE CHAR_NCHV ARG1 # E.O.LIT AND CHAR # CARRET THEN PUT(CHAR)
        RETURN

END OUTSTR

! PROCEDURE: WSTR
! WRITE STRING ARG1 ON FILE ARG2
!
%WSTR(X,Y)

        WHILE CHAR_NCHV X # E.O.LIT THEN W(Y,CHAR)

        RETURN
END WSTR

! PROCEDURE: NXCHR
! SAME AS 'NCHR' BUT IF ARGUMENT 2 = TRUE THEN
! CONVERTS UPPER TO LOWER CASE
!
%NXCHR(@ARG1,ARG2)

LOCAL I

        TYPE_NCHR(@ARG1)
        IF $A+OCT 40<=CHAR<=$Z+OCT 40 AND ARG2=TRUE THEN CHAR_CHAR-OCT 40
        RETURN TYPE

END NXCHR

! PROCEDURE: NCHR
! SCANS ARGUMENT AND RETURNS AS VALUE CHARACTER TYPE
! SETS CHAR_CHARACTER VALUE
!
%NCHR(@ARG)

        EIF CHAR_NCHV ARG=EOLIT THEN RETURN EMPTY
        ORIF $A<=CHAR<=$Z THEN RETURN STRING
        ORIF $0<=CHAR<=$9 THEN RETURN NUMBER
        ORIF $A+OCT 40<=CHAR<=$Z+OCT 40 THEN RETURN STRING
        ORIF $A-OCT 100<=CHAR<=$Z-OCT 100 THEN RETURN DELIMT
        ELSE RETURN DELIMT

END NCHR

! PROCEDURE: SINC
! STRING TO INTERNAL CONVERSION
! TWO ARGUMENTS: POINTER TO STRING AND RADIX
!
%SINC(@ARG1,ARG2)

LOCAL VAL

        VAL_0
        LOOP DO
          IF CHAR_NCHV ARG1=EOLIT THEN RETURN VAL       !SPEC.CHECK FOR EOLIT
          IF NOT $0<=CHAR<=ARG2+$0 THEN RETURN -CHAR
          VAL_VAL*ARG2+(CHAR-$0)
          WHILE NOT (CHAR=EOLIT OR CHAR=$  OR CHAR=$, OR CHAR=CAR.RET)
          END
        RETURN VAL

END SINC

! PROCEDURE: INSC
! INTERNAL TO STRING CONVERSION
! THREE ARGUMENTS: 1:NUMBER, 2:STRING TO APPEND, 3:RADIX
!
%INSC(ARG1,@ARG2,ARG3)

LOCAL T(MAX.DIG),K,L

        K_ARG1
        LOOP DO
          FOR L_MAX.DIG BY -1
          [K;T(L)]_K DIVMOD ARG3
          WHILE K>0
          END

        FOR L_L TO MAX.DIG NCHV ARG2_T(L)+$0
        NCHV ARG2_EOLIT
        RETURN

END INSC


! PROCEDURE: READ
! ARGUMENT 1:INPUT FILE [NOT CURRENTLY USED], 2:OUTPUT FILE
!
! PARAMETERS FOR READ ARE THE SAME AS THOSE FOR PUNCHING EXCEPT THAT
! THEY ARE REVERSED.
!
! READ WILL CHECK FOR PARITY IF ENABLED AND WILL WRITE PARITY ERRORS
! OUT ONTO FILE DSK:PARITY.TMP
!
! **** CAUTION ****
! THIS ROUTINE AND ALL ASSOCIATED WITH IT DEPEND HIGHLY
! ON THE FACT THE THE OUTPUT FILE NUMBER IS STORED INTO
! THE CELL 'OFILE'
! IF IT IS NOT, YOUDE BETTER LOOK AT ALL THE SUBROUTINES!!!
!
! SOMEONE COULD WIN MERIT BY REPLACING ALL OF THE REFERENCES AND
! CALLS WHICH USE OFILE TO USE "@SOMETHING" SO AS TO TRANSFER THE
! FILE NUMBER VARIABLY
!
! RETURNS SIZE OF FILE READ IN
!
%READ(ARG1,ARG2)

LOCAL ERD:,ERRD:,TMP1,NULER:,LSI

! SET TYPE OF READ TO BE DONE
        TORTBD_TRUE

!NOW THINGS ARE SET UP -- LET'S GO
        IFILE_OPEN(@PARNAM(0),DIRECT+CHARACTER+OUTPUT,0,2)
        WSTR(POINT('PARITY ERRORS WHILE READING FILE '),IFILE)
        WSTR(POINTX(OFILS),IFILE)
        REPEAT 2 W(IFILE,CARRET)

        IF SYMBN=2 AND RPTYPE#FALSE THEN&
        [MSG('BINARY READ CANNOT HAVE LITERAL REPRESENTATION$');&
        RETURN FIRK]

        SUBINI                  ! INIT SUBSTITUTE JUNK
        MAKTMP(0)                       ! MAKE TEMPORARY FILE
        SETTY(ESCAPE)                        ! SET UP 8-LEVEL TTY
        IF USEFLG=FALSE THEN MSG('$TURN ON READER$')
        IONEOU(OCT 21 !XON!)

!CALL SETSCR -- READS TTY W/O HI SEG THEN SETS FOR FILE INPUT
        TMP1_POINTX(SCRNAM)
        SETFID(MYFID,@TMP1,POINTX(SCRNAM),0,ERRD)
        DELETE(@SCRNAM(0),NULER)      !MAKE SURE FILE MISSING
NULER:  SETSCR(ERRD)

        EIF SYMBN=1 THEN LOOP [SUBWT(CHAR_SUBRD(ERD) BAND OCT 177,OFILE)]

        ELSE LOOP DO

        CHAR_RDFIL(ERD)         ! READ A CHARACTER

        DO PARITY OF OFF:PACKD

ODD:    IF CHAR BAND OCT 200 # MAKPAR(CHAR,1) THEN PARERR(CHAR)
        CHAR BAND_ OCT 177
EVEN:   IF CHAR BAND OCT 200 # MAKPAR(CHAR,0) THEN PARERR(CHAR)
        CHAR BAND_ OCT 177
OFF:    CHAR BAND_ OCT 177

        END

        SUBWT(CHAR,OFILE)        ! WRITE OUT

        END

! END OF READING FILE
! LABEL DUE TO END-OF-FILE BRANCH
ERD:    SUBCLN(0,OFILE)
        CRLF; OUTNUM(LSI_SIZE(OFILE),CIORDX)
        MSG(IF SYMBN=2 THEN ' WORDS ON FILE$' ELSE ' CHARACTERS ON FILE$')
        CLOSE(OFILE<==TEL)
        CLOSE(IFILE<==TEL)
        IF PARTY#0 THEN DO

          MSG('$THERE WERE '); OUTNUM(PARTY,CIORDX)
          MSG(' PARITY ERROR(S) WHILE READING YOUR TAPE')
          MSG('$PLEASE READ THE FILE ')
          MSG(@PARNAM(0)); MSG(' FOR DETAILS$')
        END ELSE DELETE(@PARNAM(0))
        DELETE(@TAPNAM(0))
        DELETE(@SCRNAM(0))      !DELETE READ SCRATCH FILE
        RETURN LSI ! RETURNS SIZE OF OUTPUT FILE

ERRD:   ERR('$SYSTEM ERROR: CANNOT OPEN NNNRED.TMP SCRATCH FILE$')
        GO ESCAPE

END READ

! PROCEDURE: OUTTIT
! STRING ARGUMENT, PUNCHES TITLE
!
%OUTTIT(ARG1)

LOCAL VAL1

        WHILE CHAR_NCHV ARG1#E.O.LIT THEN DO
          VAL1_TWORDS(CHAR)
          WHILE CHAR_NCHV VAL1#TCHR THEN OUTIMG(CHAR)
          OUTIMG(0); OUTIMG(0)          !SPACE THE LETTERS
          END

        RETURN

END OUTTIT

! PROCEDURE: CONFMP
! WILL TYPE CONFIRMATION MESSAGE, WAIT FOR C.R., AND SLEEP FOR A WHILST
!
%CONFMP

        EIF SLEEPY=FALSE THEN DO
        MSG('$TYPE CARRIAGE RETURN OR LINE FEED.')
        MSG('$THEN TURN PUNCH ON.$$')
        END
        ELSE [MSG('$$TURN PUNCH ON$$')]
        WHILE NOT (LASFMP_GET=LNFEED OR LASFMP=CARRET) THEN NULL
        CLIBUF
        SLEEP(2)
        RETURN

END CONFMP

! PROCEDURE: LEDTRL
! WILL PRINT (ARG1) INCHES OF BLANKS (NULLS) USING OUTIMG
!
%LEDTRL(ARG1)

        REPEAT ARG1*10 OUTIMG(0)

        RETURN

END LEDTRL

! PROCEDURE: PUNCH
! PUNCHES PAPER TAPE
!
! PARAMETERS FOR PUNCH ARE:
!  IF SYMBN=1 THEN SYMBOLIC PUNCH:
!    READ FROM FILE IS 7-BIT CHARACTER ORIENTED FILE
!    PARITY=DATA:  ALWAYS PUNCH 8TH BIT ON OUTPUT
!    PARITY=EVEN:  PUNCH EVEN PARITY
!    PARITY=ODD:   PUNCH ODD PARITY
!    PARITY=NONE:  PUNCH NO PARITY
!
!  IF SYMBN=2 THEN BINARY PUNCH:
!    PARITY=DATA:  EACH WORD CONTAINS ONE CHARACTER WHICH IS 8-BITS OF
!                  DATA WHICH WILL BE RIGHT-JUSTIFIED (AND OCT 177)
!    PARITY=EVEN:  EACH WORD CONTAINS SIX 6-BIT DATA ITEMS WHICH
!                  WILL BE PUNCHED WITH EVEN PARITY AND 7TH BIT OFF
!    PARITY=ODD:   SAME AS EVEN BUT ODD PARITY PUNCHED
!    PARITY=NONE:  SAME AS EVEN BUT NO PARITY PUNCHED (BITS 7 & 8 OFF)
!
%PUNCH(ARG1,ARG2)

LOCAL EPUN:

        IF PARITY=OFF AND SYMBN=2 THEN DO ! 8-TH LEVEL ON BIN/NO PAR PUN
          ALWP8T_-1
          LOOP DO
          PRM('$ALWAYS PUNCH 8-TH LEVEL? '); STR_NXLIN
          EIF TYPE_CTOKEN(@STR,YESNO,RESIN)#RESWRD THEN NULL
          ORIF TOKEN=12 THEN ALWP8T_FALSE
          ORIF TOKEN=11 THEN ALWP8T_TRUE
          ELSE ERR('$ANSWER YES OR NO:')
          WHILE ALWP8T=-1
          END
          END
        IF SYMBN=2 AND RPTYPE#FALSE THEN&
        [MSG('BINARY PUNCH CANNOT HAVE LITERAL REPRESENTATION$');&
        RETURN FIRK]

        MAKTMP(1)               ! MAKE TEMPORARY FILE
        IF USEFLG=FALSE THEN CONFMP ELSE [OPNPTP(ESCAPE);LASFMP_LNFEED]

! IF LASFMP#CARRET THEN GIVE LEADER SPEIL ELSE DONT
        IF LASFMP#CARRET THEN DO

        LEDTRL(4)
        OUTTIT(POINT(' File=')); OUTTIT(POINTX(IFILS))
        OUTTIT(POINT('  Type='))
        IF SYMBN=1 THEN OUTTIT(POINT('SYM'))&
        ELSE OUTTIT(POINT('BIN'))
        OUTTIT(POINT('  Parity=')); OUTTIT(POINT(CWORDS(PARITY)))

        END

! NOW OUTPUT TIEL (IF THERE) AND GO
        IF TITLE=TRUE THEN [LEDTRL(4);OUTTIT(POINTX(TITBUF))]
        LEDTRL(LENGTH)          !OUTPUT LEADER
        REPEAT 3 OUTIMG(OCT 377)        !OUTPUT THREE 'START-UP' RUBOUTS

! NOW PUNCH FILE

        SUBINI                  !INIT SUBSTITUTION STUFF
        SETRWE(ARG1,EPUN)              !IOCS END OF FILE

        EIF SYMBN=1 THEN LOOP [OUCH(CHAR_LEV7(ARG1) BAND OCT 177)]

        ELSE LOOP DO

        CHAR_LEV8(ARG1)         ! GET CHARACTER

        DO PARITY OF OFF:PACKD

DATA:PACKD: CHAR BAND_OCT 377           !FULL CHARACTER
ODD:    CHAR BOR_(MAKPAR(CHAR,1))
EVEN:   CHAR BOR_(MAKPAR(CHAR,0))
OFF:    CHAR BAND_OCT 177
        IF ALWP8T=TRUE THEN CHAR BOR_OCT 200    !SET SIGN BIT

        END
        OUTIMG(CHAR)
        END

! END OF PUNCHING FILE
! LABEL DUE TO IOCS END OF FILE BRANCH

EPUN:   REPEAT 3 OUTIMG(OCT 377)        !OUTPUT THREE 'CLOSING-UP' RUBOUTS
        LEDTRL(LENGTH)          !OUTOUT TRAILER
        IF USEFLG=FALSE THEN DO
! INCLUDE NEXT LINE FOR C.R. AFTER PUNCHING
!       WHILE CHAR_GET#CARRET THEN NULL
!       CLIBUF
        END ELSE CLSPTP
        CLOSE(IFILE<==TEL)
        CLOSE(OFILE<==TEL)
        DELETE(@TAPNAM(0),0)
        RETURN

END PUNCH

! PROCEDURE: MAKTMP
! MAKES TEMPORARY FILE CONTAINS USEFUL(???) INFORMATION
!
%MAKTMP(ARG1)

LOCAL TMP1

        TMP1_OPEN(@TAPNAM(0),OUTPUT+CHARACTER+SEQUEN,0,2)

! CRASH PROTECTION WRITES OUT '62 TMPFIL,REALFIL'
! WHOCH TELLS THE PROGRAM TO DO A CRASH PROTECTION COPY
        IF ARG1=0 AND SYMBN=1 THEN DO
          WSTR(POINT('62 '),TMP1); WSTR(POINTX(SCRNAM),TMP1)
          WX(TMP1,$,); WSTR(POINTX(OFILS),TMP1); W(TMP1,CARRET)
          END

        WSTR(POINT('EDITING '),TMP1)
        EIF ECHAR+ELINE=0 THEN [WSTR(POINT('NO'),TMP1)]
        ELSE DO
          IF ECHAR#0 THEN [WSTR(POINT(' CHARACTER="'),TMP1);&
          WX(TMP1,ECHAR); W(TMP1,$")]
          IF ELINE#0 THEN [WSTR(POINT(' LINE="'),TMP1);&
          WX(TMP1,ELINE); W(TMP1,$")]
        END
        W(TMP1,CARRET)
         EIF CIORDX=10 THEN WSTR(POINT('RADIX DECIMAL'),TMP1)
         ORIF CIORDX=8 THEN WSTR(POINT('RADIX OCTAL'),TMP1)
         ELSE WSTR(POINT('TYPE ,"ASSUMING CURRENT RADIX",'),TMP1)
         W(TMP1,CARRET)
        IF ECHO=FALSE THEN [WSTR(POINT('ECHO OFF'),TMP1)]
        IF ECHO=TRUE THEN [WSTR(POINT('ECHO ON'),TMP1)]
        W(TMP1,CARRET)
        WSTR(POINT('PARITY '),TMP1); WSTR(POINT(CWORDS(PARITY)),TMP1)
        W(TMP1,CARRET); WSTR(POINT('REPRESENTATION '),TMP1)
        WSTR(POINT(IF RPTYPE=FALSE THEN 'OFF' ELSE CWORDS(RPTYPE)),TMP1)
        W(TMP1,CARRET)
        EIF ARG1=1 THEN &
         WSTR(POINT('TYPE ,"CANNOT RECOVER FROM PUNCH",'),TMP1)
         W(TMP1,CARRET)
        ORIF ARG1=0 AND SYMBN#1 THEN &
         WSTR(POINT('TYPE ,"CANNOT RECOVER FROM BINARY READ",'),TMP1)
        ELSE WSTR(POINT('SSPLICEREAD '),TMP1)
        EIF ARG1=1 OR (ARG1=0 AND SYMBN#1) THEN &
         WSTR(POINT('DO TERMINAL'),TMP1)
        ELSE WSTR(POINTX(OFILS),TMP1)
        W(TMP1,CARRET); CLOSE(TMP1)

        RETURN

END MAKTMP

! PROCEDURE: COPYT
! ARG1 : STRING POINTER (MODIFIED)
! TAKES STRING POINTER IN FORM:  FROM,TO
! AND CONVERST RAW DATA 'FROM' TO 'TO'
!
%COPYT(@ARG1)

        TORTBD_TRUE             !SCRATCH READ

LOCAL A1(0:10),A2(0:10),B1,B2,NCOPYT:,ECOPY1:,F2

        B1_POINTX(A1); B2_POINTX(A2)
        WHILE NCHV ARG1 # $, THEN NCHV B1_CHV ARG1
        NCHV B1 _ E.O.LIT
        WHILE NCHV ARG1 # CAR.RET AND CHV ARG1 # E.O.LIT &
          THEN NCHV B2_CHV ARG1
        NCHV B2 _ E.O.LIT

! NOW OPEN THE FILES
        F2_POINTX(A1)
        SETFID(MYFID,@F2,POINTX(SCRNAM),0,ECOPY1)
        OFILE_OPEN(@A2(0),OUTPUT+CHARACTER+DIRECT,ECOPY1,2)

!NOW INITIATE THE COPY PROCEDURE

        SETUP(NCOPYT)
        SUBINI
        SYMBN_1

! NOW CONVERT THE DATA
        LOOP SUBWT(CHAR_SUBRD(NCOPYT) BAND OCT 177,OFILE)

! E O F
NCOPYT: CLOSE(OFILE<==TEL); RETURN

! ECOPY1 - ERROR WHEN NO FILE OPENED
ECOPY1: ERR('$SPLICE COMMAND ERROR: CANNOT COPY OLD TEXT TO TEMPORARY FILE$')
        GO ALTSHT

END COPYT

! PROCEDURE: MAKPAR
! ARG1 = CHARACTER TO RETURN PARITY BIT ON
! ARG2 = 0 IF EVEN PARITY WANTED ELSE ARG2 = 1 FOR ODD PARITY
! RETURNS THE VALUE OF THE PARITY BIT (1 OR 0) RIGHT-JUSTIFIED
!
%MAKPAR(ARG1,ARG2)

LOCAL PARBIT

        ARG1 BAND_ OCT 177
        IF ARG2=1 THEN [PARBIT_1] ELSE [PARBIT_0]       !INIT PARITY SETTING

        WHILE ARG1#0 THEN [INC PARBIT;ARG1 BAND_(ARG1-1)]

        RETURN ((PARBIT BAND OCT 1) SHL OCT 7) BAND OCT 200

END MAKPAR

! PROCEDURE: SUBPUT
! ARGUMENT IS THE BYTE POINTER TO STORE FROM
! WILL RETURN LOCATION IN SUBSTITUTE STORAGE OF THE
! NEW STRING
!
%SUBPUT(ARG1)

LOCAL STR1

        STR1_SUBPTR             !SAVE CURRENT POINTER
        WHILE NCHV SUBPTR_NCHV ARG1#E.O.LIT THEN NULL
        NCHV SUBPTR_E.O.LIT
        IF SUBPTR BAND OCT 777777 > @SUBUFF(0)+S.BUFF THEN&
        [MSG('$SUBSTITUTE STORAGE EXCEEDED$'); HALT]
        RETURN STR1

END SUBPUT


%SUBPRC

LOCAL SUBPT,SUBFG,SUBD,SUBGF,CNT,IMGSTR,IMGBUF(0:(NO.CHAR/CHARSPERWORD)+1)
LOCAL PEBUF(0:PE.MAX),PECNT,CRAP.CNT,DISLIN,DISCHR,SHCNT,ACHAR,CNTRA,CNTRB,SUBWPT

! PROCEDURE: SUBINI
! INITS SUBSTITUTE OUTPUT ROUTINE "SUBCR" AND "LEV8"
!
%SUBINI

        WINT                    ! INIT WRITE-OUT ROUTINE
        CRAP.CNT_NO.CRAPS               !INITIALIZE CRASH PROTECTION
        SUBGF_6
        SUBD_0
        SUBWPT_BYPT(@SUBD,-1,6)
        DISLIN_DISCHR_SUBFG_PARTY_SUBPT_FALSE       !RESET FLAGS
        RETURN

END SUBINI

! PROCEDURE: WINT
! INITIALIZE WRITE-OUT ROUTINE
!
%WINT

        IMGSTR_POINTX(IMGBUF); CNT_PECNT_0
        NCHV IMGSTR_E.O.LIT
        RETURN

END WINT

! PROCEDURE: SUBWT
! ARGUMENT 1 IS CHARACTER TO BE WRITTEN
! ARGUMENT 2 IF WILE TO BE USED BY 'WX'
! WILL WRITE CHARACTER OUT PROPERLY
!
%SUBWT(ARG1,ARG2)

        INC DISCHR              !DIS IS A CHARACTER

        IF SYMBN=1 THEN DO

          EIF ARG1=0 OR ARG1=OCT 177 OR ARG1=OCT 377 THEN NULL
          ORIF ARG1=ECHAR THEN DO
            IF IMGSTR#POINTX(IMGBUF) THEN &
            [PCHV IMGSTR; DEC CNT] ! DEC ONLY IF NOT AT BEG O BUF
            END
          ORIF ARG1=ELINE THEN WINT
          ELSE [NCHV IMGSTR_ARG1; INC CNT]
  
          IF ARG1=LNFEED OR ARG1=CARRET OR CNT>NO.CHAR THEN NCHV IMGSTR_E.O.LIT&
          ELSE RETURN
        IF ARG1#LNFEED THEN INC DISLIN
        DISCHR_0
          SWSTR(CHPT(@IMGBUF(0),0),OFILE)
          PAROUT(ARG2)
          WINT
          RETURN
        END

        DO PARITY OF OFF:PACKD

DATA:PACKD: WX(OFILE,ARG1 BAND OCT 377); CRASHP
OFF:EVEN:ODD: IF SUBGF=FALSE THEN DO

        WX(OFILE,SUBD); CRASHP
        SUBGF_6; SUBD_0; SUBWPT_BYPT(@SUBD,-1,6)
        END
        DEC SUBGF; RETURN NCHV SUBWPT_ARG1 BAND OCT 77
        END

        RETURN

END SUBWT

! PROCEDURE: SWSTR
! WRITE STRING ARG1 ONTO FILE ARG2
! SAME AS 'WSTR' BUT USES 'SWOUT' INSTEAD OF IOCS 'W'
!
%SWSTR(ARG1,ARG2)

        WHILE CHAR_NCHV ARG1 # E.O.LIT THEN SWOUT(CHAR,OFILE)

        RETURN

END SWSTR

! PROCEDURE: SWOUT
! ARG1: CHARACTER TO WRITE, ARG2: FILE NO. TO WRITE
! IF SYMBOLIC REP. INT OR BOTH WILL WRITE SYMBOLICALLY, ELSE
! WILL JUST WRITE THE CHARACTER OUT USING IOCS 'WX'
!
%SWOUT(ARG1,OFILE)

        IF SYMBN=1 AND (RPTYPE=3 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF); INSC(ARG1,@STR,CIORDX); STR_POINTX(TOKBUF)
          WHILE CHAR_NCHV STR#E.O.LIT THEN [W(OFILE,CHAR);CRASHP]
          W(OFILE,CARRET); CRASHP
          RETURN
        END ELSE DO
          WX(OFILE,ARG1); CRASHP
          RETURN
        END

END SWOUT

! PROCEDURE: SUBCLN
! CLEANS UP AFTER READING IS DONE
! ARGUMENT 2 IS OUTPUT FILE, 1 IS DUMMY
!
%SUBCLN(ARG1,ARG2)

        IF SYMBN=1 THEN DO
          IF CNT=0 THEN RETURN
          NCHV IMGSTR_E.O.LIT
          SWSTR(CHPT(@IMGBUF(0),0),ARG2)
          PAROUT(ARG2)
          RETURN
        END

        IF SYMBN=2 AND PARITY#10 AND SUBGF#6 THEN [WX(ARG2,SUBD);CRASHP]

        RETURN

END SUBCLN

! PROCEDURE: SUBRED
! ARGUMENT 1 IS END-OF-FILE BRANCH LOCATION
! WILL READ ONE CHARACTER VIA 'RDFIL' SUBROUTINE AND WILL
! EVEN DO SUBSTITUTION
! MUST BE PROCEDED INITIALLY BY 'SUBINI' CALL AND 'SETTY' CALL
!
%SUBRED(ERROR:)

        LOOP DO
        IF SUBFG=TRUE AND CHAR_NCHV SUBPT#E.O.LIT THEN RETURN CHAR
        SUBFG_FALSE; CHAR_(IF TORTBD=FALSE THEN RDTTY(ERROR) ELSE RDFIL(ERROR))
        IF SUBPT_ISUBTAB(CHAR BAND OCT 177)=0 THEN DO

          DO PARITY OF OFF:PACKD

DATA:PACKD: IF CHAR BAND OCT 200 = 0 THEN PARERR(CHAR)
ODD:    IF CHAR BAND OCT 200 # MAKPAR(CHAR,1) THEN PARERR(CHAR)
EVEN:   IF CHAR BAND OCT 200 # MAKPAR(CHAR,0) THEN PARERR(CHAR)

        END
          RETURN CHAR BAND OCT 177
          END
        SUBFG_TRUE
        END

END SUBRED

! PROCEDURE: SUBRD
! RETURN CHARACTER VALUE
! HANDLES SYM. REPRESENTATION FROM TERMINAL
! ARG1: EOF BRANCH
!
%SUBRD(ERROR:)

        EIF SYMBN=1 AND (RPTYPE=4 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF)
          WHILE CHAR_(SUBRED(ERROR) BAND OCT 177)#CARRET THEN IF&
          (CHAR#LNFEED AND CHAR#0 AND CHAR#OCT 177) THEN NCHV STR_CHAR
          NCHV STR_CARRET; NCHV STR_E.O.LIT; STR_POINTX(TOKBUF)
          TYPE_STOKEN(@STR,0,0)
         IF TYPE=FIRK THEN DO
            MSG('$ERROR DURING READ IN "'); PRINT(@TOKBUF(0))
            MSG('"$')
            END
          RETURN TOKEN BAND OCT 177
          END
        ELSE RETURN SUBRED(ERROR)

END SUBRD

! PROCEDURE: SERRD
! ARGUMENT IS ERROR LABEL..READS CHARACTER FROM FILE AND
! IGNOREDS NULL AND EOLIT CHARACTERS
!
%SERRD(ERROR:)

        WHILE CHAR_SUBRD(ERROR)=0 OR CHAR=OCT 177 OR CHAR=OCT 377 THEN NULL
        RETURN CHAR

END SERRD

! PROCEDURE: PAROUT
! WRITES BAD PAR INFO OUT
!
%PAROUT(ARG1)

        IF SYMBN=2 THEN RETURN
        IF PECNT=0 THEN RETURN
        WSTR(POINT('IN LINE '),IFILE)
        STR_POINTX(TOKBUF); INSC(DISLIN,@STR,10); STR_POINTX(TOKBUF)
        WHILE ACHAR_NCHV STR#E.O.LIT THEN W(IFILE,ACHAR)
        W(IFILE,CARRET)
        STR_CHPT(@IMGBUF(0),0)
        WHILE ACHAR_NCHV STR # E.O.LIT THEN DO
! WRITE CHAR. OUT   CR GOES OUT AS '(CR)' AND LF GOES OUT AS '(LF)'
          IF ACHAR=CARRET THEN WSTR(POINT('(CR)'),IFILE)
          IF ACHAR=LNFEED THEN WSTR(POINT('(LF)'),IFILE)
          IF LNFEED#ACHAR#CARRET THEN W(IFILE,ACHAR)
          END
        W(IFILE,CARRET)
        FOR CNTRA_1 TO PEBUF(PECNT) BY 1 DO
          ACHAR_0
          FOR CNTRB_1 TO PECNT BY 1 [IF CNTRA=PEBUF(CNTRB)&
          AND PEBUF(CNTRB)#0 THEN ACHAR_1]
          IF ACHAR=0 THEN W(IFILE,$ ) ELSE W(IFILE,$^)
          END
        REPEAT 2 W(IFILE,CARRET)
        RETURN

END PAROUT

! PROCEDURE: PARERR
! WILL WRITE OUT ON TEMP FILE 'PARITY ERROR AT POSITION XXX LINE XXX',
! 'CHARACTER CAUSING BAD PARITY 'X' OCTAL XXX BINARY XXXXXX'
!
%PARERR(ARG1)

        IF NOT (OCT 177#CHAR BAND OCT 177#0) THEN RETURN ELSE INC PARTY

        IF SYMBN=2 THEN DO

          WSTR(POINT('OCT '),IFILE)
          FOR SHCNT_2 TO 0 BY -1&
          W(IFILE,(ARG1 SHR (SHCNT*3) BAND OCT 7)+$0)
          WSTR(POINT(' BINARY '),IFILE)
          FOR SHCNT_7 TO 0 BY -1&
          W(IFILE,(ARG1 SHR SHCNT BAND OCT 1)+$0)
          WSTR(POINT('; TAPE FRAME POS. '),IFILE)
          STR_POINTX(TOKBUF); INSC(DISCHR,@STR,10); STR_POINTX(TOKBUF)
          WHILE ACHAR_NCHV STR#E.O.LIT THEN W(IFILE,ACHAR)
          WSTR(POINT(' DSK WORD '),IFILE)
          STR_POINTX(TOKBUF)
          IF SYMBN=10 THEN INSC(DISCHR,@STR,10) ELSE INSC(DISCHR/6,@STR,10)
          STR_POINTX(TOKBUF)
          WHILE ACHAR_NCHV STR#E.O.LIT THEN W(IFILE,ACHAR)
          W(IFILE,CARRET)
          RETURN
          END

        IF INC PECNT<=PE.MAX THEN PEBUF(PECNT)_CNT+1 ELSE DEC PECNT
        RETURN

END PARERR

! PROCEDURE: CRASHP
! DOES CRASH PROTECTION
! TAKES FILE NAME IN 'OFILS' AND WILL CLOSE AND OPEN IT AGAIN
! IF THE TENTH BUFFER IS WRITTEN OUT.
! MUST BE CALLED IMMEDIATELY AFTER A 'W' OR 'WX' CALL
!
%CRASHP

! CHECK TO SEE IF NOT INVOLKED
        IF CRASHER=FALSE THEN RETURN

! ** IF CRASHER=TRUE THEN ECNT IN (SYS)IOCS
! ** MUST BE MADE GLOBAL
!       IF ECNT(OFILE)#0 THEN RETURN
        IF DEC CRAP.CNT#0 THEN RETURN   !DECREMENT BUFFER COUNT
        CLOSE(OFILE)                     !CLOSE THE FILE
        IF SYMBN=1 THEN CHAR_CHARACTER ELSE CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        OFILE_OPEN(@OFILS(0),DIRECT+CHAR+UPDATE,0,2)
        SETCP(OFILE,SIZE(OFILE))
        CRAP.CNT_NO.CRAPS
        RETURN

END CRASHP

! PROCEDURE: SUBCR
! GIVEN FILE NO. IN 'A' WILL RETURN CHARACTERS TO BE PUNCHED
! EVEN DOES SUBSTITUTION !!!
!
%SUBCR(ARG1)

        LOOP DO
        IF SUBFG=TRUE AND CHAR_NCHV SUBPT#E.O.LIT THEN RETURN CHAR
        SUBFG_FALSE; CHAR_R(ARG1)
        IF SUBPT_ESUBTAB(CHAR BAND OCT 177)=0 THEN RETURN CHAR
        SUBFG_TRUE
        END

END SUBCR

! PROCEDURE: LEV7
! WILL READ A 7 LEVEL FILE AND DO THE APPROPRIATE 'SYMBOLIC' READING
! IF NECESSARY.
!
%LEV7(ARG1)

        EIF SYMBN=1 AND (RPTYPE=3 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF)            !SET LINE POINTERS
          WHILE CHAR_SUBCR(ARG1)#CARRET THEN IF CHAR#LNFEED&
          THEN NCHV STR_CHAR
          NCHV STR_CARRET; NCHV STR_E.O.LIT; STR_POINTX(TOKBUF)
          TYPE_STOKEN(@STR,0,0)
          IF TYPE=FIRK THEN DO
            MSG('$ERROR DURING PUNCH IN "'); PRINT(@TOKBUF(0))
            MSG('"$')
            MSG('$PUNCHING ABORTED$')
            SETCP(ARG1,SIZE(ARG1))
            TOKEN_0
            END
          RETURN TOKEN BAND OCT 177
          END
        ELSE RETURN SUBCR(ARG1)

END LEV7

! PROCEDURE: OUCH
! WILL PUT EITHER CHARACTER OR NUMBER OUT DURING PUNCH IN 8-LEVEL
! FORMAT
!
%OUCH(ARG1)

        EIF SYMBN=1 AND (RPTYPE=4 OR RPTYPE=5) THEN DO
          STR_POINTX(TOKBUF); INSC(ARG1,@STR,CIORDX); STR_POINTX(TOKBUF)
          WHILE CHAR_NCHV STR#E.O.LIT THEN OUCS(CHAR)
          OUCS(CARRET); OUCS(LNFEED)
          RETURN
          END
        ELSE RETURN OUCS(ARG1)

END OUCH

! PROCEDURE: OUCS
! ARGUMENT IS CHARACTER WILL PUNCH SYMBOLICALLY
! ACCORDIND TO DEFINITION OF "PARITY"
!
%OUCS(ARG1)

        DO PARITY OF OFF:PACKD

DATA:PACKD: ARG1 BOR_OCT 200
ODD:    ARG1 BOR_(MAKPAR(ARG1,1))
EVEN:   ARG1 BOR_(MAKPAR(ARG1,0))

        END

        OUTIMG(ARG1)

        RETURN

END OUCS

! PROCEDURE: LEV8
! DEPENDING ON DEFINITION OF 'PARITY' WILL DECIDE TO RETURN
! SIX 6-BIT BYTES PER WORD READ OR ONE 8-BIT BYTE PER WORD READ
! WILL BE APPROPRIATELY BANDED FOR YOUR CONVINIENCE.
!
%LEV8(ARG1)

        DO PARITY OF OFF:PACKD

DATA:PACKD: RETURN R(ARG1) BAND OCT 377
OFF:EVEN:ODD: IF SUBFG=FALSE THEN [SUBFG_6;SUBD_R(ARG1);SUBPT_BYPT(@SUBD,-1,6)]
        DEC SUBFG; RETURN NBYV SUBPT BAND OCT 77        ! 6 BIT-BYTE

        END
        RETURN

END LEV8

END SUBPRC

! PROCEDURE: CNTER(ARG1)
! DECIDES ON SUBSTITUTE WRITE-OUT
! ARGUMENT 1 IS STRING TO LOOK AT
!
%CNTER(ARG1)

LOCAL I

        I_0

        WHILE NCHV ARG1 # E.O.LIT THEN INC I

        RETURN I

END CNTER

! PROCEDURE: SUBOUT
! ARGUMENTS: 1:OUTFN, 2: STRING TO WRITE
! WRITES IT OUT THE BEST WAY IT KNOWS HOW
! RETURNS "0" IF ONE ARGUMENT OUTPUT,
! ELSE RETURNS "1" IF MUILT-ELEMENT ARGUMENT OUTPUT
!
%SUBOUT(ARG2,ARG1)

LOCAL QUOTFL,COMAFL,STPT(0:MAX.DIG),STR1,ARG3

        ARG3_ARG1; NCHV ARG3 ! FOR NOTHING CHECK
        QUOTFL_COMAFL_FALSE     !INIT FLAGS
        WHILE TYPE_NCHR(@ARG1)#EMPTY THEN DO
          EIF TYPE=DELIMT AND CHAR#$   THEN DO
           IF QUOTFL=TRUE THEN [W(ARG2,$");INC COMAFL;QUOTFL_FALSE]
           IF COMAFL#FALSE THEN [W(ARG2,$,)]
           EIF CHAR<S.SIZE THEN DO
            STR1_POINT(SWORDS(CHAR))
            WHILE CHAR_NCHV STR1#E.O.LIT THEN W(ARG2,CHAR)
            END
           ELSE DO
            STR1_POINTX(STPT); INSC(CHAR,@STR1,CIORDX); NCHV STR1_E.O.LIT
            STR1_POINTX(STPT)
            WHILE CHAR_NCHV STR1#E.O.LIT THEN W(ARG2,CHAR)
            W(ARG2,$B)
            END
        END
          ELSE DO
            IF QUOTFL=FALSE THEN DO
             IF COMAFL#FALSE THEN W(ARG2,$,)
             W(ARG2,$");QUOTFL_TRUE
            END
            W(ARG2,CHAR)
            END
        INC COMAFL
        END

! END OF WHILE LOOP
! IF ARG2 = ARG3 THEN E.O.LIT WAS FIRST CHARACTER, I.E., NULL STRING
        IF ARG1=ARG3 THEN DO
! IT WAS
          STR1_POINT('NOTHING')
          WHILE CHAR_NCHV STR1 # E.O.LIT THEN W(ARG2,CHAR)
          END

        IF QUOTFL=TRUE THEN [W(ARG2,$")]        !TERMINATE QUOTE
        RETURN COMAFL

END SUBOUT
! PROCEDURE: SUBGET
! RETURNS ONE STRING VALUE FOR SUBSTITUTE COMMAND
! THE WORD "NOTHING" WILL CAUSE A 0 TO BE RETURNED
! TWO ARGUMENTS: 1:STRING TO GET FROM (UPDATES IT), 2:=1 IF FIRST
! CALL WHICH "ARG1,ARG2" IS VALID ALONE AS TWO STRINGS, ELSE =0
!
%SUBGET(@ARG1,ARG2)

LOCAL STR1,STR2,STPT1(0:15),STPT2(0:15),CNTR,AHOLD,BHOLD,CHOLD,DHOLD

        EIF ARG2=1 THEN STR1_STR2_POINTX(STPT1)
        ELSE STR1_STR2_POINTX(STPT2)
        CNTR_0

        LOOP DO

          AHOLD_ARG1; BHOLD_TERMCH; CHOLD_TYPE; DHOLD_TOKEN; TYPE_STOKEN(@ARG1,0,0); INC CNTR
          EIF TERMCH=CARRET AND CNTR=2 AND ARG2=1 THEN&
            [ARG1_AHOLD; TERMCH_BHOLD; TYPE_CHOLD; TOKEN_DHOLD; NCHV STR1_E.O.LIT; RETURN STR2]

          ORIF TYPE=STRING THEN COPYST(POINTX(TOKBUF),@STR1)
          ORIF TYPE=FIRK THEN RETURN FIRK
          ELSE NCHV STR1_TOKEN

        WHILE TERMCH=$, AND TYPE#EMPTY
        END

        NCHV STR1_E.O.LIT; RETURN STR2
END SUBGET


        \\->BEGIN
  _*