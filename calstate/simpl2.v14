GLOBAL %HOST

BASE 0
FIND JOBERR,%RETLIN
!CG INTERFACE:

FIND %TV,P,T(10),V(10),X(10),CREFSW,%OUTCH,%BIO,INP
FIND ID(10),%UTV,%UNARY,%JMP.LNK,%CJMP.LNK,%CG
FIND %FGTALL,%CLOSE,%CRR.SYM,%CRD.SYM,LASTBR,%UPERR
FIND %RCP,%WIO,%MCLOSE

! PA INTERFACE:

FIND %REMOVMAC,%NEW.BLOCK,STB,%DMP,%D.NXT.SYM,%PRINT.LINE.CR
FIND %NEW.SYM.TBL,%SYMPOS
DEF KIND.V(I) AS BYT(^(VAL.ADDR(I)),8,27)
DEF LOC.V(I) AS BYT(^(VAL.ADDR(I)),19,0)
DEF DEPTH.V(I) AS BYT(^(VAL.ADDR(I)),5,22)
DEF ALT.NAME(I) AS BYT(^I,1,35)
DEF ALT.ADDR(I) AS BYT(^I,18,0)
DEF ID.SPLIT(A,K,D,SC,ST,L) AS [1,8,5,2,1,19]*[A,K,D,SC,ST,L]

DEF KON AS 3
DEF W.ABS AS 4
DEF W.REL AS 5
DEF REG        AS 8
DEF INDR.OP AS 10
DEF AT.OP AS 9
DEF BLK.SIZ AS 256

!GI INTERFACE:

FIND %WARN,%STK.ID,%USTK.ID,%GETSYM,%PRINT,%PUT,%OPEN,%CIO,%GET
FIND RESULT(2),LSNUM,SYMBUF(2),RPTR
FIND %GI,PRO.DP,NULL.DP,RECOVER:

GLOBAL ALTERNATE,KIND,DEPTH,SCOPE,STATE,LOC,TCONFL,%PAK.VB,%UNPAK.VB
GLOBAL %HOSTEND,%VAL.ADDR,%DCL.ALT,%DEF.ALT
GLOBAL %GEN,%GLNUM,%BEG.LV,%END.LV,%HO.CLR,%MK.ST.BLK
GLOBAL CD.P,DT.P,%DCL,%DCL.STR,%K.ADD,%K.NOT,%TV.KON
GLOBAL %K.AR,%MAK.POS,%RLS.K,%TV.ID,%DCL.LAB,%LOC.MOD
GLOBAL %TVKI,%LOG,%K.NEG,%K.SIGN,%TVDKI,%K.SGN
GLOBAL %K.SPLIT,%GEN.KON,K.LH,K.RH
GLOBAL %INPW,%PWF,HIB, LOB,%PVAL,%BFWD,%FIXUP,%BCFWD
GLOBAL %GKIND,FNO,TITLE.P,%MKENTRY
GLOBAL %ERR,%IERR,ERRCNT
GLOBAL %ALLOC,%ALTER,%LDEF,%PDEF,PRO.NAME

LOCAL OUTREL,RELBYT,%KONREF,%STBLK,IDSTART
LOCAL %PSYM,%POCT,%BL.START,%BL.PUT,%BL.END,%BL.FPUT
LOCAL %RAX50,%REL.SYM
LOCAL %SYMLIT,%STEP.C
LOCAL FUP.BEG,FUP.BLK(),FUP.INX
LOCAL ECS.BEG,ECS.BLK(),ECS.INX
LOCAL DLN.BEG,DLN.BLK(),DLN.INX
LOCAL HOENDFL,A.STB,ENT.MODE,TITLE,HI.SIZ.LOC,%REM.QUOTE

DEF FN.REL AS FNO
DEF ABSOLUTE AS 0
DEF LO.SEG AS 1
DEF HI.SEG AS 2
DEF LR.HI.SEG AS 3
DEF KVSZ AS 30
LOCAL KV(KVSZ),KU(KVSZ)
LOCAL J,K.INDX
DEF SPLIT AS [BITSPERWORD/2,BITSPERWORD/2]
DEF K.LEFT(K) AS (K SHR (BITSPERWORD/2))



DEF CODE(L) AS L<OCT 1.000000
DEF CD.END AS OCT 777.777
DEF DT.END AS OCT 1.777.777
DEF CD.BEG AS OCT 1
DEF DT.BEG AS OCT 1.000.001

DEF NULL.LINK AS 0

DEF OUTER.BLOCK AS -1

DEF ALT.MARK AS OCT 400.000

! ORDER SIGNIFICANT IN THESE DEFS, RANGE TEST MADE IN CODE:
!
!      KIND   LOC
!      ---------------        ----------------

DEF UNDCL      AS 0           !      0
DEF FLAB        AS 1    ! FONY LABEL
DEF LABEL      AS 2
DEF PROC       AS 3
DEF VARB       AS 4
DEF SVEC       AS 5
DEF DVEC       AS 6
DEF TEXT       AS 7
DEF MACRO      AS 14 !        INDEX FOR MACRO PROCESSOR


!      SCOPE:

DEF FIND.S     AS 0
DEF GLOBAL.S   AS 1
DEF PARAM.S    AS 2           !      @<NAME>  ONLY
DEF LOCAL.S    AS 3

! STATE IS 1 IF DEFINED.

! DEPTH IS NULL.DP BEFORE FIRST PROCEDURE

!****************************

%HOST(CFILE)

LOCAL PTR1,CHAR
PTR1_TITLE.P
HOENDFL_0
       IF CREFSW#0 THEN DO
       OUTCH(OCT 177); OUTCH(OCT 102); OUTCH(OCT 20)
       WHILE CHAR_NCHV(PTR1)#E.O.LIT THEN OUTCH(CHAR)
       OUTCH(OCT 177); OUTCH(OCT 104)
	END

ERRCNT_0
CD.P_CD.BEG; DT.P_DT.BEG
TITLE_RAX50(TITLE.P)
ENT.MODE_0 ; BL.START(4) ; ENT.MODE_1
ECS.BEG_0; ECS.BLK_@ECS.BEG; ECS.INX_BLK.SIZ-1
DLN.BEG_0; DLN.BLK_@DLN.BEG; DLN.INX_BLK.SIZ-1
FUP.BEG_0; FUP.BLK_@FUP.BEG; FUP.INX_BLK.SIZ-1
K.INDX_0; IDSTART_0
A.STB_NEW.SYM.TBL(2,0)
BEG.LV(OUTER.BLOCK); GI; CG
RETURN

%HOSTEND
LOCAL I,J,K,L2:,L4:,LITARY(1:53),PTR1,PTR2,D,F,N

HOENDFL_-1; END.LV(OUTER.BLOCK)
ECS.BLK_ECS.BEG
WHILE ECS.BLK#0 THEN DO
	K_0; J_IF ECS.BLK(0)=0 THEN ECS.INX ELSE BLK.SIZ-1
	WHILE INC K<=J THEN DO
		RELBYT_ABSOLUTE
		OUTREL_OCT 600.000.000.000 BOR REL.SYM(HW(@ECS.BLK(K)))
		BL.PUT
		RELBYT_HI.SEG
		OUTREL_OCT 400.000.000.000 BOR HW(@ECS.BLK(K),1)
		BL.PUT
	END
	ECS.BLK_ECS.BLK(0)
END

DLN.BLK_DLN.BEG; I_0
WHILE DLN.BLK#0 THEN DO
	K_0; J_IF DLN.BLK(0)=0 THEN DLN.INX ELSE BLK.SIZ-1
	WHILE INC K<=J THEN DO
		RELBYT_ABSOLUTE; F_1; OUTREL_OCT 46; N_INC I
		WHILE F_F*10<=N THEN NULL
		WHILE F_F/10>0 THEN [[D;N]_N DIVMOD F; OUTREL_ &
			OUTREL*OCT 50+D+1]
		OUTREL_OUTREL BOR OCT 100.000.000.000
		BL.PUT
		RELBYT_HI.SEG; OUTREL_DLN.BLK(K); BL.PUT
	END
	DLN.BLK_DLN.BLK(0)
END

BL.END
I_CD.P; RELBYT_ABSOLUTE
BL.START(1); J_-1
WHILE INC J<K.INDX THEN [OUTREL_KV(J); STEP.C]

DMPSY:	DMP(STB,L2)
L1: J_D.NXT.SYM; IF KIND.V(J+BLK.SIZ)=TEXT THEN DO
	GETSYM(J)
K_54; WHILE DEC K>0 THEN LITARY(K)_0
PTR1_CHPT(SYMBUF+1); PTR2_CHPT(LITARY+1,-1); K_CHV(PTR1)
WHILE NCHV(PTR2)_NCHV(PTR1)#K THEN NULL; J_0
CHV(PTR2)_E.O.LIT
WHILE INC J<=SYMBUF(0) THEN [OUTREL_LITARY(J); STEP.C]
END
GO L1

L2:	BL.END; BL.START(OCT 10); RELBYT_LR.HI.SEG; J_-1
WHILE INC J<K.INDX THEN [OUTREL_[18,18]*[KU(J)-CD.BEG,I-CD.BEG]&
		;BL.PUT; I_LOC.MOD(I,1)]

DMP(STB,L4)
L3: J_D.NXT.SYM; IF KIND.V(J+BLK.SIZ)=TEXT THEN DO
	GETSYM(J)
	OUTREL_[18,18]*[LOC.V(J+BLK.SIZ)-CD.BEG,I-CD.BEG]; I_LOC.MOD(I,SYMBUF(0))
	BL.PUT
END
GO L3

L4: FUP.BLK_FUP.BEG
WHILE FUP.BLK#0 THEN DO
	K_0; J_IF FUP.BLK(0)=0 THEN FUP.INX ELSE BLK.SIZ-1
	WHILE INC K<=J THEN [OUTREL_FUP.BLK(K); BL.PUT]
	FUP.BLK_FUP.BLK(0)
END

BL.END; STBLK; BL.START(5); RELBYT_HI.SEG; OUTREL_CD.P-CD.BEG; BL.PUT
RELBYT_LO.SEG; OUTREL_DT.P-DT.BEG; BL.PUT; BL.END
MCLOSE(FN.REL,HI.SIZ.LOC,[18,18]*[CD.P-CD.BEG+OCT 400.000,OCT 400.000])

IF INP#0 THEN IF ERRCNT=0 THEN RETURN ELSE GO ERRPRT
PUT(CARRET); PRINT('PROG SIZE = '); POCT(CD.P-CD.BEG)
PUT(CARRET); PRINT('DATA SIZE = '); POCT(DT.P-DT.BEG)
PUT(CARRET)
ERRPRT:	IF ERRCNT=0 THEN PRINT('NO') ELSE [PVAL(ERRCNT); &
        UPERR(JOBERR_ERRCNT)]
PRINT(' ERROR'); IF ERRCNT#1 THEN PUT($S)
PRINT(' FOUND'); PUT(CARRET)

RETURN
END HOSTEND

%HO.CLR
RETURN
END HO.CLR

%PWF
       [BITSPERWORD-8,8]*[HIB,LOB]_INPW
RETURN
END PWF


%INPW
       RETURN RESULT(INC RPTR)
END INPW

%ERR(LIT)
RETLIN; PRINT(LIT); PRINT.LINE.CR; IF HOENDFL=-1 THEN RETURN ELSE GO RECOVER
END ERR

%IERR(LIT,IDPT)
RETLIN; PRINT(LIT); PSYM(IDPT); PRINT.LINE.CR
IF HOENDFL=-1 THEN RETURN ELSE GO RECOVER
END IERR

%PSYM(I)
PRINT(SYMLIT(I))
RETURN
END PSYM

%SYMLIT(I)
GETSYM(I-BLK.SIZ); CH(@SYMBUF(SYMBUF(0)+1))_EOLIT
RETURN @SYMBUF(1)
END SYMLIT

%POCT(N)
       LOCAL K
       IF N =0 THEN [PUT($0);RETURN]
       K_BITSPERWORD/3
       WHILE 7 BAND(N_N ROTL 3)=0 THEN DEC K
       WHILE DEC K>=0 THEN PUT($0+7 BAND N<==N ROTL 3)
RETURN
END POCT

%PVAL(N) ! PRINT DECIMAL NUMBER
IF N<0 THEN [N_-N; PUT($-)]
LOCAL D,F
F_1; WHILE F_F*10<=N THEN NULL
WHILE F_F/10>0 THEN [[D;N]_N DIVMOD F; PUT($0+D)]
RETURN
END PVAL

%GLNUM ! GENERATE LINE NUMBER COMMENT:
!IF DLN.INX>BLK.SIZ-2 THEN [DLN.BLK_DLN.BLK(0)_NEW.BLOCK(1) &
	; DLN.INX_0; DLN.BLK(0)_0]
!DLN.BLK(INC DLN.INX)_CD.P-CD.BEG
RETURN
END GLNUM


!*****************
!      
!      EMITTERS OF WORDS OF CODE:

%GEN(MODE,INS,AC,IX,INDR,OPND)

LOCAL %OCD.P,%ODT.P,%OLNK,MV,IDPT

! MODE OPND
! 
! 0    OPERAND INDEX
! 1    ABSOLUTE
! 2    CODE ADDRESS
! 3    DATA ADDRESS
! 4    LINK

OUTREL_[9,4,1,4,18]*[INS,AC,INDR,IX,0]
LASTBR_0
TCONFL_ IF INS= OCT 254 !JRST! THEN 1 ELSE 0 !TRANSFER OF CONTROL FLAG!

DO MODE OF 0:4

0 !OPERAND! : IDPT_ID(OPND); MV_V(OPND)
       DO T(OPND) OF KON:REG
       REG:W.ABS: HW(@OUTREL,1)_MV; RELBYT_ABSOLUTE
       KON: OLNK(KON.REF(MV))
       W.REL: IF IDPT=0 THEN ODT.P(MV) ELSE DO
		UNPAK.VB(IDPT)
		EIF SCOPE=FIND.S THEN DO
			EIF HW(@IX)=0 THEN [OLNK(@LOC); PAK.VB(IDPT)]
			ELSE DO
			     IF ECS.INX>BLK.SIZ-2 THEN [ECS.BLK_ &
			       ECS.BLK(0)_NEW.BLOCK(1); ECS.INX_ &
			       0; ECS.BLK(0)_0]
			     ECS.BLK(INC ECS.INX)_[18,18]* &
			       [VAL.ADDR(IDPT),CD.P-CD.BEG]
			     HW(@OUTREL,1)_HW(@IX); RELBYT_ABSOLUTE
			END
		END
		ELSE DO KIND OF FLAB:TEXT
		FLAB: LABEL: PROC: EIF SCOPE=PARAM.S THEN ODT.P(LOC)
		ORIF STATE=1 THEN OCD.P(LOC)
		ELSE [OLNK(@LOC);PAK.VB(IDPT)]
		VARB: SVEC: DVEC: IF CODE(LOC) THEN OCD.P(LOC) ELSE ODT.P(LOC)
		TEXT: OLNK(@LOC); PAK.VB(IDPT)
		END ! KIND OF LABEL:TEXT
	END
       END ! T(OPND) OF KON:REG

1 !ABSOLUTE! : RELBYT_ABSOLUTE; HW(@OUTREL,1)_OPND

2 !CODE! : OCD.P(OPND)

3 !DATA! : ODT.P(OPND)

4 !LINK! : OLNK(OPND)

END ! MODE OF 0:4

STEP.C; RETURN

%OCD.P(CD) ! OUTPUT CODE REFERENCE RELATIVE TO C.
RELBYT_HI.SEG; HW(@OUTREL,1)_CD-CD.BEG+HW(@IX)
RETURN
END OCD.P

%ODT.P(DT) ! OUTPUT DATA REFERENCE RELATIVE TO D.
RELBYT_LO.SEG; HW(@OUTREL,1)_DT-DT.BEG+HW(@IX)
RETURN
END ODT.P

%OLNK(@LNK) ! OUTPUT REFERENCE TO LINK
! CD.BEG MUST BE SUBTRACTED FROM ALL CD.P REFERENCES
! NOTE THAT IF LINK=0, IT IS END OF CHAIN SINCE LOWEST CD.P=1
IF LNK=0 THEN RELBYT_0 ELSE [RELBYT_HI.SEG; LNK_LNK-CD.BEG]
HW(@OUTREL,1)_LNK<==CD.P
RETURN
END OLNK

END GEN


%GEN.KON
EIF T(P)=KON THEN [RELBYT_ABSOLUTE; OUTREL_V(P); STEP.C]
ELSE GEN(0,0,0,0,0,P)
RETURN
END GEN.KON

%STEP.C
BL.PUT
IF INC CD.P<CD.END THEN RETURN; WARN('PROG OFL'); EXIT
END STEP.C

%MKSTBLK(IDPT)  !MAKE A START BLOCK---TYPE 7
	UNPAK.VB(IDPT)
	IDSTART_LOC; RETURN
%STBLK
	IF IDSTART=0 THEN RETURN
	BLSTART(7) !START TYPE 7
	RELBYT_HISEG; OUTREL_IDSTART-CD.BEG; BL.PUT; BL.END
	RETURN
END STBLK
END MKSTBLK

%MKENTRY(IDPT) ! GENERATE AN ENTRY BLOCK WORD
IF NOT ENT.MODE THEN ERR('\ENTRYNAME MUST BE FIRST STATEMENTS OF PROGRAM')
OUTREL_RAX50(REM.QUOTE(IDPT))
RELBYT_ABSOLUTE
BL.FPUT
RETURN
END MKENTRY

%REM.QUOTE(IDPT)
LOCAL T1,T2,C,CNT

T1_T2_CHPT(SYMLIT(IDPT),-1)
C_NCHV T2 ; CNT_0
WHILE (NCHV T1_NCHV T2)#C THEN INC CNT
CHV T1_EOLIT ; NCHV T1_EOLIT
SYMBUF(0)_(CNT-1)/CHARS.PER.WORD+1
RETURN CHPT(@SYMBUF(1),-1)
END REM.QUOTE


!*********************

%PAK.VB(IDPT)
IDPT_VAL.ADDR(IDPT)
^IDPT_ID.SPLIT(ALTERNATE,KIND,DEPTH,SCOPE,STATE,LOC)
RETURN
END PAK.VB

%UNPAK.VB(IDPT)
IDPT_VAL.ADDR(IDPT)
ID.SPLIT(ALTERNATE,KIND,DEPTH,SCOPE,STATE,LOC)_^IDPT
RETURN
END UNPAK.VB

%VAL.ADDR(IDPT)
RETURN IF ALT.NAME(IDPT) THEN ALT.ADDR(IDPT) ELSE IDPT
END VAL.ADDR

%GKIND (IDPT)  !RETURN KIND GIVEN SYMBOL ID
RETURN KIND.V(IDPT)
END GKIND

%ALLOC(N) ! ALLOCATE DATA STORAGE AND RETURN DT.P TO FIRST WORD
IF N_DT.P+N<DT.END THEN RETURN DT.P<==N
WARN('DATA OFL'); EXIT
END ALLOC

%ALTER(CD) ! ALTER CD.P TO CD
CD.P_CD; BL.END; BL.START(1)
RETURN
END ALTER

%LOC.MOD(L,M) ! MODIFY PROGRAM LOCATION L BY M
RETURN [18,18]*[HW(@L),HW(@L,1)+M]
END LOC.MOD

%DCL(IDPT,KIND.1,SCOPE.1,LOC.1) ! DECLARE A VARIABLE (IDPT)
IF CREFSW#0 THEN IF LABEL#KIND.1#PROC THEN CRD.SYM(IDPT) ELSE CRR.SYM(IDPT)
UNPAK.VB(IDPT)
IF FLAB#KIND#UNDCL AND DEPTH=PRO.DP THEN IERR('DUPLICATE: ',IDPT)
STK.ID(IDPT)
KIND_KIND.1; DEPTH_PRO.DP; SCOPE_SCOPE.1; LOC_LOC.1
STATE_[KIND>PROC OR SCOPE=FIND.S OR SCOPE=PARAM.S]
ALTERNATE_0
^IDPT_0
PAK.VB(IDPT)
RETURN
END DCL

%DCL.ALT(IDPT) !PUT LOADER NAME IN ALTERNATE SYMBOL TABLE
LOCAL MID,AID

REM.QUOTE(IDPT)

MID_SYMPOS(STB)+BLK.SIZ
AID_SYMPOS(A.STB)+BLK.SIZ

IF (FLAB#KIND.V(AID)#UNDCL AND DEPTH.V(AID)=PRO.DP) OR &
   ( NOT ALT.NAME(MID) AND &
    FLAB#KIND.V(MID)#UNDCL AND DEPTH.V(MID)=PRO.DP) THEN &
        IERR('DUPLICATE LOADER NAME: ',AID)

STKID([18,18]*[ALT.MARK,AID])
RETURN AID
END DCL.ALT

%DEF.ALT(MID,AID) !GIVE IDENTIFIER MID LOADER NAME AID
^AID_^MID
ALT.NAME(MID)_1
ALT.ADDR(MID)_AID
RETURN
END DEF.ALT

%DCL.STR(IDPT)
IF KIND.V(IDPT)=UNDCL THEN DO
KIND_TEXT; SCOPE_LOCAL.S; DEPTH_NULL.DP; STATE_1; LOC_NULL.LINK
PAK.VB(IDPT)
END
RETURN
END DCL.STR


%LDEF(IDPT) ! DEFINE LABEL HERE
LOCAL X,%DEF.CD
UNPAK.VB(IDPT)
IF FLAB#KIND#LABEL OR STATE#0 THEN DCL(IDPT,LABEL,LOCAL.S,NULL.LINK)
KIND_LABEL
DEF.CD
RETURN

%%PDEF(IDPT) ! DEFINE PROCEDURE HERE
UNPAK.VB(IDPT)
IF KIND#PROC OR STATE#0 THEN IERR('UNDECLARED: ',IDPT)
DEF.CD
RETURN

%DEF.CD ! PACK AWAY DEF OF CD.P
IF CREFSW#0 THEN CRD.SYM(IDPT)
IF LOCAL.S#SCOPE#GLOBAL.S THEN IERR('NO NO: ',IDPT)
FIXUP(LOC)
STATE_1; LOC_CD.P; PAK.VB(IDPT); FGTALL
RETURN
END DEF.CD
END LDEF


%BFWD(XLINK) ! ONE OF A LIST OF LINKED BRANCHES TO UNKNOWN LOCATION
IF LASTBR=0 THEN JMP.LNK(XLINK)
RETURN
END BFWD

%BCFWD(XLINK,CREL)
CJMP.LNK(XLINK,CREL); RETURN
END BCFWD

%FIXUP(LINK) ! SATISFY CHAINED REFERENCES HERE (CD.P)
IF LINK=NULL.LINK THEN RETURN
IF FUP.INX>BLK.SIZ-2 THEN [FUP.BLK_FUP.BLK(0)_NEW.BLOCK(1); &
	FUP.INX_0; FUP.BLK(0)_0]
FUP.BLK(INC FUP.INX)_[18,18]*[LINK-CD.BEG,CD.P-CD.BEG]
FGTALL
RETURN
END FIXUP

%TV.ID(IDPT)
       UNPAK.VB(IDPT)
       IF KIND=UNDCL THEN IERR('UNDECLARED: ',IDPT)
       TV(W.REL); ID(P)_IDPT
       EIF KIND=TEXT THEN UNARY(AT.OP)
	ELSE IF CREFSW#0 THEN CRR.SYM(IDPT)
       IF SCOPE=PARAM.S THEN UNARY(INDR.OP)
RETURN
END TV.ID

%DCL.LAB(IDPT) ! IMPLICIT DECL OF LABEL BY VIRTUE OF "GO"
UNPAK.VB(IDPT)
IF KIND=LABEL AND DEPTH<PRO.DP &
 AND SCOPE=LOCAL.S THEN [ DCL(IDPT,FLAB,LOCAL.S,NULL.LINK);RETURN]
IF LABEL#KIND#FLAB THEN DCL(IDPT,LABEL,LOCAL.S,NULL.LINK)
RETURN
END DCL.LAB

%REL.SYM(IDPT) ! GENERATE REL FILE NAME FOR IDPT
RETURN RAX50(CHPT(SYMLIT(VAL.ADDR(IDPT)),-1))
END REL.SYM

%BEG.LV(P.ID) ! BEGIN A PROCEDURE
IF P.ID#OUTER.BLOCK THEN [BL.END ; BL.START(1)]
STKID(@P.ID)
RETURN

%%END.LV(P.ID)        !END A PROCEDURE
LOCAL ID, V.ID, X.LINK, T.CD.P

BL.END  ! TERMINATE CURRENT BLOCK ON REL FILE
BL.START(2)  ! AND START A SYMBOL BLOCK

OUTREL_( IF P.ID#OUTER.BLOCK THEN REL.SYM(P.ID) &
                             ELSE TITLE) BOR OCT 140.000.000.000
RELBYT_ABSOLUTE
BL.PUT  ! OUTPUT THE BLOCK NAME. IF OUTER BLOCK, USE PROGRAM TITLE.
OUTREL_PRO.DP+1
BL.PUT  ! OUTPUT LEVEL OF BLOCK

WHILE ID_USTKID(@V.ID)#@P.ID THEN DO
 EIF HW(@ID)=ALT.MARK THEN ID_HW(@ID,1)
 ELSE DO
  UNPAK.VB(ID)
  EIF KIND=MACRO THEN REMOVMAC(LOC)
  ORIF KIND=FLAB THEN DO
   X.LINK_LOC
   ^ID_V.ID
   UNPAK.VB(ID)
   T.CD.P_CD.P<==LOC
   FIXUP(X.LINK)
   CD.P_T.CD.P
  END
  ORIF STATE=0 THEN DO
   WARN('UNDEFINED: '); PSYM(ID); PUT(CARRET)
  END
  ELSE DO
   EIF SCOPE=FIND.S THEN OUTREL_OCT 600.000.000.000
   ORIF SCOPE=GLOBAL.S THEN OUTREL_OCT 040.000.000.000
   ELSE OUTREL_OCT 100.000.000.000
   OUTREL BOR_REL.SYM(ID)
   RELBYT_ABSOLUTE
   BL.PUT
   EIF LOC=NULL.LINK THEN [OUTREL_0 ; RELBYT_ABSOLUTE]
   ORIF CODE(LOC) THEN [OUTREL_LOC-CD.BEG ; RELBYT_HI.SEG]
   ELSE [OUTREL_LOC-DT.BEG ; RELBYT_LO.SEG]
   OUTREL BAND_OCT 777.777
   BL.PUT
  END
 END
 ^ID_V.ID
END
IF V.ID#P.ID THEN IERR('SHOULD BE END OF ',V.ID)

END BEG.LV

!******************

!      KONSTANT MANAGEMENT:

%RLS.K(O)
RETURN
END RLS.K

%K.ADD(O,N)
       V(O)_V(O)+N
       RETURN
END K.ADD

%K.SGN(O)
        RETURN IF V(O)<0 THEN 1  ELSE 0
END K.SGN
%K.SIGN(O)
       RETURN IF V(O)<0 THEN -1 ELSE 0
END K.SIGN

%K.NEG(O)
       V(O)_-V(O)
       RETURN
END K.NEG

%K.NOT(O)
       V(O)_BNOT V(O)
       RETURN
END K.NOT

%K.SPLIT(O)
       SPLIT*[K.LH,K.RH]_V(O)
       RETURN
END K.SPLIT

%K.AR (OP) ! RETURN 1 IF CONSTANT CLOSURE SUCCESSFUL
LOCAL I,J
DEF KOP(OPR) AS V(P-1) OPR_J
DEF KOP1(OPR) AS V(P-1)_I OPR J

IF NOT T(P-1)=KON=T(P) THEN RETURN 0
J_V(P); I_V(P-1)
DO OP SHR 4 OF 0:4
0:     DO OP OF HEX 00 !+!:HEX 03 !/!
       HEX 00 !+!: KOP(+)
       HEX 01 !-!: KOP(-)
       HEX 02 !*!: KOP(*)
       HEX 03 !/!: IF J=0 THEN WARN('ZERO DIV') ELSE KOP(/)
       END
1:     KOP1(MOD)
2:     DO OP OF HEX 20 !BAND!:HEX 23 !BEQV!
       HEX 20 !BAND!: KOP(BAND)
       HEX 21 !BOR! : KOP(BOR)
       HEX 22 !BXOR!: KOP(BXOR)
       HEX 23 !BEQV!: KOP(BEQV)
       END
3:     DO OP OF HEX 30 !SHL!:HEX 33 !ROTR!
       HEX 30 !SHL! : KOP1(SHL)
       HEX 31 !SHR! : KOP1(SHR)
       HEX 32 !ROTL!: KOP1(ROTL)
       HEX 33 !ROTR!: KOP1(ROTR)
       END
4:     DO OP OF HEX 40 !MAX!:HEX 41 !MIN!
       HEX 40 !MAX!: KOP1(MAX)
       HEX 41 !MIN!: KOP1(MIN)
       END
END
RETURN 1
END K.AR

%MAK.POS(O) ! MAKE OPERAND O POSITIVE, RETURN 1 IF NEGATION REQUIRED
       IF K.SIGN(O)=0 THEN RETURN 0
       K.NEG(O); RETURN 1
END MAK.POS

%LOG(O) ! RETURN LOG BASE 2 OF VALUE IF EXACT ELSE -1
       IF T(O)#KON THEN RETURN -1
       J_ABS V(O)
       IF J=0 OR J BAND -J # J THEN RETURN -1
       LOCAL K
       K_0; WHILE J>1 THEN [J_J/2; INC K]; RETURN K
END LOG

%TVKI(K)
       TV(KON)
       V(P)_K
RETURN
END TVKI

%KON.REF(K) ! RETURN LINK TO KONSTANT K
J_K.INDX
WHILE DEC J>=0 THEN IF K=KV(J) THEN RETURN @KU(J)
IF K.INDX>KVSZ THEN ERR('KON OFL')
KV(K.INDX)_K; KU(K.INDX)_NULL.LINK
J_@KU(K.INDX); INC K.INDX
RETURN J
END KON.REF

%TVDKI(LH,RH)
TVKI(SPLIT*[LH,RH]); RETURN
END TVDKI

%TV.KON(KTYPE,IDPT)
LOCAL C,NC,BAS,NUM
TABLE BAS.TAB(1:4)[16,8,128,10]
BAS_BAS.TAB(KTYPE)
C_CHPT(SYMLIT(IDPT),-1); NUM_0
WHILE NC_NCHV C#EOLIT THEN DO
       DO KTYPE OF 4
       1:     NUM_(NUM SHL 4)+(NC_NC-IF NC>$9 THEN $A-HEX A ELSE $0)
       2:     NUM_(NUM SHL 3)+(NC_NC-$0)
       3:     NUM_(NUM SHL 7)+NC
       4:     NUM_NUM*10+(NC_NC-$0)
       END
       IF NOT 0<=NC<BAS THEN IERR('FAR OUT DIGIT',IDPT)
END
TVKI(NUM)
RETURN
END TV.KON

%RAX50(PTR) ! CONVERT SYMBOL PTR TO RADIX 50
LOCAL J,R,CHR
J_6; R_0
WHILE DEC J>=0 AND CHR_NCHV(PTR)#EOLIT THEN DO
	EIF $0<=CHR<=$9 THEN CHR_CHR+(1-$0)
	ORIF $A<=CHR<=$Z THEN CHR_CHR+(OCT 13-$A)
	ORIF CHR=$. THEN CHR_OCT 45
	ORIF $$<=CHR<=$% THEN CHR_CHR+(OCT 46-$$)
	ELSE ERR('ILLEGAL LOADER NAME CHARACTER')
	R_OCT 50*R+CHR
END
RETURN R
END RAX50

%BL.START (TYP)  !START A REL BLOCK TYPE=TYP
LOCAL OUTBUF(247),OUTPTR,RELWD,NWFLAG,%BS,%BE,%BL.HDR

IF ENT.MODE THEN BL.HDR

BS(TYP)
RETURN

%BS(TYP)
OUTBUF(0)_TYP SHL 18
OUTPTR_RELWD_1
IF TYP=1 THEN DO
   OUTPTR_2; OUTBUF(2)_CD.P-CD.BEG; OUTBUF(1)_HI.SEG
   INC OUTBUF(0)
END
NWFLAG_-1
RETURN
END BS

%BL.PUT    !PUT OUTREL INTO BUFFER WITH RELOCATION OF RELBYT

IF ENT.MODE THEN BL.HDR

BL.FPUT
RETURN

%BL.FPUT

IF INC OUTPTR>247 THEN DO
   BIO(FN.REL,OUTBUF,248)
   BL.START(HW(OUTBUF)); INC OUTPTR
END
IF (OUTPTR-1)MOD 19=0 THEN [RELWD_RELWD+19; INC OUTPTR]
OUTBUF(OUTPTR)_OUTREL; INC OUTBUF(0)
OUTBUF(RELWD)_(OUTBUF(RELWD)SHL 2) BOR RELBYT
NWFLAG_0
RETURN
END BL.FPUT
END BL.PUT

%BL.END   !END UP BLOCK

IF ENT.MODE THEN BL.HDR

BE
RETURN

%BE

IF NWFLAG#0 THEN RETURN
IF (OUTPTR-1) MOD 19#0 THEN  &
   OUTBUF(RELWD)_OUTBUF(RELWD) SHL (36-(((OUTPTR-1) MOD 19)*2))
BIO(FN.REL,OUTBUF,INC OUTPTR)
RETURN
END BE
L.END

%BL.HDR
LOCAL TOUTREL,TRELBYT

BE
[TOUTREL;TRELBYT]_[OUTREL;RELBYT]
BS(6) ; OUTREL_TITLE ; RELBYT_ABSOLUTE ; BL.FPUT
        OUTREL_[6,12,18]*[0,-2,0] ; RELBYT_0 ; BL.FPUT ; BE
BS(3) ; OUTREL_0 ; RELBYT_ABSOLUTE ; BL.FPUT ; BE
HI.SIZ.LOC_RCP(FN.REL)-1
[OUTREL;RELBYT]_[TOUTREL;TRELBYT]
ENT.MODE_0
BS(1)
RETURN
END BL.HDR

END BL.START

END HOST
    ¡