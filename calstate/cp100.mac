;DEFINE VERSION NUMBER

	TYMSPC==1		;TYMSHARE SPECIFICATION
	TYMREL==0		;TYMSHARE RELEASE NUMBER

DEFINE TITL(TS,TR)<
TITLE	COMSUB  -- VERSION TS' TR
IF1,<PRINTX COMPAC-10 MACRO SUBROUTINES>
SUBTTL	COMPAC-10 MACRO SUBROUTINES 
VCOMSUB==BYTE(9)0,TS,0,TR>

	TITL(\TYMSPC,\TYMREL)

COMMENT !
THIS COMMENT BLOCK CONTAINS THE NAMES OF ALL THE PEOPLE
WHO HAVE WORKED ON COMSUB.  IF YOU UPDATE THIS PACKAGE,
PLEASE ADD YOUR NAME, AND THE VERSION, AND THE DATE
AT THE BOTTOM OF THE LIST.  ALSO, UPDATE THE SPECS
OF COMPAC WHERE APPLICABLE.

VERSION	DATE	NAME		WHY

0.0	5/15/73	GARY GERE	AUTHOR: FIRST RELEASE

!

;ACCUMULATOR DEFINITIONS
	;FUNCTION	;SUBROUTINE	;GENERAL
	;USE		;USE		;USE
R0==0	;DESTROY+RESULT	;DESTROY	;GENERAL BLT REGISTER
R1==1	;DESTROY	;DESTROY	;GENERAL SCRATCH
R2==2	;SAVE+ARGUMENT	;SAVE+ARGUMENT	;GENERAL SCRATCH
R3==3	;"		;"		;"
R4==4	;"		;"		;"
R5==5	;"		;"		;"
R6==6	;"		;"		;"
R7==7	;"		;"		;"
R10==10	;"		;"		;"
R11==11	;"		;"		;"
R12==12	;"		;"		;"
R13==13	;"		;"		;"
R14==14	;"		;"		;"
R15==15	;"		;"		;"
R16==16	;SAVED		;SAVED		;JSA-JRA REGISTER
R17==17	;SAVED		;SAVED		;GENERAL PURPOSE PDL
;SOME CONSTANTS FOR US
PDL:	IOWD	150,PDLBLK
PDLBLK:	BLOCK	150

;COMMON BLOCK DEFINITIONS

	EXTERNAL	CPGLOB

KURSOR==CPGLOB+0
LINSIZ==KURSOR+1
NATCH==LINSIZ+1
INLINE==NATCH+1
ISTTY==INLINE+^D270
HUSH==ISTTY+1
UNCOLA==HUSH+1
IPROMP==UNCOLA+1
IDFILE==IPROMP+1

	EXTERNAL	CPLIST

LIST==CPLIST+0

	EXTERNAL	CPNOYB

TOKNUM==CPNOYB+0
MTCHNO==TOKNUM+1
ITEMSZ==MTCHNO+1
TRMFLG==ITEMSZ+1
TRMCHR==TRMFLG+1
ANFLG==TRMCHR+1
NANFLG==ANFLG+1
NATCHN==NANFLG+1
TOKCNT==NATCHN+1
LSTPTR==TOKCNT+1
INFLNO==LSTPTR+1
IDPTR==INFLNO+1
IDSTAK==IDPTR+1
INFOIO==IDSTAK+<^D6*^D10>+1
INFKEY==INFOIO+1
OPDEF TRUE [SETOM]
OPDEF FALSE [SETZM]
OPDEF .PSH [PUSH R17,]
OPDEF .PUL [POP R17,]

DEFINE .ARG(X)<@X-1(R16)>	;AS ARG(1) GETS FOOTRAN ARGUMENT
DEFINE ARGS(X)<IRP X<JUMP X>>	;SETS UP FOOTRAN ARGUMENT BLOCK
DEFINE PSH(X)<IRP X<.PSH X>>	;MULTI-ELEMENT PUSH ON STACK
DEFINE PUL(X)<IRP X<.PUL X>>	;MULTI-ELEMENT PULL FROM STACK
DEFINE MSG(X)<OUTSTR [ASCIZ/
X
/]>				;TYPE MESSAGE TO TELETYPE

;CALSUB <NAME> - CALLS A FOOTRAN-CALLABLE SUBROUTINE
DEFINE CALSUB(X)<
	MOVEM	R17,PDL		;PUT PDL POINTER BACK
	JSA	R16,X		;AND CALL SUBROUTINE
>

;RETSUB - RETURNS FROM FOOTRAN FUNCTION/SUBROUTINE
OPDEF RETSUB [JRA R16,(R16)]


;SUBF <NAME> - DEFINES ENTRY INTO FOOTRAN FUNCTION/SUBROUTINE IN THIS
;PACKAGE. PLACES ZERO CELL PROPERLY AND GENERATES LABEL AND
;ENTRY STATEMENT PROPERLY
DEFINE SUBF(ROUTINE)<
;**** FOOTRAN-CALLABLE FUNCTION/SUBROUTINE ROUTINE

	ENTRY	ROUTINE

ROUTINE:Z			;FOOTRAN JRA-JSA
	EXCH	R17,PDL		;GET OUR PDL WORKING
	PSH	PDL		;SAVE THE LAST R17
	PSH	R16		;SAVE REGISTER 16
	CALSUB	SAVREG		;SAVE THE REGISTERS
>

;RETF - RETURNS FROM FOOTRAN SUBROUTINE
DEFINE RETF<
	JRST	[CALSUB RESREG	;RESTORE REGISTERS
		PUL R16		;RESTORE R16
		PUL PDL		;GET R17
		EXCH R17,PDL	;AND R17 IS BACK
		RETSUB]		;RETURN [I HOPE!]
>
;SUBROUTINES USED BY COMSUB

;SAVREG -- SAVES FOOTRAN VOLITILE REGISTERS
; (FOR THIS IMPLEMENTATION, SAVES 2-15)
SAVREG:	Z			;CALLED VIA JSA
	PSH	<R2,R3,R4,R5,R6,R7,R10,R11,R12,R13,R14,R15>
	RETSUB			;RETURN

;RESREG --- RESTORES REGISTERS SAVED BY SAVREG
; (FOR THIS IMPLEMENTATION, RESTORES 2-15)
RESREG:	Z			;CALLED VIA JSA
	PUL	<R15,R14,R13,R12,R11,R10,R7,R6,R5,R4,R3,R2>
	RETSUB			;RETURN

;SAVALL -- SAVES ALL REGISTERS 
; (FOR SIMPL WHO KILLS THEM ALL)
;DOESNT SAVE R16 (REALLY SCRATCH)
;ALSO, MOVES R17 INTO PDL
SAVALL:Z			;ENTER HERE
	PSH	<R0,R1,R2,R3,R4,R5,R6,R7,R10,R11,R12,R13,R14,R15>
	MOVEM	R17,PDL		;SAVE THE PDL
	RETSUB			;RETURN

;RESALL -- RESTORES ALL REGISTERS FROM SAVALL
;EXCEPT R16
;GETS PDL POINTER FROM PDL
RESALL:Z			;ENTER HERE
	MOVE	R17,PDL		;GET THE PDL
	PUL	<R15,R14,R13,R12,R11,R10,R7,R6,R5,R4,R3,R2,R1,R0>
	RETSUB			;RETURN

;EXIT POOINT EXFOO
;SAYS LAST FOOTRAN I-O AND EXITS
; * * * CAUTION * * *
;BECAUSE FORSE DOES NOT MAKE THE ROUTINE 'USRLOC'
;GLOBAL TO ALL OF US, THE NEAREST GLOBAL TO IT WE
;CAN ACCESS IS 'ILUUO.'.
;BECAUSE OF THIS, THE 'ILUUO.+' REFERENCE BELOW IS USED
;TO TYPE 'LAST FOOTRAN I-O AT USER LOC XXX'
;IF ERROR.MAC IN LIB40 IS CHANGED, THIS MUST BE ALSO
	EXTERNAL	ILUUO.

EXFOO:	PUSHJ	R17,ILUUO.+11	;*******KLUDGE,SEE LIB40SYM*******
	EXIT
;SUBROUTINE NEXCH(INCODE,KANDO) - ARG1 IS INCODE,
;ARG2 IS KANDO
;RETURNS A CHARACTER (FROM NOWCH)
SUBF NEXTCH
	MOVE	R2,.ARG 1	;GET FIRST ARGUMENT
	MOVEM	R2,NEXTM1#	;SAVE IT IN TEMP STORAGE
	MOVE	R3,.ARG 2	;GET 2ND ARGUMENT
	MOVEM	R2,NEXTM2#	;LIKEWISE
	CALSUB	NOWCH		;CALL NOW CHARACTER
	ARGS	<NEXTM1,NEXTM2>	;ARGUMENTS
	SKIPN	NEXTM2		;SKIP IF KANDO = TRUE
	JRST	NEXTCA		;FALSE
	JRST	NEXTCB		;TRUE

;HERE WHEN KANDO IS FALSE
NEXTCB:	AOS	KURSOR		;INCREMENT KURSOR
	MOVEM	R2,NEXTM1	;SET UP ARG:1
	MOVEM	R3,NEXTM2	;SET UP ARG:2
	CALSUB	NOWCH		;CALL NOW CHARACTER
	ARGS	<NEXTM1,NEXTM2>	;ARGUMENTS

;TEST K: AGAIN
	SKIPN	NEXTM2		;SKIP IF KANDO = TRUE
	JRST	NEXTCA		;FALSE
	JRST	NEXTCE		;TRUE

;HERE ON K: TRUE SECOND TIME AROUND
;SINCE NOWCH RETURNS ANSWER IN R0,
;WE DONT DO ANYTHING AT THIS END
NEXTCE:	SETZ	R1,		;NO MULTI-RETURN
	TRUE	.ARG 2		;SET KANDO (ARG:2) = TRUE
	RETF			;RETURN FROM SUBROUTINE

;HERE ON K: FALSE BOTH TIMES
NEXTCA:	FALSE	.ARG 2		;KANDO TO FALSE
	SETZB	R0,R1		;SET ZERO RESULT
	RETF			;END OF SUBROUTINE
;SUBROUTINE LASTCH(INCODE,KANDO) - ARG1 IS INCODE,
;ARG2 IS KANDO
;RETURNS A CHARACTER (FROM NOWCH MINUS A BIT [YUK])
SUBF LASTCH
	MOVE	R2,.ARG 1	;GET THE FIRST ARGUMENT
			;ALWAYS R2 = INCODE
;CHECK LIMITS OF R2 FOR GOOD
	CAIL	R2,1
	CAILE	R2,^D8		;VALID RANGE?
	JRST	[MSG <? RUNTIME ERROR IN LASTCH ROUTINE
? INCODE (ARGUMENT 1) IS NOT WITHIN 1 AND 8, INCLUSIVE
>
		JRST EXFOO]
	MOVE	R3,KURSOR	;GET KURSOR
			;R3 = KURSOR

;LOOP TO GET CHARACTER
LASTCA:	SOJLE	R3,LASTCB	;IF JUMP THEN KURSOR = 1
;BRANCH ON CHARACTER
	MOVE	R5,INLINE-1(R3)	;GET CHARACTER
	CAIE	R5," "		;SKIP IF BLANK
	JRST	LASTCC		;NOT BLANK - OTHER
	JRST	LASTCD		;BLANK

;HERE ON NON BLANK CHARACTER
LASTCC:	TRUE	.ARG 2		;KANDO [ARG2] TO TRUE -1
	MOVEM	R5,LASTM1#	;SAVE ARG1
	MOVEM	R2,LASTM2#	;SAVE ARG2
	CALSUB	CPPACK		;CALL PACKER
	ARGS	<LASTM1,LASTM2>	;ARG 1 AND 2
	MOVE	R0,LASTM1	;GET LASTM1 BACK [CHARACTER]
	SETZ	R1,		;RESET THE SECOND VALUE
	MOVEM	R3,KURSOR	;SAVE KURSOR BACK
	RETF			;RETURN

;HERE ON BLANK CHARACTER
LASTCD:	CAILE	R2,4		;IF INLINE <=4 THEN ILL BLANK
	JRST	LASTCC		;BLANK OKAY
	JRST	LASTCA		;NOT OKAY - BACK ANOTHER

;HERE ON BACK KURSOR
LASTCB:	FALSE	.ARG 2		;KANDO ARG2: TO FALSE 0
	MOVEI	R3,1		;ON FAILURE RETURN, 
	MOVEM	R3,KURSOR	;LEAVE KURSOR = 1
	SETZB	R0,R1		;ZERO RETURN VALUE
	RETF			;RETURN
;SUBROUTINE CPFETL(CIS) - ARG1 IS INFLNO (IOCS INPUT FILE NO.)
;LOADS THE ARRAY INLINE WITH THE APPROPRIATE INFORMATION

	EXTERNAL	SETRWE,GETLINE,IOCS,IMAGE,FREE

SUBF CPFETL
	MOVEM	R16,CPFT16#	;SAVE R16
	CALSUB	CPIOCS		;TRY AND INIT IOCS
CPFETA:	MOVE	R1,.ARG 1	;CALL IOCS: R1=FILE.NO
	JSA	R16,SAVALL		;SAVE ALL REGISTERS
	MOVEI	R2,CPFETD	;SET READ-WRITE ERROR
	JSP	R17,SETRWE	;AS I SAID
	JSA	R16,RESALL		;RESTORE REGISTERS
	JSA	R16,SAVALL		;CHECKPOINT REGISTERS
	JSP	R17,GETLINE	;CALL GETLINE
	MOVEM	R1,CPFTM1#	;SAVE BYTE POINTER
	JSA	R16,RESALL		;RESTORE REGS
	MOVE	R16,CPFT16
;OUTPUT THE STRING OF HUSH AND INFLNO ARE # 0
	SKIPN	HUSH		;SKIP IF HUSH TRUE
	SKIPN	.ARG 1		;SKIP IF INPFILE # TEL
	JRST	CPFETE		;= TEL
;ECHO
	OUTSTR	FREE		;OUTPUT IOCS FREE BUFFER
	OUTCHR	[12]		;OUTPUT L.F.
;RESET COUNTER, BEGIN
CPFETE:	SETZ	R2,		;CHARACTER COUNTER
;LOOP
CPFETB:	ILDB	R3,CPFTM1	;GET CHARACTER [HOPE]
	JUMPE	R3,CPFETC	;E.O.LIT TERMS IT
	MOVEM	R3,INLINE+0(R2)	;PUT OUT THE CHARACTER
	AOJA	R2,CPFETB	;LOOP

;HERE ON E.O.LIT DURING SCAN
CPFETC:	SOS	R2		;SUB 1
	MOVEM	R2,LINSIZ	;SAVE SIZE OF LINE-CR
	FALSE	R3,INLINE+0(R2)	;SAVE CHARACTER
	SETOB	R0,R1		;TRUE RETURN
	MOVE	R16,CPFT16
	RETF			;RETURN

;HERE ON END OF FILE [WE HOPE]
CPFETD:	SETZM	LINSIZ		;RESET LINE SIZE
	JSA	R16,RESALL		;RES ALL REGS
	SETZB	R0,R1	;ZERO RETURN
	MOVE	R16,CPFT16
	RETF		;RETURN (HA HA HA)
;SUBROUTINE CPTCHR(J,K)
;ARG1:(J) --> LIST(J): WORD TO LOOK AT
;ARG2: CHARACTER DISPLACEMENT
;EXTRACT CHARACTER K FROM LIST(J)
SUBF CPTCHR
;GET LIST(J) IN
	MOVE	R2,.ARG 1	;GET ARGS 1
	MOVE	R3,.ARG 2	;AND 2
;FIRST CHECK BOUNDS OF ARG 2 (1-5)
	CAIL	R3,1
	CAILE	R3,5
	JRST	[MSG <? RUNTIME ERROR IN CPTCHR ROUTINE
? K (ARGUMENT 2) IS NOT WITHIN 1 AND 5, INCLUSIVE
>
		JRST EXFOO]

	MOVE	R4,LIST-1(R2)	;GET LIST, AND...
;THE FOLLOWING LDB LOOKS LIKE:  LDB LST(R3)
;THE LIST 'LST' IS THE LITERAL, AND THE LDB JUST EXECUTES
;FROM THE POINTER REFERENCED BY THE CHARACTER DISPLACEMENT
;BETTER THAN COMPUTING IT ALL THE TIME, EH?
	LDB	R0,[0
		POINT 7,R4,^D6
		POINT 7,R4,^D13
		POINT 7,R4,^D20
		POINT 7,R4,^D27
		POINT 7,R4,^D34](R3)	;TRICKY, EH?
	SETZ	R1,		;RESET SECOND PART
	RETF			;RETURN * * *
;SUBROUTINE CPWHOM
;NO ARGUMENTS
;RETURNS IN 'IDFILE' THE TEXT
;  (SYS)PROG.INF
;PROG GOTTEN FROM GETTAB OF CURRENT PROGRAM NAME
SUBF CPWHOM
	MOVE	R2,[POINT 7,IDFILE]	;ASCII POINTER
	HRROI	R3,3		;GETTAB TABLE 3
	GETTAB	R3,		;GET TABLE
GETFAI:	JRST	[MSG <? RUNTIME ERROR IN CPWHOM ROUTINE
? GETTAB FAILED TO GET PROGRAM NAME
>
		JRST EXFOO]

;CHECK AND SEE IF PROG IS RUNNING OUT OF SYS:
;IF IT IS, THEM PUT (SYS) ON FRONT OF FNAME
	HRROI	R4,-25
	GETTAB	R4,
	JRST	GETFAI		;GETTAB FAILED
	CAME	R4,[1,,4]		;SKIP IF SYS
	JRST	NOTSYS		;NOT SYS
	MOVE	R4,[POINT 7,[ASCIZ /(SYS)/]]
;LOOP TO PUT SYS OUT THERE
	ILDB	R5,R4		;GET CHARACTER
	JUMPE	R5,.+3		;E.O.LIT TERMS IT
	IDPB	R5,R2		;STORE CHARACTER
	JRST	.-3		;LOOP

;GET PROG NAME ON THERE
NOTSYS:	SETZ	R4,
	MOVE	R5,[POINT 6,R3]	;SIXBIT POINT TO R3
;LOOP. WILL PICK OFF CHARACTERS FROM R3
;R4 MUST BE ZERO SO IF 6 CHARACTERS, E.O.LIT WILL BE
;RETURNED ON 7TH ILDB
	ILDB	R6,R5		;GET CHARACTER
	JUMPE	R6,.+4		;E.O.LIT TERMS IT
	ADDI	R6,40		;TO 7 BIT TEXT
	IDPB	R6,R2		;STORE CHARACTER
	JRST	.-4		;LOOP

;PUT ON .INF AND THE E.O.LIT
	MOVE	R3,[POINT 7,[ASCIZ /.INF/]]
	ILDB	R4,R3		;GET CHARATER
	IDPB	R4,R2		;PUT IT OUT
	JUMPN	R4,.-2		;LOOP UNTIL E.O.LIT
	RETF			;RETURN ...
;SUBROUTINE CPOPEN(INFLNO)
;ARG1:INFLNO == PLACE TO STORE NAME OF FILE
;ERROR RETURN CAUSES FOOTRAN I-O ERROR
	EXTERNAL	OPEN
SUBF CPOPEN
	MOVEM	R16,TMPR16#		;SAVE R16
	CALSUB	CPIOCS		;INIT IOCS
	JSA	R16,SAVALL	;ALL REGISTERS SAVED
	MOVEI	R1,IDFILE	;R1:=LOC O FILE NAME
	MOVEI	R2,20+10	;INPUT + DIRECT + CHARACRTER
	MOVEI	R3,CPOFAL	;FAILURE POINT
	MOVEI	R4,2		;2 BUFFERS
	JSP	R17,OPEN	;OPEN FILE .. HOPE
; IF IT RETURNS, IT WAS SUCCESSFUL;
	MOVEM	R1,OPNTM1#	;SAVE OPEN FILE NO.
	JSA	R16,RESALL
	MOVE	R1,OPNTM1	;GET FILE NO.
	MOVE	R16,TMPR16
	MOVEM	R1,.ARG 1	;ARG1:=FILE NO.
	RETF			;RETURN

;FAILURE
CPOFAL:	JSA	R16,RESALL
	JRST	[OUTSTR [ASCIZ /
? RUNTIME ERROR IN CPOPEN ROUTINE
? IOCS:OPEN FAILED TO OPEN THE FILE /]
		OUTSTR	IDFILE	;OUT FNAME
		OUTSTR [ASCIZ /
/]
		JRST EXFOO]
;SUBROUTINE CPCLOS(INFLNO) -- CLOSE IOCS FILE
	EXTERNAL	CLOSE
SUBF CPCLOS
	CALSUB	CPIOCS		;INIT IOCS
	MOVEM	R16,TMPR16	;SAVE R16
	MOVE	R1,.ARG 1	;GET ARGUMENT 1
	JSA	R16,SAVALL	;SAVE IT ALL
	JSP	R17,CLOSE	;CLOSE IOCS WAY
	JSA	R16,RESALL
	MOVE	R16,TMPR16	;GET R16 BACK
	RETF			;RETURN
;SUBROUTINE CPRDCP(INFLNO,CURPOS) -- READ CURSOR POSITION
;ARG1:INFLNO= IOCS INPUT FILE NUMBER
;ARG2:CURPOS RETURNS KURSOR POSITION
	EXTERNAL	CP
SUBF CPRDCP
	MOVEM	R16,TMPR16	;SAVE R16
	JSA	R16,SAVALL	;SAVE ALL REGS
	MOVE	R1,.ARG 1	;GET INFLNO
	JSP	R17,CP		;GET KURSOR POSITION
	MOVEM	R1,RDCTM1#	;SAVE IT
	JSA	R16,RESALL	;GET REGS
	MOVE	R16,TMPR16	;GET R16
	MOVE	R1,RDCTM1
	MOVEM	R1,.ARG 2	;CURPOS_CP(INFLNO)
	RETF			;RETURN
;SUBROUTINE CPWRCP(INFLNO,CURPOS) -- SET CURSOR POSITION
;ARG1:INFLNO= IOCS INPUT FILE NUMBER
;ARG2:CURPOS= CURSOR POSITION TO GO TO
	EXTERNAL	SETCP
SUBF CPWRCP
	MOVEM	R16,TMPR16	;SAVE R16
	JSA	R16,SAVALL	;SAVE ALL REGS
	MOVE	R1,.ARG 1	;1:INFLNO
	MOVE	R2,.ARG 2	;2:CURSOR
	JSP	R17,SETCP	;SET KURSOR POSITION !!
	JSA	R16,RESALL	;GET REGS
	MOVE	R16,TMPR16	;GET R16
	RETF			;RETURN * * *
;SUBROUTINE CPXTR1(IWORD) -- UNPACKS IWORD
;  SEE SPEC, I'M TOO LAZY TO TYPE 30 LINES OF TEXT
; DESCRIBING WHAT THIS THING DOES
; *************************
SUBF CPXTR1
	MOVE	R2,.ARG 1	;GET ARG 1 (==IWORD)
	LDB	R3,[POINT 9,R2,^D35]
	MOVEM	R3,TOKNUM
	LDB	R3,[POINT 6,R2,^D26]
	MOVEM	R3,MTCHNO
	LDB	R3,[POINT 4,R2,^D11]
	MOVEM	R3,ITEMSZ
;
;NOW THAT SEEMED PRETTY STRAIGHT FORWARD, JUST
;UNPACKING BITS BECAUSE FOOTRAN IS NOT AS VERSATILE
;AS ONE MIGHT HAVE BEEN LEAD TO BELIEVE.
;NOW THE FUN PART BEGINS,  GET THE SPEC READY .....
;

;1.SET ALL 36 BITS OF TRMFLG = BIT 0 OF R2
	LDB	R3,[POINT 8,R2,7]
	SETZM	TRMFLG
	TLNE	R2,400000	;CHECK BIT 0
	SETOM	TRMFLG

;2. MOVE THE RIGHTMOST SEVEN BITS OF R3 INTO
;   TRMCHR AND RETURN
	SKIPE	TRMFLG
	JRST	XTR1TR
	MOVEM	R3,TRMCHR	;SET TRMCHR = THOSE 7 BITS
	RETF			;RETURN * * *

;3. OTHERWISE:
;TRMCHR_0
XTR1TR:	SETZM	TRMCHR		;GUESS WHAT
	SETZM	ANFLG
	TLNE	R2,200000
	SETOM	ANFLG		;ANFLG=VALUE OF BIT 1
	SETZM	NANFLG
	TLNE	R2,100000
	SETOM	NANFLG		;NANFLG=VALUE OF BIT 2
	RETF
;SUBROUTINE CPXTR2(IWORD) -- UNPACKS IWORD
;  SEE COMMENT FOR CPXTR1
; ******************
SUBF CPXTR2
	MOVE	R2,.ARG 1	;GET ARGUMENT 1
	LDB	R3,[POINT 18,R2,^D35]
	MOVEM	R3,LSTPTR
	LDB	R3,[POINT 9,R2,^D8]
	MOVEM	R3,NATCHN
	LDB	R3,[POINT 9,R2,^D17]
	MOVEM	R3,TOKCNT
	RETF
;SUBROUTINE LOOKFN
; LOOKS AT FILE NAME
SUBF LOOKFN
	MOVEI	R2,CPINLI
	MOVEM	R2,WHRTGO#		;SET CHAR GETTER
	MOVE	R2,KURSOR
	MOVEM	R2,LOOTM1#		;SAVE KURSOR
	CALSUB	CPFNAM
	JUMPE	R0,LOOFAI		;FAILED ON LOOKUP

;NOW, COPY THE :LOOFIL: AREA TO :IDFILE:
	MOVE	R1,[LOOFIL,,IDFILE]	;COPY LOOFIL->IDFILE
	BLT	R1,IDFILE+4		;5 WORDS (0-4)
	SETOB	R0,R1		;TRUE RETURN
	RETF			;RETURN

CPINLI:	MOVEI	R0,5		;NOWCH CODE 5: RJZF SKIP BLANK
	MOVEM	R0,ALPHA#	;SAVE IN TEMP ADR FOR CALSUB
	CALSUB	NOWCH		;CALL NOWCH ROUTINE
	ARGS	<ALPHA,BETA#>	;ALPHA:INCODE, BETA:KANDO
	AOS	KURSOR		;INC KURSOR (OUR DUTY!)
	SKIPN	BETA		;SKIP IF OKAY CHAR
	JRST	[SETZ R0,	;NOT OKAY, FORCE E.O.LIT
		SOS KURSOR	;RESET KURSOR
		JRST .+1]	;RETURN
; REMEMBER, NOWCH RETURNS CHARACTER IN R0!!
	EXCH	R0,R2		;R2 NOW HAS CHAR (R2_CHAR)
	POPJ	R17,		;RETURN

LOOFAI:	MOVE	R2,LOOTM1
	MOVEM	R2,KURSOR		;RESET KURSOR ON FAIL
	SETZB	R0,R1		;FALSE RETURN
	RETF			;RETURN
;SUBROUTINE IOTEST
; WITH IDFILE SET W/ FNAME, TEST IT FOR IO AND
; RETURN CODES AS PER SPEC (SEE SPEC).
	EXTERNAL	JOBJDA
SUBF IOTEST
; THE LAST KNOWN FILE NAME WAS IN [IDFILE(0:4)]
; SO, WE CALL CPFNAM AND DECODE THE FILE NAME INTO
; A LOOKUP BLOCK
	MOVEI	R0,TGNOF	;WHERE TO GET NAME OF FILE
	MOVEM	R0,WHRTGO	;SET @ CELL
	MOVE	R0,[POINT 7,IDFILE]	;POINTS TO FILE NAME
	MOVEM	R0,GNOFP#	;POINTER TO GET NAME OF FILE
	CALSUB	CPFNAM		;DECODE THE FNAME
	JUMPE	R0,[MOVEI R0,^D11
		SETZ R1,
		RETF]		;SYS ERR: BAD FNAME
; WE NOW HAVE A GOOD [?] FILE NAME IN :LOONAM:
; DO THE DECODING PROCESS
	PUSHJ	R17,SETUP	;SETUP LOOKUP BLOCK [OURS]
; FIND A CHANNEL, R2 WILL CONTAIN IT FROM NOW ON
	SETZ	R2,		;POSSIBLE CHANNELS
	CAMLE	R2,JOBHCU	;IF R2>JOBHCU THEN OKAY
	JRST	.+3
	SKIPN	JOBJDA(R17)	;SKIP IF CHANNEL FREE
	AOJA	R2,.-3		;CONTINUE SEARCH
	CAILE	R2,17		;ONLY 17 POSSIBLE CHANNELS
	JRST	[MOVEI R0,^D7
		SETZ R1,
		RETF]		;NO FREE CHANS LEFT
;OH KAY
;   TES THE FILE
;1. TRY LOOKUP FOR THE USUAL FATAL ERRORS
	XCT	%OPEN(R2)	;OPEN DSK
	JRST	[OUTSTR [ASCIZ /? RUNTIME ERROR IN IOTEST ROUTINE
? CANNOT INIT DEVICE DSK: ON FREE CHANNEL TO TEST /]
		OUTSTR	IDFILE
		OUTSTR	[ASCIZ /
/]
		JRST EXFOO]
	XCT	%LOOKUP(R2)	;EXECUTE LOOKUP
	JRST	.+2
	JRST	STEP2		;OKAY
; FAILURE LOOKUP - FIND OUT WHY
	HRRZ	R5,SCRNAM+1	;GET ERRCODE
	JUMPE	R5,[MOVEI R0,1
		SETZ	R1,
		JRST BACK]	;FILE NOT FOUND - OKAY
	CAIN	R5,2
	JRST	[MOVEI R0,2
		SETZ	R1,
		JRST BACK]	;FILE PROTECT FAILURE
	CAIN	R5,1
	JRST	[MOVEI R0,^D8
		SETZ R1,
		JRST BACK]	;ILL USR NAME
	CAIN	R5,3
	JRST	[MOVEI R0,^D9
		SETZ R1,
		JRST BACK]	;FILE BUSY
	CAIN	R5,6
	JRST	[MOVEI R0,^D10
		SETZ R1,
		JRST BACK]	;BAD ON DSK
	MOVEI	R0,^D11
	SETZ	R1,
	JRST	BACK		;SYS ERR***

;LOOKUP OKAY, FILE EXISTS.
; TRY CODE (6): SUPERCEED
STEP2:	XCT	%CLOSE(R2)	;CLOSE UP FILE
	PUSHJ	R17,SETUP	;SET UP FBLOCK
	XCT	%ENTER(R2)	;TRY AND ENTER THE FILE
	JRST	STEP3		;FAILED.
; SUPERCEED WORKED!!!   ...  RETURN CODE (6)
	XCT	%CLOSE(R2)	;CLOSE THE CHAN
	MOVEI	R0,^D6
	SETZ	R1,
	JRST	BACK		;BACK WE GO

;LOOKUP OKAY, NO SUPERCEED ENTER
; TRY LOOKUP-ENTER
STEP3:	XCT	%CLOSE(R2)	;MAKE SURE CHAN CLOSED
	PUSHJ	R17,SETUP
	XCT	%LOOKUP(R2)	;DO LOOKUP
	JRST	STEP4		;LOOKUP FAILED ???
	PUSHJ	R17,SETUP
	XCT	%ENTER(R2)	;DO ENTER
	JRST	STEP4		;ENTER FAILED
; MODIFIED ENTER WORKS    ...   RETURN CODE (5)
; OR CODE (4) DEPENDING ON WRITE CONDITION OF THE FILE
; TRY OUTPUT FIRST THING. IF IT WORKS, OKAY !!!
	MOVEI	R6,DSKBUF
	EXCH	R6,JOBFF
	XCT	%OUTPUT(R2)	;DUMMY OUTPUT
; NOW MAKE ONE DUMMY BUFFER-FULL
	MOVEM	R6,JOBFF	;RESTORE JOBFF
	IDPB	R6,OBUF+1
	SOS	OBUF+2
	XCT	%OUTPUT(R2)	;DO OUTPUT
	XCT	%GETSTS(R2)	;GET (R4) STATUS OF CHAN
; IF 760000 BIT(S) SET CODE 4 ELSE CODE 5
	TRNE	R4,760000	;SKIP IF NO BITS SET
	SKIPA	R1,[4]		;NO-- CODE 4
	MOVEI	R1,^D5		;YES--COEDE 5
	EXCH	R0,R1
	SETZ	R1,
	XCT	%CLOSE(R2)
	JRST	BACK		; RETURN
	XCT	%CLOSE(R2)	;CLOSE CHAN
	MOVEI	R0,^D5		;CODE (5): MODIFY
	SETZ	R1,
	JRST	BACK		;RETURN

;LOOKUP OKAY, NO LOOKUP-ENTER
; (CAN'T APPEND EITHER)
STEP4:	XCT	%CLOSE(R2)	;CLOSE CHAN
	MOVEI	R0,^D3
	SETZ	R1,
	JRST	BACK

; HERE WHEN ALL DONE
BACK:	XCT	%RELEASE(R2)	;RELEASE CHAN
	RETF			;RETURN * * *
	EXTERNAL	JOBFF,JOBHCU
; SETUP - COPIES A GOOD LOOKUP BLOCK [FROM CPFNAM]
; INTO A SCRATCH LOOKUP BLOCK :SCRNAM:
SETUP:	PUSH	R17,R0		;SAVE R0
	MOVE	R0,[LOONAM,,SCRNAM] ;BLT CODE
	BLT	R0,SCRNAM+3	;BLT IT DOWN
	POP	R17,R0		;POP IT BACK
	POPJ	R17,		;RETURN

SCRNAM:	BLOCK	4		;LOOKUP BLOCK

; TGNOF - ILDB'S FROM :GNOFP:
; W.O.LIT RETURNS C.R.
TGNOF:	ILDB	R2,GNOFP	;GET NEXT CHARACTER
	JUMPN	R2,.+2
	MOVEI	R2,15		;C.R. FOR E.O.LIT
	POPJ	R17,		;RETURN

;IO INST'S INDEXED
DEFINE X(OPCODE,ADDR,AC)<IRP AC<OPCODE AC,ADDR>>

%OPEN:	X<OPEN>,<OPNBLK>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>CLOSE:	X<CLOSE>,<4+10+20+40+100>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%RELEASE: X<RELEASE>,<0>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%LOOKUP: X<LOOKUP>,<SCRNAM>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%INPUT:	X<INPUT>,<0>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%ENTER:	X<ENTER>,<SCRNAM>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%OUTPUT: X<OUTPUT>,<0>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%USETI:	X<USETI>,<(R4)>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%USETO:	X<USETO>,<(R4)>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

%GETSTS: X<GETSTS>,<R4>,<0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17>

OPNBLK:	Z
	SIXBIT	/DSK/
	XWD	OBUF,IBUF

OBUF:	BLOCK	3
IBUF:	BLOCK	3

DSKBUF:	BLOCK	<^D250*4>
; ESCAPE ROUTINES

;SUBROUTINE CPEOFF
; DISARMS ESCAPES
SUBF CPEOFF
	MOVE	R0,[2,,000000]
	SETJAL	R0,
	RETF

;SUBROUTINE CPEON
; ARMS ESCAPES
SUBF CPEON
	SETZ	R0,
	SETJAL	R0,
	RETF
IF1,<PRINTX 1/2 WAY DONE>
IF2,<PRINTX I'M DONE>
END
;SUBROUTINE CPIOCS - INIT'S IOCS IF NEVER DONE B4, ELSE RETURNS
SUBF CPIOCS
	SKIPE	CPFTM2#		;IF ZERO MUST INIT IOCS
	RETF			;IT IS INITED -- RETURN
;INITIALIZE IOCS
	SETZB	R0,R1		;RESET ALL REGISTERS
	MOVEI	R1,2		;2 BUFFERS
	MOVEM	R16,SVR16#
	JSA	R16,SAVALL		;CHECKPOINT REGISTERS
	JSP	R17,IOCS	;INIT IOCS
	MOVE	R16,SVR16
	JSA	R16,RESALL		;RESTORE REGS
	SETOM	CPFTM2		;SET THAT FLAG
	RETF			;RETURN * * *
;COMPAC INTERNAL FOOTRAN LOGICAL FUNCTION CPFNAM
; TAKES CHARACTERS (CELL :WHRTGO: CONTAINS LOCATION OF
; ROUTINE WHICH WILL RETURN ONE CHARACTER AT A TIME)
; AND BUILDS UP SIX BIT FILE NAME BLOCK :LOONAM:
; AND STORES FILE NAME, IN 7-BIT ASCII STRING, E.O.LIT
; TERMINATED, IN :LOOFIL:
;IN STANDARD 3-WORD FORMAT
SUBF CPFNAM
	SETZM	LOONAM
	MOVE	R0,[LOONAM,,LOONAM+1]
	BLT	R0,EOBLTB	;ZERO OUT BLOCK
	MOVE	R2,[POINT 7,LOOFIL]	;POINT FOR RECONSTRUCTION
	MOVEM	R2,FNAPTR#	;POINTER FOR RECONSTRUCTION
	MOVEI	R15,1
	MOVEM	R15,ALPHA
	CALSUB	NOWCH
	ARGS	<ALPHA,BETA>
LOOLB1:	PUSHJ	R17,CPATOM	;GET AN ATOM
	CAIE	R2,"("		;AN OPEN PARENTHESIS
	JRST	LOOLB2		;NO
	IDPB	R2,FNAPTR	;BUILD UP STRING
	SKIPE	LOONAM		;A NAME YET?
	JRST	UBLUIT		;TOO BAD. . .
	JUMPN	R3,UBLUIT	;NON-EMPTY ATOM OMBS
	PUSHJ	R17,CPATOM	;. . GET REST OF ATOM . . .
	CAIE	R2,")"		;MUST TERM W/ OPEN PAREN
	JRST	UBLUIT		;TOO BAD
	IDPB	R2,FNAPTR	;BUILD STRING
	MOVEM	R3,USRNM1#	;SAVE USER NAME
	MOVEM	R4,USRNM2#	;DITTO "
	MOVEI	R2,USRNM1
	MOVEM	R2,LOONAM+3	;SET LOOKUP NAME POINTER
	JRST	LOOLB1		;LOOP

LOOLB2:	CAIE	R2,"."		;DOT ?
	JRST	LOOLB3
	IDPB	R2,FNAPTR	;BUILD STRING
	SKIPE	LOONAM		;NULL EXT ILLEG.
	JRST	UBLUIT		;BYE . . .
	JUMPN	R4,UBLUIT	;ONLY SIX CHAR ATOM
	MOVEM	R3,LOONAM
	JRST	LOOLB1		;LOOP

LOOLB3:	; DONE HERE WITH THE FNAME
	SKIPE	LOONAM
	JRST	LOOLB4		;EXT MUST BE ENTERED
	JUMPN	R4,UBLUIT	;1 WORD ATOM ONLY
	MOVEM	R3,LOONAM
	JRST	LOORET		;RETURN * * *

LOOLB4:	; HERE ON EXT. 
	SKIPE	LOONAM+1
	JRST	UBLUIT		;EXT. MUST BE NULL
	TRNE	R3,777777
	JRST	UBLUIT		;EXT. 3 CHAR
	JUMPN	R4,UBLUIT	;1 WORD ATOM ONLY
	MOVEM	R3,LOONAM+1	;SAVE EXT
	JRST	LOORET		;RETURN * * *

UBLUIT:	SETZB	R0,R1		;RESET ALL THAT
	RETF			;RETURN * * *

LOORET:	SETOB	R0,R1		;TRUE RETURN
; ** NOW CHECK AND SEE IF FILE NAME IS BLANK
; ** IF SO, BYE BYE LOVE **
	SKIPN	LOONAM		;IF = 0 THEN F IT
	JRST	UBLUIT		;U BLU IT CHARLEY
	SETZ	R2,		;E.O.LIT CHARACTER
	IDPB	R2,FNAPTR	;PUT E.O.LIT ON STRING
	RETF			;RETURN * * *

LOONAM:	BLOCK	4		;PLACE FOR 4-WORD 6-BIT STR
LOOFIL:	BLOCK	5		;PLACE FOR FNAME 7-BIT STR
EOBLTB:	Z				;LAST ZERO'D LOCATION
;SUBROUTINE NOWCH(INCODE,KANDO) -- CALLED FROM COMPAC,
;IT GET'S THE NEXT CHARACTER FROM THE INPUT LINE
;ARG1:INCODE (FOR PACKER), ARG2:KANDO (RETURNS VALUE -1 OR 0)
SUBF NOWCH
	MOVE	R2,.ARG 1	;GET THE FIRST ARGUMENT [INCODE]
;CHECK VALID RANGE ( 1<=INCODE<=8 )
	CAIL	R2,1
	CAILE	R2,^D8		;SKIP IF 1<=R2<=8
	JRST	[MSG <? RUNTIME ERROR IN NOWCH ROUTINE
? INCODE (ARGUMENT 1) IS NOT WITHIN 1 AND 8, INCLUSIVE
>
		JRST EXFOO]
			;REMEMBER THAT R2 = INCODE
	MOVE	R3,KURSOR	;OUR KURSOR
			;REMEMBER THAT R3 = KURSOR (OUR VERSION)

;LOOP ON CHARACTER SCAN
;INLINE-1 IS USED BECAUSE WE ARE BASE 0 ARRAY AND
;FORTRAN IS BASE 1 ARRAY
NOWCHA:	MOVE	R5,INLINE-1(R3)	;GET CHARACTER
	JUMPE	R5,NOWCHB	;ZERO-GO.
	CAIN	R5," "		;IS IT A BLANK ??
	JRST	NOWCHC		;YES - PROCESS IT

;HERE ON OTHER
NOWCHD:	TRUE	.ARG 2		;SET KANDO [ARG 2] = -1
	MOVEM	R5,NOWTM1#	;SET ARGS FOR CALL
	MOVEM	R2,NOWTM2#	;ARG1:CHAR, ARG2:INCODE
	CALSUB	CPPACK		;CALL PACKER
	ARGS	<NOWTM1,NOWTM2>	;ARGUMENTS 1 AND 2
	MOVE	R0,NOWTM1	;GET ADJUSTED CHARACTER
	SETZ	R1,		;ONLY 1 WORD RETURN
	MOVEM	R3,KURSOR	;RESET KURSOR
	RETF			;RETURN * * *

;HERE ON ZERO WORD [OR BAD]
NOWCHB:	FALSE	.ARG 2		;SET KANDO TO ZERO [FALSE]
	SETZB	R0,R1		;ZERO RETURN
	RETF			;RETURN * *0*

;HERE ON BLANK
NOWCHC:	CAILE	R2,4		;IF INCODE <=4 THEN NO BLANK
	JRST	NOWCHD		;OKAY - GO
	AOJA	R3,NOWCHA	;IGNORE BLANK - REPROCESS
;SUBROUTINE CPPACK(C,INCODE) -- ARG1 IS CHARACTER,
;ARG2 IS INCODE, AS FOLLOWS:
;	1 RJZF
;	2 RJBF
;	3 LJZF
;	4 LJBF
;	5 RJZF
;	6 RJBF
;	7 LJZF
;	8 LJBF
;SO, 1-4 AND 5-8 ARE THE SAME
SUBF CPPACK
	MOVE	R2,.ARG 1	;GET CHARACTER IN R2
	MOVE	R3,.ARG 2	;GET INCODE
	JRST	.(R3)		;BRANCH TO DECODER
;BRANCH TABLE
	JRST	PKRJZF
	JRST	PKRJBF
	JRST	PKLJZF
	JRST	PKLJBF
	JRST	.-4
	JRST	.-4
	JRST	.-4
	JRST	.-4
;ROUTINES FOLLOW....
;PKRJZF: RIGHT-JUSTIFIED [NO SHIFT] AND ZERO FILLED
PKRJZF:	ANDI	R2,177		;AND OUT CHARACTER
	JRST	PKRETF
;PKRJBF: RIGHT-JUSTIFIED AND BLANK FILLED
PKRJBF:	ANDI	R2,177		;GET CHARACTER
	ADD	R2,[ASCII /    /]	;PUT IN 4 SPACES
	JRST	PKRETF
;PKLJZF: LEFT JUSTIFIED AND ZERO FILLED
PKLJZF:	ANDI	R2,177		;GET CHARACTER
	LSH	R2,<^D36-^D7>	;SHIFT CHARACTER
	JRST	PKRETF
;PKLJBF: REALLY HAVE FUN, LEFT JUSTIFIED AND BLANK FILLED
;THIS CHEATS, LOADS R3 WITH SPACES AND SHIFTS UP
PKLJBF:	MOVE	R3,[ASCII /     /]
	ANDI	R2,177
	LSHC	R2,<^D36-^D7>	;SHIFT IT ALL UP
	JRST	PKRETF

;WHEN DONE, HERE WE GO
PKRETF:	MOVEM	R2,.ARG 1	;STORE CHARACTER OUT
	RETF			;ALL DONE
;SUBROUTINE CPATOM
; CELL :WHRTGO: IS ROUTINE TO GET CHARACTER
; RETURNS WITH ATOM IN R3 AND R4 (TWO WORD ATOM)
; TERMINATOR IS IN R2
; ALSO, APPENDS CHARACTERS TO STRING POINTER :FNAPTR:
; CALLED BY PUSHJ
; MAY DESTROY ALL REG EXCEPT R16 AND R17
CPATOM:	MOVE	R5,[POINT 6,R3]
	MOVEI	R6,^D12
	SETZB	R3,R4		;RESET ATOM FINDER

ATOMX1:	PUSHJ	R17,@WHRTGO
	CAIL	R2,"A"
	CAILE	R2,"Z"
	JRST	.+2
	JRST	ATOMX2
	CAIL	R2,"0"
	CAILE	R2,"9"
	POPJ	R17,		;ALL DONE, NOT A-Z 1-9
ATOMX2:	IDPB	R2,FNAPTR		;APPEND CHARACTER
	SUBI	R2,40
	SOJLE	R6,ATOMX1	;IGNORE PAST 12 CHARS
	IDPB	R2,R5		;STORE CHARACTER
	JRST	ATOMX1		;LOOP
  'o'º