!**COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD MA 01754**
!AUTHOR NORMA ABEL/HPW
GLOBAL BIND DOXPV = 1^18 +67;		!VERSION DATE: 30-OCT-1973
%*****
	TAKE A NUMBER AND MAKE 4 SIXBIT DIGITS OUT OF IT
	USED TO GENERATE TEMPORARY NAMES
*****%

MACRO MAKNAME(NUMB)=
	(.NUMB<9,3>+16)^18 + (.NUMB<6,3>+16)^12 + (.NUMB<3,3>+16)^6
	+ (.NUMB<0,3>+16)$;
FORWARD INITLTEMP,SSIZTMP;
GLOBAL ROUTINE DOXPN(CNODE)=
BEGIN


	EXTERNAL CORMAN,NEWENTRY,FLINK,KARIAB,KARIIB;
	EXTERNAL C1L,C1H,C2L,C2H,TBLSEARCH,CNVNODE;
	EXTERNAL COPRIX,SPKABA,CNSTCM,EXPRTYPER,MAKPR1;
	EXTERNAL KDPRL;
	!CREATE DO LOOP CONTROL EXPRESSION
	!CNODE POINTS TO DO STATEMENT ENCODED SOURCE
	MAP BASE CNODE;
	OWN	DOINITL,					!POINTER TO INITIAL VALUE
	DOULIM,						!POINTER TO UPPER LIMIT
	DOSTEPSIZ,					!POINTER TO STEP SIZE;0 IF STEP SIZE IS 1
	DOSYMBOL,					!POINTER TO INDUCTION VARABLE
	DOCESSOR,					!PREDECESSOR OF DO STATEMENT
	OPEXPR,						!TEMPORARY
	PEXPR;						!TEMPORARY
	OWN SSIZMINUSONEFLG;	!SET THIS FLAG IF STEP SIZE IS MINUS ONE
	OWN BASE T;		!TEMPORARY
	MAP PEXPRNODE DOCESSOR;
	MAP PEXPRNODE DOSYMBOL:DOINITL:DOULIM:DOSTEPSIZ:PEXPR:OPEXPR;

	!MACRO WILL MOVE LABEL ON THE DO STATEMENT ITSELF (IF ANY)
	!BACK TO THE STEP SIZE COMPUTATION OR INITIAL VALUE
	!COMPUTATION IF THESE ARE PRESENT
	MACRO ADJLAB=
		IF .CNODE[SRCLBL] NEQ 0 THEN
		BEGIN
			LOCAL BASE TMP;
			OPEXPR[SRCLBL]_.CNODE[SRCLBL];
			CNODE[SRCLBL]_0;
			TMP_.OPEXPR[SRCLBL];
			TMP[SNHDR]_.OPEXPR;
		END$;

	DOSYMBOL_.CNODE[DOSYM];
	DOSYMBOL[IDATTRIBUT(STORD)]_1;	%1(67)-113%	!SET STORD FOR INDEX
	DOINITL_.CNODE[DOM1];
	DOULIM_.CNODE[DOM2];
	DOSTEPSIZ_.CNODE[DOM3];
	DOCESSOR_.CNODE[DOPRED];
	CNODE[NEDSMATRLZ]_1;		!SET BIT OPTIMIZER WILL RESET


	!IF EITHER OF THE LIMITS OR THE STEP SIZE IS A NEGATIVE OF A CONSTANT,
	! FOLD THAT NEGATION HERE SO THAT THE GENERATED CODE FOR
	!       DO 10 I=10,1,-1
	! WILL NOT TREAT THE -1 AS AN ARBITRARY EXPRESSION(SRM-FEB 9,1973)
	IF .DOINITL[OPR1] EQL NEGFL
	THEN
	BEGIN
		T_.DOINITL[ARG2PTR];	!ARG UNDER THE NEG
		IF .T[OPR1] EQL CONSTFL THEN DOINITL_NEGCNST(T);
	END;
	IF .DOULIM[OPR1] EQL NEGFL
	THEN
	BEGIN
		T_.DOULIM[ARG2PTR];	!ARG UNDER THE NEG
		IF .T[OPR1] EQL CONSTFL THEN DOULIM_NEGCNST(T);
	END;
	IF .DOSTEPSIZ[OPR1] EQL NEGFL
	THEN
	BEGIN
		T_.DOSTEPSIZ[ARG2PTR];	!ARG UNDER THE NEG
		IF .T[OPR1] EQL CONSTFL THEN DOSTEPSIZ_NEGCNST(T);
	END;


	!IF EITHER OF THE LIMITS OR THE STEP SIZE HAS A DIFFERENT VAL-TYPE FROM
	! THE INDUCTION VARIABLE, MUST PERFORM TYPE CONVERSION (SRM-OCT 6,1972)
	IF .DOINITL[VALTP2] NEQ .DOSYMBOL[VALTP2] THEN DOINITL_CNVNODE(.DOINITL,.DOSYMBOL[VALTYPE],0);
	IF .DOULIM[VALTP2] NEQ .DOSYMBOL[VALTP2] THEN DOULIM_CNVNODE(.DOULIM,.DOSYMBOL[VALTYPE],0);
	IF .DOSTEPSIZ[VALTP2] NEQ .DOSYMBOL[VALTP2] THEN DOSTEPSIZ_CNVNODE(.DOSTEPSIZ,.DOSYMBOL[VALTYPE],0);




	IF .DOSYMBOL[VALTP1] NEQ INTEG1
	THEN
		 CNODE[REALARITH]_1;
	PEXPR_0;

	%(***SET "PEXPR" TO POINT TO AN EXPRESSION NODE FOR "M2-M1"
		THIS WILL BE USED IN THE COMPUTATION OF THE LOOP ITERATION CT***)%
	IF .DOULIM[OPR1] EQL CONSTFL AND .DOINITL[OPR1] EQL CONSTFL THEN
	BEGIN
		COPRIX_KKARITHOP(.DOINITL[VALTP1],SUBOP);
		C1H_.DOULIM[CONST1];
		C1L_.DOULIM[CONST2];
		C2H_.DOINITL[CONST1];
		C2L_.DOINITL[CONST2];
		CNSTCM();
		PEXPR_MAKECNST(.DOINITL[VALTYPE],.C2H,.C2L);
	END

	ELSE
	!IF NOT BOTH CONSTANTS, BUILD EXPRESSION
	BEGIN
		!BUILD AN EXPRESSION NODE
		!CHECK THE PROPERTIES OF THE INITIAL VALUE
		!BAD RESULTS (IN CODE) IF IT IS A CONSTANT EXPRESSION
		!AS WE WILL NOT FOLD IT HERE

		IF .DOINITL[OPRCLS] NEQ DATAOPR THEN
		BEGIN
			CNODE[INITLTMP]_1;	!SET FLAG
			!MAKE AN ASSIGNMENT STATEMENT FOR IT
			!OPEXPR IS USED AS A TEMPORARY
			FLINK _ .DOCESSOR;
			NAME _ IDOFSTATEMENT _ ASGNDATA;
			NAME<RIGHT> _ SORTAB;
			OPEXPR _ NEWENTRY();
			OPEXPR[A1VALFLG]_1;		!THE TEMP
			OPEXPR[LHEXP]_INITLTEMP(.DOINITL[VALTYPE]);
			OPEXPR[RHEXP]_.DOINITL;
			DOINITL[PARENT]_.OPEXPR;
			!RESET DOPRED  IN THE DO STATEMENT
			CNODE[DOPRED]_.OPEXPR;
			!RESET MY LOCALS FOR THE RIGHT THING
			DOINITL_.OPEXPR[LHEXP];
			DOCESSOR_.OPEXPR;
			!MOVE THE LABEL BACK IF THERE IS ONE
			ADJLAB;
		END;

		PEXPR_MAKPR1(.CNODE,ARITHMETIC,SUBOP,.DOULIM[VALTYPE],.DOULIM,.DOINITL);
		OPEXPR_.PEXPR[ARG1PTR];
		PEXPR[A1VALFLG]_.OPEXPR[OPRCLS] EQL DATAOPR;
		OPEXPR_.PEXPR[ARG2PTR];
		PEXPR[A2VALFLG]_.OPEXPR[OPRCLS] EQL DATAOPR;
	END;


	!LOOK AT THE STEP SIZE


	SSIZMINUSONEFLG_FALSE;		!FLAG FOR STEP SIZE = -1, INIT TO FALSE

	IF .DOSTEPSIZ[OPR1] EQL CONSTFL THEN
	BEGIN
		!CHECK FOR STEP SIZES ONE AND MINUS ONE
		IF .DOSTEPSIZ[VALTYPE] EQL REAL THEN
		BEGIN
			%(***FOR REALS- MUST ROUND FROM 2 WDS OF PREC TO ONE BEFORE
				EXAMINING THE VALUE (KEEP THEM AS UNROUNDED 2 WD VALS
				INSIDE THE COMPILER) ***)%
			C1H_.DOSTEPSIZ[CONST1];	!SET GLOBALS FOR THE ASSEMBLY LANG
			C1L_.DOSTEPSIZ[CONST2];		! THAT ROUNDS THE CONST
			COPRIX_KDPRL;
			CNSTCM();			!ROUND - LEAVE RESULT IN C2H

			IF .C2H EQL #201400000000 THEN
				CNODE[SSIZONE]_1
			ELSE IF .C2H EQL #576400000000
			THEN
				SSIZMINUSONEFLG_TRUE
		END ELSE
		IF .DOSTEPSIZ[VALTP1] EQL INTEG1 THEN
		BEGIN
			IF .DOSTEPSIZ[CONST2] EQL 1 THEN
				CNODE[SSIZONE]_1
			ELSE IF .DOSTEPSIZ[CONST2] EQL -1 THEN
				SSIZMINUSONEFLG_TRUE
		END
		ELSE
		%(***FOR DOUBLE PRECISION AND COMPLEX - DONT BOTHER OPTIMIZING THE -1 CASE***)%
		BEGIN
			IF .DOSTEPSIZ[CONST1] EQL #201400000000 AND .DOSTEPSIZ[CONST2] EQL 0
			THEN CNODE[SSIZONE]_1
		END;

	END;		!STEP SIZE NOT A CONSTANT
	IF .DOSTEPSIZ[OPRCLS] NEQ DATAOPR THEN
	BEGIN
		!STEP SIZE REALLY REQUIRES A COMPUTATION.
		!MAKE AN ASSIGNMENT STATEMENT FOR IT AND PUT
		!IT IN FRONT OF THE DO STATEMENT
		FLINK _ .DOCESSOR;
		NAME _ IDOFSTATEMENT _ ASGNDATA;
		NAME<RIGHT> _ SORTAB;
		OPEXPR _ NEWENTRY();
		OPEXPR[A1VALFLG]_1;
		OPEXPR[LHEXP]_SSIZTMP(.DOSTEPSIZ[VALTYPE]);
		DOSTEPSIZ[PARENT]_.OPEXPR;
		OPEXPR[RHEXP]_.DOSTEPSIZ;
		!FIX FIELDS IN DO STATMENT NODE
		CNODE[DOPRED]_.OPEXPR;
		!FIX LOCALS
		DOSTEPSIZ_.OPEXPR[LHEXP];
		!SET FLAG
		CNODE[SSIZINTMP]_1;
		!MOVE THE LABEL BACK
		ADJLAB;
	END;


		CNODE[DOSSIZE]_.DOSTEPSIZ;
		CNODE[DOCTLVAR]_SSIZTMP(INTEGER);

	!NOW MAKE THE LOOP CONTROL EXPRESSION

	IF NOT .CNODE[SSIZONE] THEN
	BEGIN
		OPEXPR_.PEXPR;
		IF .DOSTEPSIZ[OPR1] EQL CONSTFL AND .PEXPR[OPR1] EQL CONSTFL
			AND .PEXPR[VALTYPE] NEQ COMPLEX   !CANNOT FOLD COMPLEX DIVIDE
		 THEN
		BEGIN
			!CONSTANTS OF SAME TYPE
			COPRIX_KKARITHOP(.PEXPR[VALTP1],DIVOP);
			C1H_.PEXPR[CONST1];
			C1L_.PEXPR[CONST2];
			C2H_.DOSTEPSIZ[CONST1];
			C2L_.DOSTEPSIZ[CONST2];
			CNSTCM();
			PEXPR_MAKECNST(.PEXPR[VALTYPE],.C2H,.C2L);
		END
		ELSE
		IF .SSIZMINUSONEFLG
		THEN
		BEGIN
			!FOR STEP SIZE EQUAL TO MINUS 1, NEGATE THE DIFFERENCE BETWEEN
			! THE BOUNDS RATHER THAN DIVIDING IT BY -1
			PEXPR_MAKPR1(.CNODE,NEGNOT,NEGOP,.PEXPR[VALTYPE],0,.PEXPR);
			IF .OPEXPR[OPR1] EQL DATAOPR 
			THEN PEXPR[A2VALFLG]_1
			ELSE OPEXPR[PARENT]_.PEXPR;
		END
		ELSE
		BEGIN
			PEXPR_MAKPR1(.CNODE,ARITHMETIC,DIVOP,.PEXPR[VALTYPE],.PEXPR,.DOSTEPSIZ);
			IF .OPEXPR[OPRCLS] NEQ DATAOPR	!(IF OPEXPR IS A SCALAR VARIABLE,
			THEN				! DO NOT SET PARENT PTR IN IT - SRM)
			OPEXPR[PARENT]_.PEXPR;
			!CHECK OUT THE VALFLAGS
			OPEXPR_.PEXPR[ARG1PTR];
			PEXPR[A1VALFLG]_.OPEXPR[OPRCLS] EQL DATAOPR;
			OPEXPR_.PEXPR[ARG2PTR];
			PEXPR[A2VALFLG]_.OPEXPR[OPRCLS] EQL DATAOPR;
		END;
	END;

	!CONVERT THE QUOTIENT(WHICH IS TO BE USED AS A LOOP COUNT) TO INTEGER
	! IF IT IS NOT INTEGER
	IF .PEXPR[VALTYPE] NEQ INTEGER THEN
	PEXPR_CNVNODE(.PEXPR,INTEGER,0);

	!ADD ONE TO THE QUOTIENT (WHICH HAS BEEN CONVERTED TO INTEGER)
	IF .PEXPR[OPR1] EQL CONSTFL
	THEN PEXPR_MAKECNST(INTEGER,0,.PEXPR[CONST2]+1)
	ELSE
	BEGIN
		OPEXPR_MAKECNST(INTEGER,0,1);
		PEXPR_MAKPR1(.CNODE,ARITHMETIC,ADDOP,INTEGER,.PEXPR,.OPEXPR);
	END;



!IF LOOP CAN BE HANDLED WITH AN AOBJN, MAKE LOOP CONTROL CONSTANT
IF .PEXPR[OPR1] EQL CONSTFL		!NUMBER OF ITERATIONS A COMPILE TIME CONSTANT
	 AND NOT .CNODE[REALARITH]	! LOOP INDEX MUST BE INTEGER 
	 AND .CNODE[SSIZONE]		!STEP SIZE MUST BE ONE
	AND .DOINITL[CONST2] LEQ #377777	!LOWER BOUND ON INDEX MUST BE LESS THAN 17 BITS
	AND .DOINITL[CONST2] GEQ 0		! AND MUST BE POSITIVE
	AND .DOULIM[CONST2] LEQ #377777		!UPPER BOUND ON INDEX MUST BE LESS THAN 17 BITS
	AND .DOULIM[CONST2] GEQ 0		! AND MUST BE POSITIVE
THEN
BEGIN
	OWN CT;
	CT_ABS(.PEXPR[CONST2]);
	PEXPR_MAKECNST(INTEGER,0,-.CT^18+.DOINITL[CONST2]);
	CNODE[OTHDOFLGS]_0;		!RESET ALL OTHER FLAGS
	CNODE[FLCWD]_1;
END ELSE
	!SET SOME OTHER FLAGS DESCRIBING THE CONTROL WORD (IF ITS CONSTANT)
	IF .PEXPR[OPR1] EQL CONSTFL THEN
	BEGIN
		%(***IF THE NUMBER OF TIMES THAT THE LOOP IS TO BE EXECUTED IS A POS
			NUMBER THAT CAN BE USED IMMEDIATE MODE, DO SO. FOR A NEG
			ITERATION COUNT, DONT BOTHER. (NOTE THAT CAN COUNT ON THE CT BEING 
			AN INTEGER***)%
		IF .PEXPR[CONST2] GEQ 0 AND .PEXPR[CONST2] LEQ #777777
		THEN
			CNODE[CTLIMMED]_1;
		CNODE[CTLNEG]_1;
	END ELSE
		IF .PEXPR[OPRCLS] EQL DATAOPR THEN
			CNODE[CTLNEG]_1
		ELSE
	!INSERT THE NEGATE NODE NEEDED
	PEXPR_MAKPR1(.CNODE,NEGNOT,NEGOP,INTEGER,0,.PEXPR);




CNODE[DOLPCTL]_.PEXPR;
CNODE[DOM1]_.DOINITL;		!INITIAL VALUE FOR LOOP INDEX
END;

EXTERNAL
	SSIZTC,			!COUNTER FOR STEP SIZE TEMPS
				!GENERATED FOR DO LOOPS
	INTLTC;			!COUNTER FOR TEMPS GENERATED
				!FOR DO LOOP INITIAL VALUES
%*****
	NOTE THAT THE NAMES WILL NOT BE UNIQUE OR VALID IF THERE
	ARE MORE THAN 9999 FOR EACH
*****%


!************************************

GLOBAL ROUTINE SSIZTMP(SSIZ)=
BEGIN
EXTERNAL TBLSEARCH;

!CREATE A STEP SIZ TEMPORARY FOR DO LOOPS

LOCAL STPTMP;
MAP BASE STPTMP;

	NAME_IDTAB;
	ENTRY[0]_SIXBIT'.S'+MAKNAME(SSIZTC);
	SSIZTC_.SSIZTC+1;		!ADD A SIXBIT 1
	STPTMP_TBLSEARCH();		!LOOK UP
	STPTMP[VALTYPE]_.SSIZ;
	!SET THE VALUE TYPE OF THE VARIABLR
	.STPTMP
END;

!***************************************

GLOBAL ROUTINE INITLTEMP(IVAL)=

BEGIN
EXTERNAL TBLSEARCH;

!MAKE AN INITIAL VALUE TEMPORARY

LOCAL ITLTMP;
MAP BASE ITLTMP;

!IVAL POINTS TO THE DO NODE INITIAL VALUE

	NAME_IDTAB;
	ENTRY[0]_SIXBIT'.I'+MAKNAME(INTLTC);
	INTLTC_.INTLTC+1;		!ADD SIX BIT ONE
	ITLTMP_TBLSEARCH();
	ITLTMP[VALTYPE]_.IVAL;
	.ITLTMP
END;



GLOBAL ROUTINE IODOXPN(IOSTMNT)=
%(***************************************************************************
	ROUTINE TO WALK THRU AN IOLIST AND PERFORM DOXPN ON ALL IMPLICIT
	DO STMNT NODES. SETS THE "DOPRED" FIELD OF EACH DO STMNT NODE
	BEFORE CALLING DOXPN.
	CALLED WITH A PTR TO THE IO STMNT FOR WHICH THE IOLIST IS TO BE
	PROCESSED.
***************************************************************************)%
BEGIN
	EXTERNAL CORMAN;
	MAP BASE IOSTMNT;
	OWN PEXPRNODE IOLPTR;
	OWN PEXPRNODE PRVELEM;	!PTR TO THE ELEMENT IN THE IOLIST PRECEEDING
					! THE ELEMENT POINTED TO BY IOLPTR


	IF (IOLPTR_.IOSTMNT[IOLIST]) EQL 0
	THEN RETURN;		!IF STMNT HAS NO IOLIST

	%(***IF THE FIRST ELEMENT IN THE IOLIST IS A DO-STMNT, INSERT A 
		CONTINUE STMNT IN FRONT OF IT FOR THE "DOPRED" FIELD
		OF THE DO STMNT TO POINT BACK TO***)%
	IF .IOLPTR[OPERATOR] EQL DOSTATEMENT
	THEN
	BEGIN
		NAME_CONTDATA;
		PRVELEM_CORMAN();
		PRVELEM[OPERATOR]_CONTSTATEMENT;
		PRVELEM[CLINK]_.IOLPTR;
		IOSTMNT[IOLIST]_.PRVELEM;
	END;


	%(***WALK THRU SUCCESSIVE ELEMS OF THE IOLIST. SET THE "DOPRED" FIELD
		OF EACH DO-STMNT NODE TO PT TO THE NODE PRECEEDING IT. CALL
		DOXPN FOR EACH DO STMNT NODE***)%
	%(** IF HAVE AN EXPRESSION NODE UNDER A DATACALL, FILL
		IN THE PARENT POINTER)%
	UNTIL .IOLPTR EQL 0
	DO
	BEGIN
		IF .IOLPTR[OPERATOR] EQL DOSTATEMENT
		THEN
		BEGIN
			IOLPTR[DOPRED]_.PRVELEM;
			DOXPN(.IOLPTR);
		END
		ELSE
		IF .IOLPTR[OPERATOR] EQL DATACLFL
		THEN
		BEGIN
			OWN PEXPRNODE T;
			T _ .IOLPTR[DCALLELEM];

			IF .T NEQ 0		!IF THERE WAS AN ERROR FOUND WHEN
						! PROCESSING THIS DATA ELEMNT (EG
						! AN ILLEGAL ARRAYREF)
			THEN
			BEGIN
				IF .T[OPRCLS] NEQ DATAOPR
				THEN
				T[PARENT] _ .IOLPTR
			END;
		END;

		%(***GO ON TO THE NEXT ELEMENT***)%
		PRVELEM_.IOLPTR;
		IOLPTR_.IOLPTR[CLINK];
	END;
END;
FORWARD ALLONES;


ROUTINE ADJGEN(DTABB,ARY)=
BEGIN
	!GENERATE ACTUAL FN(CALL STATEMENT)
	!NODE FOR CALL TO RUN-TIME
	!ROUTINES FOR ADJUSTABLE DIMENSIONS

	LABEL ARGDO;
	OWN BASE CALNODE;
	EXTERNAL FLINK,NEWENTRY,CSTMNT,CORMAN,ONEPLIT;
	MAP BASE CSTMNT;
	EXTERNAL TBLSEARCH;
	MAP BASE DTABB: ARY;
	OWN BASE G:ROUT:DNUM:J;
	OWN DIMSUBENTRY DSUBETRY;
	OWN ARGUMENTLIST CLNODLST;

	FLINK _ .CSTMNT;
	NAME _ IDOFSTATEMENT _ CALLDATA;
	NAME<RIGHT> _ SORTAB;
	CALNODE _ NEWENTRY();
	G_ALLONES(.DTABB);

	!THE SPECIAL PURPOSE ROUTINE FOR ALL LOWER BOUND OF
	!ONE WILL BE CALLED ONLY IF IT IS ALSO TRUE THAT
	!ALL DIMENSIONS ARE ADJUSTABLE. WE NOW DETERMINE THAT FACT
	!BY SEEING IF THE SECOND ONE IS ADJUSTABLE. THE
	!FIRST ONE ALWAYS HAS A FACTOR OF ONE .

	IF .DTABB[DIMNUM] GTR 1 THEN
	BEGIN
		DSUBETRY_.DTABB+4;	!SECOND ONE
		IF NOT .DSUBETRY[VARFACTFLG] THEN G_0;
	END;

	IF .G THEN
	ENTRY_SIXBIT'ADJ1. '
	ELSE
	ENTRY_SIXBIT'ADJG. ';

	NAME_IDTAB;
	ROUT_TBLSEARCH();
	!FILL IN THE POINTER TO THE FUNCTION NAME
	CALNODE[CALSYM]_.ROUT;
	IF .FLAG THEN
	ELSE
	ROUT[OPERSP]_FNNAME;
	DNUM_.DTABB[DIMNUM];

	!COMPOSE THE ARGUMENT LIST FOR A CALL TO
	!ADJ1.OR ADJG.


	!FIRST GET THE CORE FOR THE LIST
	NAME<LEFT>_(3-.G)*(.DNUM)+6;
	!FOR EACH DIMENSION
	!ONE WORD FOR U(I)			!MAYBE ONE FDR L(I)
	!ONE WORD FOR MULT(I)
	!=(2 OR 3)*DNUM
	!+
	!ONE WORD FOR OFFSET
	!+
	!ONE WORD FOR NUMBER OF DIMENSIONS
	!+
	!WORD THAT CONTAINS NUMBER OF PARAMETERS
	!+
	!ZERO HEADER WORD (FILLED IN IN CODE
	!+
	!WORD FOR ARRAY SIZE
	!+
	!WORD FOR BASE ADDRESS OF ARRAY
	!GENERATION WITH LABEL FOR GENERATED
	!ARG LIST

	CLNODLST_CALNODE[CALLIST]_CORMAN();
	!FILL IN ARG LIST
	!FIRST THE NUMBER OF ARGUMENTS

	CLNODLST[ARGCOUNT]_.NAME<LEFT>-2;

	!NOW FILL IN THE ARGUMENT LIST.
	!J POINTS TO ARG ENTRY WHILE THE INCR LOOP
	!GOES THROUGH ALL DIMENSIONS
	!THE FIRST ARGUMENT WE WILL FIRST FILL IN IS UB(1)
	!WHUCH IS THE FOURTH ARGUMENT,THUS J=4.
	!THEN MULT(2) WHICH IS THE DIMFACTOR FROM THE
	!DIMENSION SUBENTRY AFTER THE ONE CONTAINING UB(1).
	J_6;
	DSUBETRY_.DTABB+2;
	!IN ORDER FOR THE LOOP TO OPERATE CORRECTLY, WE ARE
	!NOT DOING WHAT IT APPEARS WE ARE DOING. WE WILL
	!FILL IN MULT(1), UB(1),.....MULT(N),UB(N) AND
	!THEN SINCE MULT(1) IS SPECIAL REALLY FILL IT IT LATER
	!ROUT WILL BE USED AS A TEMP TO
	!HELP US SAVE THE RIGHT THING TO PUT INTO MULT(1)
	!LATER.
	!A DOUBLE PRECISION OR COMPLEX ARRAY STARTS OUT AT TWO
	IF .ARY[DBLFLG] THEN ROUT_MAKECNST(INTEGER,0,2)
	ELSE
	BEGIN
		IF .ARY[VALTYPE] EQL STRING THEN ROUT _ MAKECNST(INTEGER,0,((.ARY[IDSTRCAP] +4)/5))
		ELSE ROUT_.ONEPLIT;
	END;

	ARGDO:
	INCR I FROM 1 TO .DNUM DO
	BEGIN
			!HOLE FOR PARTIALLY CONSTANT ONES
			CLNODLST[.J,ARGNPTR]_.DSUBETRY[DIMUB];
			CLNODLST[.J,AVALFLG]_1;
			IF NOT .G THEN
			BEGIN
			!ALL LOWER BOUNDS ARE NOT 1
				J_.J+1;
				CLNODLST[.J,ARGNPTR]_.DSUBETRY[DIMLB];
				CLNODLST[.J,AVALFLG]_1;
			END;
			!DONT PUT OUT FACTOR FOR LAST ONE
			IF .I EQL .DNUM THEN LEAVE ARGDO;
			DSUBETRY_.DSUBETRY+2;
			J_.J+1;
			CLNODLST[.J,ARGNPTR]_.DSUBETRY[DIMFACTOR];
			CLNODLST[.J,AVALFLG]_1;
			J_.J+1;
	END;							!INCR LOOP

	!FILL IN ARGUMENT 1, THE NUMBER
	!OF DIMENSIONS
	
	CLNODLST[1,ARGNPTR]_MAKECNST(INTEGER,0,.DNUM);
	CLNODLST[1,AVALFLG]_1;
	!FILL IN ARRAY SIZE
	CLNODLST[2,ARGNPTR]_.DTABB[ARASIZ];
	CLNODLST[2,AVALFLG]_1;
	!FILL IN ARGUMENT 2, BASE ADDRESS OF ARRAY
	CLNODLST[3,ARGNPTR]_.ARY;
	CLNODLST[3,AVALFLG]_1;
	!FILL IN ARGUMENT 4, THE ARRAY OFFSET
	CLNODLST[4,ARGNPTR]_.DTABB[ARAOFFSET];
	CLNODLST[4,AVALFLG]_1;
	!FILL IN MULT(1)
	CLNODLST[5,ARGNPTR]_.ROUT;
	CLNODLST[5,AVALFLG]_1;
	
END;

ROUTINE ALLONES(DTABB)=

BEGIN
	!LOOK THROUGH DIMENSION TABLE ENTRY
	!TO SEE IF ALL LOWER BOUNDS ARE 1.
	!RETURN 1 (TRUE) IF THEY ARE AND
	!0 (FALSE) IF NOT
	EXTERNAL ONEPLIT;
	OWN DNUM,DSUBETRY;
	MAP PEXPRNODE DTABB;
	MAP DIMSUBENTRY DSUBETRY;
	DNUM_.DTABB[DIMNUM];
	DSUBETRY_.DTABB+2;				!POINT TO FIRST SUBENTRY
	INCR I FROM 1 TO .DNUM DO
	BEGIN
		IF .DSUBETRY[DIMLB] NEQ .ONEPLIT
		THEN
		RETURN(0)
		ELSE
		DSUBETRY_.DSUBETRY+2;
	END;
	RETURN 1
END;

ROUTINE CHKADJ(PARM)=
BEGIN
	!CHECK INFO SAVED IN CHOSEN FOR
	!AN ADJUSTABLE ARRAY WITH DIMENSION
	!PARM.
	!PARM IS A FORMAL PARAMETER ON A
	!SUBSEQUENT ENTRY TO THE ROUTINE
	!GLOBAL QQ USED TO RETURN INDEX IF
	!ROUTINE VALUE IS TRUE
	EXTERNAL QQ,CHOSEN;
	OWN DTABB,DNUM,DSUBETRY;
	MAP PEXPRNODE DTABB;
	MAP DIMSUBENTRY DSUBETRY;

	QQ_0;
	WHILE .CHOSEN[.QQ] NEQ 0 DO
	BEGIN
		DTABB_.CHOSEN[.QQ]<RIGHT>;
		DNUM_.DTABB[DIMNUM];
		DSUBETRY_.DTABB+2;
		INCR I FROM 1 TO .DNUM DO
		BEGIN
			IF .DSUBETRY[DIMLB] EQL .PARM
			THEN RETURN 1
			ELSE
			IF .DSUBETRY[DIMUB] EQL .PARM
			THEN RETURN 1
			ELSE
			DSUBETRY_.DSUBETRY+2;
		END;
		QQ_.QQ+1;
	END;
END;

GLOBAL ROUTINE ADJCALL=
BEGIN
	!INSERT CALL STATEMENT NODES FOR ADJUSTABLY DIMENSIONED
	!ARRAYS TO CALL THE OBJECT TIME ROUTINES
	!ADJ1. OR ADJG. TO COMPUTE FACTORS AND OFFSET
	EXTERNAL CSTMNT,CHOSEN,ENTRY,NAME,CORMAN;
	EXTERNAL VERYFRST,QQ;
	OWN DTABB,CLST,CALNODE,CLNODLST,G,CLSTARG;
	MAP ARGUMENTLIST CLNODLST:CLST;
	MAP BASE CSTMNT:DTABB:CLSTARG;

	VERYFRST_0;
	CSTMNT_.SORCPTR<LEFT>;
	WHILE .CSTMNT NEQ 0 DO
	BEGIN
		!IF ITS AN ENTRY
		IF .CSTMNT[SRCID] EQL ENTRID THEN
		!IF THERE ARE PARAMETERS
		IF .CSTMNT[CALLIST] NEQ 0 THEN
		BEGIN
			CLST_.CSTMNT[CALLIST];
			INCR I FROM 1 TO .CLST[ARGCOUNT] DO
			BEGIN
				CLSTARG_.CLST[.I,ARGNPTR];
				!IF AN ARRAY LOOK TO SEE
				!IF IT IS ADJUSTABLE

				IF .CLSTARG[OPR1] EQL
				OPR1C(DATAOPR,FORMLARRAY)
				THEN
				BEGIN
					DTABB_.CLSTARG[IDDIM];
					!LOOK TO SEE IF IT IS
					!ADJUSTABLY DIMENSIONED
					IF .DTABB[ADJDIMFLG] THEN
					BEGIN
						ADJGEN(.DTABB,.CLSTARG);
						!SAVE INFO FOR USE AT FUTURE
						!ENTRY POINTS.
						!THE GLOBAL VERYFRST IS USED
						!UNMEUMONICALLY HERE AS THE
						!INDEX INTO CHOSEN, GLOBAL
						!VECTOR
						CHOSEN[.VERYFRST]<_.CLSTARG;
%1(66)-102%					CHOSEN[.VERYFRST]<RIGHT>_.DTABB;
%1(66)-102%					VERYFRST_.VERYFRST+1;
						!THE GLOBAL VECTOR CHOSEN WILL KEEP
						!PREVIOUS ENTRY INFORMATION
						!EACH SINGLE WORD ENTRY WILL LOOK LIKE

						!-----------------------------------------------!
						!		ARY	!	PDIMTAB		!
						!-----------------------------------------------!

						!WHERE ARY IS A POINTER TO THE
						!SYMBOL TABLE ENTRY FOR THE ARRAY
						!AND
						!PDIMTAB IS A POINTER TO THE DIMENSION
						!TABLE ENTRY FOR THE ARRAY
					END;
				END ELSE
				!SINCE WE ARE FOLLOWING THE
				!"NEW" STANDARD.  THE ARRAY
				!DIMENSIONS MAY BE
				!CHANGED AT OTHER THAN MAIN
				!ROUTINE ENTRY BY PASSING
				!A DIMENSION.  WE MUST CHECK
				!BY LOOKING THROUGH THE
				!INFO IN CHOSEN IF THIS HAS
				!INDEED OCCURRED.

				IF .CSTMNT[ENTNUM] NEQ 0 THEN
				!THIS IS NOT THE PRINCIPLE ENTRY

				IF CHKADJ(.CLSTARG) THEN
				ADJGEN(.CHOSEN[.QQ]<RIGHT>,.CHOSEN[.QQ]<LEFT>);
			END;
		END;
		CSTMNT_.CSTMNT[SRCLINK];
	END;
END;
  :