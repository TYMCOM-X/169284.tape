GLOBAL %GI
! GRAPH INTERPRETER	FOR SIMPL

! GI CONTAINS ALL KNOWLEDGE OF SIMPL GRAMMAR AND PARTICULAR PARSE GRAPH
! BEING USED BY THE PARSER.	GI SHOULD BE INDEPENDENT OF COMPILER
! HOST MACHINE AND OBJECT TARGET MACHINE.

BASE 0
DEF NELV(STK) AS STK(STKINC(STK))
DEF ELV(STK) AS	STK(STK(0))


! CG AND ECG INTERFACE :
FIND %UTV,%CG.CLR,%G.RPT.I,%G.RPT.L,%LOD.DRS,%LP.BPTR
FIND %JMPV,%BINARY,%UNARY,%JMP,%TV.RET,%G.TTYIN
FIND %G.PRHD,%G.SV.ARG,%INDEX,%STORE,%DBLE,%G.ENTRY
FIND ID(10),V(10),%INIT.CALL,P,%QUABYT,%G.CND.AE,%FIELDS,%G.ELS.AE
FIND %CALL,%LOD.RES,%G.RET,%G.GO,%G.HALT,%G.EXIT,%MAK.ST,%DCALL
FIND %PARAM,%G.LD.1,%G.MAK.0,%BYTES,%TV,%FGTALL
FIND %G.MOVE,%G.MOVE.T,%G.MOVE.F
FIND %G.FOR.12,%G.FOR.11,%G.FOR.15,%G.FOR.16,%G.FOR.A
FIND %G.FOR.B,%G.FOR.C
	DEF TEL AS -1
	DEF NIL AS -2
	DEF UPK AS -3

 ! DEF NCHV AS 3
 ! DEF NHWV AS 4
 ! DEF PCHV AS 5
 ! DEF PHWV AS 6
 ! DEF @ AS 9
 ! DEF 1^ AS 10
 ! DEF 1INC AS 14
 ! DEF 1DEC AS 15

 ! DEF MOD AS HEX 10
 ! DEF BAND AS HEX 20
 ! DEF SHL AS HEX 30
 ! DEF _ AS HEX 70
 ! DEF DFSSTO.OP	AS HEX 71
 ! DEF INDEX AS HEX 60
 ! DEF MAX AS HEX 40
 ! DEF MIN AS HEX 41
 ! DEF <=> AS HEX 72
 ! DEF DBSTO.OP AS HEX 73
 ! DEF DIVMOD AS HEX 50

! HOST INTERFACE:
FIND KIND,DEPTH,SCOPE,STATE,LOC,%PAK.VB,%UNPAK.VB,%TVID,%DCL,%TV.KON
FIND %STKID,%DCL.STR,%PRINT,%BCFWD,%LOC.MOD,%MKSTBLK,TCONFL,%MKENTRY
FIND %K.AR,%K.NOT,%K.NEG,%MAK.POS,%DCL.ALT,%DEF.ALT
DEF REMINT AS V(UTV+1)

DEF NULL.LINK AS 0

DEF UNDCL AS 0
DEF FLAB AS 1
DEF LABEL AS 2
DEF PROC AS 3
DEF VARB AS 4
DEF SVEC AS 5
DEF DVEC AS 6
DEF TEXT AS 7

DEF VEC.P(K) AS SVEC<=K<=DVEC

DEF FIND.S AS 0
DEF GLOBAL.S AS 1
DEF PARAM.S AS 2
DEF LOCAL.S AS 3


FIND RET.LOC(-1:10),BP.STK(-1:10)
FIND %INPW,%PWF,HIB,LOB,%ERR,%IERR,%GLNUM
FIND CD.P,DT.P,%ALLOC,%ALTER,%FIXUP,%BFWD
FIND %LDEF,%PDEF,%GEN.KON,%TVKI,%BEG.LV,%END.LV,%HO.CLR,%DCL.LAB


DEF DO.SZ AS 25 ! BLOCK NESTING

DEF CG.CNT.SIZ AS 4
GLOBAL CG.CNT(1:CG.CNT.SIZ)

GLOBAL FOR.ID,FOR.T,FOR.S1,FOR.S2,LOOP.T,LOOP.LVL
GLOBAL BASS,PRO.DP,NULL.DP,RECOVER:
DEF PRO.SZ AS 10
GLOBAL %STKINC,%STKDEC,%STKCK,%DRIVE
GLOBAL DOTYP(-2:DO.SZ),DOL1(DO.SZ)
! --------------
! RELPK	DECLS:

LOCAL %RELPK,%TPRT,%FPRT,%OTPRT,%O.COND.P,%O.IF,%O.UNLESS
LOCAL %THENP,%MOR,%MAND

DEF O.NOT AS NOTST_(NOTST SHL 1) BOR NOTFL
DEF C.NOT AS [NOTFL_NOTST BAND 1; NOTST_NOTST SHR 1]
DEF NOT.P AS NOTFL_NOTFL BXOR 1
DEF C.COND.P AS [C.NOT; INC ELV(PCNT)]

DEF BRT.SZ AS 12
DEF LAB.T.SZ AS 25
DEF PCNT.SZ AS 5

LOCAL BRT(-2:BRT.SZ),BRF(-2:BRT.SZ)
LOCAL LAB.T(-2:LAB.T.SZ),LAB.F(-2:LAB.T.SZ)
LOCAL PCNT(-2:PCNT.SZ)

LOCAL CREL,NOTFL,NOTST
GLOBAL TRN(6)
! ----------------------------


%GI ! *************************** 

LOCAL %PRG,%LSTMT,%DOCASE,%FORP,%IFGRP,%AE,%PRIM,%LAL
LOCAL %SST,%SW,%ASS,%CALLT,%LEFPT,%COND,%REL,%RELOP,%LOCDEC,%PRHD
LOCAL %PREND,%KON,%TABDEC,%DASS,%DAE,%KONEX,%END.LOOP
LOCAL DCF,IDW


LOCAL LAB.STK(-1:10)
DEF DOLVL AS DOTYP(0)

! INITIALIZE STACKS:

DEF SETSTK(STK,SIZ) AS [STK(0);STK(-1)]_[0;SIZ]
DEF CLRSTK(STK) AS STK(0)_0
DEF SAVSTK(STK) AS STK(-2)_STK(0)
DEF RESSTK(STK) AS STK(0)_STK(-2)
SETSTK(BP.STK,10) ! TERMINII STACK FOR [..]*[..]	
SETSTK(RET.LOC,PRO.SZ) ! PROC RETURN STACK
SETSTK(BRT,BRT.SZ)
SETSTK(BRF,BRT.SZ)
SETSTK(LABT,LABT.SZ)
SETSTK(LABF,LABT.SZ)
SETSTK(PCNT,PCNT.SZ)
SETSTK(LAB.STK,10) ! LABEL STACK
SETSTK(DOTYP,DO.SZ)
! NEGATION OR ORDER REVERSAL RELOP TRANSFORMATIONS:

TRN(1)_5 ! <	-->	>
TRN(2)_6 ! <=	->	>=
TRN(3)_3 ! =	->	=
TRN(4)_4 ! #	->	#
TRN(5)_1 ! >	->	<
TRN(6)_2 ! >=	->	<=

!*********

! COMMENCE GENERATING CODE:

	BASS_1; PRO.DP_NULL.DP_0; DCF_0; LOOP.LVL_0
	RETURN

!--------------------------

! ** BLOCK STACK ****	COMMENTS ** :

!	DOTYP	DOL1	STMT TYPE
!	-----	----	------- 
!1	DO.ST	--	PURE DO 
!2	DO.CAS	TOP CD.P	DO CASE
!	(USES TWO AUX STK LOCS TOO)
!3	LIF.ST	LIF.PH	IF COND STMT	
!	LIF.ST	ELS.PH	IF COND SST ELSE STMT	
!4	EN.EL.PH	--	END ELSE STMT 
!5	EIF.ST	TRUE LINK	EIF
!6	EI.EL.PH	TRUE LINK	STMT ON EIF OR ORIF
!7	FIF.ST	TRUE LINK	FIF
!8	ELS.ST	TRUE LINK	ELSE
!9	WHIL.ST	TOP CD.P	WHILE
!10	FOR.ST	TOP CD.P	FOR (USE ONE AUX)
!11	RPT.ST	" "	REPEAT AE DO (ONE AUX)
!12	LOOP.ST	--	LOOP SST OR LOOP STMT
!	(USES TWO AUX)

!GENERATED CODE FOR	DO C OF LB:UB	-- 
!	LOAD 1,C
!	JMP ^*+2-LB(1)
!	JMP UB+1	
!DOL1: JMP LB 
!	JMP LB+1	
!	ETC..
! ***********************	
DEF DO.ST	AS 1
DEF DO.CAS	AS 2
DEF LIF.ST	AS 3
DEF LIF.PH	AS 1
DEF ELS.PH	AS 2
DEF EN.EL.PH	AS 4
DEF EIF.ST	AS 5
DEF EI.EL.PH	AS 6
DEF FIF.ST	AS 7
DEF ELS.ST	AS 8
DEF WHIL.ST	AS 9
DEF FOR.ST	AS 10
DEF RPT.ST	AS 11
DEF LOOP.ST	AS 12

DEF DO.LB	AS DOTYP(DOLVL-2) ! LOWER BOUND
DEF DO.UB	AS DOL1(DOLVL-2)	! UPPER BOUND
DEF DO.LINK	AS DOL1(DOLVL-1)	! CHAIN HEAD OF SKIP BRANCHES
DEF DO.VB	AS DOTYP(DOLVL-1) 
DEF DO.STP	AS DO.LB 
DEF DO.TOP	AS DOL1(DOLVL)	!	TOP CD.P 

DEF LOOP.END AS DOTYP(LOOP.LVL-2)
DEF LOOP.INIT AS DOL1(LOOP.LVL-2)

%DRIVE

LOCAL CNT.INX

SAVSTK(BRT); SAVSTK(BRF); SAVSTK(LAB.T); SAVSTK(LAB.F)
SAVSTK(PCNT); SAVSTK(DOTYP)
GLNUM
NXW: PWF 
DO HIB OF 32
2:PRG 
3:LSTMT	
4:DOCASE 
5:FORP
6:IFGRP	
7:AE	
8:PRIM
9:LAL 
10:SST
11:SW 
12:ASS
13:CALLT 
14:LEFPT 
15:COND	
16:REL
17:RELOP 
18:LOCDEC
19:PRHD	
20:PREND 
21:KON	
23:TABDEC
24:DASS	
25:DAE
29:KONEX

1:	DO LOB OF 3
	1: RETURN
	2: CNT.INX_INPW; CG.CNT(CNT.INX)_INPW
	3: IDW_INPW
	END
END
GO NXW
RECOVER: HO.CLR; CG.CLR; CLRSTK(LAB.STK); CLRSTK(BP.STK)
	 DCF_0
	RESSTK(BRT); RESSTK(BRF); RESSTK(LAB.T); RESSTK(LAB.F)
	RESSTK(PCNT); RESSTK(DOTYP)
	RETURN

END DRIVE

%PRG ! -- 2 
LOCAL CASE,ELSFLG,DOT,DOL	
DO LOB OF 3:24 
9:	NELV(LAB.STK)_IDW
11:	IF DCF=0 THEN DO
	IF ELV(DOTYP)#DO.CAS THEN ERR('MISPLACED CASE')
	BFWD(@DO.LINK)
	DCF_-1
	END
	CASE_REM.INT	
	IF NOT DO.LB<=CASE<=DO.UB THEN ERR('FAR OUT CASE')
	DOL_CD.P; ALTER(LOC.MOD(DO.TOP,CASE-DO.LB))
	JMP(DOL); ALTER(DOL); FGTALL
3:	WHILE LAB.STK(0)>0 THEN DO
	LDEF(ELV(LAB.STK))
	DEC LAB.STK(0)
	END
	DCF_0
21:22: ELSFLG_LOB-22 ! SET <0 IF ELSE AFTER END
	IF DOLVL=0 OR DOT_ELV(DOTYP)>DO.CAS THEN ERR('ILLEGAL END')
	IF DOT=DO.CAS THEN [FIXUP(DO.LINK); DOLVL_DOLVL-2]
	DEC DOLVL
ESTMT: WHILE DOLVL>0 AND DOT_ELV(DOTYP)>DO.CAS THEN DO
	DOL_DO.TOP
	DO DOT OF LIF.ST:LOOP.ST
LIF.ST:	EIF DOL=ELS.PH THEN FPRT
	ORIF ELSFLG>=0 THEN OTPRT
	ELSE [TPRT; DEC DOLVL; RETURN]
EN.EL.PH:	FPRT
EIF.ST:	GO DO.END
EI.EL.PH:	BFWD(@DO.TOP); ELV(DOTYP)_EIF.ST; GO DO.END
FIF.ST:	OTPRT; FIXUP(DOL)
ELS.ST:	FIXUP(DOL)
WHIL.ST:FOR.ST:RPT.ST:LOOP.ST:  END.LOOP
	END ! DO DOT OF LIF.ST:RPT.ST
	DEC DOLVL
	END
DO.END: IF ELSFLG<0 THEN ERR('ILLEGAL ELSE')

23:	FPRT; ELSFLG_0; GO ESTMT
24:	NELV(DOTYP)_EN.EL.PH
20:	BASS_REM.INT	
	END	
RETURN
END PRG	

%LSTMT ! -- 3
DO LOB OF 3:12
3:	NELV(DOTYP)_LIF.ST
6:	TPRT; DO.TOP_ELS.PH
8:	DO.TOP_LIF.PH
9:	LOOP.T_-1
10:	EIF LOOP.T=0 THEN DO
		O.UNLESS
	END
	ELSE DO
		NELV(DOTYP)_WHIL.ST
		DO.TOP_CD.P
		FGT.ALL
		O.IF
	END
11:	THEN.P; UTV
	IF LOOP.T=0 THEN DO
		BFWD(@LOOP.END)
		OTPRT
	END
12:	DOLVL+_2; NELV(DOTYP)_LOOP.ST
	FGT.ALL; DO.VB_LOOP.LVL<==DOLVL
	LOOP.INIT_LOOP.END_NULL.LINK
	BFWD(@LOOP.INIT); DO.TOP_CD.P
END
RETURN
END LSTMT

%DOCASE ! -- 4 
LOCAL I,J
DO LOB OF 7:9 
7:	DOLVL_DOLVL+2; NELV(DOTYP)_DO.CAS; DO.LINK_NULL.LINK
	DO.UB_REM.INT; DO.LB_REM.INT; I_DO.UB-DO.LB+1	
	JMPV(2-DO.LB); J_CD.P; BFWD(@DO.LINK); DO.TOP_CD.P
	WHILE DEC I>=0 THEN JMP(J)
9:	TVKI(1) 
8:	NELV(DOTYP)_DO.ST
END
RETURN
END DOCASE

%FORP ! -- 5
LOCAL LK
DO LOB OF 5:16
12:	FOR.ID_IDW; FOR.S1_FOR.S2_FOR.T_0
	REPEAT 4 IF CG.CNT(INC FOR.S1)#0 THEN DO
		INC FOR.S2
		FOR.T_2*FOR.S1+IF CG.CNT(FOR.S1)=1 THEN -1 ELSE 0
	END
	IF FOR.S2>1 THEN FOR.T_0
	EIF LOOP.T=0 THEN FOR.T_9+(FOR.T+1)/2
	ELSE [INC DOLVL; NELV(DOTYP)_FOR.ST; DO.TOP_FOR.T]
	G.FOR.12
11:	G.FOR.11
15:	G.FOR.15
16:	G.FOR.16
7:8:9:10: G.FOR.A(LOB)
5:6:	G.FOR.B
	IF LOOP.T#0 THEN [DO.LINK_FOR.S1; DO.VB_FOR.S2]
14:	EIF LOOP.T=0 THEN DO
		LK_NULL.LINK
		BFWD(@LK)
		FIXUP(LOOP.INIT)
	END
	ELSE [INC DOLVL; NELV(DOTYP)_RPT.ST]
13:	G.RPT.I
	EIF LOOP.T=0 THEN DO
		LOOP.INIT_NULL.LINK
		BFWD(@LOOP.INIT)
		FIXUP(LK)
		G.RPT.L(@LOOP.END)
	END
	ELSE DO
		FGT.ALL
		DO.TOP_CD.P
		LK_NULL.LINK
		G.RPT.L(@LK)
		DO.LINK_LK
	END
END
RETURN
END FORP	

%IFGRP ! -- 6
DO LOB OF 9
1:	NELV(DOTYP)_EIF.ST; DO.TOP_NULL.LINK
3:	BFWD(@DO.TOP)
9:	ELV(DOTYP)_EI.EL.PH
4:	IF ELV(DOTYP)#EIF.ST THEN ERR('ORIF WITHOUT EIF')
	OTPRT
5:	IF ELV(DOTYP)#EIF.ST THEN ERR('FIF WITHOUT EIF')
	OTPRT; ELV(DOTYP)_FIF.ST
6:	IF ELV(DOTYP)#EIF.ST THEN ERR('ELSE WITHOUT EIF')
	OTPRT; ELV(DO.TYP)_ELS.ST
8:	IF ELV(DOTYP)=FIF.ST THEN OTPRT
	FIXUP(DO.TOP); STKDEC(DOTYP)
END
RETURN
END IFGRP

%AE ! -- 7	
DO LOB OF 3:20 
3:4:	BINARY(LOB-3) 
6:7:	BINARY(LOB-4) 
8:	BINARY(HEX 10 !MOD!)
10:11:12:13:	BINARY(LOB+(HEX 20 !BAND!-10))
15:16:17:18:	BINARY(LOB+(HEX 30 !SHL!-15))
19:20:	BINARY(LOB+(HEX 40 !MAX!-19))
END
RETURN
END AE

%PRIM ! -- 8
EIF LOB<=17 THEN UNARY (LOB-2)
ORIF LOB<=23 THEN BYTES(LOB-19)	
ELSE DO LOB OF 26:46 
26:	TVID(IDW); IF KIND#PROC THEN IERR('NOT A PROCEDURE: ',IDW)
	 INIT.CALL	
27:	TVID(IDW)
	EIF KIND=PROC THEN INIT.CALL
	FIF NOT VEC.P(KIND) THEN IERR('CANNOT BE SUBSCRIPTED: ',IDW)
28:	TVID(IDW)
	EIF KIND=PROC THEN [INIT.CALL; CALL] 
	FIF KIND=LABEL OR KIND=FLAB OR KIND=SVEC THEN UNARY(9 !@!)
29:	TV.RET	
30:	G.TTYIN 
31:	STORE(HEX 71 !<==!)
32:	UNPAK.VB(ID(P-1))
	EIF KIND=PROC THEN [PARAM;CALL]
	ELSE INDEX
46:	TVID(IDW); UNARY(9 !@!)
35:40: NELV(BP.STK)_P
43:	FIELDS(1)
38:	TVKI(0)
39:	QUA.BYT
42:	G.CND.AE; TPRT
44:	G.ELS.AE; FPRT
41:	THENP; UTV; G.LD.1; TPRT; G.MAK.0; FPRT
END
RETURN
END PRIM 

%LAL ! LONG AE LIST -- 9
DO LOB OF 3:6
3:5:	PARAM
6:	CALL
END
RETURN
END LAL	

%SST ! SHORT STATEMENT -- 10	
DO LOB OF 63
2:	UTV	
11:	LOD.RES; UTV	
21:	LOD.DRS; UTV; UTV
10:	G.RET
5:	STORE(HEX 72 !<=>!)	
7:	DCL.LAB(IDW); TVID(IDW); G.GO
9:	UNARY(10 !^!); G.GO 
12:	G.HALT	
13:	G.EXIT	
15:	UNARY(14 !INC!); MAK.ST	
16:	UNARY(15 !DEC!); MAK.ST	
33:	UNARY(3 !NCHV!); MAK.ST 
34:	UNARY(5 !PCHV!); MAK.ST 
27:	TPRT
28:	FPRT
32:	OTPRT
31:	UTV
47:	UNARY(4 !NHWV!); MAK.ST 
48:	UNARY(6 !PHWV!); MAK.ST 
38:	UTV; UTV
52:	MKSTBLK(IDW)  !MAKE A START BLOCK
29:39:	LOOP.T_-1
30:40:	IF LOOP.LVL=0 THEN ERR('OUTSIDE OF LOOP'); LOOP.T_0
25:	END.LOOP; DEC DOLVL
59:60:	G.MOVE(LOB-60)
61:	G.MOVE.F
63:	G.MOVE.T
55:     MKENTRY(IDW)
END
RETURN
END SST	

%SW ! STORAGE WORD -- 11
DO LOB OF 9 
2:	TVID(IDW)
	EIF KIND=PROC THEN ERR('STORAGE WORD REQUIRED')	
	FIF NOT VEC.P(KIND) THEN IERR('CANNOT BE SUBSCRIPTED: ',IDW)
5:	INDEX
3:	TVID(IDW)
	IF VARB#KIND#DVEC THEN ERR('STORAGE WORD REQUIRED')	
7:	UNARY(10 !^!)
9:	TV.RET	
END
RETURN
END SW

%ASS ! -- 12.5
IF LOB#10 THEN STORE(HEX 6B+LOB !_:MAX_!) ELSE TV(NIL)
RETURN
END ASS

%CALLT ! CALL STATEMENT -- 13 
DO LOB OF 8
2:	TVID(IDW); IF KIND#PROC THEN IERR('NOT A PROCEDURE: ',IDW)
	 INIT.CALL
5:	PARAM; CALL
8:	CALL
END
RETURN
END CALLT

%LEFPT ! LEFT PART -- 14
EIF LOB<=4 THEN BYTES(LOB-2)	
ORIF LOB<=10 THEN UNARY(LOB-4)
ELSE DO LOB OF 11:19
11:	QUA.BYT 
12:	TV(TEL) 
13:14: NELV(BP.STK)_P
15:	TV(UPK)
16:	TVKI(0)
17:	TV(NIL)
18:19:	LP.BPTR(LOB-18)
END
RETURN
END LEFPT

%COND ! -- 15
DO LOB OF 13
2:	O.IF
4:	THENP; UTV
6:	MOR; UTV
8:	MAND; UTV
9:	O.COND.P
11:	O.COND.P; NOT.P
10:13: C.COND.P
END
RETURN
END COND

%REL ! -- 16
DO LOB OF 15
3:	MAND
5:	CREL_TRN(CREL)
9:	O.NOT; NOT.P
10:	C.NOT
12:	TVKI(0); CREL_IF NOTFL=0 THEN 4 !#! ELSE 3 !=!
14:15:	CREL_IF NOTFL=0 THEN LOB-7 ELSE 14-LOB
END
RETURN
END REL

%RELOP ! -- 17
CREL_IF NOTFL=0 THEN LOB-1 ELSE 8-LOB; RETURN
END RELOP

%LOCDEC ! LOCAL(ETC) -- 18 
LOCAL X,LB,UB,NAME,ANAME
DO LOB OF 22
2:	SCOPE_LOCAL.S	
16:	SCOPE_GLOBAL.S 
17:	SCOPE_FIND.S
4:	[KIND;LOC]_[PROC;NULL.LINK]; GO C10D ! PROCEDURE
14:	[KIND;LOC]_[X_IF SCOPE#LOCAL.S THEN LABEL ELSE FLAB;NULL.LINK]; GO C10D ! LABEL
15:	KIND_VARB; UB_LB_0; GO C10C ! SCALAR
7:	NAME_IDW ! ARRAY. SAVE NAME WHILE PROCESSING DIMENSIONS
8:	KIND_DVEC; UB_LB_0; GO C10B ! DYNAMIC ARRAY
13:	UB_REM.INT; LB_REM.INT; GO C10A ! LOWER BOUND SPECIFIED
10:	LB_BASS; UB_REM.INT ! USE BASE AS LOWER BOUND
C10A:	KIND_SVEC
C10B:	IDW_NAME ! RESTORE ARRAY NAME
C10C:	LOC_IF SCOPE#FIND.S THEN LOC.MOD(ALLOC(UB-LB+1),-LB) &
	ELSE NULL.LINK
C10D:	DCL(IDW,KIND,SCOPE,LOC)
20:     IF SCOPE=LOCAL.S THEN ERR('LOADER NAME ILLEGAL FOR LOCAL')
        ANAME_DCL.ALT(IDW)
22:     DEF.ALT(IDW,ANAME)
END
RETURN
END LOCDEC	

%PRHD ! PROC HEAD -- 19 
LOCAL K,S,ENTRY,ENTR.FLG
DO LOB OF 3:18
3:	PDEF(IDW) ! DEFINE PROC AT OLD PRO.DP
	PRO.DP_STKINC(RET.LOC); BEG.LV(IDW)
	G.PRHD
	ENTR.FLG_0
16:	ENTRY_NULL.LINK; BFWD(@ENTRY); ENTR.FLG_-1
	PDEF(IDW)
	G.ENTRY
5:	[K;S]_[PROC;PARAM.S]	
9:	[K;S]_[VARB;PARAM.S]	
13:	[K;S]_[DVEC;LOCAL.S]	
11:	[K;S]_[LABEL;PARAM.S] 
14:	[K;S]_[VARB;LOCAL.S]	
7:	UNPAK.VB(IDW)
	IF ENTR.FLG#0 AND STATE#0 AND KIND#UNDCL AND DEPTH=PRO.DP &
	THEN [IF KIND#K OR SCOPE#S THEN IERR('REDEFINED: ',IDW)] &
	ELSE DCL(IDW,K,S,ALLOC(1))
	TVID(IDW); G.SV.ARG; UTV
18:	IF ENTR.FLG#0 THEN FIXUP(ENTRY)
END
RETURN
END PRHD 

%PREND ! PROC END -- 20.3	
IF DOLVL#0 THEN ERR('DO WITHOUT END')
IF TCONFL=0 THEN G.RET ! GENERATE RETURN IF FALL-THRU
END.LV(IDW); PRO.DP_STKDEC(RET.LOC)
RETURN
END PREND

%KON ! -- 21
DO LOB OF 2:13 
2:4:6:8:	TV.KON(LOB/2,IDW)	!	HEX CON,OCT CON,$ CON,DEC CON
7:	DCL.STR(IDW); TVID(IDW)
9:	TVKI(0) ! EOLIT	
10:	TVKI(OCT 15)	
11:	TVKI(36)
12:	TVKI(5) 
13:	TVKI(OCT 12)
END
RETURN
END KON	

%TABDEC ! -- 23
LOCAL UB,LB,I,NAME,%OUTK,FWD,ANAME
DO LOB OF 35
3:26:	SCOPE_LOCAL.S
TABI:	FWD_NULL.LINK; BFWD(@FWD)
25:	SCOPE_GLOBAL.S; GO TABI
2:24:	FIXUP(FWD)
4:	NAME_IDW
5:	KIND_SVEC 
20:	LB_UB_0; KIND_VARB; GO NCHK
7:	LB_BASS; UB_REM.INT
ACHK:	IDW_NAME
NCHK:	DCL(IDW,KIND,SCOPE,LOC.MOD(CD.P,-LB))
	UB_UB-LB+1 ! COUNT
8:	LB_REM.INT 
18:	UB_REM.INT; GO ACHK 
33:     IF SCOPE=LOCAL.S THEN ERR('LOADER NAME ILLEGAL FOR LOCAL')
        ANAME_DCL.ALT(IDW)
35:     DEF.ALT(IDW,ANAME)
11:22: OUTK; UTV
12:	I_REM.INT ! MULTIPLIER 
13:	TVKI(0); WHILE DEC UB>=0 THEN GEN.KON; UTV
14:	WHILE DEC I >=0 THEN OUTK; UTV
END
RETURN
%OUTK	
IF DEC UB<0 THEN [IDW_NAME; IERR('TOO MANY ENTRIES: ',IDW)	]
GEN.KON
RETURN
END OUTK
END TABDEC	

%DASS ! DOUBLE ASSIGNMENT -- 24	
DO LOB OF 3:5	
3:	STORE(HEX 73 !DSW_DAE!)
4:5: TV(NIL) 
END
RETURN
END DASS 

%DAE ! DOUBLE AE -- 25	
IF LOB#12 THEN DBLE(LOB-3+HEX 50 !DIVMOD!) ELSE DCALL
RETURN
END DAE	

%KONEX ! KONEX -- 29
DO LOB OF 5:26
5:6:	K.AR(LOB+(HEX 40 !MAX!-5)); UTV
9:10:11:12:  K.AR(LOB+(HEX 00 !ADD!-9)); UTV
13:	K.AR(HEX 10 !MOD!); UTV
15:16:17:18:  K.AR(LOB+(HEX 20 !BAND!-15)); UTV
20:21:22:23:  K.AR(LOB+(HEX 30 !SHL!-20)); UTV
24:	K.NOT(P)
25:	K.NEG(P)
26:	MAK.POS(P)
END
RETURN
END KONEX

%END.LOOP ! END WHILE,FOR,REPEAT AND LOOP LOOPS
DO ELV(DOTYP) OF WHIL.ST:LOOP.ST
WHIL.ST: JMP(DO.TOP); OTPRT
RPT.ST:	JMP(DO.TOP); FIXUP(DO.LINK); DEC DOLVL
FOR.ST:	FOR.S1_DO.LINK; FOR.S2_DO.VB; FOR.T_DO.TOP
	G.FOR.C; DEC DOLVL
LOOP.ST: FIXUP(LOOP.INIT)
	JMP(DO.TOP)
	FIXUP(LOOP.END)
	LOOP.LVL_DO.VB
	DOLVL+_-2
END
RETURN
END END.LOOP

! ----------------------------


%RELPK ! RELATIONAL PACKAGE

LOCAL I,J
LOCAL %T.TEST,%F.TEST,%MRG.B,%MRG.T,%MRG.F
LOCAL %BRTRU,%BRFAL,%ETL,%EFL,%C.IF

DEF A.AND AS T.TEST
DEF A.OR AS [F.TEST; EFL]
DEF A.NAND AS F.TEST
DEF A.NOR AS [T.TEST; ETL]

%O.UNLESS ! INITIALIZE FOR START OF NOT CONDITIONAL
O.COND.P; NOTFL_1; NELV(PCNT)_0; RETURN
END O.UNLESS

%O.IF ! INITIALIZE FOR START OF CONDITIONAL
O.COND.P; NOTFL_0; NELV(PCNT)_0; RETURN
END O.IF

%MAND ! APPLY AND OPERATOR TO PREVIOUS RELATIONAL
IF NOTFL=0 THEN A.AND ELSE A.NAND; RETURN
END MAND

%MOR ! APPLY OR OPERATOR TO PREVIOUS RELATIONAL
IF NOTFL=0 THEN A.OR ELSE A.NOR; RETURN
END MOR

%THENP ! TERMINATE CONDITIONAL AT THEN. GENERATE LAST RELOP
!LAST AND FORCE ALL TRUE BRANCHES TO THEN STATEMENTS
T.TEST; ETL; STKDEC(PCNT); RETURN
END THENP

%TPRT ! TERMINATE TRUE PART. GENERATE BRANCH AROUND ELSE CODE
INC ELV(BRT); NELV(LAB.T)_0
	BFWD(@ELV(LAB.T)) 
EFL; RETURN
END TPRT

%FPRT ! TERMINATE FALSE PART
ETL; C.IF; RETURN
END FPRT

%OTPRT ! ONLY TERMINATE TRUE PART
EFL; C.IF; RETURN
END OTPRT

%O.COND.P ! INITIALIZE FOR ( , NOT ( AND IF ...
NELV(BRT)_NELV(BRF)_0; O.NOT; RETURN
END O.COND.P

%T.TEST ! GENERATE RELATIONAL TEST FOR TRUE
IF ELV(PCNT)>0 THEN DO
	MRG.B; MRG.F; BRFAL; ETL; STKDEC(BRT)
END ELSE BRFAL
RETURN
END T.TEST

%F.TEST ! GENERATE REALTIONAL TEST FOR FALSE
IF ELV(PCNT)>0 THEN DO
	MRG.B; MRG.T; BRTRU; EFL; STKDEC(BRF)
END ELSE BRTRU
RETURN
END F.TEST

%MRG.B ! MERGE ALL TRUE AND FALSE BRANCHES FOR LAST OPERAND
J_ELV(PCNT)<==0
WHILE DEC J>0 THEN [MRG.T; MRG.F]; RETURN
END MRG.B

%MRG.T ! MERGE TRUE BRANCHES
I_ELV(BRT); STKDEC(BRT); ELV(BRT)_ELV(BRT)+I; RETURN
END MRG.T

%MRG.F ! MERGE FALSE BRANCHES
I_ELV(BRF); STKDEC(BRF); ELV(BRF)_ELV(BRF)+I; RETURN
END MRG.F

%BRTRU ! GENERATE BRANCH TO TRUE LINK
IF ELV(BRT)=0 THEN [ELV(BRT)_1; NELV(LAB.T)_NULL.LINK]
BCFWD(@ELV(LAB.T),CREL); RETURN
END BRTRU

%BRFAL ! GENERATE BRANCH TO FLASE LINK
IF ELV(BRF)=0 THEN [ELV(BRF)_1; NELV(LAB.F)_NULL.LINK]
BCFWD(@ELV(LAB.F),7-CREL); RETURN
END BRFAL

%ETL ! EMIT TRUE LABELS
I_ELV(BRT)<==0
WHILE DEC I>=0 THEN [FIXUP(ELV(LAB.T)); STKDEC(LAB.T)]
RETURN
END ETL

%EFL ! EMIT FALSE LABELS
I_ELV(BRF)<==0
WHILE DEC I>=0 THEN [FIXUP(ELV(LAB.F)); STKDEC(LAB.F)]
RETURN
END EFL

%C.IF ! CLOSE IF
C.NOT; STKDEC(BRT); STKDEC(BRF); RETURN
END C.IF

END RELPK
! ------------------------------------ 

%STKINC(STK())
 IF STK(0)<STK(-1) THEN RETURN INC STK(0) ELSE ERR('STK OFL')
END STKINC

%STKDEC(STK())
 IF STK(0)>0 THEN RETURN DEC STK(0) ELSE ERR('STK UFL')
END STKDEC

%STKCK(STK())
 IF 0<STK(0)<=STK(-1) THEN RETURN STK(0) ELSE ERR('STK BNDS')
END STKCK


END GI
    