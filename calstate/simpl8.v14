GLOBAL %CG
BASE 0

! HOST INTERFACE:

FIND %K.AR,%K.NOT,%K.ADD,%K.SIGN,%MAK.POS,%K.NEG,%LOG
FIND K.LH,K.RH,%K.SPLIT,%RLS.K,%GEN,%ERR,%WARN,%ALLOC
FIND %TVDKI,%TVKI,%GKIND,%K.SGN
DEF INT(I) AS V(I)
DEF REMINT AS INT(UTV+1)

DEF M.O AS 0 ! OPND STK REFERENCE
DEF M.LIT AS 1 ! LITERAL
DEF M.CD	AS 2 ! CODE REF
DEF M.DT	AS 3 ! DATA REF

DEF UNDCL AS 0
DEF FLAB AS 1
DEF LABEL AS 2
DEF PROCD AS 3
DEF VARB AS 4
DEF SVEC AS 5
DEF DVEC AS 6
DEF TEXT AS 7


GLOBAL %BINARY,%UNARY,%BYTES,%QUA.BYT,%PROC,%PARAM,%CALL,%DCALL
GLOBAL %TV,%UTV,%STK,%LP.OPND,%OFF,%FGTALL,%CG.CLR,%ST,%MOD.STO
GLOBAL %GEN.I,%SLAVE,%DUP,%DIDDLE,%PBYT,LASTBR,%GEN.O,%UNIFY,%GEN.O1
DEF PMAX AS 30
GLOBAL P,T(PMAX),V(PMAX),X(PMAX),ID(PMAX)
GLOBAL %RECORD
GLOBAL %INIT.CALL,%LD,%TVLIT,%OPND,%RLS,%EMANC,%FRE.X,%FRE.D.X,%CLR
GLOBAL %COMP,%DBLE,%INDEX,%STORE
GLOBAL MODE,INST,IMM,AC,INDX,INDR,ADDR


!---------------------------------- 
!	MISCELLANEOUS GOODIES	
 DEF	X.LO	AS 1 ! LEAST GENERAL PURPOSE REGISTER	
 DEF	X.HI	AS 15! GREATEST GENERAL PURPOSE REGISTER	
DEF	ANY	AS -1! SELECT ANY REGISTER (OR BIT) 
DEF	DBL	AS -2! SELECT A REGISTER PAIR 
DEF	ALLB	AS -1! SELECT ALL BITS	
DEF	QUO	AS 0 ! WHERE QUOTIENTS FALL
DEF	REM	AS 1 ! WHERE REMAINDERS FALL	

!---------------------------------------	
	BASE X.LO
	GLOBAL R.STATE(X.HI),RT(X.HI),RV(X.HI),RX(X.HI),RID(X.HI)	
	BASE 0	
!
! ECG INTERFACE:

FIND %EZ.BYT,%BYT.PTR,%FIELDS

%CG


LOCAL %TV.U,%SWITCH,%SAV
LOCAL %RST,%MATCH,%EZ.LD
LOCAL %PUSH,%POP,%REF.OPND,%EZ.FRE.X
LOCAL O1,O2,PARM.FG,W1,W2,SUB.P,REG.P
LOCAL PDP,P.STACK(100)

!
!**************************************** 
! OPND STK CODES:	
!	T	V	X	ID	
!	-----	-----	---- -----	
!	NIL	--	--	--	<NULL FIELD>
!	TEL	--	--	-- <TTY_>
!	KON	<CODES KNOWN TO HOST>
!	W.ABS	LOC	UNOPS --
!	W.REL	<HOST>	UNOPS IDW OR 0 IF TEMP CELL
!	SUB	LINK	"	--	
!	REG	REG#	"	--	
! THE SUB-LINK POINTS TO TWO-OPND BLOCK: [ARRAY,SUBSCRIPT]	
!---------	
!	REGISTER DESCRIPTOR CODES:
!	RT	RV	RX	RID
!	-----	-----	-----	------
!	0	--	--	-- 
!	W.ABS	LOC	UNOPS -- 
!	W.REL	<HOST>	"	<HOST>
!--------
!	PERMITTED UNOP COMBINATIONS: 
!	-<AE>
!	BNOT <AE>	
!	^<AE>
!	@<SW>
!	<BYT-OP> <AE> 
!	<BYT-OP>^<AE> 
!	-<BYT-OP><AE> 
!	-<BYT-OP>^<AE>
!	-^<AE>	
!	BNOT ^ <AE>
!	- BNOT <AE>	::=	INC <AE>
!	- BNOT ^ <AE> 
!	-@<SW>	
!	BNOT @ <SW>
!	- BNOT @ <SW> 
!********************************************
 DEF	UPK	AS -3 ! [..]*[..]_
 DEF	NIL	AS -2 ! NULL FIELD
 DEF	TEL	AS -1 ! TTY_
 DEF	KON	AS 3 ! INTEGER CONSTANT VALUE 
 DEF	W.ABS AS 4 ! ^KON 
 DEF	W.REL	AS 5 ! OPND IN CODE-SPACE	
 DEF	SUB	AS 6 ! SUBSCRIPTED VARB (USES 3 ENTRIES)	
 DEF	REG	AS 8 ! VALUE IN A REGISTER 
! PENDING UNOP CODES:
 DEF	U.AT	AS 1 ! AT SIGN 
 DEF	U.UP	AS 2 ! INDIRECT ^ 
 DEF	U.BNOT	AS 4 ! BITS NOT
 DEF	U.NG	AS 8 ! NEGATION
DEF	XOPND	AS BNOT(U.UP BOR U.AT)
DEF	XBE	AS BNOT(U.BNOT BOR U.UP BOR U.AT) 
DEF	XAE	AS BNOT(U.NG BOR U.UP BOR U.AT)	
DEF	U.BYTS	AS HEX F0 ! ORDER IS: CHV,HWV,NCHV,NHWV,PCHV,PHWV,LH,RH	
 DEF	AT.P(O) AS U.AT BAND X(O)#0 
 DEF	NEG.P(O) AS U.NG BAND X(O)#0	
 DEF	INDR.P(O) AS U.UP BAND X(O)#0
 DEF	BNOT.P(O) AS U.BNOT BAND X(O)#0
DEF	BYTS.P(O) AS U.BYTS BAND X(O)#0
! BINARY OPERATORS:	
!ARITH:
! DEF	ADD.OP	AS HEX 00
! DEF	SUB.OP	AS HEX 01
! DEF	MUL.OP	AS HEX 02
! DEF	DIV.OP	AS HEX 03
!MODULO: 
! DEF	MOD.OP	AS HEX 10
!BITS:
! DEF	BAND.OP AS HEX 20
! DEF	BOR.OP	AS HEX 21
! DEF	BXOR.OP AS HEX 22
! DEF	BEQV.OP AS HEX 23
!SHIFT:	
! DEF	SHL.OP	AS HEX 30
! DEF	SHR.OP	AS HEX 31
! DEF	ROTL.OP AS HEX 32
! DEF	ROTR.OP AS HEX 33
 DEF	R.SHIFT(OP) AS (OP BAND 1 #0)
!MIN.MAX:
! DEF	MAX.OP	AS HEX 40
! DEF	MIN.OP	AS HEX 41
!DBLE: 
! DEF DIVMOD.OP	AS HEX 50
! DEF MODDIV.OP	AS HEX 51
! DEF DMUL.OP AS HEX 52
! DEF DMODDIV.OP AS HEX 53
! DEF DDIVMOD.OP	AS HEX 54
! DEF DSHL.OP	AS HEX 55
! DEF DSHR.OP	AS HEX 56
! DEF DROTL.OP	AS HEX 57
! DEF DROTR.OP	AS HEX 58
 DEF DR.SHIFT(OP) AS (OP BAND 1=0)
! DEF INDEX.OP	AS HEX 60
!STORE:	
! DEF STO.OP	AS HEX 70
! DEF DFSTO.OP	AS HEX 71
! DEF EXCH.OP	AS HEX 72
! DEF DBSTO.OP	AS HEX 73
!***	
!UNARY OPERATORS: 
! DEF CHV.OP	AS 1	
! DEF HWV.OP	AS 2	
! DEF NCHV.OP	AS 3	
! DEF NHWV.OP	AS 4	
! DEF PCHV.OP	AS 5	
! DEF PHWV.OP	AS 6	
! DEF LH.OP	AS 7	
! DEF RH.OP	AS 8	
! DEF AT.OP	AS 9	
! DEF INDR.OP	AS 10 
! DEF BNOT.OP	AS 11 
! DEF NEG.OP	AS 12 
! DEF ABS.OP	AS 13 
! DEF INC.OP	AS 14 
! DEF DEC.OP	AS 15 
!PARTIAL WORD SELECTORS OTHER THAN BYT AND THE V SUFFIX ONES:	
! DEF CH.OP	AS 1	CH(AE,AE)	
! DEF HW.OP	AS 2 HW(AE,AE)	
! DEF CHPT.OP	AS 3 CHPT(AE,AE)
! DEF HWPT.OP	AS 4 HWPT(AE,AE)
!---------------------------------------- 
! INITIALIZATIONS: *********************************	

P_0; SUB.P_PMAX+1; REG.P_1; PDP_P.STACK; PARM.FG_0; W1_X.LO-1
WHILE INC W1<=X.HI THEN RSTATE(W1)_0
RETURN

%CG.CLR
CG; FGTALL; RETURN
END CG.CLR
%BINARY (OP)
!	TRY TO ADDRESS LEFT ARG LAST TO ENCOURAGE POSSIBILITY
!	OF RESULT-TO-MEMORY INSTRUCTIONS.	
LOCAL %ARITH,%MODULO,%BITS,%SHIFT,%MODUDIV
LOCAL %MIN.MAX,%MULDIV
EIF K.AR(OP) THEN UTV
ELSE DO
	O2_P 
	O1_P-1
	DO OP SHR 4 OF 0:4
	0: ARITH	
	1: MODULO
	2: BITS	
	3: SHIFT 
	4: MIN.MAX	
	END
	RLS(O1); DEC P; STK(O2)
END
RETURN

%ARITH	
LOCAL W1,W2,J	

DO.AR: DO (3*OP+T(O1)/(REG-W.ABS))*3+T(O2)/(REG-W.ABS) OF 0:35	
OK.1: O1<=>O2; RETURN
1: C1: !KON+CORE! K.SPLIT(O1); IF K.LH=K.RH=0 THEN RETURN ELSE GO LIKE.1

!LOAD O1 UNLESS O2 EASIER! 
LIKE.1:	IF EZ.LD(O1)#0 THEN GO DO.AR	
	IF EZ.LD(O2)#0 THEN GO DO.AR 
LD.1:	LD(ANY,O1,XAE); GO DO.AR
2: C2: !KON+REG! K.SPLIT(O1); IF K.LH=K.RH=0 THEN RETURN
	OFF (ANY,O2,BNOT(U.BNOT BOR U.NG))
	IF BNOT.P(O2) THEN DO !KON+BNOT(REG)! 
	K.ADD(O1,IF NEG.P(O2) THEN 1 ELSE -1)	
	COMP(O2,U.BNOT+U.NG)
	END	
	INST_IF K.SGN(O1) BXOR [NEG.P(O2)] =0 THEN &
	OCT 270 !ADD! ELSE OCT 274 !SUB!
	MAK.POS(O1)	
GEN.O2:	GEN.O(INST,O2,O1); RETURN
3: !CORE+KON! O1<=>O2; GO C1	
4: !CORE+CORE! NULL	
LIKE.2:	O1<=>O2; GO LIKE.1
5: !CORE+REG! NULL
C5:	OFF(ANY,O1,XAE); OFF(ANY,O2,BNOT U.NG)	
	INST_IF [NEG.P(O1)]=[NEG.P(O2)] THEN OCT 270 !ADD! &
	ELSE OCT 274 !SUB
	IF NEG.P(O1) THEN COMP(O1,U.NG)
	GO GEN.O2	
6: !REG+KON! O1<=>O2; GO C2
7: !REG+CORE! O1<=>O2; GO C5	
8: !REG+REG! IF INDR.P(O2) THEN O1<=>O2
	GO C5
10: C10: !KON-CORE! COMP(O2,U.NG)	
C10A:	OP_HEX 00 !ADD!; GO C1 
11: !KON-REG! GO C10 
12: C12: !CORE-KON! K.NEG(O2); O1<=>O2; GO C10A 
13: C13: !CORE-CORE! COMP(O2,U.NG); OP _ 0!ADD!; GO LIKE.1
14: !CORE-REG! GO C13
15: !REG-KON! GO C12 
16: !REG-CORE! GO C13
17: !REG-REG! GO C13
19: !KON*CORE! O1<=>O2; GO C21
20: !KON*REG! O1<=>O2; GO C21 
21: C21: !CORE*KON! MULDIV(0) 
22: !CORE*CORE! GO LIKE.2	
23: C23: !CORE*REG! NULL
	OFF(ANY,O2,BNOT U.NG) 
	COMP(O1,U.NG BAND X(O2))
	GEN.O(OCT 220 !IMUL!,O2,O1); RETURN
24: !REG*KON! GO C21 
25: !REG*CORE! O1<=>O2; GO C23
26: !REG*REG! IF INDR.P(O2) THEN O1<=>O2; GO C23
28: C28: !KON/CORE! K.SPLIT(O1); IF K.LH=K.RH=0 THEN GO OK.1
	GO LD.1
29: !KON/REG! GO C28 
30: C30: !CORE/KON! K.SPLIT(O2); IF K.LH=K.RH=0 THEN WARN('ZER DIV!')
	MULDIV(1)
31: !CORE/CORE! GO LD.1 
32: !CORE/REG! GO LD.1	
33: !REG/KON! LD(DBL,O1,BNOT U.NG); GO C30
34: C34: !REG/CORE! LD(DBL,O1,BNOT U.NG)	
	COMP(O1,RST(O2,U.NG))	
	MODUDIV(QUO)	
35: !REG/REG! GO C34 

END
RETURN

%MULDIV(FLG) ! FLG=0 -> AE*KON ; FLG=1 -> AE/KON
LOCAL A,J,ADDR
K.SPLIT(O2); IF K.LH=K.RH=0 THEN RETURN
IF K.LH=0 AND K.RH=1 THEN GO OK.1
IF K.LH=K.RH=OCT 777.777	THEN [COMP(O1,U.NG); GO OK.1]
IF FLG=0 AND ADDR_LOG(O2)>0 THEN DO
	IF K.SIGN(O2)<0 THEN COMP(O1,U.NG)
	LD(ANY,O1,BNOT U.NG)
	GEN(M.LIT,OCT 240 !ASH!,V(O1),0,0,ADDR); RT(V(O1))_0; GO OK.1
END
IF FLG#0 THEN [ A_DBL; INST_OCT 230 !IDIV!] &
 ELSE [ A_ANY; INST_OCT 220 !IMUL!]
LD(A,O1,BNOT U.NG)
IF RST(O1,U.NG)#0 THEN K.NEG(O2)
IF FLG#0 THEN[ CLR(V(O1)+1);RT(V(O1)+1)_0]
GEN.O(INST,O1,O2); GO OK.1
END MULDIV
END ARITH	

%MODULO
LOCAL J	
	LD(DBL,O1,ALLB) 
	MODUDIV(REM)
RETURN
END MODULO

%BITS
OFF(ANY,O1,XBE); OFF(ANY,O2,XBE)
IF T(O1)=REG THEN O1<=>O2 
IF T(O2)#REG THEN LD(ANY,O2,BNOT U.BNOT) ELSE OFF(ANY,O2,BNOT U.BNOT)
! ** SEE PAGE 41 OF DEC MANUAL ** !
W1_IF RST(O2,U.BNOT)#0 THEN BNOT OCT 5 ELSE OCT 5
W2_IF RST(O1,U.BNOT)#0 THEN BNOT OCT 3 ELSE OCT 3
DO OP OF HEX 20 !BAND!:HEX 23 !BEQV!	
HEX 20 !BAND!: INST_W1 BAND W2
HEX 21 !BOR! : INST_W1 BOR	W2
HEX 22 !BXOR!: INST_W1 BXOR W2
HEX 23 !BEQV!: INST_W1 BEQV W2
END
INST_OCT 400 !SETZ!+4*(INST BAND OCT 17); GEN.O(INST,O2,O1)
RETURN
END BITS

%SHIFT 
INST_IF OP<HEX 32 !ROTL! THEN OCT 242 !LSH! ELSE OCT 241 !ROT!
IF T(O2)=KON THEN DO
	LD(ANY,O1,ALLB) 
	IF R.SHIFT(OP) THEN K.NEG(O2)
	K.SPLIT(O2); K.RH_[BITSPERWORD-18,10,8]*[0,K.LH,K.RH]
	GEN(M.LIT,INST,V(O1),0,0,K.RH); RT(V(O1))_0
END ELSE DO !AE SHIFT AE!	
	IF R.SHIFT(OP) THEN COMP(O2,U.NG) 
	LD(ANY,O1,ALLB); LD(ANY,O2,ALLB) 
	GEN(M.LIT,INST,V(O1),V(O2),0,0); RT(V(O1))_0
END
O1<=>O2
RETURN
END SHIFT 

%MIN.MAX	
	EIF T(O1)=REG THEN NULL
	ORIF T(O2)=REG THEN O1<=>O2	
	ORIF T(O1)=KON THEN O1<=>O2	
	ORIF T(O2)=KON THEN NULL	
	FIF X(O2)>X(O1) THEN O1<=>O2 
	LD(ANY,O1,BNOT U.NG)
	IF NEG.P(O1) THEN DO ! MAX<=>MIN ! 
	OP_HEX 40 !MAX!+HEX 41 !MIN!-OP	
	IF T(O2)#KON THEN COMP(O2,U.NG) ELSE K.NEG(O2) 
	END	
	INST_IF OP=HEX 40 !MAX! THEN 5 ELSE 3 
	IF T(O2)=KON THEN DO
	K.SPLIT(O2)
	EIF K.LH=0 THEN GEN(M.LIT,OCT 300 !CAI!+INST,V(O1),0,0,K.RH)
	ELSE GEN(M.O,OCT 310 !CAM!+INST,V(O1),0,0,O2)	
	END ELSE DO
	INST_INST+IF RST(O2,U.AT)#0 THEN &
	OCT 300 !CAI! ELSE OCT 310 !CAM! 
	GEN.O(INST,O1,O2) 
	END	
	GEN.O(OCT 200 !MOVE!,O1,O2)
	O2<=>O1

RETURN
END MIN.MAX	

%MODUDIV(RESULT)	! 'RESULT' CHOOSES BETWEEN THE REG PAIR 
LOCAL A	
A_V(O1)	
! OPND O1 IN REGISTER A. DIVIDE BY O2. 
	OFF(A+1,O2,XAE)	
	EZ.LD(O2)
	IF T(O2)#REG OR V(O2)#A+1 THEN CLR(A+1)	
	GEN.O(OCT 230 !IDIV!,O1,O2); RT(A+1)_0; EMANC(A)
	V(O1)_A_A+RESULT 
	SLAVE(A); O1<=>O2
RETURN
END MODUDIV	
END BINARY	


%STORE	(OP)
LOCAL A ,%MOVEV,O1,O2,%ST.I.D
	O1_P-1
	O2_P
DO OP OF HEX 70 !_! : HEX 80 !MAX_!
HEX 70 !_!: !O2_O1!	IF T(P)=UPK THEN DO
	DEC P; FIELDS(0)
END ELSE DO
	MOVEV(O1,O2); DEC P
END
HEX 71 !<==! :	LD(ANY,O2,ALLB); GEN.O(OCT 250 !EXCH!,O2,O1)	
	DIDDLE(O1); RLS(O1); DEC P; STK(O2)	
HEX 72 !EXCH!: !O1<=>O2! NULL 
	A_FRE.X; SLAVE(A)
	OPND(O1); DUP(O1); GEN.I(OCT 200 !MOVE!,A)
	OPND(O2); GEN.I(OCT 250 !EXCH!,A)
	OPND(O1); GEN.I(OCT 202 !MOVEM!,A); EMANC(A)
	UTV; UTV; UTV; RECORD(A,O1)
HEX 73 !DSW_DAE!:	![O1;O2]_[P-3;P-2] ! NULL 
	MOVEV(P-2,O2); MOVEV(P-3,O1); DEC P; DEC P
HEX 76: IF NOT ST.I.D(1) THEN [OP_OCT 273 !ADDB! ; GO BINBAK]
HEX 77: IF T(O1)=NIL THEN [OP_OCT 213 !MOVNS!; GO UNBAK]
	IF NOT ST.I.D(-1) THEN [OP_OCT 277 !SUBB!; LD(ANY,O1,ALLB); GO XBINBAK]
HEX 78: OP_OCT 223 !IMULB!
BINBAK: LD(ANY,O1,ALLB); GO DOBAK
HEX 79: OP_OCT 233 !IDIVB!; LD(DBL,O1,ALLB)
XBINBAK: GEN.O(OCT 250 !EXCH!,O1,O2)
	DIDDLE(O1)
DOBAK:	GEN.O(OP,O1,O2); DIDDLE (O2); RECORD(V(O1),O2); RLS(O2); DEC P; STK(O1)
HEX 7A: OP_OCT 407 !ANDB!;  GO BINBAK
HEX 7B: OP_OCT 437 !ORB!;   GO BINBAK
HEX 7C: OP_OCT 433 !XORB!;  GO BINBAK
HEX 7D: OP_OCT 447 !EQVB!; GO BINBAK
HEX 7E: OP_OCT 463 !SETCMB!
UNBAK:	T(O1)_REG; SLAVE(V(O1)_FRE.X); X(O1)_ID(O1)_0
	GEN.O(OP,O1,O2); DIDDLE(O2); UTV
END
RETURN

%MOVEV(AE,LP)
LOCAL A	
EIF T(LP)=NIL THEN NULL
ORIF T(LP)=TEL THEN DO
	LD(ANY,AE,ALLB)
	GEN(M.LIT,OCT 51 !TTCALL!, 1 !OUTPUT! , 0,0,V(AE))
END
ORIF BYTS.P(LP) THEN DO
	LD(ANY,AE,ALLB); A_V(AE) 
DO (X(LP)<==X(LP) BAND OCT 17) SHR 4 OF 1 !CHV! : 8 !RH! 
1 !CHV!: 2 !HWV!:	OPND(LP); EZBYT(OCT 137 !DPB!,A,LP) 
3 !NCHV!: 4 !NHWV!:	OPND(LP); EZBYT(OCT 136 !IDPB!,A,LP) 
5 !PCHV!:	OPND(LP); PBYT(OCT 137 !DPB!,A,LP,7) 
6 !PHWV!:	OPND(LP); PBYT(OCT 137 !DPB!,A,LP,18)
7 !LH!: OFF(ANY,LP,XOPND);OPND(LP);IMM_0
        	GEN.O1(OCT 506 !HRLM!,AE,LP)	
8 !RH!: OFF(ANY,LP,XOPND);OPND(LP);IMM_0
        	GEN.O1(OCT 542 !HRRM!,AE,LP)	
END
	DIDDLE(LP); RLS(LP)
END
ELSE ST(AE,LP)
RETURN
END MOVEV

%ST.I.D(I)
IF T(O1)=KON AND ABS INT(O1)=ABS I THEN DO
	UNARY(IF INT(O1)=I THEN 14 !INC! ELSE 15 !DEC!)
	RLS(O1); DEC P; STK(O2); RETURN 1
END
RETURN 0
END ST.I.D
END STORE

%ST(AE,SW)
LOCAL XI,A
EIF T(AE)=KON AND ((A_INT(AE))=0 OR A=-1) THEN DO
	OPND(SW)
	GEN.I(IF A=0 THEN OCT 402 !SETZM! ELSE OCT 476 !SETOM!,0)
	DIDDLE(SW); RLS(SW)
END
ELSE DO
LD(ANY,AE,IF T(AE)#REG OR NEG.P(AE) THEN U.BNOT ELSE 0) 
OPND(SW); A_V(AE) 
XI_RST(SW,U.AT) BOR RST(SW,U.UP) BOR (X(AE) BAND (U.NG BOR U.BNOT))
EIF X(AE)=0 THEN INST_OCT 202 !MOVEM!
ORIF X(AE)=U.NG THEN INST_OCT 212 !MOVNM!
ORIF X(AE)=U.BNOT THEN INST_OCT 452 !SETCAM!
ELSE HALT
GEN.I(INST,A)	
DIDDLE(SW); RLS(SW)
RECORD(A,SW); RX(A)_XI
END
RETURN
END ST

%DBLE (OP)
LOCAL A,J,%MDV,%DDV.MOD,O1,O2,%MAK.DBL
	O2_P
	O1_P-1
DO OP OF HEX 50 !DIVMOD!:HEX 58 !DROTR!
HEX 50 !DIVMOD!: MDV(OCT 230 !IDIV!)
HEX 51 !MODDIV!: MDV(OCT 230 !IDIV!); V(P)<=>V(P-1)	
HEX 52 !DMUL!: MDV(OCT 224 !MUL!) 
HEX 53 !DMODDIV!: DDV.MOD; V(O1)<=>V(O1-1)
HEX 54 !DDIVMOD!: DDV.MOD
HEX 55 !DSHL!: HEX 56 !DSHR!: INST_OCT 246 !LSHC!; GO SHFT1	
HEX 57 !DROTL!: HEX 58 !DROTR!: INST_OCT 245 !ROTC! 
SHFT1:	IF T(O2)=KON THEN DO
	K.SPLIT(O2); IF K.LH=K.RH=0 THEN [UTV; RETURN]
	END
	LD(DBL,O1-1,ALLB); A_V(O1-1)	
	IF T(O1)=REG AND ABS(A-V(O1))=1 AND INST*OCT 245 !ROTC! THEN DO
	!THIS FOR THE CASE O1 ROTC O2 === O2 ROTC O1
	!WHERE THE REGISTERS ARE ALREADY ADJACENT
	IF A>V(O1) THEN A_V(O1); OFF(V(O1),O1,ALLB)
	END ELSE LD(A+1,O1,ALLB)	
	IF T(O2)=KON	THEN DO !AE SHIFT KON!
	J_INT(O2); IF DR.SHIFT(OP) THEN J_-J
	GEN(M.LIT,INST,A,0,0,J)
	END ELSE DO !AE SHIFT AE! 
	IF DR.SHIFT(OP) THEN COMP(O2,U.NG) 
	LD(ANY,O2,ALLB); GEN(M.LIT,INST,A,V(O2),0,0)
	END	
	UTV; MAKDBL
END
RT(A)_RT(A+1)_0; SLAVE(A); SLAVE(A+1)
RETURN

%MDV(INST)	
LD(DBL,O1,ALLB); A_V(O1); OFF(A+1,O2,XOPND) 
IF T(O2)#REG OR V(O2)#A+1 THEN CLR(A+1)
GEN.O(INST,O1,O2); MAK.DBL; RETURN	
END MDV	

%DDV.MOD	
 LD(DBL,O1-1,ALLB); LD((A_V(O1-1))+1,O1,ALLB)
GEN.O(OCT 234 !DIV!,O1-1,O2); UTV; MAK.DBL; RETURN
END DDV.MOD	

%MAK.DBL 
UTV; UTV; TVLIT(REG,A,0,0); TVLIT(REG,A+1,0,0); RETURN
END MAK.DBL 
END DBLE

%INDEX ! P-1(P)
IF GKIND(ID(P-1))=DVEC	THEN DO! DYNAMIC ARRAY!	
	IF T(P)=KON THEN DO
		V(P)_INT(P); T(P)_W.ABS; ID(P)_X(P)_0
		TV.U(P-1); TV.U(P)
	END ELSE DO
		BINARY(0 !ADD!)
		OFF(ANY,P,ALLB);COMP(P,U.UP);RETURN
	END
END ELSE DO
	TV.U(P); TV.U(P-1)
END
DEC P; T(P)_SUB; V(P)_SUB.P; X(P)_ID(P)_0
RETURN
END INDEX 

%UNARY(OP)	
DO OP OF 1 !CHV!:15 !DEC!	
9 !@!:	EIF X(P)=U.UP THEN X(P)_0
	ORIF W.ABS<=T(P)<=SUB AND X(P)=0 THEN X(P)_U.AT 
	ELSE DO !@<AE>!	
	LD(ANY,P,ALLB); SAV(P); X(P)_U.AT
	END	
10 !^!: DO T(P)/(REG-W.ABS) OF 0:2	
	0: !KON! V(P)_INT(P); T(P)_W.ABS; ID(P)_X(P)_0
	1: !CORE! EIF X(P)=0 THEN X(P)_U.UP	
	ORIF X(P)=U.AT THEN X(P)_0	
	ELSE[LD(ANY,P,ALLB);X(P)_U.UP] 
	2: !REG! EIF X(P)=0 THEN X(P)_U.UP
	ELSE [LD(V(P),P,ALLB); X(P)_U.UP]
	END 
11 !BNOT!:	EIF T(P)=KON THEN K.NOT(P)
	ORIF NEG.P(P) THEN [LD(ANY,P,ALLB);X(P)_U.BNOT] 
	ELSE COMP(P,U.BNOT) 
12 !NEG!:	EIF T(P)=KON THEN K.NEG(P)
	ELSE COMP(P,U.NG)	
13 !ABS!:	EIF T(P)=KON THEN MAK.POS(P) 
	ELSE [RST(P,U.NG); UNIFY(OCT 214 !MOVM!)]
14 !INC!:	MOD.STO(OCT 350 !AOS!)
15 !DEC!:	MOD.STO(OCT 370 !SOS!)
1 !CHV!: 2 !HWV!: 3 !NCHV!: 4 !NHWV!: 5 !PCHV!: 6 !PHWV!: NULL 
	IF X(P) BAND U.UP#X(P) THEN LD(ANY,P,ALLB)
	X(P)_X(P) BOR (OP SHL 4)
END
RETURN
END UNARY

%BYTES(OP)	
LOCAL J	
IF OP=2 !HW! AND T(P)=KON AND 0<=J_INT(P)<=1 THEN DO
	UTV; OFF(ANY,P,BNOT U.AT)
	J_(IF J=0 THEN 7 !LH! ELSE 8 !RH!) SHL 4
	X(P)_IF X(P)=U.AT THEN J ELSE J BOR U.UP 
	RETURN
END
BYT.PTR(IF OP BAND 1 = 0 THEN 18 ELSE 7)	
IF OP<3 !CHPT! THEN X(P)_OP SHL 4
RETURN
END BYTES

%QUA.BYT ! BYT(WORD,AE1,AE2)	
LOCAL WORD
WORD_P-2
IF T(WORD)<W.ABS OR (T(WORD)=REG AND X(WORD)#U.UP) OR (X(WORD) BAND BNOT U.UP)#0 THEN DO
	LD(ANY,WORD,ALLB); SAV(WORD); X(WORD)_U.AT
END ELSE X(WORD)_IF X(WORD)=U.UP THEN 0 ELSE U.AT
IF T(P-1)=T(P)=KON THEN DO
	LD(ANY,WORD,ALLB); RT(V(WORD))_0
	ADDR_[BITSPERWORD-18,6,6,6]*[0,INT(P),INT(P-1),0]
	GEN(M.LIT,OCT 505 !HRLI!,V(WORD),0,0,ADDR)
	UTV; UTV
END ELSE DO 
	LD(ANY,P,ALLB)
	GEN(M.LIT,OCT 242 !LSH!,V(P),0,0,6); RT(V(P))_0
	GEN.O(OCT 270 !ADD!,P,P-1)
	GEN(M.LIT,OCT 242 !LSH!,V(P),0,0,24)
	GEN.O(OCT 270 !ADD!,P,WORD)
	RLS(P-1); RLS(WORD); P_WORD; STK(P+2)
END
X(P)_1 !CHV! SHL 4
RETURN
END QUA.BYT 

%PROC 

%INIT.CALL ! START PROCEDURE CALLING SEQ
LOCAL I
TVKI(REG.P<==X.LO) ! SAVE CURRENT REG.P FOR LATER RECOVERY
I_P-1; T(I)<=>T(P); V(I)<=>V(P); X(I)<=>X(P); ID(I)<=>ID(P)
RETURN
END INIT.CALL

%PARAM 
INC REG.P; RETURN 
END PARAM 

%CALL	
LOCAL I,J,NP
NP_P-REG.P; PARM.FG_1; I_X.LO-1
WHILE INC I<REG.P THEN DO
	J_I+NP+1
	IF T(J)=REG THEN LD(I,J,ALLB)
END
I_X.LO-1; WHILE INC I<REG.P THEN LD(I,I+NP+1,ALLB) 
I_0; WHILE INC I<NP THEN DO
	J_I; WHILE T(J)=SUB THEN J_V(J)+1
	IF T(J)=REG THEN SAV(J)
END
P_NP
OPND(P+1); GEN.I(OCT 265 !JSP!,X.HI)
I_0; WHILE INC I<REG.P THEN EMANC(I)
FGTALL; REG.P_REMINT; TVLIT(REG,X.LO,0,0); SLAVE(X.LO); PARM.FG_0
RETURN
END CALL	

%DCALL
TVLIT(REG,X.LO+1,0,0); SLAVE(X.LO+1)
RETURN
END DCALL
END PROC 

%GEN.O(INST,AC,O) 
	OFF(ANY,O,XOPND) 
	OPND(O) 
%%GEN.O1(INST,AC,O)
	AC_V(AC)
	RT(AC)_0
	GEN.I(INST,AC)
RETURN
END GEN.O

%MOD.STO(INS) !MODIFY STORAGE
LOCAL A
SLAVE(A_IF T(P)=REG THEN V(P) ELSE FRE.X)
OPND(P)
GEN.I(INS,A)
DIDDLE(P)
RECORD(A,P)
UTV
TV.LIT(REG,A,0,0)
RETURN
END MOD.STO

%UNIFY(INS) ! PERFORM FORCED UNOP
LOCAL A	
OFF(ANY,P,XOPND)	
A_IF T(P)=REG THEN V(P) ELSE FRE.X
SLAVE(A)
OPND(P)	
GEN.I(INS,A); UTV
TVLIT(REG,A,0,0); RT(A)_0
RETURN
END UNIFY

%OFF(A,O,UNOPS) ! PERFORM SPECIFIED UNOPS TO OPND O USING
	! REGISTER A IF NECESSARY. 
	IF UNOPS_X(O) BAND UNOPS#0 THEN LD(A,O,UNOPS)	
RETURN
END OFF	

%LD(AC,O,UNOPS) 

! LOAD OPERAND O INTO REGISTER AC INSURING THAT SPECIFIED
! UNOPS HAVE BEEN PERFORMED. OTHER UNOPS CAN BE DONE BUT
! IF NOT, WILL BE HANDLED BY CALLER. ALL THAT CALLER
! REQUIRES IS THAT SPECIFIED UNOPS ARE NO LONGER PENDING.
! THE UNOPS U.UP AND U.AT AND ALL THE BYTE UNOPS ARE
! UNCONDITIONALLY PERFORMED.

DEF ON(U) AS (X(O) BAND (U) BAND UNOPS # 0)
LOCAL A

	UNOPS_UNOPS BOR (U.UP BOR U.AT BOR U.BYTS)

! IF A PARTICULAR REGISTER IS REQUESTED AND THE REGISTER IS
! FREE, SEE IF OPERAND IS ALREADYHE REGISTER.

	IF AC>=X.LO AND R.STATE(AC) = 0 THEN DO	
	IF MATCH(AC,O)#0 THEN DO
	RLS(O); T(O)_REG; V(O)_AC; COMP(O,RX(AC)); SLAVE(AC)
	END
	END
	IF T(O)#REG THEN GO SEEK.AR 

! OPERAND IS IN A REGISTER BUT MAY NOT BE REGISTER REQUESTED.

SEEK.AC:	EIF AC=ANY THEN AC_V(O)
	ORIF AC=DBL THEN [IF V(O)<X.HI THEN [AC_V(O); CLR(V(O)+1)] &
        ELSE AC_FRE.D.X]
	FIF AC#V(O) AND R.STATE(AC)#0 THEN DO
	RT(V(O))<=>RT(AC)
	RV(V(O))<=>RV(AC)
	RX(V(O))<=>RX(AC)
	RID(V(O))<=>RID(AC)
	R.STATE(V(O))<=>R.STATE(AC)
	GEN(M.LIT,OCT 250 !EXCH!,AC,0,0,V(O))
	A_REF.OPND(AC)
	V(A)<=>V(O)
	END
USE.AC: IF NOT ON(ANY) AND V(O)=AC THEN RETURN	
	SLAVE(AC)
	OPND(O)
	IF BYTS.P(O) THEN GO LD.BYT
	IF AC#V(O) THEN DO
	RT(AC)_RT(V(O))
	RV(AC)_RV(V(O))
	RX(AC)_RX(V(O))
	RID(AC)_RID(V(O))
	END

! PERFORM PENDING REQUESTED PENDING UNOPS AND MOVE TO AC

LD.AC: SWITCH(X(O) BAND (U.AT BOR U.UP))
	IF T(O)=REG AND AC=ADDR=V(O) AND X(O)= &
	(U.NG BOR U.BNOT) THEN DO
	GEN(M.LIT,OCT 340 !AOJ!,AC,0,0,0)
	SWITCH(U.BNOT); SWITCH(U.NG)
	END ELSE IF ON(U.BNOT) THEN DO
	GEN.I(OCT 460 !SETCM!,AC); SWITCH(U.BNOT)
	IF ON(U.NG) THEN DO
	GEN(M.LIT,OCT 210 !MOVN!,AC,0,0,AC)
	SWITCH(U.NG)
	END
	END ELSE IF ON(U.NG) THEN DO
	GEN.I(OCT 210 !MOVN!,AC); SWITCH(U.NG)
	END ELSE GEN.I(OCT 200 !MOVE!,AC)
AC.DUN:	RLS(O); T(O)_REG; V(O)_AC; RETURN

! OPERAND NOT IN A REGISTER. SEE IF A REGISTER HAS A COPY OF
! OPERAND AND IF SO, USE THAT REGISTER AS A SOURCE FOR
! THE OPERAND.

SEEK.AR: A_X.LO-1 
	WHILE INC A<=X.HI THEN IF MATCH(A,O)#0 THEN DO
	RLS(O); T(O)_REG; V(O)_A; COMP(O,RX(A))
	IF R.STATE(A)=0 THEN [SLAVE(A); GO SEEK.AC] &
	ELSE GO NEW.AC
	END
!FIND A NEW AC 
NEW.AC:	EIF AC=ANY THEN AC_FRE.X
        ORIF AC=DBL THEN AC_FRE.D.X
	ELSE CLR(AC)
	IF T(O)=REG THEN [SLAVE(V(O)); GO USE.AC]
	SLAVE(AC)
	IF T(O)=KON THEN DO !SPECIAL CUTE LOADS FOR CONSTANTS! 
	K.SPLIT(O)
	EIF K.LH=0 THEN &
	GEN(M.LIT,OCT 201 !MOVEI!,AC,0,0,K.RH)
	ORIF K.RH=0 THEN &
	GEN(M.LIT,OCT 515 !HRLZI!,AC,0,0,K.LH)	
	ORIF K.LH=OCT 777.777 THEN &
	GEN(M.LIT,OCT 211 !MOVNI!,AC,0,0,-K.RH)
	ORIF K.RH=OCT 777.777 THEN &
	GEN(M.LIT,OCT 525 !HRLOI!,AC,0,0,K.LH) 
	ELSE GEN(M.O,OCT 200 !MOVE!,AC,0,0,O) 
	X(O)_0; RT(AC)_0; GO AC.DUN 
	END	! T(O)=KON

	PUSH(4,RETURN,AC,O,UNOPS)
	OPND(O)
	POP(4,@RETURN,@AC,@O,@UNOPS)

	IF BYTS.P(O) THEN GO LD.BYT
	RECORD(AC,O)
	GO LD.AC 

LD.BYT: DO (X(O)<==X(O) BAND OCT 17) SHR 4 OF 1 !CHV!:8 !RH!
1 !CHV!: 2 !HWV!: EZBYT(OCT 135 !LDB!,AC,O)	
3 !NCHV!: 4 !NHWV!: EZBYT(OCT 134 !ILDB!,AC,O)
5 !PCHV!: A_7;GO LD.BY1
6 !PHWV!: A_18
LD.BY1:  PUSH (4,RETURN,AC,O,UNOPS)
        PBYT(OCT 135 !LDB!,AC,O,A)
        POP (4,@RETURN,@AC,@O,@UNOPS)
7 !LH!:	GEN.I(OCT 554 !HLRZ!,AC)
8 !RH!:	GEN.I(OCT 550 !HRRZ!,AC)
	END
	X(O)_X(O) BAND U.NG
	RT(AC)_0
	IF ON(U.NG) THEN DO
	X(O)_0; GEN(M.LIT,OCT 210 !MOVN!,AC,0,0,AC)
	END
	GO AC.DUN

%SWITCH(UNOP)!RECORD UNOP IN BOTH REGISTER AND OPND DESCRIPTORS
	IF UNOP=0 THEN RETURN
	COMP(O,UNOP)	
	IF RT(AC)=0 THEN RETURN
	EIF UNOP<=RX(AC) OR (UNOP=U.UP AND RX(AC)#0) THEN &
	RT(AC)_0
	ELSE RX(AC)_RX(AC) BOR UNOP 
	RETURN
END SWITCH
END LD 

%EZ.LD(O) ! CAN O BE LOADED AT NO COST?	
IF T(O)=REG THEN RETURN 1
LOCAL A	
A_X.LO-1	
WHILE INC A<X.HI THEN DO 
	IF R.STATE(A)=0 AND MATCH (A,O)#0 THEN GO USE.A	
END
RETURN 0
USE.A: RLS(O); COMP(O,RX(A)); T(O)_REG; V(O)_A; SLAVE(A); RETURN 1
END EZ.LD	

%OPND(O)
	LOCAL I
	INDX_0
	DO T(O) OF KON:REG
KON:	K.SPLIT(O)
	EIF K.LH=0 THEN [IMM_1; ADDR_K.RH; MODE_M.LIT]
	ELSE [IMM_0; ADDR_O; MODE_M.O]
	INDR_0
REG:	EIF INDR.P(O) THEN [ADDR_0; INDX_V(O)]
	ELSE ADDR_V(O)
	MODE_M.LIT
	INDR_0
	GO DO.W.2
W.ABS: W.REL:	ADDR_O
DO.W.1:	MODE_M.O
	INDR_[INDR.P(O)]
DO.W.2:	IMM_[AT.P(O)]
SUB:	I_V(O)+1
	EIF T(I)=KON THEN INDX_[18,18]*[INT(I),0]
	ELSE DO
		PUSH(2,RETURN,O)
		LD(ANY,I,ALLB)
		POP(2,@RETURN,@O)
		INDX_V(V(O)+1)
	END
	ADDR_V(O)
	GO DO.W.1
	END
RETURN
END OPND

%LP.OPND(O) ! DON'T ALLOW IMMEDIATE CONSTANTS!	
IF MODE=M.LIT AND IMM=1 THEN [MODE_M.O;IMM_0;ADDR_O]
RETURN
END LP.OPND 

%GEN.I(INS,A)	
GEN(MODE,INS+IMM,A,INDX,INDR,ADDR)
RETURN
END GEN.I

%PBYT(INS,A,O,BYTSIZ)
LOCAL R,BU	
BU_(36/BYTSIZ)*BYTSIZ
R_FRE.X	
SLAVE(R)
DUP(O)
GEN.I(OCT 200 !MOVE!,R) ! LOAD POINTER VALUE	
TVDKI(BYTSIZ SHL 12,0)
GEN(M.O,OCT 270 !ADD!,R,0,0,P); UTV ! INCREMENT "BITS LEFT"
GEN(M.LIT,OCT 305 !CAIGE!,R,0,0,0) ! TEST OVERFLOW	
TVDKI(BU SHL 12,1)
GEN(M.O, OCT 274 !SUB!,R,0,0,P) ! DECR WORD ADDR !;UTV
OPND(P)
GEN.I(OCT 202 !MOVEM!,R) ! UPDATE POINTER WORD!;UTV
GEN(M.LIT,INS,A,0,0,R) ! EMPLOY THE POINTER VALUE	
EMANC(R)
RETURN
END PBYT 

!***********
!
! REGISTER UTILITIES
!
!***********

%FRE.X ! FIND A FREE REGISTER	
	LOCAL A,O,J
	A_REG.P
	IF R.STATE(REG.P)=0 THEN GO RET.A
	WHILE INC A<X.HI THEN DO
	IF R.STATE(A)=0 AND RT(A)=0 &
        AND R.STATE(A+1)=0 THEN GO RET.A
	INC A 
	END	
! SETTLE FOR ANY INACTIVE REG !	
	IF A_EZ.FRE.X>X.LO THEN GO RET.A
!EVICT AN OPND!
	J_0; WHILE INC J<=P THEN DO	
	O_J; WHILE T(O)=SUB THEN O_V(O)+1
	IF T(O)=REG THEN [A_SAV(O); GO RET.A]
	END	
	HALT 
RET.A: RT(A)_0; RETURN A
END FRE.X

%FRE.D.X ! FIND A FREE REGISTER PAIR!
LOCAL A,O,J
A_REG.P-1
!TRY FOR AN UNNAMED UNUSED PAIR!
WHILE INC A<X.HI THEN DO
        IF R.STATE(A)=0 AND RT(A)=0 &
        AND R.STATE(A+1)=0 AND RT(A+1)=0 THEN GO RET.D.A
END
!SETTLE FOR AN UNUSED PAIR!
A_REG.P-1
WHILE INC A<X.HI THEN DO
        IF R.STATE(A)=0 AND R.STATE(A+1)=0 THEN GO RET.D.A
END
!NONE FREE EVICT 2 OPNDS!
J_0; WHILE INC J<=P THEN DO
        O_J; WHILE T(O)=REG THEN DO
                IF A_SAV(O)<X.HI THEN &
                [IF R.STATE(A+1)=0 THEN GO RET.D.A; &
                SAV(A+1); GO RET.D.A]
                END
        END
HALT  !COMPILER ERROR, NO REGISTERS AVAILABLE!
RET.D.A: RT(A)_0;RT(A+1)_0;RETURN A
END FRE.D.X
%EZ.FRE.X! RETURN FREE REG# IF ONE EXISTS, ELSE X.LO-1	
LOCAL A	
A_X.LO-1	
WHILE INC A<X.HI THEN IF R.STATE(A)=0 THEN RETURN A 
RETURN X.LO-1
END EZ.FRE.X 

%MATCH(AC,O) ! IS REGISTER AC A SOURCE FOR OPND O ?
	IF T(O)=REG AND V(O)=AC THEN RETURN 1 
	IF RT(AC)#T(O) OR RV(AC)#V(O) OR RID(AC)#ID(O) THEN RETURN 0	
	IF RX(AC)=X(O) THEN RETURN 1	
	IF BYTS.P(O) THEN RETURN 0	
! CHECK FOR COMPATABLE UNOPS. 
	LOCAL DIF	
	DIF_RX(AC) BXOR X(O)	
	IF DIF BAND U.AT # 0 THEN RETURN 0
	IF DIF BAND (U.UP BAND RX(AC))#0 THEN RETURN 0
	IF DIF BAND U.BNOT = 0 THEN RETURN 1 
	IF RX(AC) BAND U.NG # 0 THEN RETURN 0 ELSE RETURN 1 
END MATCH

%CLR(A1) ! CLEAR REGISTER A1
LOCAL A2,O
IF R.STATE(A1)=0 THEN RETURN
O_REF.OPND(A1)
IF PARM.FG=0 AND A2_EZ.FRE.X>X.LO THEN DO
	GEN(M.LIT,OCT 200 !MOVE!,A2,0,0,A1)
	R.STATE(A2)<=>R.STATE(A1)
	RT(A2)_RT(A1)
	RV(A2)_RV(A1)
	RX(A2)_RX(A1)
	RID(A2)_RID(A1)
	V(O)_A2
END ELSE SAV(O)
RETURN
END CLR

%SAV(O) ! PUT AN OPND FROM REG TO CORE
	LOCAL A,L	
	IF T(O)#REG THEN HALT
	A_V(O); L_ALLOC(1)
	EIF INDR.P(O) OR BYTS.P(O) OR X(O)=0 THEN &
	GEN(M.DT,OCT 202 !MOVEM!,A,0,0,L) 
	ORIF BNOT.P(O) THEN &
	[COMP(O,U.BNOT); GEN(M.DT,OCT 452 !SETCAM!,A,0,0,L)]	
	ORIF	NEG.P(O) THEN &
	[COMP(O, U.NG); GEN(M.DT,OCT 212 !MOVNM! ,A,0,0,L)]	
	ELSE HALT	
	RLS(O); T(O)_W.REL; V(O)_L; ID(O)_0
RETURN
END SAV

%FGTALL
LOCAL R
R_X.LO-1
WHILE INC R<=X.HI THEN RT(R)_0
LASTBR_0
RETURN
END FGTALL

%SLAVE(A) ! INDICATE REGISTER IN USE
INC R.STATE(A); RETURN
END SLAVE

%EMANC(R) ! HEREBY PROCLAIM THE FREEDOM OF R 
IF NOT X.LO<=R<=X.HI OR DEC R.STATE(R)<0 THEN HALT
RETURN
END EMANC

%REF.OPND(AC) ! FIND WHICH OPND REFERS TO AC 
LOCAL J,O
IF R.STATE(AC)=0 THEN HALT 
J_0
WHILE INC J<=P THEN DO	
	O_J; WHILE T(O)=SUB THEN O_V(O)+1
	IF T(O)=REG AND V(O)=AC THEN RETURN O	
END
HALT	
END REF.OPND

%RECORD(R,O) ! LET ALL KNOW WHAT REGISTER CONTAINS!
IF W.ABS<=T(O)<=W.REL THEN DO
	RT(R)_T(O); RV(R)_V(O); RX(R)_0; RID(R)_ID(O) 
END ELSE RT(R)_0
RETURN
END RECORD	

%DIDDLE(O) ! ANY REGISTER WHO THOUGHT HE KNEW O IS MISTAKEN 
LOCAL R	
R_X.LO-1	
WHILE INC R<=X.HI THEN DO
	IF RT(R)=T(O) AND RV(R)=V(O) AND RID(R)=ID(O)THEN RT(R)_0
END
RETURN
END DIDDLE	

!*************
!
! STACK UTILITIES
!
!*************

%TV(TYPE)
	IF INC P >= SUB.P THEN ERR('OPND STK OFL')
	V(P)_X(P)_ID(P)_0; RETURN T(P)_TYPE
END TV

%TVLIT(A,B,C,D)
	TV(A); V(P)_B; X(P)_C; ID(P)_D; RETURN A
END TVLIT

%STK(O)
	IF O=P THEN RETURN	
	T(P)_T(O); V(P)_V(O); X(P)_X(O); ID(P)_ID(O) 
RETURN
END STK

%DUP(O) ! DUPLICATE OPERAND O ON TOP OF STACK
TVLIT(T(O),V(O),X(O),ID(O))
IF T(O)=SUB THEN [SUB.P_SUB.P-2; O_V(O)+1]
IF T(O)=SUB THEN HALT
IF T(O)=REG THEN SLAVE(V(O))
RETURN
END DUP

%TV.U(O) ! PUT O ON UPPER PART OF OPND STK AREA
IF DEC SUB.P<=P THEN ERR('OPND OFLOW')	
LOCAL PS
PS_P<==SUB.P; STK(O); P_PS; RETURN
END TV.U	

%UTV ! UN-TV: REMOVE ITEM FROM STACK
RLS(P); RETURN DEC P
END UTV

%RLS(O) ! RELEASE A SUPERFLUOUS OPND
IF T(O)=SUB THEN [O_V(O)+1; SUB.P_SUB.P+2]
DO T(O) OF KON:REG
SUB:	HALT
KON:	RLS.K(O)
REG:	EMANC(V(O))
END
RETURN
END RLS	

%COMP(O,U)	
	X(O)_X(O) BXOR U	
	RETURN	
END COMP 

%RST(O,U) ! TURNOFF U IN O . WAS A CLEAR REQUIRED?	
IF X(O) BAND U=0 THEN RETURN 0; COMP(O,U); RETURN U	
END RST

%PUSH(N,A,B,C,D) ! MAX 4 ARGS	
LOCAL P	
P_PDP_PDP+N 
DO N OF 4 
1: GO C1 
2: GO C2 
3: GO C3 
4: GO C4 
END
C4: ^DEC P_D
C3: ^DEC P_C
C2: ^DEC P_B
C1: RETURN ^DEC P_A	
END PUSH 

%POP(N,@A,@B,@C,@D)	
DO N OF 4
1: GO C1 
2: GO C2 
3: GO C3 
4: GO C4 
END
C4: D_^DEC PDP 
C3: C_^DEC PDP 
C2: B_^DEC PDP 
C1: RETURN A_^DEC PDP
END POP	

END CG
  @0Ç