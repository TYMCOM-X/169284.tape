C       DOCMEN.FTF
        SUBROUTINE DOCMENT(VALID, REPEAT)
C
C       THIS IS THE DOCUMENT FUNCTIONAL UNIT
C
C       IT PERFORMS ALL THE PROCESSING ASSOCIATED WITH THE DOCUMENT
C       SPECIFICATION.
C
        INTEGER ID(3), REPEAT, OUTTEST
        LOGICAL VALID, FIRSTIM
        DATA FIRSTIM /.TRUE. /
C
        COMMON /FILES/ XFILE(7), YFILE(7), SFILE(7), PFILE(7),
     1  SIGFILE(7), FLIBLIS(7), PIDFILE(7), PPFILE(7)
        INTEGER XFILE, YFILE, SFILE, PFILE, SIGFILE, FLIBLIS, PIDFILE,
     1  PPFILE
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY,
     1  HUSH, UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PLUGBUF/ PPID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRING,
     2  SGRPRNG, PPX, PPY, FROMPP, TOPP, PPFLAG, THISPP, PLUGID(3),
     3  NPP, PP1, SAVEIT
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD, DRIVE, PPX, PPY
        INTEGER PPID, ILT, OLT, GRPNO, SGRPNO, WOCC, TCC, PPCORAL,
     1  GRPRING, SGRPRNG, FROMPP, TOPP, THISPP, PLUGID, PP1
        LOGICAL PPFLAG, SAVEIT
C
C
        EXTERNAL DPOSTS
C
C       EXIT IF VALIDITY CHECK
        IF (.NOT. VALID) GO TO 100
C
C       CLOSE ANY APPROPRIATE FILES
        CALL WCLOSE(XFILE(1) )
        CALL WCLOSE(YFILE(1) )
        CALL WCLOSE(SFILE(1) )
        CALL WCLOSE(PFILE(1) )
        CALL WCLOSE(PIDFILE(1) )
        CALL WCLOSE(PPFILE(1) )
        FIRSTIM = .TRUE.
        RETURN
C
C       NOT VALIDITY CHECKING...DETERMINE IF FIRST ENTRY
  100   IF (.NOT. FIRSTIM) GO TO 110
        FIRSTIM = .FALSE.
        CALL WOPEN(XFILE(1) )
        CALL WOPEN(YFILE(1) )
        CALL WOPEN(SFILE(1) )
        CALL WOPEN(PFILE(1) )
        CALL WOPEN(PIDFILE(1) )
        CALL WOPEN(PPFILE(1) )
C
C       HERE ON NON-VALIDITY CHECKING...GET A LINE, DETERMINE WHAT TO DO
  110   UNCOLA = .FALSE.
C
C       GET A LINE AND TEST IT
  120   CALL NEWLINE
C
C       DETERMINE IF THIS IS A VALID COMMAND
  130   I = LPARSE(21)
        IF (I .EQ. 0) GO TO 120
        IF (I .LT. 0) GO TO 140
        IF (I .GT. 7) GO TO 140
        IF (PRINTER(4) ) GO TO (200, 300, 400, 500, 600, 700, 1200), I
C
C       PRINT FILE NOT YET OPENED
        CALL ERROR('PRINT FILE NOT YET DEFINED','NO PRINT FILE')
        GO TO 130
C
C       UNRECOGNIZABLE...SEE IF ANYONE ELSE KNOWS IT
  140   CALL LISTEST
        GO TO 130
C
C       HERE IF ERROR
  150   CALL ERROR('SYNTAX ERROR IN COMMAND', 'SYNTAX')
        GO TO 130
C
C       NOT EDGE PIN
  160   CALL ERROR('NOT EDGE PIN','NOT EDGE')
        GO TO 130
C
C       FILE NAME SYNTAX
  170   CALL ERROR('FILE NAME SYNTAX','FILE SYNTAX')
        GO TO 130
C
C
C
C       "WIREWRAP"
  200   CALL WIREIT(.TRUE.)
        GO TO 110
C
C
C
C       "PRINT"...TEST FOR "SIGNALS"
  300   IF (LPARSE(22) .NE. 1) GO TO 150
        CALL DSIGNAL
        GO TO 110
C
C
C
C       "WRITE"
  400   IF (LPARSE(13) .NE. 1) GO TO 150
        IF (LPARSE(12) .NE. 1) GO TO 150
        IF (.NOT. LOOKFN(I) ) GO TO 170
        IF (OUTTEST(.TRUE., .FALSE.) .EQ. 3) GO TO 130
C
C       GOT "WRITE TAPE ON **"...DO IT
        CALL WIREIT(.FALSE.)
        GO TO 110
C
C
C
C       "POST"...TEST FOR "COUNT"
  500   IF (LPARSE(23) .NE. 1) GO TO 150
        I = (XMAX - XMIN)*20.0 + 2
        CALL DYNARY(IERR, DPOSTS, I, 0)
        GO TO 110
C
C
C
C       "SOCKET"..TEST FOR "MAP"
  600   IF (LPARSE(24) .NE. 1) GO TO 150
        N = SFILE(3)
        DO 610 I = 1, N
        CALL PAGE(I)
        CALL GETSOC(I)
  610   CALL LSOCKET(.FALSE.)
        GO TO 110
C
C
C
C       "UNUSED"...CHECK IT OUT
  700   I = LPARSE(25)
        GO TO (800, 900, 1000, 1100), I
        GO TO 150
C
C
C
C       "UNUSED SOCKETS"
  800   CALL PAGE(1)
        CALL LEMPTY(.FALSE.)
        GO TO 110
C
C
C
C       "UNUSED PLUGS"
  900   CALL DNOPLUG
        GO TO 110
C
C
C
C       "UNUSED GROUPS"
 1000    CALL PAGE(1)
        CALL LUGSG(.FALSE., 1)
        GO TO 110
C
C
C
C       "UNUSED SUBGROUPS"
 1100    CALL PAGE(1)
        CALL LUGSG(.FALSE., 2)
        GO TO 110
C
C
C
C       "ADD"...TEST FOR EXTENSIONS
 1200    IF (LPARSE(26) .NE. 1) GO TO 150
        IF (.NOT. PACK(ID(1), 10, 0) ) GO TO 150
        IF (.NOT. SOCFIND(ID(1) ) ) GO TO 150
        IF (.NOT. SPINPNT) GO TO 160
        IF (LPARSE(27) .NE. 1) GO TO 150
        IF (.NOT. LOOKFN(I) ) GO TO 170
        IF (LPARSE(28) .NE. 1) GO TO 150
        IF (LPARSE(29) .NE. 1) GO TO 150
        IF (.NOT. PACK(PLUGID(1), 14, 0) ) GO TO 150
        IF (LIBTEST(1) .EQ. 3) GO TO 150
C
C       GOT "ADD EDGE .SOCID. TO .FILE. WITH NAME .PLGID."
        CALL DSAVE
        GO TO 110
        END
        SUBROUTINE WIREIT(PF)
C
C       THIS ROUTINE GENERATES THE WIRING PATTERNS FOR WIRRAP
C       THE ACTUAL PROCESS GENERATED DEPENDS ON .PF.
C       IF .PF. IS TRUE, A PRINTER FILE IS GENERATED, WHICH IS PEOPLE-
C       READABLE
C       IF .PF. IS FALSE, A BINARY FILE IS GENERATED, WHICH MAY BE
C       TRANSLATED (BY ANOTHER PROGRAM) INTO A WIRE-WRAP TAPE.
C
C
C
        COMMON /FILES/ FILES(7, 3), PFILE(7)
        INTEGER PFILE
        EQUIVALENCE (NPINS, PFILE(3) )
C
        COMMON /WITNESS/ WITNESS(9)
        INTEGER WITNESS
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /PINS/ PINID, NEXTPIN, LASTPIN, XPIN, YPIN, BPSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL,
     2  PINFLAG, THISPIN
        INTEGER PINID, BPSIG, FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB,
     1  CNGWORD, THISPIN
        LOGICAL PINFLAG
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLAG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL NEWMOD, MODFLAG, WRITEIT, PICFRAM
C
        INTEGER TEXT(4)
        INTEGER BITMASK
        LOGICAL PF
        DATA TEXT / 'WIRRAP WIRE FILE' /
        DATA MASK / "377777777777 /
        DATA BITMASK / "400000000000 /
C
    1   FORMAT (' CHECK',5X,'FROM',5X,'TO',13X,'LEVEL'//)
    2   FORMAT (//' LOWER-LEVEL WRAPS COMPLETED, COMMENCE UPPER'//)
    3   FORMAT (//' ALL WRAPS COMPLETED, TOTAL OF ',A5,
     1  ' WIRES REQUIRED TO WIRE BOARD'//)
    4   FORMAT (I5)
C
C       FIRST OF ALL, SET UP LEVELS
        CALL LEVEL(MODFLAG)
        MODFLAG = .TRUE.
        CALL SETWRI
        NWIRES = 0
C
C       SET UP THE FILES AS NECESSARY
        IF (PF) GO TO 100
C
C       SET UP FOR BINARY FILE
        WITNESS(2) = 12
        CALL WOPEN(WITNESS(1) )
        WRITE (WITNESS(1) # 1) NWIRES
        GO TO 110
C
C       SET UP FOR PRINTER FILE
  100   CALL PAGE(1)
        WRITE (PRINTER(1), 1)
        CALL LINE
        CALL LINE
        CALL LINE
C
C       NOW SET UP AND PROCESS ALL LOWER-LEVEL WRAPS
  110   LLEVEL = 0
        DO 140 LOWHI = 1, 2
C
C       FIRST SCAN FOR APPROPRIATE BUSSED SIGNALS, OUTPUT THEM
        DO 120 I = 1, NPINS
        CALL GETPIN(I)
        IF (TOSIG .EQ. 0) GO TO 120
        IF (.NOT. FROMSIG) GO TO 120
        IF ( (ATTRIB .AND. BITMASK) .NE. LLEVEL) GO TO 120
C
C       GOT BUSSED PIN...OUTPUT IT
        CALL DLINE(PF, I, NWIRES)
C
C       END OF LOOP
  120   CONTINUE
C
C       NOW SCAN FOR APPROPRIATE NON-BUSSED SIGNALS, OUTPUT THEM
        DO 130 I = 1, NPINS
        CALL GETPIN(I)
        IF (TOSIG .EQ. 0) GO TO 130
        IF (FROMSIG) GO TO 130
        IF ( (ATTRIB .AND. BITMASK) .NE. LLEVEL) GO TO 130
C
C       GOT NON-BUSSED PIN...OUTPUT IT
        CALL DLINE(PF, I, NWIRES)
C
C       END OF LOOP
  130   CONTINUE
C
C       NOW CHANGE TO UPPER LEVEL, THEN REPEAT
        LLEVEL = BITMASK
        IF (.NOT. PF) GO TO 140
C
C       PRINT MODE, COMMENT THAT WE'RE GOING TO UPPER LEVEL
        IF (LOWHI .EQ. 2) GO TO 140
        WRITE (PRINTER(1), 2)
        CALL LINE
        CALL LINE
        CALL LINE
        CALL LINE
        CALL LINE
C
C       END OF LOOP OVER BOTH LEVELS
  140   CONTINUE
C
C       NOW CLEAN UP THE FILES APPROPRIATELY
        ENCODE (5, 4, LLEVEL) NWIRES
        CALL DBLANK(5, LLEVEL)
        IF (PF) GO TO 150
C
C       BINARY FILE...TELL HOW MANY WIRES, CLEAN UP AND CLOSE
        TYPE 3, LLEVEL
        NWIRES = NWIRES + 1
        WRITE (WITNESS(1) # 1) NWIRES, TEXT, XMIN, XMAX, YMIN, YMAX
        CALL WCLOSE(WITNESS(1) )
        WITNESS(2) = 1
        WITNESS(5) = 0
        WITNESS(6) = 0
        WITNESS(7) = 0
        WITNESS(8) = 0
        WITNESS(9) = 0
        RETURN
C
C       HERE FOR PRINT FILE...CLEAN UP
  150   WRITE (PRINTER(1), 3) LLEVEL
        CALL LINE
        CALL LINE
        CALL LINE
        CALL LINE
        CALL LINE
        RETURN
        END
        SUBROUTINE DLINE(PF, I, NWIRES)
C
C       THIS ROUTINE GENERATES ONE WIRE FOR WIRRAP
C       THE ACTUAL PROCESS GENERATED DEPENDS ON .PF.
C       IF .PF. IS TRUE, A PRINTER FILE IS GENERATED, WHICH IS PEOPLE-
C       READABLE
C       IF .PF. IS FALSE, A BINARY FILE IS GENERATED, WHICH MAY BE
C       TRANSLATED (BY ANOTHER PROGRAM) INTO A WIRE-WRAP TAPE.
C       IN THIS CASE, THAT FILE HAS THE FORMAT:
C
C       EACH RECORD IS 12 WORDS LONG;  THE FIRST RECORD CONTAINS, AS THE
C       FIRST WORD, THE NUMBER OF RECORDS IN THE FILE (INCLUSIVE)
C
C       EACH RECORD (OTHER THAN THE FIRST) HAS THE CONTENTS:
C
C       WORD    MODE            USAGE
C       1       LOGICAL         .TRUE. IF UPPER LEVEL WRAP
C       2       REAL            X-POSITION OF FIRST PIN
C       3       REAL            Y-POSITION OF FIRST PIN
C       4       REAL            X-POSITION OF SECOND PIN
C       5       REAL            Y-POSITION OF SECOND PIN
C       6       INTEGER         NUMBER OF ADDITIONAL SIGNIFICANT WORDS
C                               IN THIS RECORD
C       7       REAL            X-POSITION OF FIRST WIRE BEND
C       8       REAL            Y-POSITION OF FIRST WIRE BEND
C       9       REAL            X-POSITION OF SECOND WIRE BEND
C       10      REAL            Y-POSITION OF SECOND WIRE BEND
C       11      REAL            X-POSITION OF THIRD WIRE BEND
C       12      REAL            Y-POSITION OF THIRD WIRE BEND
C
C
C
        COMMON /WITNESS/ WITNESS(9)
        INTEGER WITNESS
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /PINS/ PINID, NEXTPIN, LASTPIN, XPIN, YPIN, BPSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL,
     2  PINFLAG, THISPIN
        INTEGER PINID, BPSIG, FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB,
     1  CNGWORD, THISPIN
        LOGICAL PINFLAG
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLAG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL NEWMOD, MODFLAG, WRITEIT, PICFRAM
C
        COMMON /ROUTE/ ISAVE, JSAVE, XYLIST(2, 5, 2)
C
        DIMENSION XY1(2), XY2(2), XY(2, 3)
        INTEGER BITMASK, ID1(3), ID2(3)
        LOGICAL LR, PF
        DATA MASK / "377777777777 /
        DATA BITMASK / "400000000000 /
        DATA LR / .TRUE. /
C
    1   FORMAT ('  ( )      ', 3A5, 5X, 3A5, 10X, A5, 2X, A1)
C
C       GET THE PIN STARTING, DETERMINE LEVEL
        CALL GETPIN(I)
        LEVEL = ATTRIB .AND. BITMASK
        NWIRES = NWIRES + 1
C
C       DETERMINE WHAT TO DO
        IF (PF) GO TO 120
C
C       GENERATE BINARY FILE
        DO 100 J = 1, 3
        XY(J, 1) = 0.0
  100    XY(J, 2) = 0.0
        NWORDS = 0
        XY1(1) = XPIN
        XY2(2) = YPIN
        ITEM = TOSIG
        CALL GETPIN(ITEM)
        XY2(1) = XPIN
        XY2(2) = YPIN
        V = HOWFAR(XY1, XY2)
C
C       PROCESS BEND DATA IF NECESSARY
        IF (.NOT. PICFRAM) GO TO 110
        XY(1, 1) = XYLIST(1, ISAVE, 1)
        XY(2, 1) = XYLIST(2, ISAVE, 1)
        XY(1, 1) = XYLIST(1, JSAVE, 2)
        XY(2, 2) = XYLIST(2, JSAVE, 2)
        NWORDS = 4
        IF ( ABS(XY(1, 1) - XY(1, 2) ) .LT. .005) GO TO 110
        IF ( ABS(XY(2, 1) - XY(2, 2) ) .LT. .005) GO TO 110
C
C       GOT A BEND IN THE MIDDLE OF THE WIRE...DO IT
        NWORDS = 6
        XY(1, 3) = XY(1, 1)
        XY(2, 3) = XY(2, 2)
        LR = .NOT. LR
        IF (LR) GO TO 110
C
C       BEND THE OTHER WAY
        XY(1, 3) = XY(1, 2)
        XY(2, 3) = XY(2, 1)
C
C       NOW GENERATE THE RECORD AND QUIT
  110   WRITE (WITNESS(1) ) LEVEL, XY1, XY2, NWORDS, XY
        RETURN
C
C
C
C       PRINT THE FILE
  120   IT = 5HLOWER
        IF (LEVEL) IT = 5HUPPER
C
C       GET THE NAME OF THE FIRST PIN
        CALL BPID(I, ID1)
C
C       SAME FOR SECOND PIN
        ITEM = TOSIG
        CALL BPID(ITEM, ID2)
        CALL GETPIN(ITEM)
        ITEM = 1H 
        IF (.NOT. LEVEL) GO TO 130
        IF (TOSIG .EQ. 0) ITEM = 1H$
C
C       NOW PRINT IT AND EXIT
  130   WRITE (PRINTER(1), 1) ID1, ID2, IT, ITEM
        CALL LINE
        RETURN
        END
        SUBROUTINE LEVEL(CHANGE)
C
C       THIS ROUTINE GENERATES CHANGE ORDERS
C
C       FIRST:  SET ALL LEVELS;
C
C       THEN:  IF CHANGE IS .TRUE., SEARCH FOR MODIFIED CHANGE
C       SEQUENCES, DELETE AND PRINT EACH
C
C       THEN: IF .CHANGE., SEARCH AND PRINT ALL ADDITIONS:
C
C       THEN MODIFY ALL CHANGE DATA TO REFLECT NEW USAGE.
C
        DIMENSION ID1(3), ID2(3)
        DOUBLE PRECISION HIGH, LOW, HILOW
        DATA HIGH / 'N UPP', "426440000000 /
        DATA LOW / ' LOWE', "510000000000 /
        DATA BITMASK / "400000000000 /
        DATA MASK / "377777777777 /
        INTEGER BITMASK
        LOGICAL CHANGE
C
        COMMON /FILES/ FILES(7, 3), PFILE(7)
        INTEGER PFILE
        EQUIVALENCE (PFILE(3), NPINS)
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /HASHCON/ HASHCON, NBLOCK, THISSIG, SIGID, NEXTSIG,
     1  SIGPIN, SIGFLAG, DEFSIG(2), CDSN
        DOUBLE PRECISION SIGID
        INTEGER HASHCON, THISSIG, SIGPIN, DEFSIG, CDSN
        LOGICAL SIGFLAG
C
        COMMON /PINS/ PINID, NEXTPIN, LASTPIN, XPIN, YPIN, BPSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD(2),
     2  PINFLAG, THISPIN
        INTEGER PINID, BPSIG, FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB,
     1  CNGWORD, THISPIN
        LOGICAL PINFLAG
C
    1   FORMAT (' REMOVE A',2A5,' WIRE FROM PIN ',3A5,' AND PIN ',3A5//)
    2   FORMAT (' PLACE A',2A5,' WIRE FROM PIN ',3A5,' TO PIN ',3A5//)
C
C
C
C
C
C       SEARCH ALL SIGNALS, SET UP LEVELS
        DO 140 I = 1, NBLOCK
        CALL GETSIG(I)
        IF (SIGID .EQ. 0) GO TO 140
        ITEM = SIGPIN .AND. MASK
        IF (ITEM .EQ. 0) GO TO 140
C
C       GOT A SIGNAL...SET THE ATTRIBUTE BIT FOR LEVEL
        IF (SIGPIN) GO TO 110
        IT = 0
  100   CALL GETPIN(ITEM)
        ITEM = TOSIG
        ATTRIB = (ATTRIB .AND. MASK) .OR. IT
        PINFLAG = .TRUE.
        IT = IT .XOR. BITMASK
        IF (ITEM .NE. 0) GO TO 100
        GO TO 140
C
C       HERE IF BUSSED SIGNAL...SEARCH AND DO EACH SUB-STRING
  110   CALL GETPIN(ITEM)
        ITEM = FROMSIG .AND. MASK
        IT = 0
C
C       CLEAN UP SUB-STRING
  120   ATTRIB = (ATTRIB .AND. MASK) .OR. IT
        PINFLAG = .TRUE.
        J = TOSIG
        IF (J .EQ. 0) GO TO 130
        CALL GETPIN(J)
        IT = IT .XOR. BITMASK
        GO TO 120
C
C       END OF SUB-STRING
  130   IF (ITEM .NE. 0) GO TO 110
C
C       END OF SIGNAL LOOP
  140   CONTINUE
C
C
C
C
C
C       NOW ALL SIGNALS HAVE THE LEVEL ATTRIBUTE SET
C
C       DETERMINE IF TO WRITE CHANGE ORDERS
        IF (.NOT. CHANGE) GO TO 260
C
C       GENERATE CHANGE ORDERS
C       SEARCH FIRST FOR OLD UPPER-LEVEL WRAPS TO REMOVE,
C       THEN AGAIN FOR COVERED LOWER .TO.'S
C       THEN AGAIN FOR COVERED LOWER .FROM.'S,
C       THEN AGAIN FOR LOWER
        HILOW = HIGH
        DO 210 I = 1, 4
        IF (I .EQ. 4) HILOW = LOW
C
C       DO FOR ALL PINS IN DATA-BASE
        DO 200 J = 1, NPINS
        CALL GETPIN(J)
        GO TO (150, 160, 170, 180), I
C
C       UPPER LEVEL CHECK
  150   ITEM = CNGWORD(1) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 200
        IF (ITEM .EQ. TOSIG) GO TO 200
        IF (.NOT. CNGWORD(1) ) GO TO 200
        CNGWORD(1) = 0
        PINFLAG = .TRUE.
        CALL GETPIN(ITEM)
        CNGWORD(2) = 0
        PINFLAG = .TRUE.
        GO TO 190
C
C       CHECK FOR COVERED LOWER .TO.
  160   ITEM = CNGWORD(1) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 200
        IF (ITEM .EQ. TOSIG) GO TO 200
        IF (CNGWORD(1) ) GO TO 200
        ITEM = CNGWORD(2) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 200
        CNGWORD(2) = 0
        PINFLAG = .TRUE.
        CALL GETPIN(ITEM)
        CNGWORD(1) = 0
        PINFLAG = .TRUE.
        GO TO 190
C
C       CHECK FOR COVERED LOWER .FROM.
  170   ITEM = CNGWORD(2) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 200
        IF (ITEM .EQ. FROMSIG) GO TO 200
        IF (CNGWORD(2) ) GO TO 200
        ITEM = CNGWORD(1) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 200
        CNGWORD(1) = 0
        PINFLAG = .TRUE.
        CALL GETPIN(ITEM)
        CNGWORD(2) = 0
        PINFLAG = .TRUE.
        GO TO 190
C
C       CHECK FOR LOWER SIGNALS
  180   ITEM = CNGWORD(1) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 200
        IF (ITEM .EQ. TOSIG) GO TO 200
        IF (CNGWORD(1) ) GO TO 200
        CNGWORD(1) = 0
        PINFLAG = .TRUE.
        CALL GETPIN(ITEM)
        CNGWORD(2) = 0
        PINFLAG = .TRUE.
C
C       HERE TO REMOVE A WIRE..GET THE PIN ID
  190   CALL BPID(ITEM, ID2)
        CALL BPID(J, ID1)
        WRITE (PRINTER(1), 1) HILOW, ID1, ID2
        CALL LINE
C
C       END LOOP OVER PINS
  200   CONTINUE
C
C       END LOOP OVER CONDITIONS
  210   CONTINUE
C
C       NOW DO THE SAME FOR WIRES WHICH FLIPPED UPPER AND LOWER
        IT = BITMASK
        HILOW = HIGH
        DO 230 I = 1, 2
C
C       DO FOR ALL PINS
        DO 220 J = 1, NPINS
        CALL GETPIN(J)
        ITEM = CNGWORD(1) .AND. MASK
        IF (ITEM .EQ. 0) GO TO 2       IF (CNGWORD(1) .XOR. ATTRIB) GO TO 220
C
C       GOT A FLIPPED WIRE
        IF (ATTRIB .XOR. IT) GO TO 220
        CNGWORD(1) = 0
        PINFLAG = .TRUE.
        CALL BPID(J, ID1)
        CALL GETPIN(ITEM)
        CNGWORD(2) = 0
        PINFLAG = .TRUE.
        CALL BPID(ITEM, ID2)
        WRITE (PRINTER(1), 1) HILOW, ID1, ID2
        CALL LINE
C
C       END LOOP OVER ALL PINS
  220   CONTINUE
C
C       END LOOP OVER CONDITIONS
        IT = 0
  230   HILOW = LOW
C
C
C
C
C
C       ALL NECESSARY WIRES HAVE BEEN REMOVED, CNGWORD = 0 FOR NEW WIRES
C       NOW GENERATE ALL NEW WIRES TO ADD, LOW THEN HIGH
        HILOW = LOW
        IT = 0
        DO 250 I = 1, 2
C
C       DO FOR ALL PINS
        DO 240 J = 1, NPINS
        CALL GETPIN(J)
        IF (TOSIG .EQ. 0) GO TO 240
        IF (CNGWORD(1) .NE. 0) GO TO 240
        IF (ATTRIB .XOR. IT) GO TO 240
C
C       GOT ONE...SET IT UP
        ITEM  = TOSIG
        CALL BPID(J, ID1)
        CALL BPID(ITEM, ID2)
        WRITE (PRINTER(1), 2) HILOW, ID1, ID2
        CALL LINE
C
C       END OF LOOP OVER PINS
  240   CONTINUE
C
C       END OF LOOP OVER CONDITIONS
        HILOW = HIGH
  250   IT = BITMASK
C
C
C
C
C
C       CHANGE ORDERS GENERATED, NOW SET UP THE FILE FOR NEXT TIME
  260   DO 270 I = 1, NPINS
        CALL GETPIN(I)
        IT = ATTRIB .AND. BITMASK
        ITEM = IT .XOR. BITMASK
        CNGWORD(1) = 0
        CNGWORD(2) = 0
        IF (TOSIG .NE. 0) CNGWORD(1) = (TOSIG .AND. MASK) .OR. IT
        IF (SPRING .EQ. 0) GO TO 270
        IF (FROMSIG .NE. 0) CNGWORD(2) = (FROMSIG .AND. MASK) .OR. ITEM
  270   PINFLAG = .TRUE.
C
C       DONE...WRITE THE LAST PIN BACK AND QUIT
        CALL PUTPIN
        CALL SETWRI
        RETURN
        END
        SUBROUTINE DSIGNAL
C
C       THIS ROUTINE PRINTS THE LIST OF ALL SIGNALS
C
        COMMON /CPGLOB/ KURSOR, LINSIZ
C
        COMMON /HASHCON/ NHASH, NBLOCK, THISSIG, SIGID(2), NEXT,
     1  NEXTPIN, SIGWRIT
        INTEGER THISSIG, SIGID
        LOGICAL SIGWRIT
C
        COMMON /PINS/ PINID, CORAL(2), XPIN, YPIN, PSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL,
     2  PINFLAG, THISPIN
        INTEGER PINID, CORAL, PSIG, FROMSIG, TOSIG, PPPNT, SPRING,
     1  ATTRIB, CNGWORD, NULL, THISPIN
        LOGICAL PINFLAG
C
        DIMENSION ID(5), MATCH(2), NOW(3)
        DATA ID(1) / ' ' /
        DATA ID(5) / 0 /
        DATA NOW(3) / 0 /
        DOUBLE PRECISION LOW, THIS, SIGNAL
        EQUIVALENCE (LOW, MATCH(1)),(THIS, NOW(1)),(SIGNAL, SIGID(1))
C       SET UP DATA
        CALL PAGE(1)
        MATCH(1) = "400000000000
        MATCH(2) = 0
C
C       SEARCH FOR SIGNAL WHICH IS GREATER THAN LOW, BUT OTHERWISE LOWEST
  100   NOW(1) = "377777777777
        NOW(2) = "777777777777
        N = 0
        DO 110 I = 1, NBLOCK
        CALL GETSIG(I)
        IF (SIGID(1) .EQ. 0) GO TO 110
        IF (SIGNAL .LE. LOW) GO TO 110
        IF (SIGNAL .GE. THIS) GO TO 110
C
C       GOT ONE...SAVE IT
        THIS = SIGNAL
        N = I
  110   CONTINUE
C
C       HAVE SCANNED ALL SIGNALS...DID WE FIND ONE?
        IF (N .EQ. 0) RETURN
C
C       GOT ONE...SAVE FOR NEXT TIME
        LOW = THIS
        CALL GETSIG(N)
        CALL SIGLIST(.FALSE., 1)
        GO TO 100
        END
        SUBROUTINE DPOSTS(LIST)
C
C       THIS ROUTINE GENERATES THE POST-COUNT MAP
C       LIST IS THE BUFFER TO USE FOR EDITING
C
        COMMON /FILES/ FIL1(7, 3), PFILE(7), FIL2(7, 6), TFILE(7)
        INTEGER PFILE, TFILE
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /PINS/ PINID, CORAL(2), XPIN, YPIN, PSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL,
     2  PINFLAG, THISPIN
        INTEGER PINID, CORAL, PSIG, FROMSIG, TOSIG, PPPNT, SPRING,
     1  ATTRIB, CNGWORD, NULL, THISPIN
        LOGICAL PINFLAG
C
        COMMON /TITLE/ TITLE(21), XMIN, XMAX, YMIN, YMAX, PICFRAM
        LOGICAL PICFRAM
C
        INTEGER LIST(1), CHARS(0/3)
        DATA CHARS / "60, "61, "62, "44 /
C
    1   FORMAT('*', 26A5)
C
C       COMPUTE THE SIZE OF THE DATA-BLOCK TO USE
        NXCHAR = (XMAX - XMIN + .06)*20.0
        NYCHAR = (YMAX - YMIN + .06)*20.0
        NWORDS = (NXCHAR + 4)/5
        TFILE(2) = NWORDS
        CALL WOPEN(TFILE(1) )
        DO 100 I = 1, NWORDS
  100   LIST(I) = ' '
C
C       BLANK OUT THE BUFFER FILE
        DO 110 I = 1, NYCHAR
  110   WRITE (TFILE(1) # I ) (LIST(J), J = 1, NWORDS)
C
C       NOW READ EACH PIN, PUT THE APPROPRIATE CHARACTER IN BUFFER
        NPINS = PFILE(3)
        IMAX = YMAX * 1000.0 + 0.5
        IMIN = XMIN * 1000.0 + 0.5
        DO 130 I = 1, NPINS
        CALL GETPIN(I)
        IX = XPIN * 1000.0 + 0.5
        IY = YPIN * 1000.0 + 0.5
        IX = (IX - IMIN)/50 + 1
        IY = (IMAX - IY)/50 + 1
C
C       READ IN THE APPROPRIATE LINE
        READ (TFILE(1) # IY) (LIST(J), J = 1, NWORDS)
        J = 0
        IF (TOSIG .NE. 0) J = 1
C
C       TEST IF BUSSED SIGNAL
        IF (FROMSIG) GO TO 120
        IF (FROMSIG .NE. 0) J = 1 + J
        IF (J .NE. 1) GO TO 120
C
C       ONLY ONE WIRE ON PIN...DETERMINE IF UPPER LEVEL
        IF (ATTRIB) J = 3
        IF (ATTRIB) GO TO 120
C
C       .TO. NOT UPPER LEVEL...DETERMINE IF .FROM. IS
        IF (TOSIG .NE. 0) GO TO 120
        K = FROMSIG
        CALL GETPIN(K)
        IF (ATTRIB) J = 3
C
C       HAVE FOUND OUT ABOUT THE WIRES
  120   CALL MPUTCH(CHARS(J), IX, LIST(1) )
  130   WRITE (TFILE(1) # IY) (LIST(J), J = 1, NWORDS)
C
C       NOW HAVE PUT CHARACTER CODES INTO ALL BUFFER, PRINT THEM BACK OUT
        IPAG = 1
        IMIN = 1
  140   IMAX = IMIN + 25
        IF (IMAX .GT. NWORDS) IMAX = NWORDS
        CALL PAGE(IPAG)
        IPAG = IPAG + 1
        POSITION (TFILE(1), 1)
        DO 150 I = 1, NYCHAR
        READ (TFILE(1) ) (LIST(J), J = 1, NWORDS)
  150   WRITE (PRINTER(1), 1 ) (LIST(J), J = IMIN, IMAX)
        IMIN = IMAX
        IF (IMIN .NE. NWORDS) GO TO 140
C
C       DONE...CLEAN UP
        CALL WCLOSE(TFILE(1) )
        TFILE(2) = 1
        RETURN
        END
        SUBROUTINE DNOPLUG
C
C       THIS ROUTINE LISTS ALL UNUSED PLUGS.  THEY ARE UNUSED IF NO
C       SIGNALS ARE ATTACHED
C
        INTEGER ID(3)
        LOGICAL ANY, MAYBE
C
        COMMON /CPGLOB/ KURSOR, LINSIZ
C
        COMMON /FILES/ FILE(7, 2), SFILE(7)
        INTEGER SFILE
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, NEXT, PINPNT, XPIN, YPIN, SIGID(2),
     1  LASTSIG, NEXTSIG, PLUGPNT, NEXTRNG, ATTRIB, DIST, CHANGE,
     2  NULL, PINFLAG, THISPIN
        INTEGER PINID,PINPNT, SIGID, PLUGPNT, ATTRIB, CHANGE, NULL,
     1  THISPIN
        LOGICAL PINFLAG
C
C       GET NUMBER OF SOCKETS
        N = SFILE(3)
        CALL PAGE(1)
        CALL BLANK
        CALL BUFOUT(' UNUSED PLUGS: ')
        ANY = .FALSE.
        LINSIZ = 17
C
C       FIND EACH SOCKET, DETERMINE IF EMPTY
        DO 160 I = 1, N
        CALL GETSOC(I)
        M = NSOCPIN
        K = SPINPNT .AND. "377777777777
        MAYBE = .FALSE.
C
C       FIRST MARK ALL THE PINS IN THE SOCKET
        DO 110 J = 1, M
        CALL GETPIN(K)
        K = NEXT
        IF (NEXTRNG .EQ. 0) GO TO 110
        IF (PLUGPNT .EQ. 0) GO TO 110
        IF (SIGID(1) .EQ. 0) GO TO 100
        IF ( (ATTRIB .AND. "040000000000) .EQ. 0) GO TO 110
  100   ATTRIB = ATTRIB .OR. "1
        PINFLAG = .TRUE.
        MAYBE = .TRUE.
  110   CONTINUE
        IF (.NOT. MAYBE) GO TO 160
C
C       NOW SCAN THE FLAGGED PINS IN THE SOCKET FOR EMPTY PLUGS
        K = SPINPNT .AND. "377777777777
        DO 150 J = 1, M
        CALL GETPIN(K)
        IF ( (ATTRIB .AND. "1) .EQ. 0) GO TO 150
C
C       GOT A POSSIBLE...CHECK IT OUT, ALSO CLEAR FLAGS
        MAYBE = .TRUE.
  120   ATTRIB = ATTRIB .AND. "777777777776
        PINFLAG = .TRUE.
  130   IF (NEXT .EQ. K) GO TO 140
        L = NEXT
        CALL GETPIN(L)
        IF ( (ATTRIB .AND. 1) .NE. 0) GO TO 120
        MAYBE = .FALSE.
        GO TO 130
C
C       HAVE SCANNED AND CLEARED ALL FLAGS ON PLUG RING...TEST IF EMPTY
  140   CALL GETPIN(K)
        K = NEXT
        IF (.NOT. MAYBE) GO TO 150
C
C       FOUND AN UNUSED PLUG...OUTPUT PLUG ID, PIN NAME
        ANY = .TRUE.
C       OUTPUT PLUG ID HERE
        CALL BUFOUT('  AT')
        CALL BPID(ID(1) )
        CALL BUFOUT(ID(1) )
        CALL PRINTIT
        LINSIZ = 17
  150   CONTINUE
  160   CONTINUE
C
C       DONE...OUTPUT LAST LINE
        IF (.NOT. ANY) CALL BUFOUT('NONE')
        CALL PRINTIT
        RETURN
        END
        SUBROUTINE DSAVE
C
C       THIS ROUTINE PERFORMS THE SAVE FUNCTION IN THE STATEMENT:
C       SAVE EDGE SOCKET *** ON *** WITH NAME ***
C
C       IT GENERATES THE APPROPRIATE FORMAT T3 FILE, THEN CALLS PLGSAV
C
        COMMON /LIBFILE/ LIBFILE(9)
C
        COMMON /FILES/ FILE(7, 10), T3FILE(7)
        INTEGER T3FILE
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NSOCSIZ, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, NSOCPIN, NSOCSIZ, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ BPID, NEXTPIN, LASTPIN, XPIN, YPIN, BPSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL,
     2  PINFLAG, THISPIN
        INTEGER BPID, BPSIG, FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB,
     1  CNGWORD, THISPIN
        LOGICAL PINFLAG
C
        COMMON /PLUGBUF/ PPID, DEFAULT(2), GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRING,
     2  SGRPRNG, PPX, PPY, FROMPP, TOPP, PPFLAG, THISPP, PLUGID(3),
     3  NPP, PP1, SAVEIT
        DOUBLE PRECISION GROUP, SUBGRP
        REAL LOAD, DRIVE, PPX, PPY
        INTEGER PPID, ILT, OLT, GRPNO, SGRPNO, WOCC, TCC, PPCORAL,
     1  DEFAULT, GRPRING, SGRPRNG, FROMPP, TOPP, THISPP, PLUGID, PP1
        LOGICAL PPFLAG, SAVEIT
C
C       FIRST OF ALL OPEN THE TEMP FILE
        T3FILE(2) = 23
        CALL WOPEN(T3FILE(1) )
C
C       NOW SET UP THE PARAMETERS
        NPP = NSOCPIN
        PP1 = 1
        ITEM = SPINPNT .AND. "377777777777
C
C       NOW COPY EACH PIN AND REFORMAT FOR PLUG
        DO 100 I = 1, NPP
        CALL GETPIN(ITEM)
C
C       SET UP THE NEW PLUG PIN
        PPID = BPID
        DEFAULT(1) = BPSIG(1)
        DEFAULT(2) = BPSIG(2)
        GROUP = 0
        SUBGRP = 0
        ILT = 0
        OLT = 0
        GRPNO = 0
        SGRPNO = 0
        LOAD = 0
        DRIVE = 0
        WOCC = 0
        TCC = 0
        PPX = XPIN
        PPY = YPIN
C
C       NOW LINK THE ELEMENTS
        FROMPP = I - 1
        TOPP = I + 1
        THISPP = I
        PPFLAG = .TRUE.
        CALL PUTPB
C
C       NOW SET UP FOR THE NEXT PIN
  100   ITEM = NEXTPIN
C
C       FIX LAST ELEMENT
        TOPP = 0
        PPFLAG = .TRUE.
        CALL PUTPB
C
C       NOW PUT IT OUT
        CALL GETLP
        CALL PLGSAVE
C
C       DONE...CLEAN UP
        CALL WCLOSE(LIBFILE(1) )
        CALL WCLOSE(T3FILE(1) )
        T3FILE(2) = 1
        RETURN
        END
    