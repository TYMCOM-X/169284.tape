!SP21 PUT ^ NOT :
!SP20 FIX KIND COMMENT. FIX D.NXT.SYM
!SP19  ALWAYS USE H.START+H.TBL
!SP18 ALSO DMY FOR SYM.V, SYM.N
!SP17 MODIFY DMY IN ONE
!SP16 TRY DMY TO FIX ^ BUGS
       LOCAL DMY
!SP15  USE ABS(HSUM) TO KEEP MOD NON-NEGATIVE
!SP14 REPLACE INIT.SYM.TBL WITH NEW.SYM.TBL (CAN'T PASS DYN ARRAYS)
!SP13  PUT RETURNS IN BEFORE ENDS DUE TO LAZY COMPILER
!SP12
       FIND %NEW.BLOCK ! DYNAMIC STORAGE ALLOCATOR
       FIND %PRINT.LINE.CR ! PRINT CURRENT INPUT LINE

       GLOBAL %PUT,%PRINT,%WARN,%ERROR,%STK.ID,%INIT.DCL.STK,%GET,%PRINTST
       GLOBAL %SYM.POS,%NEW.SYM.TBL,%GET.SYM,%INIT.SYM.PAK
       GLOBAL %SYM.PAK,%SETUP.H,%STEP.H,%DMP,%D.NXT.SYM
       GLOBAL                 %GET.NEW.H.TBL,TTY.POS,WARNINGS,%RETLIN
       GLOBAL %USTK.ID

       DEF BLOCK.SIZE AS 256  !      UNIT OF STORAGE ALLOCATION
 DEF   CPW    AS CHARS.PER.WORD
 DEF   CR     AS CARRET
 DEF   WARN.LIMIT AS 100 ! NUMBER OF DIAGNOSTICS BEFORE ABORTION
 DEF   NIL    AS E.O.LIT
DEF ADR.SIZ AS 18              !SIZE OF ADDRSSS FIELD
DEF FLAG.SIZ AS 1              !SIZE OF FLAG FIELD
DEF FLAG.BITS AS BNOT 00 !BITS FOR FLAG FIELD
DEF SUM.SIZ AS BITS.PER.WORD-ADR.SIZ-FLAG.SIZ-6
 DEF   TRUE   AS 1
 DEF   YES    AS 1
 DEF   NO     AS 0
 DEF   FALSE  AS 0
 DEF   IS     AS =
 DEF   ISNT   AS #

!--------------------

!      HASH QUANTITIES:

 DEF H.LINKS AS 4 !            CONTROL WORDS REQUIRED FOR LINKED HASH TABLES
 DEF H.PRIME AS 251 ! PRIME NUMBER USED FOR HASHING:
       !      H.PRIME <= BLOCK.SIZE - H.LINKS
 DEF H.PRIME.2 AS 233 ! PRIME USED FOR      STEP CALCULATION
 DEF H.BIAS AS 9               ! STEP ADJUSTMENT:    H.BIAS_(H.PRIME-H.PRIME.2)/2

       GLOBAL H.SUM,H.START,H.STEP,H.TRY ! THESE USABLE BY ALL
       GLOBAL H.TBL(),H.MAX,H.FULL    ! HASH PACKAGES.

 DEF H.COUNT AS H.TBL(-2)      !      NUMBER OF ENTRIES IN THIS PORTION OF H.TBL
 DEF H.SUC     AS H.TBL(-1)   !      LINK TO SUC.CESSOR H.TBL

!      LINK IS USED WHEN HOLE IS FOUND AND H.COUNT>=H.FULL


 DEF   H.SCRAM AS OCT 111111111111    ! RANDOMIZING MULTIPLIER
 DEF   H.SHIFT                AS 6   ! SHIFT TO ELIMINATE BIASED LOW BITS

!-------------------------------------------
!
!      SYMBOL TABLE !
!
       GLOBAL SYM.BUF(0:64) !         NAME PACKING BUFFER
       LOCAL SYM.MASK         !      A CODE-WORD UNPACKING MASK
       GLOBAL N.LEFT          ! WORDS LEFT IN TEXT BLOCK
       GLOBAL TEXT.P          !      POINTER BEFOR NEXT FREE TEXT WORD
       DEF SYM.N AS SYM.TBL(-3) ! NUMBER OF UNITS PER HASH BLOCK
       DEF SYM.V AS SYM.TBL(-4) ! VIRGIN VALUE FOR HASH TABLES
       GLOBAL B.DEPTH         ! CURRENT BLOCK DEPTH, 1 FOR OUTERMOST
       GLOBAL DCL.P           ! STACK POINTER FOR DECLARATIONS
       GLOBAL DCL.N           ! # OF WORD PAIRS LEFT IN PUSH-DOWN BLOCK

!****************************************************

!      SYMBOL TABLES ARE IN GENERAL LINKED LISTS OF MULTI-BLOCKS.
!      ONLY THE FIRST SECTION OF SUCH BLOCKS IS UNIFORMLY DEFINED.

!      THE PRIMARY SYMBOL HASH TABLE IS LINKED LIST OF DOUBLE-BLOCKS.
!      THE FIRST BLOCK.SIZE WORDS OF EACH IS THE "NAME DESCRIPTOR"
!      SECTION AND IS USED FOR ALL ACTUAL HASHING OPERATIONS.
!      FOR EACH NAME-DESCRIPTOR, AN ID-DESCRIPTOR IS FOUND BLOCK.SIZE
!      WORDS LATER IN THE SECOND SECTION.

!      A SYMBOL TO BE ENTERED IN THE SYMBOL TABLE IS PLACED IN SYM.BUF
!      SYM.BUF(1) CONTAINS THE FIRST CPW CHARS
!      SYM.BUF(N) CONTAINS THE LAST FEW CHARS AND IS FILLED OUT 
!      WITH NILS IF EXTRA ROOM IS LEFT.
!      SYM.BUF(0) IS SET TO N.

!      SYMBOLS MUST CONTAIN FROM 1 TO 256 CHARACTERS.

!      IF N=1 THEN THE NAME-DESCRIPTOR IS SIMPLY SYM.BUF(1).

!      IF N>1 THEN NAME-DESCRIPTOR HAS THE STRUCTURE:

!      [FLAG.SIZ,SUM.SIZ,6,ADR.SIZ]*[FLAG.BITS,HASH,N,P]

!      WHERE HASH IS PART OF THE HASH CALC FOR THE SYMBOL AND
!      WHERE P IS THE WORD-ADDRESS OF THE NAME-BLOCK.     THE NAME
!      BLOCK HAS THE STRUCTURE:

!      SYM.BUF(1)
!      SYM.BUF(2)
!      SYM.BUF(3) ...
!      SYM.BUF(N)
!
!      THE NAME-BLOCK'S ARE STORED IN A SET OF NON-LINKED DATA BLOCKS
!      SEPARATELY OBTAINED FROM THE HASH DOUBLE-BLOCKS.

!      THE INITIAL HASH DOUBLE BLOCK IS SYM.TBL().

!      A SINGLE TEXT OVERFLOW AREA IS USED FOR ALL SYMBOL TABLES.

!      THE PROCEDURE %SYM.POS LOOKS SYM.BUF() UP IN SYM.TBL() AND
!      ENTERS IT IF ABSENT.   SYM.POS RETURNS THE ADDRESS OF THE 
!      NAME DESCRIPTOR.

!      THE PROCEDURE GET.SYM (POS)    TAKES THE ADDRESS OF A 
!      A NAME-DESCRIPTOR AND UNPACKS IT INTO SYM.BUF.

!      THE ID-DESCRIPTOR WORD HAS THE FOLLOWING STRUCTURE:

!      [4,5]*[S.KIND,S.DEPTH]

!      IF THE ID-DESCRIPTOR WORD IS ZERO, IT IS UNUSED.

!

!      THE S.KIND AND S.DEPTH FIELDS HAVE THE SAME MEANING
!      TO THE SCANNER, PARSER, AND CODE GENERATORS.  THE OTHER BITS
!      HAVE UNIQUE MEANING TO THE SCANNER (IF MACROS OR RESERVED WORDS)
!      OR TO THE CODE GENERATORS (IF IDENTIFIERS).

!      SMALL S.KIND (<8 OR SO) ARE IDENTIFIERS OF VARIOUS MODES.
!      LARGE S.KIND (NEAR 15) ARE SCANNER/PARSER TOKENS (MACROES,
!      RESERVED WORDS OR SO).         SUCH SCANNER-TOKENS CAN BE PROTECTED
!      FROM THE CODE GENERATORS BY HAVING 0 S.DEPTH VALUES.
!      BUT IF THEY HAVE POSITIVE S.DEPTH VALUES, THEY WILL BE
!      UNSTACKED AND DESTROYED AT ENDS JUST LIKE IDENTS.
!      MACRO NAMES AND IDENTIFIERS INHERIT THE
!      B.DEPTH VALUE OBTAINING AT THE TIME OF THEIR DECLARATION.

!
!!!
!
!--------------------------------
!      BLOCK STRUCTURE:
!
!      AT ANY POINT DURING COMPILATION, THERE IS THE CURRENT OPEN
!      BLOCK, ONE OR MORE STILL UNCOMPLETED BLOCKS IN WHICH WE
!      ARE CURRENTLY NESTED, AND ONE OR MORE BLOCKS WHOSE
!      ENDS HAVE OCCURRED AND WHICH ARE OF NO CONCERN WHATEVER
!      TO US.                 WHEN WE ENCOUNTER AN END, THE SYMBOLS
!      LOCAL TO THE CURRENT BLOCK ARE PURGED FROM THE SYMBOL
!      TABLE (AND ANY UNDEFINED CHAINS ARE WRITTEN OUT).  SYMBOLS
!      WHICH HAD BEEN OVERWRITTEN BY THE CURRENT
!      BLOCK ARE RECOVERED AND
!      PUT BACK IN THE SYMBOL TABLE, AND THE IMMEDIATELY 
!      SURROUNDING BLOCK BECOMES THE CURRENT BLOCK. THE
!      DEPTH IS DECREMENTED.  WHEN A PROCEDURE
!      HEADER IS ENCOUNTERED, A MARKER IS PLACED IN THE
!      SYMBOL TABLE BACKUP STACK, AND THE DEPTH IS INCREMENTED.

!      DCL.STK() CONTAINS PAIRS OF WORDS: ( ID.POS , ID-DESCRIPTOR ).
!      WHERE ID.POS=SYM.POS+BLOCK.SIZE FOR ANY GIVEN SYMBOL.
!      THE ENTRIES FOR THE CURRENTLY OPEN BLOCK REPRESENT THE
!      STATES OF              CURRENT VARIABLES PRIOR TO THE BEGINNING
!      OF THE BLOCK.          THE SPECIAL PAIR (PROC.ID.POS,-1) IS PLACED
!      ON THE STACK WHEN A NEW BLOCK (PROCEDURE) BEGINS. THIS PAIR
!      ACTS AS A MARKER TO TERMINATE UNSTACKING AT THE MATCHING
!      END.

!      DCL.STK() IS A LINKED LIST OF DATA-BLOCKS.    THE FIRST WORD
!      OF EACH BLOCK CONTAINS THE ADDRESS OF THE LAST CELL     OF
!      THE PREVIOUS BLOCK, AND THE LAST CELL CONTAINS THE ADDRESS
!      OF THE FIRST WORD OF THE NEXT BLOCK.

!*********************************************************************

%SYM.PAK       !              SYMBOL TABLE PACKAGE


!
!------------------------

%GET ! INPUT ONE CHARACTER FROM TERMINAL

       LOCAL T,T1
       T_TTY
       IF T=CR THEN [ TTY.POS_1; T1_TTY] ELSE INC TTY.POS
       RETURN T
END GET

!---------------------------------------------

!      PRINT A MESSAGE ON THE TERMINAL

%PUT(CHAR)
       IF CHAR=CR THEN [TTY.POS_1; TTY_CR; TTY_LN.FEED; RETURN]
       IF TTY.POS>72 THEN [TTY_CR; TTY_LNFEED; &
       TTY_CHAR; TTY.POS_2; RETURN]
       TTY_CHAR; INC TTY.POS; RETURN
END PUT

%RETLIN
       IF TTY.POS#1 THEN PUT(CR)
       RETURN
END RETLIN

%PRINT(TEXT)   !              PRINT('THIS IS A MESSAGE')

       LOCAL P
       P_CHPT(TEXT,-1)
%%PRINTST(P)
PRINT1: IF NCHV(P) IS NIL THEN RETURN; PUT(CHV(P)); GO PRINT1

END PRINT


!------------------


%ERROR(TEXT)

       PRINT(TEXT); PUT(CR); PRINT.LINE.CR
       EXIT

       HALT
END ERROR
!-------------------------



!-------------

!      PRINT A WARNING MESSAGE 

%WARN(TEXT)

       PRINT(TEXT); PUT(CR); PRINT.LINE.CR
       INC WARNINGS; IF WARNINGS<WARN.LIMIT THEN RETURN
       ERROR('TOO MANY WARNINGS, COMPILATION ABORTED.')
END WARN

!-------------------------------------------------------




!      STACK AN IDENTIFIER DUE TO OVER-RIDING DECLARATION:

%STK.ID(ID.POS)

       LOCAL P1

       IF DEC DCL.N<0 THEN GO NEW.BLK
STKIT:         ^INC DCL.P_ID.POS;     ^INC DCL.P_^ID.POS;     RETURN

NEW.BLK:       IF P1_^INC DCL.P=0 THEN DO
       ^DCL.P_(P1_NEW.BLOCK(1,0)) ! STORE FORWARD POINTER
       ^P1_DCL.P ! STORE BACK POINTER
       END
       DCL.P_P1 ! STEP TO NEW BLOCK
       DCL.N_(BLOCK.SIZE-4)/2;        GO STK.IT

END STK.ID

%INIT.DCL.STK

       DCL.P_NEWBLOCK(1,0)
       ^DCL.P_0 ! NO BACK POINTER
       DCL.N_(BLOCK.SIZE-2)/2

       RETURN
END INIT.DCL.STK

!-------------------------------

%SETUP.H

       H.SUM_ABS(H.SUM)
       H.START_H.SUM MOD H.PRIME
       H.STEP_H.BIAS+H.SUM MOD H.PRIME.2
       H.MAX_H.TBL+H.PRIME

       RETURN
END SETUP.H

%STEP.H

       H.TRY_H.TRY+H.STEP
       IF H.TRY>=H.MAX THEN H.TRY_H.TRY-H.PRIME
       RETURN
END STEP.H

%GET.NEW.H.TBL(N,V)

       IF H.SUC=V THEN H.SUC_H.LINKS+NEW.BLOCK(N,V)
       H.TBL_H.SUC
       H.MAX_H.TBL+H.PRIME

       RETURN
END GET.NEW.H.TBL


!----------------------------------

!      SYMBOL TABLE LOOKUP ROUTINE:

%SYM.POS ( SYM.TBL() )

       LOCAL WORD,I,P

       H.TBL_SYM.TBL
       IF SYM.BUF(0)=1 THEN GO SHORT.NAME

       H.SUM_SYM.BUF(I_1)

SCRAM:         H.SUM_(H.SUM ROTL 5) BXOR SYM.BUF(INC I)
       IF I ISNT SYM.BUF(0) THEN GO SCRAM
       H.SUM_(H.SUM*H.SCRAM) ROTR H.SHIFT
       WORD_[SUM.SIZ,6,ADR.SIZ,FLAG.SIZ]*&
       [H.SUM,SYM.BUF(0),0,FLAG.BITS]

       SETUP.H
NXT.TBL:       H.TRY_H.START+H.TBL
TRY1:  IF ^H.TRY IS 0 THEN GO ENTER
       IF ^H.TRY BAND SYM.MASK IS WORD THEN GO COMPARE
TRY2:  STEP.H;                GO TRY1

COMPARE:       I_0; P_((^H.TRY BAND (BNOT SYM.MASK)) SHR FLAG.SIZ)-1
COMP1:         IF SYM.BUF(INC I) ISNT ^INC P THEN GO TRY2
       IF I ISNT SYM.BUF(0) THEN GO COMP1 ELSE RETURN H.TRY

ENTER:         IF H.COUNT >= H.FULL THEN GO NEW.TBL
       INC H.COUNT
 IF N.LEFT<SYM.BUF(0) THEN [TEXT.P_NEW.BLOCK(1,0)-1;N.LEFT_BLOCK.SIZE]
!      PLACE ADDRESS INTO WORD FOR SYMBOL ENTRY
       N.LEFT_N.LEFT-SYM.BUF(0);      ^H.TRY _ WORD +(TEXT.P+1) SHL 1
       I_0
ENT1:  ^INC TEXT.P_DMY_SYM.BUF(INC I) ; IF I ISNT SYM.BUF(0) THEN GO ENT1
       RETURN H.TRY


NEW.TBL:       GET.NEW.H.TBL(SYM.N,SYM.V); GO NXT.TBL

!---

SHORT.NAME:    H.SUM_SYM.BUF(1) SHR 1; SETUP.H
SH.NXT.TBL:    H.TRY_H.START+H.TBL
SH.TRY:        IF ^H.TRY= SYM.BUF(1) THEN RETURN H.TRY
       IF ^H.TRY # 0 THEN [STEP.H;    GO SH.TRY]
IF H.COUNT<H.FULL THEN &
       [INC H.COUNT; ^H.TRY_SYM.BUF(1) BAND HEX FFFFFFFFE; RETURN H.TRY]
       GET.NEW.H.TBL(SYM.N,SYM.V); GO SH.NXT.TBL


!------

%NEW.SYM.TBL ( N ,V )

       LOCAL SYM.TBL()
       SYM.TBL_H.LINKS+NEW.BLOCK(N,V)
       SYM.N_N; SYM.V_V

       RETURN SYM.TBL
END NEW.SYM.TBL
END SYM.POS

!---------------------------------------

!      UNPACK A SYMBOL INTO SYM.BUF()

%GET.SYM (SYM.POSIT)

       LOCAL C,N,P

        IF SYM.POSIT<0 THEN [SYM.BUF(0)_1;SYMBUF(1)_EOLIT;RETURN]
       [SUM.SIZ,6,ADR.SIZ,FLAG.SIZ]*[,N,P,C]_^SYM.POSIT

       IF C   = 0 THEN [SYM.BUF(0)_1;&
       SYM.BUF(1)_^SYM.POSIT;RETURN]

       SYM.BUF(0)_N; SYM.BUF(N_1)_^P

NEXT:  SYM.BUF(INC N)_^INC P; IF N ISNT SYM.BUF(0) THEN GO NEXT

       RETURN
END GET.SYM

!-------------------------

!
%INIT.SYM.PAK  !              INITIALIZE ENTIRE SYMBOL TABLE PACKAGE:


       H.FULL _ 213 ! SUGGESTED HASH LOAD (85% PACKED)
       TTY.POS_1
       WARNINGS_0
       N.LEFT_0; TEXT.P_0
       SYM.MASK_[SUM.SIZ,6,ADR.SIZ,FLAG.SIZ]* &
       [BNOT 0,BNOT 0,0,BNOT 0]
       INIT.DCL.STK
       

       RETURN
END INIT.SYM.PAK

!-----------

!      DUMP ALL SYMBOLS OF A SYMBOL TABLE:



%DMP (SYM.TBL(),DONE)

       LOCAL P
       P_SYMTBL-1
       LOCAL PMAX
       PMAX_P+H.PRIME
       RETURN

%D.NXT.SYM     ! DUMP THE NEXT SYMBOL

D1:    IF INC P > PMAX THEN GO NXT.LINK
       IF ^P IS 0 THEN GO D1
       RETURN P

NXT.LINK:      P_^(PMAX-H.PRIME); IF P=0 THEN GO ^DONE
       DEC P; PMAX_P+H.PRIME; GO D1

       RETURN
END DNXTSYM
END DMP

!REVERSE OF STK.ID


%USTK.ID(@ADR)
       IF INC DCL.N>=BLOCK.SIZE/2 THEN &
       [DCL.N_1; IF DCL.P_(^DCL.P)-1<0 THEN &
       ERROR ('DECL STACK UNDERFLOW')]
       ADR_^DCL.P; DCL.P_DCL.P-2; RETURN ^(DCL.P+1)
END USTK.ID

END SYM.PAK
  