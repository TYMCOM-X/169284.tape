C       LIST.FTF
        SUBROUTINE LISTEST
C
C       THIS ROUTINE PROCESSES THE LIST COMMANDS
C       IT IS CALLED WITH ANY UNRECOGNIZED COMMAND, AND DETERMINES IF
C       IT IS A LIST COMMAND.  IF SO IT PROCESSES IT AND ANY FURTHER
C       LIST COMMANDS UNTIL IT FINDS A NEW COMMAND IT CANT RECOGNIZE.
C       IT THEN RETURNS.  IF THE FIRST COMMAND WAS NOT A LIST
C       COMMAND, IT CALLS GENERAL FOR STANDARD PROCESSING.
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270),
     1  ISTTY, HUSH, UNCOLA, IPROMP, IDFILE(5)
C
C
        INTEGER ID(3), OUTTEST
        LOGICAL FIRSTIM
C
C       SET FIRST-TIME FLAG TRUE
        FIRSTIM = .TRUE.
C
C       DETERMINE IF A LIST COMMAND
  100   I = LPARSE(3)
        GO TO (150, 180), I+1
C
C       UNRECOGNIZED COMMAND..CALL GENERAL IF FIRST TIME
  110   IF (.NOT. FIRSTIM) GO TO 130
        CALL GENERAL
C
C       THE EXIT POINT
  120   RETURN
C
C       WE'VE ANALIZED A LIST COMMAND...IS THIS HELP?
  130   I = LPARSE(2)
        GO TO (120, 150, 160, 120), I+2
C
C       HERE IF SUCCESS IN PROCESSING...SET PROMPT FLAG
  140   UNCOLA = .FALSE.
C
C       HERE IF BLANK LINE..READ IT AGAIN
  150   CALL PROMPT
        IF (FETCHL(I) ) GO TO 100
        GO TO 150
C
C       HERE IF WE GOT "HELP"...DO IT
  160   CALL CPINFO(12)
        IF (.NOT. FETCHL(I) ) GO TO 150
C
C       TEST IF SECOND "HELP" IN SEQUENCE
        IT = KURSOR
        I = LPARSE(2)
        GO TO (100, 150, 170, 100), I+2
C
C       GOT SECOND HELP, LET GENERAL HANDLE IT
  170   KURSOR = IT
        CALL GENERAL
        RETURN
C
C       GOT A LIST COMMAND, PROCESS IT
  180   FIRSTIM = .FALSE.
        I = LPARSE(4)
        GO TO (200, 210, 220, 230, 240, 250, 260, 290), I
C
C       HERE IF UNRECOGNIZED LIST COMMAND...BITCH
  190   CALL ERROR('UNRECOGNIZED LIST COMMAND', 'LIST ?')
        GO TO 100
C
C       ERROR IN SIGNAL SPECIFICATION
  185   CALL ERROR('SIGNAL IDENTIFICATION SPECIFICATION', '???')
        GO TO 100
C
C
C
C       "LIST SIGNAL"
  200   IF (.NOT. SIGREF(I) ) GO TO 185
        CALL SIGLIST(.TRUE., 1)
        GO TO 140
C
C
C
C       "LIST SOCKET"
  210   IF (.NOT. PACK(ID(1), 10, 0) ) GO TO 190
        IF (.NOT. SOCFIND(ID(1) ) ) GO TO 190
        CALL LSOCKET(.TRUE.)
        GO TO 140
C
C
C
C       "LIST LOAD"
  220   IF (.NOT. SIGREF(I) ) GO TO 185
        CALL SIGLIST(.TRUE., 2)
        GO TO 140
C
C
C
C       "LIST LENGTH"
  230   IF (.NOT. SIGREF(I) ) GO TO 185
        CALL SIGLIST(.TRUE., 3)
        GO TO 140
C
C
C
C       "LIST CONFLICT"
  240   IF (.NOT. SIGREF(I) ) GO TO 185
        CALL LBATTLE
        GO TO 140
C
C
C
C       "LIST EMPTY"
  250   IF (LPARSE(5) .NE. 1) GO TO 190
        CALL LEMPTY(.TRUE.)
        GO TO 140
C
C
C
C       "LIST UNUSED *"
  260   I = LPARSE(6)
        GO TO (190, 190, 270, 280, 190), I+2
C
C
C
C       "LIST UNUSED GROUPS"
  270   CALL LUGSG(.TRUE., 1)
        GO TO 140
C
C
C
C       "LIST UNUSED SUBGROUPS"
  280   CALL LUGSG(.TRUE., 2)
        GO TO 140
C
C
C       "LIST ON"...VERIFY "FILE", THEN GET PRINTER FILE
  290   IF (LPARSE(51) .NE. 1) GO TO 190
        IF (.NOT. LOOKFN(I) ) GO TO 190
        IF (OUTTEST(.FALSE., .TRUE.) .EQ. 3) GO TO 100
        GO TO 140
        END
        SUBROUTINE SIGLIST(TERM, NJUMP)
C
C       SIGLIST ASSUMES THAT /HASHCON/ CONTAINS THE INFORMATION ON THE
C       SIGNAL OF INTEREST.  NJUMP TELLS WHAT ADDITIONAL INFORMATION
C       IS TO BE OUTPUT.  1: PIN NAMES ONLY; 2: PINS AND LOAD/DRIVE;
C       3: PINS AND LENGTHS OUTPUT.  IF TERM IS TRUE, OUTPUT IS TO
C       THE TERMINAL, ELSE IT IS TO BE PRINTED
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270)
C
        COMMON /HASHCON/ NHASH(2), THISSIG, SIGID(2), NEXT, NEXTPIN
        INTEGER THISSIG, SIGID
C
        COMMON /PINS/ PID, CORAL(2), BX, BY, BSIG(2), LASTB, NEXTB,
     1  PPPOINT, NSRING, CODES, DIST, UNUSED(2), PINFLAG, THISPIN
        INTEGER PID, CORAL, BSIG, PPPOINT, CODES, THISPIN
        LOGICAL PINFLAG
C
        COMMON /PLUGPIN/ PPID, DEF(2), IDGRP(2), IDSBGRP(2), ILT, OLT,
     1  NGRP, NSGRP, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), NEXPPG,
     2  NEXPPSG, PPX, PPY, PPFLAG, THISPP
        INTEGER PPID, DEF, OLT, WOCC, TCC, PPCORAL, THISPP
        LOGICAL PPFLAG
C
        DIMENSION ID(3)
        LOGICAL TERM
        DATA ID(3) / 0 /
        DATA MASK / "377777777777 /
C
    1   FORMAT('<', F8.3, '>' )
    2   FORMAT(F10.1)
    3   FORMAT(1X, 2A5, '....BUSSED SIGNAL'/)
C
C       CLEAR THE BUFFER AND PERFORM SET-UP
        LIST = NEXTPIN .AND. MASK
        CALL BLANK
        IF (LIST .EQ. 0) GO TO 110
        IF (NEXTPIN .GT. 0) GO TO 120
        IF (.NOT. TERM) GO TO 100
C
C       BUSSED SIGNAL IN TERMINAL MODE..TELL IT LIKE IT IS AND EXIT
        TYPE 3, SIGID
        RETURN
C
C       BUSSED SIGNAL IN PRINTER MODE...FIND SUBSTRING IN USE
  100   CALL GETPIN(LIST)
        IF (NEXTB .NE. 0) GO TO 120
        LIST = LASTB .AND. MASK
        IF (LIST .NE. 0) GO TO 100
C
C       NOT IN USE
  110   LINSIZ = 2
        CALL BUFOUT(SIGID(1) )
        LINSIZ = 15
        CALL BUFOUT('NOT IN USE')
        GO TO 240
C
C       NORMAL SEQUENCE...SET UP STUFF
  120   LINSIZ = 2
        CALL BUFOUT(SIGID(1) )
        I = LIST
        LINSIZ = 15
        SUM = 0.0
        MAX = 120
        IF (TERM) MAX = 60
C
C       OUTPUT THE NEXT PIN
  130   CALL BPID(I, ID)
        CALL GETPIN(I)
        K = LINSIZ
        CALL BUFOUT(ID)
        IF ( (CODES .AND. "004000000000) .EQ. 0) GO TO 140
        CALL BUFSTR(INLINE, K-2, '$')
C
C       TAKE APPROPRIATE BRANCH FOR TYPE OF OUTPUT
  140   GO TO (170, 150, 160), NJUMP
C
C       COMPUTE LOADS
  150   LINSIZ = LINSIZ + 2
        V = 1.0
        IF ( (CODES .AND. "004000000000) .NE. 0) V = -8.0
        IF ( (CODES .AND. "100000000000) .NE. 0) V = LOAD
        IF ( (CODES .AND. "100000000000) .NE. 0) V = -DRIVE
        SUM = SUM + V
        ENCODE (10, 2, ID) V
        CALL RTRUNC(10, ID)
        CALL BUFOUT(ID)
        GO TO 170
C
C       COMPUTE LENGTHS
  160   LINSIZ = LINSIZ + 2
        IF (NEXTB .EQ. 0) GO TO 180
        K = K + 8
        V = DIST
        SUM = SUM + V
        ENCODE (10, 1, ID) V
        CALL RTRUNC(10, ID)
        CALL BUFOUT(ID)
C
C       GENERAL USAGE
  170   LINSIZ = LINSIZ + 5
        I = NEXTB
        IF (I .EQ. 0) GO TO 180
        IF (LINSIZ .LT. MAX) GO TO 130
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINTIT
        LINSIZ = 15
        GO TO 130
C
C       HERE WHEN DONE...OUTPUT LAST LINE
  180   IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINTIT
C
C       SKIP IF TERMINAL, OR IF NOT BUSSED
        IF (TERM) GO TO 200
        IF (NEXTPIN .GE. 0) GO TO 200
        CALL GETPIN(LIST)
        LIST = LASTB .AND. MASK
  190   IF (LIST .EQ. 0) GO TO 250
        CALL GETPIN(LIST)
        IF (NEXTB .NE. 0) GO TO 120
        LIST = LASTB .AND. MASK
        GO TO 190
C
C       NOW PERFORM CLEAN-UP
  200   LINSIZ = 15
        GO TO (250, 210, 220), NJUMP
C
C       LOAD
  210   CALL BUFOUT('TOTAL LOAD IS ')
        LINSIZ = LINSIZ - 1
        GO TO 230
C
C       LENGTH
  220   CALL BUFOUT('TOTAL LENGTH IS ')
        LINSIZ = LINSIZ - 4
C
C       FINISH TEXT
  230   ENCODE (10, 2, ID) SUM
        CALL RTRUNC(10, ID)
        CALL BUFOUT(ID)
  240   IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
C
C       ALL DONE...EXIT
  250   LINSIZ = 2
        IF (TERM) CALL TYPE
        RETURN
        END
        SUBROUTINE LSOCKET(TERM)
C
C       THIS ROUTINE LISTS THE CONTENTS OF THE CURRENT SOCKET.
C
        LOGICAL TERM
        INTEGER ID(3), PLID(4)
        DATA MASK / "377777777777 /
C
        COMMON /CPGLOB/ KURSOR, LINSIZ
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, NEXT, PINPNT, XPIN, YPIN, SIGID(2),
     1  LASTSIG, NEXTSIG, PLUGPNT, NEXTRNG, ATTRIB, DIST, CHANGE,
     2  NULL, PINFLAG, THISPIN
        INTEGER PINID,PINPNT, SIGID, PLUGPNT, ATTRIB, CHANGE, NULL,
     1  THISPIN
        LOGICAL PINFLAG
C
        COMMON /PLUGPIN/ PPID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRNG,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD
        LOGICAL PPFLAG
        INTEGER PPID, GRPNO, SGRPNO, WOCC, TCC
        INTEGER PPCORAL, GRPRNG, SGRPRNG, THISPP
        DOUBLE PRECISION TIE(0/3), WIREOR(0/2)
        INTEGER NTIE(0/3), NWIREOR(0/2)
        DATA TIE / 'NO FLOAT ', 'TIE UP ', 'TIE DOWN ', 'FLOAT OK ' /
        DATA NTIE / 9, 7, 9, 9 /
        DATA WIREOR / 'FORBIDDEN ', 'OK ',0, 'REQUIRE ' /
        DATA NWIREOR / 10, 3, 8 /
    1   FORMAT ('(',I3,')' )
    2   FORMAT ( F10.3 )
C
C       OUTPUT SOCKET, TYPE, ID
        ISOCK = THISSOC
        CALL BLANK
        LINSIZ = 5
        IF (SPINPNT .LT. 0) CALL BUFOUT('EDGE')
        CALL BUFOUT('SOCKET')
        CALL BUFOUT(SOCID(1) )
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
C
C       NOW SEARCH FOR ALL BUSSED SIGNALS WITHIN PLUG DESCRIPTION
        IT = SPINPNT .AND. MASK
        DO 110 I = 1, NSOCPIN
         CALL GETPIN(IT)
         IF (NEXTRNG .NE. 0) GO TO 110
C
C       GOT A BUSSED PIN...OUTPUT IT'S DESCRIPTION
        LINSIZ = 5
        CALL BUFN(PINID, 5)
        LINSIZ = 11
        CALL BUFN('BUSSED "', 8)
        CALL BUFOUT(SIGID(1) )
        CALL BUFN('"', 5)
        IF (NEXTSIG .EQ. 0) GO TO 100
        CALL BUFN('TO ', 3)
        J = NEXTSIG
        CALL BPID(J, ID)
        CALL BUFOUT(ID(1) )
        CALL GETPIN(IT)
        CALL GETSOC(ISOCK)
  100   ATTRIB = ATTRIB .OR. 1
        PINFLAG = .TRUE.
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
  110   IT = NEXT .AND. MASK
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
C
C       ALL BUSSED PINS OUTPUT...NOW SEARCH FOR SOCKET RINGS WE'VE
C       NOT YET DONE, OUTPUT THEM
        IT = SPINPNT .AND. MASK
        DO 310 I = 1, NSOCPIN
         CALL GETPIN(IT)
        IF ( (ATTRIB .AND. 1) .NE. 0) GO TO 310
C
C       WEVE GOT A NEW SOCKET RING...OUTPUT IT
        IF (PLUGPNT .EQ. 0) GO TO 120
C
C       THERE IS A PLUG HERE...TELL ABOUT IT
        CALL PLGID(PLUGPNT, PLID(1) )
        CALL BUFOUT(' PLUG:')
        CALL BUFOUT(PLID(1) )
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
C
C       NOW OUTPUT THE CONTENTS
  120   ITEM = IT
  130   CALL GETPIN(ITEM)
        IF ( (ATTRIB .AND. "004000000000) .EQ. 0) GO TO 140
C
C       SIGNAL SOURCE...SET "$" FLAG
        LINSIZ = 2
        CALL BUFOUT('$')
C
C       OUTPUT PIN ID
  140   LINSIZ = 5
        CALL BUFN(PINID, 5)
        LINSIZ = 11
        IF (SIGID(1) .NE. 0) GO TO 150
C
C       NO SIGNAL...
        CALL BUFOUT(' NO SIGNAL')
        GO TO 170
C
C       THERE IS A SIGNAL...
  150   CALL BUFN(' SIGNAL ', 8)
        CALL BUFOUT(SIGID(1) )
        CALL BUFN(':', 3)
C
C       DETERMINE FROM
        IF (LASTSIG .EQ. 0) GO TO 160
        CALL BUFN('FROM ', 5)
        J = LASTSIG .AND. MASK
        CALL BPID(J, ID)
        CALL BUFOUT(ID)
        LINSIZ = LINSIZ + 1
        CALL GETPIN(ITEM)
        CALL GETSOC(ISOCK)
C
C       DETERMINE TO
  160   IF (NEXTSIG .EQ. 0) GO TO 170
        CALL BUFN('TO ', 3)
        J = NEXTSIG .AND. MASK
        CALL BPID(J, ID)
        CALL BUFOUT(ID(1) )
        CALL GETPIN(ITEM)
        CALL GETSOC(ISOCK)
C
C       SIGNAL PROCESSED, PROCESS PLUG DATA
  170   IF (PLUGPNT .EQ. 0) GO TO 300
C
C       A PLUG EXISTS...GET THE DATA
        CALL GETPP(PLUGPNT)
        LINSIZ = 40
        CALL BUFN(PPID, 5)
        CALL BUFN(PPID, 1)
        LINSIZ = LINSIZ + 2
        IF (TERM) GO TO 230
C
C       PRINT EVERYTHING
        IF (GROUP .EQ. 0.0) GO TO 180
        CALL BUFN('GROUP: ', 7)
        CALL BUFN(GROUP, 10)
        ENCODE (5, 1, ID), GRPNO
        CALL DBLANK(5, ID)
        CALL BUFN(ID, 5)
        LINSIZ = LINSIZ + 1
  180   IF (SUBGRP .EQ. 0.0) GO TO 190
        CALL BUFN('SUBGROUP: ', 10)
        CALL BUFN(SUBGRP, 10)
        ENCODE (5, 1, ID), SGRPNO
        CALL DBLANK(5, ID)
        CALL BUFN(ID, 5)
        LINSIZ = LINSIZ + 1
  190   CALL BUFN('OUTPUT: ', 8)
        IF (OLT .EQ. 0) GO TO 200
        CALL BUFN(OLT, 5)
        LINSIZ = LINSIZ + 1
  200   IF (DRIVE .EQ. 0.) GO TO 210
        ENCODE (10, 2, ID), DRIVE
        CALL DBLANK(10, ID)
        CALL BUFN(ID, 10)
        LINSIZ = LINSIZ + 1
  210   CALL BUFN(WIREOR(WOCC), NWIREOR(WOCC) )
        CALL BUFN('   INPUT: ', 10)
        IF (ILT .EQ. 0) GO TO 220
        CALL BUFN(ILT, 5)
        LINSIZ = LINSIZ + 1
  220   IF (LOAD .EQ. 0.0) GO TO 230
        ENCODE (10, 2, ID), LOAD
        CALL DBLANK(10, ID)
        CALL BUFN(ID, 10)
        LINSIZ = LINSIZ + 1
  230   CALL BUFN(TIE(TCC), NTIE(TCC) )
C
C
C       DONE...
  300   ATTRIB = ATTRIB .OR. 1
        PINFLAG = .TRUE.
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
        ITEM = NEXTRNG
        IF (ITEM .NE. IT) GO TO 130
C
C       DONE ALL OF THIS RING...SET SPACE, CONTINUE
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
C
C       END OF LOOP OVER ALL PINS
        CALL GETPIN(IT)
  310   IT = NEXT .AND. MASK
C
C       NOW CLEAR ALL FLAGS WE'VE SET
        IT = SPINPNT .AND. MASK
        DO 320 I = 1, NSOCPIN
        CALL GETPIN(IT)
        ATTRIB = ATTRIB .AND. "777777777776
        PINFLAG = .TRUE.
  320   IT = NEXT .AND. MASK
        CALL PUTPIN
        RETURN
        END
        SUBROUTINE LBATTLE
C
C       THIS ROUTINE PERFORMS THE "LIST CONFLICTS" COMMAND
C
        COMMON /HASHCON/ HASHCON, NBLOCK, THISSIG, SIGID(2), NEXTSIG,
     1  SIGPIN, SIGFLAG, DEFSIG(2), CDSN
        INTEGER HASHCON, THISSIG, SIGID, SIGPIN, DEFSIG, CDSN
        LOGICAL SIGFLAG
C
        COMMON /PINS/ PINID, NEXTPIN, LASTPIN, XPIN, YPIN, BPSIG(2),
     1  FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB, DIST, CNGWORD, NULL,
     2  PINFLAG, THISPIN
        INTEGER PINID, BPSIG, FROMSIG, TOSIG, PPPNT, SPRING, ATTRIB,
     1  CNGWORD, THISPIN
        LOGICAL PINFLAG
C
        COMMON /PLUGPIN/ PPID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRING,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD, DRIVE, PPX, PPY
        INTEGER PPID, ILT, OLT, GRPNO, SGRPNO, WOCC, TCC, PPCORAL,
     1  GRPRING, SGRPRNG, THISPP
        LOGICAL PPFLAG
C
        INTEGER SOURCE, ID(3), LWOR(3, 0/2)
        LOGICAL ANY
        DATA SOURCE / "004000000000 /
        DATA IWOR / "320300000000 /
        DATA LWOR / 9HFORBIDDEN,0, 2HOK,0,0, 7HREQUIRE,0 /
C
    1   FORMAT (1H+,2A5,' IS A BUSSED SIGNAL, NO CHECKS PERFORMED'/)
    2   FORMAT (1H+,2A5,':  SIGNAL NOT IN USE'/)
    3   FORMAT (1H+,2A5,' CONFLICT IN LOGIC LEVELS: ',A5, $ )
    4   FORMAT (1H+,2A5,':  SOURCE WIRED-OR CONDITIONS')
    5   FORMAT (1H+,2A5,':  NO SOURCES'/)
    6   FORMAT (1H+,2A5,':  NO CONFLICTS'/)
    7   FORMAT (8X,3A5,3X,3A5 /)
C
C       IF BUSSED, COMMENT AND EXIT
        IF (SIGPIN) TYPE 1, SIGID
        IF (SIGPIN) RETURN
C
C       IF NOT IN USE, COMMENT AND EXIT
        IF (SIGPIN .EQ. 0) TYPE 2, SIGID
        IF (SIGPIN .EQ. 0) RETURN
C
C       NOT BUSSED SIGNAL...CHECK LOGIC LEVELS
        CALL BLANK
        IT = SIGPIN
        ANY = .FALSE.
        ITEM = 0
C
C       SCAN THE LIST
  100   CALL GETPIN(IT)
        IT = TOSIG
        IF (PPPNT .EQ. 0) GO TO 130
        CALL GETPP(PPPNT)
        IF ( (ATTRIB .AND. SOURCE) .NE. 0) GO TO 110
C
C       SIGNAL SINK
        IF (ITEM .EQ. 0) ITEM = ILT
        ITEM1 = ILT
        GO TO 120
C
C       SIGNAL SOURCE
  110   IF (ITEM .EQ. 0) ITEM = OLT
        ITEM1 = OLT
C
C       CHECK IT
  120   IF (ITEM1 .EQ. 0) GO TO 130
        IF (ITEM .EQ. ITEM1) GO TO 130
C
C       GOT A CONFLICT
        IF (.NOT. ANY) TYPE 3, SIGID, ITEM
        ANY = .TRUE.
        ITEM = ITEM1
        CALL BUFOUT(',')
        CALL BUFOUT(ITEM)
        CALL BUFOUT('  AT')
        CALL BPID(ID(1) )
        CALL BUFOUT(ID(1) )
C
C       DONE...ANY MORE
  130   IF (IT .NE. 0) GO TO 100
C
C       TEST IF TO TYPE LIST
        IF (.NOT. ANY) TYPE 6, SIGID
        IF (ANY) CALL TYPE
        IF (ANY) CALL TYPE
C
C       RESCAN FOR WIRED-OR CONDITIONS
        IT = SIGPIN
        ANY = .FALSE.
  140   CALL GETPIN(IT)
        IT = TOSIG
        IF ( (ATTRIB .AND. SOURCE) .EQ. 0) GO TO 150
C
C       THIS IS A SIGNAL SOURCE
        IF (.NOT. ANY) TYPE 4, SIGID
        ANY = .TRUE.
        J = MGETFD(IWOR, ATTRIB)
        CALL BPID(THISPIN, ID)
        TYPE 7, ID, (LWOR(I, J), I = 1, 3)
C
C       DONE...CONTINUE IF POSSIBLE
  150   IF (IT .NE. 0) GO TO 140
C
C       DETERMINE IF ANY SOURCES
        IF (.NOT. ANY) TYPE 5, SIGID
        RETURN
        END
        SUBROUTINE LEMPTY(TERM)
C
C       THIS ROUTINE LISTS ALL EMPTY SOCKETS.  THEY ARE EMPTY IF NO
C       SIGNALS OR PLUGS ARE ATTACHED
C
        LOGICAL TERM, ANY
C
        COMMON /CPGLOB/ KURSOR, LINSIZ
C
        COMMON /FILES/ FILE(7, 2), SFILE(7)
        INTEGER SFILE
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, NEXT, PINPNT, XPIN, YPIN, SIGID(2),
     1  LASTSIG, NEXTSIG, PLUGPNT, NEXTRNG, ATTRIB, DIST, CHANGE,
     2  NULL, PINFLAG, THISPIN
        INTEGER PINID,PINPNT, SIGID, PLUGPNT, ATTRIB, CHANGE, NULL,
     1  THISPIN
        LOGICAL PINFLAG
C
C       GET NUMBER OF SOCKETS
        N = SFILE(3)
        CALL BLANK
        CALL BUFOUT(' EMPTY SOCKETS: ')
        ANY = .FALSE.
        MAX = 120
        IF (TERM) MAX = 60
        LINSIZ = 17
C
C       FIND EACH SOCKET, DETERMINE IF EMPTY
        DO 110 I = 1, N
   CALL GETSOC(I)
        M = NSOCPIN
        K = SPINPNT .AND. "377777777777
C
C       SCAN THE PINS IN EACH SOCKET FOR A NON-EMPTY PIN
        DO 100 J = 1, M
        CALL GETPIN(K)
        K = NEXT
        IF (NEXTRNG .EQ. 0) GO TO 100
        IF (SIGID(1) .NE. 0) GO TO 110
        IF (PLUGPNT .NE. 0) GO TO 110
  100   CONTINUE
C
C       FOUND AN EMPTY SOCKET...
        ANY = .TRUE.
        CALL BUFOUT(SOCID(1) )
        CALL BUFOUT(' ')
        IF (LINSIZ .LT. MAX) GO TO 110
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINTIT
        LINSIZ = 17
  110   CONTINUE
C
C       DONE...OUTPUT LAST LINE
        IF (.NOT. ANY) CALL BUFOUT('NONE')
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINTIT
        IF (TERM) CALL TYPE
        RETURN
        END
        SUBROUTINE LUGSG(TERM, ITYPE)
C
C       List Unused Group/SubGroup...THIS ROUTINE SEARCHES ALL THE
C       PINS FOR UNUSED GROUPS...OUTPUTS THE APPROPRIATE INFORMATION
C       WHEN FOUND
C
C       TERM INDICATES TYPEWRITER OUTPUT IF TRUE, PRINTER IF FALSE
C       ITYPE INDICATES THE TYPE OF GROUP(1)/SUBGROUP(2) TO DO
C
        INTEGER ID(3), LABEL(3)
        DATA ID(3), LABEL(3) / 0, 0 /
        LOGICAL TERM, MAYBE, ANY
C
        COMMON /FILES/ FILES(7, 2), SFILE(7)
        INTEGER SFILE
C
        COMMON /CPGLOB/ KURSOR, LINSIZ
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PID, BPCORAL(2),XPINS, YPINS, BPSIG(2), FROM, TO,
     1  PLGPIN, PLGRING, CODES, DIST, NULL(2), PINFLAG, THISPIN
        INTEGER PID, BPCORAL, BPSIG, FROM, TO, PLGPIN, PLGRING, CODES,
     1  THISPIN
        LOGICAL PINFLAG
C
        COMMON /PLUGPIN/ PPID, DEFAULT, GROUP(2), SUBGRP(2), ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRNG,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        DOUBLE PRECISION DEFAULT
        REAL LOAD
        LOGICAL PPFLAG
        INTEGER PPID, GROUP, SUBGRP, GRPNO, SGRPNO, WOCC, TCC
        INTEGER PPCORAL, GRPRNG,SGRPRNG,THISPP
C
        INTEGER MASK(2)
        DATA MASK /"020000000000, "010000000000 /
C
C       BLANK OUT
        ANY = .FALSE.
        CALL BLANK
        LABEL(1) = '    G'
        LABEL(2) = 'ROUP '
        IF (ITYPE .EQ. 2) LABEL(1) = ' SUBG'
C
C       DO FOR ALL SOCKETS
        DO 160 NS = 1, NSOCPIN
        CALL GETSOC(NS)
C
C       GOTTEN THE SOCKET CODE...GET THE POINTER AND SEARCH THE PINS
        IPIN = SPINPNT .AND. "377777777777
        MAYBE = .FALSE.
        DO 100 NP = 1, NSOCPIN
        CALL GETPIN(IPIN)
C
C       DETERMINE IF THE PIN HAS NO SIGNAL, IS NOT A BUSSED PIN, 
C       HAS A PLUG ASSOCIATED, AND IS OF THE CORRECT TYPE
        IF (BPSIG(1) .NE. 0) GO TO 100
        IF (PLGRING .EQ. 0) GO TO 100
        IF (PLGPIN .EQ. 0) GO TO 100
        IF ( (MASK(ITYPE) .AND. CODES) .EQ. 0) GO TO 100
C
C       GOT A UNUSED GROUP/SUBGROUP PIN
        CODES = CODES .OR. "1
        PINFLAG = .TRUE.
        MAYBE = .TRUE.
  100   IPIN = BPCORAL(1)
C
C       HAVE NOW SEARCHED SOCKET..DETERMINE IF POSSIBLE MATCHES
        IF (.NOT. MAYBE) GO TO 160
C
C       THIS SOCKET CONTAINS A POSSIBLE ELEMENT
        IPIN = SPINPNT .AND. "377777777777
        DO 150 NP = 1, NSOCPIN
        CALL GETPIN(IPIN)
        IF ( (CODES .AND. "1) .EQ. 0) GO TO 150
C
C       WE'RE THERE...FIND THE PLUGPIN
        MAYBE = .TRUE.
        M = PLGPIN
        N = PLGPIN
        ITEM = IPIN
C
C       CLEAR FLAG FROM SOCKET PIN
  110   CODES = CODES .AND. "777777777776
        PINFLAG = .TRUE.
C
C       SEARCH PLUG SOCKET GROUP FOR NEXT PIN ASSOCIATED WITH THIS GROUP
  120   CALL GETPP(N)
        N = GRPRNG
        IF (ITYPE .EQ. 2) N = SGRPRNG
        IF (N .EQ. M) GO TO 140
C
C       SEARCH SOCKET FOR MATCHING POINTER
        IT = ITEM
  130   CALL GETPIN(IT)
        IT = BPCORAL(1)
        IF (PLGPIN .NE. N) GO TO 130
C
C       GOT MATCH
        ITEM = IT
        IF ( (CODES .AND. "1) .NE. 0) GO TO 110
C
C       MATCH FAILED...CLEAR FLAG, BUT KEEP SEARCHING
        MAYBE = .FALSE.
        GO TO 120
C
C       HERE WITH ALL SEARCH DONE
  140   IF (.NOT. MAYBE) GO TO 150
C
C       SUCCESS...OUTPUT STUFF
        ANY = .TRUE.
        CALL BLANK
        CALL BUFOUT(LABEL)
        IF (ITYPE .EQ. 1) CALL BUFOUT(GROUP(1) )
        IF (ITYPE .EQ. 2) CALL BUFOUT(SUBGRP(1) )
        CALL BUFOUT (' LOCATED AT ')
        LINSIZ = LINSIZ - 3
        CALL BPID(IPIN, ID(1) )
        CALL BUFOUT(ID(1) )
        IF (TERM) CALL TYPE
        IF (.NOT. TERM) CALL PRINTIT
C
C       DONE WITH THIS SUBGROUP
  150   CONTINUE
C
C       DONE WITH THIS SOCKET
  160   CONTINUE
C
C       DONE...RETURN
        IF (.NOT. ANY) CALL BUFOUT('     NONE')
        IF (TERM)  CALL TYPE
        IF (ANY) RETURN
        IF (TERM)  CALL TYPE
        IF (.NOT. TERM) CALL PRINT IT
        RETURN
        END
        SUBROUTINE BPID(N, ID)
C
C       THIS ROUTINE TAKES THE NUMBER OF THE PIN (N) AND RETURNS
C       THE ID OF THE PIN (A15)
C
        INTEGER ID(3)
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, NEXT, PINPNT, XPIN, YPIN, SIGID(2),
     1  LASTSIG, NEXTSIG, PLUGPNT, NEXTRNG, ATTRIB, DIST, CHANGE,
     2  NULL, PINFLAG, THISPIN
        INTEGER PINID,PINPNT, SIGID, PLUGPNT, ATTRIB, CHANGE, NULL,
     1  THISPIN
        LOGICAL PINFLAG
C
C       INITIALIZE THE NAME, SAVE THE NUMBER
        ID(1) = 0
        ID(2) = 0
        ID(3) = 0
        I = N
C
C       SEARCH FOR THE SOCKET POINTER
  100   CALL GETPIN(I)
        IF (PINPNT) GO TO 110
        I = NEXT
        GO TO 100
C
C       GOT THE POINTER TO THE SOCKET
  110   I = PINPNT .AND. "377777777777
        CALL GETSOC(I)
        CALL GETPIN(N)
        I = 1
        CALL BUFSTR(ID(1), I, SOCID(1) )
        CALL BUFSTR(ID(1), I, '-')
        CALL BUFSTR(ID(1), I, PINID)
        RETURN
        END
        LOGICAL FUNCTION PINFIND(ID)
C
C       THIS ROUTINE SEARCHES FOR A PIN WITH ID, RETURN .TRUE. IF
C       SUCCESS, /PINS/ THEN CONTAINS THE DESCRIPTION.
C       ELSE RETURN .FALSE, /PINS/ UNCHANGED (BUT MAY HAVE BEEN WRITTEN)
C
        INTEGER TP
C
        COMMON /SOCKET/ SOCID(2), NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        INTEGER SOCID, SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
        COMMON /PINS/ PINID, NEXT, PINPNT, XPIN, YPIN, SIGID(2),
     1  LASTSIG, NEXTSIG, PLUGPNT, NEXTRNG, ATTRIB, DIST, CHANGE,
     2  NULL, PINFLAG, THISPIN
        INTEGER PINID,PINPNT, SIGID, PLUGPNT, ATTRIB, CHANGE, NULL,
     1  THISPIN
        LOGICAL PINFLAG
C
C       SAVE PARAMETERS, INITIATE SEARCH
        IF (THISPIN .EQ. 0) CALL GETPIN(1)
        TP = THISPIN
        PINFIND = .TRUE.
        IT = SPINPNT .AND. "377777777777
        DO 100 I = 1, NSOCPIN
         CALL GETPIN(IT)
         IT = NEXT .AND. "377777777777
         IF (PINID .EQ. ID) RETURN
  100    CONTINUE
C
C       FAILED...RESET AND RETURN
        CALL GETPIN(TP)
        PINFIND = .FALSE.
        RETURN
        END
        LOGICAL FUNCTION SOCFIND(ID)
C
C       THIS ROUTINE SEARCHES FOR A SOCKET WITH ID, RETURN .TRUE. IF
C       SUCCESS, /SOCKET/ THEN CONTAINS THE DESCRIPTION.
C       ELSE RETURN .FALSE, /SOCKET/ UNCHANGED (BUT MAY HAVE BEEN WRITTEN)
C
        DOUBLE PRECISION ID
        INTEGER TS
C
        COMMON /FILES/ FILE(7, 2), SFILE(7)
        INTEGER SFILE
C
        COMMON /SOCKET/ SOCID, NSOCPIN, NWORDS, SPINPNT, SOCFLAG,
     1  THISSOC
        DOUBLE PRECISION SOCID
        INTEGER SPINPNT, THISSOC
        LOGICAL SOCFLAG
C
C       SAVE PARAMETERS, INITIATE SEARCH
        TS = THISSOC
        N = SFILE(3)
        SOCFIND = .TRUE.
        DO 100 I = 1, N
         CALL GETSOC(I)
         IF (SOCID .EQ. ID) RETURN
  100    CONTINUE
C
C       FAILED...RESET AND RETURN
        CALL GETSOC(TS)
        SOCFIND = .FALSE.
        RETURN
        END
        SUBROUTINE PLGID(N, ID)
C
C       THIS ROUTINE FINDS THE PLUG PIN N, AND FROM THIS DETERMINES
C       THE PLUG ID, WHICH IT RETURNS IN ID.  PLUGPIN IS RETURNED
C       WITH  PIN N, UNLESS N = 0
C
        DIMENSION ID(4)
C
        COMMON /PLUGS/ PLUGID(3), PLGPNT, NPLGPIN, PLGFLAG, THISPLG
        INTEGER PLUGID, PLGPNT, THISPLG
        LOGICAL PLGFLAG
C
        COMMON /PLUGPIN/ PPID, DEFAULT, GROUP, SUBGRP, ILT, OLT,
     1  GRPNO, SGRPNO, LOAD, DRIVE, WOCC, TCC, PPCORAL(2), GRPRING,
     2  SGRPRNG, PPX, PPY, PPFLAG, THISPP
        DOUBLE PRECISION DEFAULT, GROUP, SUBGRP
        REAL LOAD, DRIVE, PPX, PPY
        INTEGER PPID, ILT, OLT, GRPNO, SGRPNO, WOCC, TCC, PPCORAL,
     1  GRPRING, SGRPRNG, THISPP
        LOGICAL PPFLAG
C
C       FIRST OF ALL CLEAR ID
        ID(1) = 0
        ID(2) = 0
        ID(3) = 0
        ID(4) = 0
        IF (N .LE. 0) RETURN
C
C       SCAN PLUG CORAL RING
        I = N
  100   CALL GETPP(I)
        I = PPCORAL(2) .AND. "377777777777
        IF (.NOT. PPCORAL(2) ) GO TO 100
C
C       NOW GET THE PLUG DESCRIPTION
        CALL GETPLUG(I)
        CALL GETPP(N)
        ID(1) = PLUGID(1)
        ID(2) = PLUGID(2)
        ID(3) = PLUGID(3)
        RETURN
        END
        SUBROUTINE PRINTIT
C
C       THIS ROUTINE PRINTS OUT THE LINE IN INLINE
C       IT DOES PAGE COUNTING TOO
C
        CALL GOPRINT
        CALL LINE
        RETURN
        END
        SUBROUTINE LINE
C
C       THIS ROUTINE TESTS IF NEW PAGE TO BE OUTPUT
C
        COMMON /PAGING/ NLINES, NPAGES
C
C       COUNT THE LINE, RETURN IF NOT YET DONE
        NLINES = NLINES - 1
        IF (NLINES .GE. 0) RETURN
C
C       LINES EXHAUSTED...GO TO NEW PAGE
        CALL PAGE(NPAGES)
        NPAGES = NPAGES + 1
        RETURN
        END
        SUBROUTINE PAGE(NUMBER)
C
C       THIS ROUTINE OUTPUTS THE PAGE HEADER FOR THE PRINTER
C
        COMMON /PAGING/ NLINES, NPAGES
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270)
C
        COMMON /TITLE/ TITLE(16), MODIFY(2)
        INTEGER TITLE, MODIFY
C
        DIMENSION IT(3)
C
    1   FORMAT(I5)
C
C       BLANK THE BUFFER, OUTPUT TEXT
        CALL BLANK
        CALL BUFOUT('1')
        CALL BUFOUT ('PAGE')
        ENCODE (5, 1, I) NUMBER
        CALL DBLANK(5, I)
        CALL BUFOUT(I)
        CALL BUFOUT(' ')
        CALL BUFOUT(TITLE(1) )
        IF (MODIFY(1) .EQ. 0) GO TO 100
C
C       MODIFICATION LEVEL EXISTS...OUTPUT IT
        CALL BUFOUT('. . .MOD.')
        I = LINSIZ
        CALL BUFOUT(MODIFY(1) )
        INLINE(I) = "40
  100   IF (LINSIZ .GT. 120) GO TO 110
C
C       OUTPUT TIME
        CALL BUFOUT(' ')
        IT(2) = 0
        CALL TIME(IT(1) )
        CALL BUFOUT(IT(1) )
        IF (LINSIZ .GT. 115) GO TO 110
C
        CALL BUFOUT(' ')
C       OUTPUT DATE
        IT(3) = 0
        CALL DATE(IT(1) )
        CALL BUFOUT(IT(1) )
  110   CALL GOPRINT
C
C       SKIP A COUPLE OF LINES
        CALL GOPRINT
        CALL GOPRINT
        NLINES = 50
        IF (NUMBER .NE. 1) RETURN
C
C       NEW SET OF PAGES...SET UP COUNTER
        NPAGES = 2
        RETURN
        END
        SUBROUTINE GOPRINT
C
C       THIS ROUTINE PRINTS OUT THE LINE IN INLINE, TRANSLATING IT FIRST
C
        COMMON /PRINTER/ PRINTER(9)
        INTEGER PRINTER
C
        COMMON /CPGLOB/ KURSOR, LINSIZ, NATCH, INLINE(270), ISTTY, HUSH,
     1  UNCOLA, IPROMP, IDFILE(5)
        LOGICAL ISTTY, HUSH, UNCOLA
C
    1   FORMAT (130A1)
C
C       FIRST TRANSLATE THE LINE
        CALL R TO A
C
        WRITE (PRINTER(1), 1),(INLINE(I), I = 1, LINSIZ)
        CALL BLANK
        RETURN
        END
        FUNCTION HOWFAR (HERE, THERE)
C
C       HERE IS DIMENSIONED 2, AND HAS THE VALUE PAIR (X, Y)
C       THERE IS DIMENSIONED 2, AND HAS THE VALUE PAIR (X, Y)
C       HOWFAR COMPUTES THE DISTANCE FROM HERE TO THERE.
C
C       IT USES THE TEMP ARRAY XY.  THE FIRST INDEX CORRESPONDS TO
C       AN (X, Y) PAIR.  THE SECOND INDEX CORRESPONDS TO POINTS ON A
C       BOX SURROUNDING THE POINT.  THE THIRD INDEX CORRESPONDS TO
C       THE FIRST AND SECOND POINTS RESPECTIVELY.  THE BOX POINTS ARE:
C
C               I 3 I
C              -------
C             2 I 1 I 4
C              -------
C               I 5 I
C
C
C       THE RESULTING VALUES AND BOX INDICIES ARE SAVED IN COMMON /ROUTE/
C
C
        DIMENSION HERE(2), THERE(2), XY(2, 5, 2), FLAG(2)
        COMMON /ROUTE/ ISAVE, JSAVE, XY
        COMMON /FILES/ FXY(7, 2)
C       NOTE...FILE BLOCK FXCHAN IS FXY(*, 1); FYCHAN IS FXY(*, 2)
        INTEGER FXY
C
        COMMON /TITLE/ TITLE(16), MODIFY(2), NEWMOD, MODFLG, WRITEIT,
     1  XMIN, XMAX, YMIN, YMAX, PICFRAM
        INTEGER TITLE
        LOGICAL NEWMOD, MODFLG, WRITEIT, PICFRAM
C
        LOGICAL FLAG
        DATA BIGONE / 1000000.0 /
C
C       DETERMINE IF PICTURE-FRAME OR POINT-TO-POINT ROUTING
        IF (PICFRAM) GO TO 100
C
C       POINT-TO-POINT...COMPUTE IT
        DX = HERE(1) - THERE(1)
        DY = HERE(2) - THERE(2)
        HOWFAR = SQRT(DX*DX + DY*DY )
        RETURN
C
C       PICTURE FRAME...COPY PARAMETERS TO XY ARRAY
  100   DO 110 I = 1, 5
         DO 110 J = 1, 2
          XY(J, I, 1) = HERE(J)
  110     XY(J, I, 2) = THERE(J)
C
C       NOW MAKE THE BOXES EXCEEDINGLY LARGE
        DO 120 I = 1, 2
         XY(1, 2, I) = XY(1, 2, I) - BIG ONE
         XY(2, 3, I) = XY(2, 3, I) + BIG ONE
         XY(1, 4, I) = XY(1, 4, I) + BIG ONE
  120    XY(2, 5, I) = XY(2, 5, I) - BIG ONE
C
C       NOW THE BOXES MUST BE FITTED TO THE WIRING CHANNELS
C
C       DO FOR EACH FILE X AND Y
        DO 250 NFILE = 1, 2
         NXY = FXY(3, NFILE)
         IF (NXY .EQ. 0) GO TO 250
C
C       THE FILE IS NOT EMPTY...READ THE FIRST VALUE FROM IT
         READ (FXY(1, NFILE) # 1) VALUE
C
C       VERIFY THAT BOX IS NOT OUTSIDE LOWER LIMIT
         DO 160 I = 1, 2
          FLAG(I) = .FALSE.
          GO TO (130, 140), NFILE
C
C       CHECK X
  130     IF (XY(1, 1, I) .GT. VALUE) GO TO 160
          XY(1, 4, I) = VALUE
          GO TO 150
C
C       CHECK FOR Y
  140     IF (XY(2, 1, I) .GT. VALUE) GO TO 160
          XY(2, 3, I) = VALUE
C
C       SET FLAG THAT BOUNDARY FOUND
  150     FLAG(I) = .TRUE.
C
C       CHECK COMPLETED
  160     CONTINUE
C
C       SET LINE COUNTER
         N = 1
C
C       SET LOWER LIMITS
  170    DO 200 I = 1, 2
          GO TO (180, 190), NFILE
C
C       SET NEW X-BOUNDARY
  180     IF(FLAG(I)) GO TO 200
          XY(1, 2, I) = VALUE
          GO TO 200
C
C       SET NEW Y BOUNDARY
  190     IF(FLAG(I)) GO TO 200
          XY(2, 5, I) = VALUE
C
C       THAT'S DONE
  200     CONTINUE
C
C       TEST IF ALL DONE WITH THIS DIMENSION
         IF (FLAG(1) .AND. FLAG(2)) GO TO 250
         IF (N .GE. NXY) GO TO 250
C
C       READ THE NEXT VALUE, TEST IF STRADDLE
         READ(FXY(1, NFILE)) VALUE
         N = N + 1
C
C       TEST BOTH BOXES
         DO 240 I = 1, 2
          GO TO (210, 220), NFILE
C
C       CHECK X
  210     IF(FLAG(I)) GO TO 240
          IF (XY(1, 1, I) .GT. VALUE) GO TO 240
          XY(1, 4, I) = VALUE
          GO TO 230
C
C       CHECK Y
  220     IF (FLAG(I)) GO TO 240
          IF(XY(2, 1, I) .GT. VALUE) GO TO 240
          XY(2, 3, I) = VALUE
C
C       FOUND ONE..SET FLAG
  230     FLAG(I) = .TRUE.
C
C       THAT'S DONE TOO
  240     CONTINUE
C
C       CONTINUE LOOP
         GO TO 170
C
C       END LOOP OVER BOTH FILES
  250    CONTINUE
C
C       DETERMINE IF BOXES HAVE COMMON EDGE
      IF((XY(1,2,1).NE.XY(1,2,2)).AND.(XY(2,3,1).NE.XY(2,3,2)))GOTO280
C
C       HERE IF COMMON EDGE...TEST IF COMMON BOX
        IF (XY(1,2,1) .NE. XY(1,2,2) ) GO TO 260
        IF (XY(2,3,1) .NE. XY(2,3,2) ) GO TO 270
C
C       HERE IF COMMON BOX..MINIMIZE IT
        DX = ABS(XY(1,2,1) - XY(1,4,1) )
        DY = ABS(XY(2,3,1) - XY(2,5,1) )
        IF (DX .GT. DY) 260, 270
C
C       EITHER:  COMMON Y EDGE, OR:
C       DY IS LESS, MAKE DX BIG
  260   XY(1,2,1) = XY(1,2,1) - BIG ONE
        XY(1,2,2) = XY(1,2,2) - BIG ONE
        XY(1,4,1) = XY(1,4,1) + BIG ONE
        XY(1,4,2) = XY(1,4,2) + BIG ONE
        GO TO 280
C
C       EITHER:  COMMON X EDGE, OR:
C       DX IS LESS, MAKE DY BIG
  270   XY(2,3,1) = XY(2,3,1) + BIG ONE
        XY(2,3,2) = XY(2,3,2) + BIG ONE
        XY(2,5,1) = XY(2,5,1) - BIG ONE
        XY(2,5,2) = XY(2,5,2) - BIG ONE
C
C       NOW COMPUTE MINIMUM LENGTH WIRE PATH
  280   HOWFAR = BIGONE
        DO 290 I = 2, 5
C
C       COMPUTE DISTANCE TO BOX EDGE FROM POINT
         DXI = XY(1,1,1) - XY(1,I,1)
         DYI = XY(2,1,1) - XY(2,I,1)
         DI = ABS(DXI) + ABS(DYI)
C
C       SAME GAME FOR OTHER BOX
         DO 290 J = 2, 5
          DXJ = XY(1,1,2) - XY(1,J,2)
          DYJ = XY(2,1,2) - XY(2,J,2)
          DJ = ABS(DXJ) + ABS(DYJ)
C
C       NOW DISTANCE BETWEEN BOX POINTS
          DX = ABS( XY(1,I,1) - XY(1,J,2) )
          DY = ABS( XY(2,I,1) - XY(2,J,2) )
C
C       NOW TOTAL DISTANCE BETWEEN PINS
          DELTA = DI + DJ + DX + DY
C
C       TEST IF FOUND NEW MINIMUM
          IF( HOWFAR .LT. DELTA ) GO TO 290
          ISAVE = I
          JSAVE = J
          HOWFAR = DELTA
C
C       END OF SEARCH LOOP
  290     CONTINUE
        RETURN
        END
  *A