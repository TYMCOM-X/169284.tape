TITLE BASCOM
INTERN STAFLO,STACEI
INTERN RELCEI,RELFLO,IFNFLO,IFNCEI
INTERN  RUNNH
SUBTTL COMPILER MAIN LOOP
HISEG

	INTERN UUOHAN
	EXTERN	UUOH
UUOHAN:	PUSH	P,UUOH		;RETURN ADDRS ON PUSH-DOWN LIST
	LDB	X1,[POINT 9,40,8]
IFL MAXUUO-37, <
	CAILE	X1,MAXUUO
	JRST	INLSYS		;ILLEGAL UUO.
>
UUOTBL:	JRST	.(X1)
	JRST	FAILER
;BEGINNING OF COMPILATION

RUNNH:	MOVEI	X1,^D9		;CHAIN ENTRY POINT.
RUNNH1:	SETZM	ACTBL-1(X1)
	SETZM	FILD-1(X1)
	SETZM	EXTD-1(X1)
	SOJG	X1,RUNNH1
	SETOM	VRFSET
	SETOM	COMTIM
	SETZM	FILCNT
	SKIPN	CHAFLG
	JRST	.+3		;NO.
	MOVE	P,PLIST
	PUSHJ	P,TTYIN
	SKIPE	SWAPSS		;SET THE CORE CRUNCHING FLAG IF
	SETOM	PAKFLG		;THIS IS A SWAPPING SYSTEM.
	PUSHJ	P,LOCKON	;PROTECT REST OF COMPILATION
	PUSHJ	P,PRESS		;GUARANTEE SOURCE DOESN'T MOVE!!!
	MOVEI	X1,CODROL		;COMPILE TIME.
	MOVEM	X1,TOPSTG		;TXT,LIN,CODROLS ARE STODGY. OTHERS MOVE.
	MOVEI	R,LINROL
	PUSHJ	P,SLIDRL	;SLIDE LINROL DOWN NEXT TO TXTROL.
	JRST	RUNER1

SLIDRL:	MOVE	X2,CEIL(R)
	HRRZ	X1,CEIL-1(R)	;SLIDE ROLL DOWN  NEXT TO LOWER ROLL
	ADD	X2,X1
	HRL	X1,FLOOR(R)	;SET UP BLT TO MOVE ROLL
	SUB	X2,FLOOR(R)
	HRRZM	X1,FLOOR(R)	;SET NEW ROLL FLOOR
	BLT	X1,(X2)
	MOVEM	X2,CEIL(R)
	POPJ	P,

RUNER1:	MOVEM	X2,FLCOD
	MOVEM	X2,CECOD	;CODROL IS ALSO PACKED IN PLACE.
	MOVEI	X1,CODROL	;PREPARE TO CLOBBER ALL ROLLS ABOVE CODROL
	MOVE	T,JOBREL		;USE THIS VALUE.
	PUSHJ	P,CLOB		;DO THE CLOBBERING.
	MOVEI	F,0		;CLEAR COMPILATION FLAGS
	SKIPE	CHAFLG		;CHAINING?
	JRST	RUNER0		;YES, DON'T DISTURB THE TIME.
	MOVEI	T,0		;SET UP AC FOR CALLI.
	CALLI	T,27		;GET TIME OF START.
	MOVEM	T,MTIME		;SAVE TIME AT START OF RUNER
RUNER0:	SETOM	RUNFLA	
	SETZM	DATAFF		;CLEAR DATA FLAG
	SETOM	TMPLOW	;NO TEMPORARIES USED YET.

	MOVEI	F,REFROL	;CREATE A ROLL OF ZEROS
	PUSHJ	P,ZERROL

;NOW MARK THIS ROLL TO SHOW WHAT PARTS OF THIS PROG ARE INSIDE OF FUNCTIONS:
LUKDEF:	MOVEI	A,LUKDEF+1	;SCAN FOR NEXT "DEF" STA
	PUSHJ	P,NXLINE	;PREPARE TO READ THE NEXT LINE.
	MOVEI	X1,[ASCIZ/DEFFN/]
	PUSHJ	P,QST		;IS IT A "DEF" STA?
	JRST	LUKD3		;NO. GO ON TO NEXT LINE

	HRRZ	B,C		;YES. SAVE FN NAME.

	MOVEI	A,LUKD2
LUKD1:	PUSHJ	P,NXCH		;NOW LOOK FOR EQUAL SIGN
	TLNE	C,F.TERM
	JRST	LUKD3		;NO EQUAL. ITS A MULTILINE DEF.
	TLNN	C,F.EQAL
	JRST	LUKD1		;TRY NEXT CHAR.
	JRST	LUKD3-1		;ITS A ONE LINE DEF. IGNORE IT.

LUKD2:	MOVEI	A,LUKD2+2		;MARK EVERY LINE OF THIS MULTILINE FN!
	ROT	B,-7		;PUT FUNCTION NAME IN FIRST CHAR POSITION
	PUSHJ	P,NXLINE
	MOVEM	B,(G)		;NOW THIS LINE CONTAINS THE NAME OF ITS FN.
	MOVEI	X1,[ASCIZ /FNEND/]
	PUSHJ	P,QST		;END OF THE FN?
	CAIA
	MOVEI	A,LUKDEF+1		;YES. SCAN FOR NEXT DEF.

LUKD3:	AOBJN	L,(A)		;GET NEXT LINE, IF THERE IS ONE.
	JRST	RUNER2


;FINISHED MARKING FUN LINES. NOW SET UP A CLEAR LADROL...
RUNER2:	MOVEI	F,LADROL
	PUSHJ	P,ZERROL
	JRST	EACHLN

;ROUTINE TO MAKE A ROLL OF ZEROS =IN LNTH TO LINROL.
ZERROL:	MOVE	R,F
	MOVE	E,CELIN	;COMPUTE LENGTH OF ROLL
	SUB	E,FLLIN
	JUMPE	E,NOEND		;NOTHING TO DO

	MOVN	L,E		;SAVE FOR LINE CNTR.
	MOVSI	L,(L)
	PUSHJ	P,BUMPRL	;ADD TO (EMPTY) ROLL
	MOVE	T,FLOOR+(F)	;CLEAR IT TO 0S
	SETZM	(T)
	HRL	T,T
	ADDI	T,1
	MOVE	T1,CEIL+(F)
	CAILE	T1,(T)		;SUPPRESS BLT IF ONLY 1 LINE
	BLT	T,-1(T1)
	POPJ	P,
;SO FAR, WE HAVE SET UP LADROL FOR ADDRESSES & CHAINS FOR LABLES
;ALSO, L IS A WORD TO AOBJN & COUNT THROUGH LINES.
;BEGIN COMPILATION OPERATIONS FOR EACH LINE

EACHLN:	MOVE	P,PLIST		;FIX P LIST IN CASE LAST INST FAILED
	PUSHJ	P,LOCKOF	;CHECK REENTER REQUEST
	PUSHJ	P,LOCKON
	MOVE	X1,TMPLOW
	MOVEM	X1,TMPPNT	;NO UNPROTECTED TEMPORARIES USED YET.
	SETZM	LETSW
        SETZM RANFLG
        SETZM MATFLG
	EXTERN	TRNFLG,TRNFL2
	SETZM	TRNFLG		;NOT YET SEEING MAT TRN.
	SETZM	REGPNT		;REG IS FREE
	SETZM	PSHPNT		;NO "PUSH" INSTS GENERATED YET
	SETOM	VRFSET
	SKIPN	FUNAME		;IN MIDST OF MULTI-LINE FUNCTION
	JRST	.+3
	MOVMS	VRFSET
	JRST	EACHL2
	MOVE	X1,FLARG	;NO FUNCTION ARGS YET
	MOVEM	X1,CEARG
EACHL2:	PUSHJ	P,NXLINE	;SET UP POINTER TO THIS LINE.
	MOVSI	A,(SIXBIT /REM/)	;PREPARE FOR COMMENT
	CAIE	C,":"		;IMAGE = REM.
	TLNE	C,F.TERM	;NULL STATEMENT?
	JRST	EACHL1		;YES. ELIDED "REM" (FIRST CHAR WAS AN APOSTROPHE)
	PUSHJ	P,SCNLT1		;SCAN FIRST LTR
	CAIE	C,"("
	TLNE	C,F.EQAL+F.DIG+F.DOLL	;ELIDED LETTER?
	JRST	ELILET		;YES.  POSSIBLE ASSUMED "LET"
	PUSHJ	P,SCNLT2		;SCAN SECOND LETTER.
	JRST	ILLINS		;SECOND CHAR WAS NOT A LETTER.
	MOVS	X1,A
	CAIE	X1,(SIXBIT /IF/)
	CAIN	X1,(SIXBIT /ON/)
	JRST	EACHL1
	CAIE	X1,(SIXBIT /FN/)	;ELIDED LET FNX=  ?
	JRST	EACHL3		;NO.
	PUSHJ	P,SCNLT3
	JRST	ILLINS
	TLNE	C,F.EQAL	;IS FOURTH CHAR AN '=' SIGN?
	JRST	ELILET		;YES, ELIDED STATEMENT
	JRST	EACHL1		;NO, BETTER BE FNEND.

EACHL3:	PUSHJ	P,SCNLT3		;ASSEMBLE THIRD LETTER OF STATEMENT IN A
	JRST	ILLINS		;THIRD CHAR WAS NOT A LETTER
	CAMN	A,[624555000000]	;FIX FOR REM
	HRRZ	C,C			;TWO LINES.
        CAME    A,[456063000000]        ;EPS ?
	JRST	EACHL1            ;NO
        TLNN    C,F.EQAL        ;YES, IS 4TH CHAR AN "="?
        JRST    ILLINS          ;NO

ELILET:	MOVSI	A,(SIXBIT /LET/)	;ASSUME A "LET" STATEMENT.
	MOVS	T,D			;GO BACK TO THE FIRST LETTER.
	HRLI	T,440700
	PUSHJ	P,NXCHK

;HERE, FIRST 3 LTRS OF VERB (SIXBIT) ARE IN A.  USE TBL LOOKUP AND DISPATCH.

EACHL1:	MOVEI	R,STAROL
	PUSHJ	P,SEARCH	;LOOK IN STATEMENT TYPE TABLE
	JRST	ILLINS		;NO SUCH, GO BITCH
	HRRZ	A,(B)		;FOUND.

	MOVE	X1,CECOD	;PUT REL ADDRS IN LADROL
	SUB	X1,FLCOD
	MOVE	X2,FLLAD
	ADDI	X2,(L)
	HRLM	X1,(X2)
	HRLI	D,(MOVEI L,)
        TRZN   A,20000          ;EXECUTABLE?
	JRST	EACHL6
	EXTERN SORCLN
	PUSHJ	P,BUILDI	;FORCE STORE OF SOURCE LINE
	MOVE D,[MOVEM L,SORCLN]	;NUMBER IN SORCLN.
	PUSHJ	P,BUILDI
EACHL6:	MOVE	X1,A

	TRZN	X1,40000	;MORE TO COMMAND?
	SOJA	X1,EACHL5	;NO. JUST DISPATCH
	PUSHJ	P,QST		;CHECK REST OF COMMAND
	JRST	ILLINS

EACHL5:	JRST	1(X1)
;HERE ON END OF STATEMENT XLATION

NXTSTA: SETZM   XLFLG1  ;CLC CLUDGE FOR PRINT USING TO A FILE.
        TLNN	C,F.TERM		;CHECK FOR END OF LINE
	JRST	GRONK
	SKIPE	VRFSET
	JRST	.+3
	MOVE	D,[SETZM VRFBOT]
	PUSHJ	P,BUILDI


;ENTER HERE FROM ERROR ROUTINE

NXTST1:	AOBJN	L,EACHLN
NOEND:	MOVEI	T,NOEND1	;IF NONE, DIDNT SEE END
	JRST	ERRMSG
NOEND1:	ASCIZ	/
? NO END INSTRUCTION/





SUBTTL	PROGRAM "LOADER"
;HERE AFTER END STATEMENT

LINKAG:	MOVEI	R,CONROL	;SLIDE RUNTIME ROLLS DOWN INTO PLACE.
	PUSHJ	P,SLIDRL
	CAIGE	R,TMPROL
	AOJA	R,.-2		;SLIDE NEXT ROLL.
	MOVEM	X2,VARFRE	;FIRST FREE LOC IS CEIL OF TMPROL.

	MOVE	E,CETMP	;CHECK ARRAY REQUIREMENTS
	MOVE	T,FLARA
	SETZM	TRNFL2
	SETZM	TRNFLG
	JRST	LK2A

LK1:	HLRZ	X1,(T)		;KNOW SIZE?
	JUMPN	X1,LK2		;YES, JUMP
	SKIPG	2(T)		;DON'T SET UP FAKE MATRIX
	JRST	.+3		;YET, BUT REMEMBER WHICH ONE
	MOVEM	T,TRNFLG	;IT IS.
	JRST	LK2
	MOVSI	X2,^D11		;(11,1) IS STANDARD DIM
	AOJ	X2,
	MOVEI	X1,^D11
	MOVE	A,1(T)
	CAMGE	T,FLSVR	;DEFAULT SIZE OF STRING VECTORS IS (11,1)
	AOJE	A,.+2		;IMPLICIT 2-DIM ARRAY?
	JRST	.+3
	HRRI	X2,^D11
	MOVEI	X1,^D121
	MOVEM	X2,1(T)
	HRLM	X1,(T)		;STORE SIZE
LK2:	ADD	E,X1		;ADD LENGTH TO IT
	SKIPL	2(T)
	JRST	.+3
	CAMLE	X1,TRNFL2	;TRNFL2 CONTAINS THE SPACE NEEDED
	MOVEM	X1,TRNFL2	;BY THE LRGST ARRAY SET = ITS OWN TRN.
	ADDI	T,3		;ON TO NEXT ENTRY
	CAMG	T,FLSVR		;IS THIS ONE A STRING VECTOR?
	JRST	LK2A		;NO.
	HLRZ	X2,-1(T)		;LOOK AT FIRST DIMENSION
	SOJLE	X2,LK2A		;IS IT 1(AND THUS A VECTOR)?
	HRRZ	X2,-1(T)	;NO. LOOK AT SECOND DIMENSION
	SOJLE	X2,LK2A		;IS IT 1(AND THUS A VECTOR)?
	SETZM	RUNFLA		;NO. FATAL ERROR.
	PUSHJ	P,INLMES
	ASCIZ /
? STRING VECTOR IS 2-DIM ARRAY/
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3

LK2A:	CAMN	T,FLSVR		;BEGINNING OF SVRROL SCAN?
	MOVEM	E,SVRBOT		;YES, REMEMBER BOTTOM OF VECTOR POINTERS
	CAMGE	T,CESVR
	JRST	LK1
	SKIPN	TRNFLG
	JRST	LK3
	EXCH	T,TRNFLG	;NOW SET UP THE
	MOVE	X1,TRNFL2	;FAKE MATRIX.
	HRLM	X1,(T)
	ADD	E,X1
	MOVE	T,TRNFLG

LK3:	SETOM	VPAKFL		;DONT TRY TO PRESS VARAIBLE SPACE NOW!
	SUB	E,CESVR		;WE NEED THIS MANY LOCS
LK35:	MOVE	X1,VARFRE	;IS THERE ROOM FOR (E) LOCS?
	ADDI	X1,(E)
	CAMGE	X1,JOBREL
	JRST	LK37
	MOVE	X1,JOBREL
	ADDI	X1,2000
	CORE	X1,
	JRST	[MOVEI T,PANIC1
		JRST ERRMSG]
	JRST	LK35
LK37:	ADD	E,CETMP		;CALCULATE TOP OF ARRAY SPACE.
	MOVEM	E,SVRTOP	;SAVE IT.
	MOVEM	E,VARFRE	;THIS IS ALSO FIRST FREE WORD.

LK4:	MOVE	T,FLFCL
	MOVEI	R,FCNROL
LINK0A:	CAML	T,CEFCL
	JRST	LINK0C		;NO MORE FCN CALLS
	HLLZ	A,(T)		;LOOK UP FUNCTION
	PUSHJ	P,SEARCH
	JRST	LINK0B		;UNDEFINED
	MOVE	A,(B)		;DEFINED.  GET ADDRESS.
	HRLM	A,(T)
	AOJA	T,LINK0A
LINK0B:	SETZM	RUNFLA
	PUSHJ	P,INLMES
	ASCIZ	/
? UNDEFINED FUNCTION -- FN/
	LDB	C,[POINT 7,A,6]
	ADDI	C,40
	PUSHJ	P,OUCH
	SKIPE	CHAFL2
	PUSHJ	P,ERRMS3
	PUSHJ	P,INLMES
	ASCIZ	/
/
	AOJA	T,LINK0A

LINK0C:	MOVE	B,FLFOR	;UNSAT FORS?
	CAML	B,CEFOR
	JRST	LINK0D

	MOVEI	T,[ASCIZ /
? FOR WITHOUT NEXT/]
	MOVE	L,(B)		;GET POINTER TO LINE NUMBER
	PUSHJ	P,FAILR		;PRINT ERROR MSG
	ADDI	B,5		;MORE UNSAT FORS?
	JRST	LINK0C+1
LINK0D:	SKIPG	DATAFF		;WAS DATA OMITTED?
	JRST	LINK0E		;NO
	PUSHJ	P,INLMES
	ASCIZ	/
? NO DATA/
	SKIPE	CHAFL2
	PUSHJ	P,ERRMS3
LINK0G:	SETZM	RUNFLA

LINK0E:	SKIPGE	RUNLIN		;LINE NUMBER ARG IN RUN(NH) COMMAND?
	JRST	LINK0F		;NO.
	HRLZ	A,RUNLIN	;YES.  MAKE SURE IT EXISTS AND
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
        JRST    [SKIPE  COMOLY
                GO (1,UXIT)
                MOVEI T,NOLIN
		JRST ERRMSG]

	SUB	B,FLOOR(R)
	MOVEM	B,RUNLIN
	ADD	B,FLREF		;IS NOT WITHIN A MULTI-LINE DEF.
	SKIPN	(B)
	JRST	LINK0F
	MOVEI	T,ILLIN
	JRST	ERRMSG
LINK0F:	SKIPN	RUNFLA		;GO INTO EXECUTION?
        GO (1,UXIT)

	MOVE	C,FLCOD

;CODE ROLL IS IN PLACE.  C CONTAINS ITS FLOOR

LINK0:	MOVE	T,FLFCL	;LINK FCN CALLS
	MOVE	T1,CEFCL
	MOVE	A,FLCOD
	MOVEI	B,0
	PUSHJ	P,LINKUP

LINK1A:	MOVE	T,FLARA	;LINK ARRAY REFS
	MOVE	T1,CESVR
	MOVE	A,T
	MOVEI	B,3
	PUSHJ	P,LINKUP

LINK1B:	MOVE	T,FLARA	;STORE ARRAY ADDRESSES IN ARAROL
	MOVE	G,CETMP
	JRST	LINK1D
LINK1C:	HLRZ	X1,(T)		;GET ARRAY LENGTH
	HRRM	G,(T)		;STORE ABS ADDRS
	ADD	G,X1		;COMPUTE ADDRS OF NEXT ARRAY
	ADDI	T,3		;GO TO NEXT ENTRY
LINK1D:	CAMGE	T,T1
	JRST	LINK1C
LINK1:	MOVE	T,FLCAD	;LINK CONST REFS
	MOVE	T1,CECAD
	MOVE	A,FLCON
	MOVEI	B,1
	PUSHJ	P,LINKUP

LINK2:	MOVE	T,FLPTM	;LINK TEMPORARY REFS (PERM AND TEMP)
	MOVE	T1,CETMP
	MOVE	A,T
	MOVEI	B,1
	PUSHJ	P,LINKUP

LINK3:	MOVE	T,FLLAD	;LINK GOTO DESTINATIONS
	MOVE	T1,CELAD
	MOVE	A,FLCOD
	MOVEI	B,0
	PUSHJ	P,LINKUP

LINK4:	MOVE	T,FLSCA	;LINK SCALARS
	MOVE	T1,CEVSP
	MOVE	A,T
	MOVEI	B,1
	PUSHJ	P,LINKUP


LINK6:	MOVE	T,FLGSB	;LINK GOSUB REFS
	MOVE	T1,CEGSB
	MOVE	A,T
	MOVEI	B,1
	PUSHJ	P,LINKUP
	MOVE	T,FLGSB
LINK7:	CAML	T,T1		;PUT SUBRTN ADDRSES IN GSBROL
	JRST	LINK8
	HLRZ	X1,(T)
	ADD	X1,FLLAD
	HLRZ	X1,(X1)
	ADD	X1,C
	MOVEM	X1,(T)
	AOJA	T,LINK7

LINK8:	MOVE	T,FLNXT	;LINK REVERSE REFS IN FORS
	MOVE	T1,CENXT
	MOVE	A,FLCOD
	MOVEI	B,0
	PUSHJ	P,LINKUP

LINK9:	MOVE	T,FLLIT		;LINK LITROL TO SLTROL.
LINK91:	CAML	T,CELIT
	JRST	LINK92
	HRRZ	A,(T)
	ADD	A,FLSLT
	HRRM	A,(T)
	AOJA	T,LINK91
LINK92:	MOVE	T,FLSAD		;LINK POINTERS TO LITROL
	MOVE	T1,CESAD
	MOVE	A,FLLIT
	MOVEI	B,1
	PUSHJ	P,LINKUP

LINKZ:	MOVE	X1,FLSCA	;ZERO OUT SCALARS AND STRING VARS
	MOVE	X2,CEVSP
	PUSHJ	P,BLTZER
        SKIPGE X1,RUNLIN
        JRST LINKZ1
        ADD X1,FLLAD
        HLRZ X1,(X1)
        ADD X1,FLCOD
        MOVEM X1,RUNLIN
LINKZ1:	MOVE	X1,CETMP	;ZERO OUT ARRAY ELEMENTS AND STRING VECTORS.
	MOVE	X2,ARATOP
	PUSHJ	P,BLTZER
        SKIPE COMONY
        GO (1,UXIT)
        SKIPE SAVBB
        JRST SAVEBN
        GO (3,EXECUT)
SAVEBN: OPEN SAVB
        JRST SAVE4
        JRST SAVE4+1
SAVE4:	JRST	[MOVE T,SAVE1	 ;ILLEGAL DEVICE NAME
		JRST NOGETD]
	PUSHJ	P,LOCKON	;DONT ALLOW REENTRY UNTIL
				;SAVE IS CHANGED TO BUILD TEMP FILE AND RENAME.
	HLLZS	BINNAM+1	;LEVEL D FIX.
	SETZM	BINNAM+2
        MOVSI N,(SIXBIT/SAV/)
        MOVEM N,BINNAM+1
	SKIPE	OLDFLA		;TRYING TO SAVE NEW FILE?
	JRST	SAVE3
	LOOKUP	BINNAM		;YES, DOES THE FILE EXIST?
	JRST	SAVE2		;NO, GOOD
	MOVEI	T,NOTNEW
	JRST	ERRMSG
SAVE3:	LOOKUP	BINNAM		;IS THIS REALLY AN OLDFILE?
	JRST	NOGETF		;NO. GRONK.
SAVE2:	CLOSE			;OTHERWISE REPLACE WILL APPEND.
	HLLZS	BINNAM+1	;LEVEL D FIX.
	SETZM	BINNAM+2
        MOVEI X1, 055
        DPB X1,[POINT 8,BINNAM+2,8]
	ENTER	BINNAM
	JRST	NOSAVE
	SETOM	RENSW
        EXTERN TOPJOB,JOBFF

        MOVE [-3,,117]
        MOVEM TOPWRD
EXTERN JRS
        HRRZ X1,CETMP   ;HIGHEST0NON ZERO
        MOVE X2,JRS     ;JRSTPSTAR
        MOVEM X2,(X1)
        AOJ X1,
        HRLM X1,TOPWRD+1        ;JOBFF
        MOVEM X1,TOPWRD+2
        MOVEI X1,STAR
        HRRM X1,TOPWRD+1
        MOVE [HALT]
        MOVEM TOPWRD+3
        MOVE [-1,,132]
        MOVEM TOPWRD+4
        
        HRL X1,CETMP
        HRR X1,JOBREL
        MOVEM X1,TOPWRD+5
        MOVEI X1,140
        SUB X1,CETMP
        HRL X1,X1
        HRRI X1,137
        MOVEM X1,TOPWRD+6
        MOVEI T1,140
        HRRI X1,TOPWRD+7
  MOVE [IOWD 200,TOPWRD]
        HRL X1,T1
        BLT X1,TOPWRD+177
        SETZ 1,
        OUTPUT
        ADDI T1,171
        HRRI X1,TOPWRD
SAVIT:  MOVE [IOWD 200,TOPWRD]
        HRL X1,T1
        BLT X1,TOPWRD+177
        SETZ 1,
        OUTPUT
        ADDI T1,200
        CAMLE T1,CETMP
        JRST CLOUT
        SETZM TOPWRD
        MOVE X1,[TOPWRD,,TOPWRD+1]
        BLT X1,TOPWRD+177
        HRRI X1,TOPWRD
        JRST SAVIT
CLOUT:        CLOSE
        GO (1,BASIC)


NOTNEW: ASCIZ/
DUPLICATE FILE NAME- USE REPLACE
/
;SUBROUTINE TO LINK ROLL ENTRIES

;CALL WITH A=ORG OF VALUE ROLL, B=INCREMENT (0 IF EXPLICIT REL LOC)
;T=FLOOR OF SRC ROLL, T1=CEIL OF SRC ROLL

LINKUP:	MOVE	X2,A
	MOVSI	X1,C

LNKP1:	CAML	T,T1		;FINISHED ROLL?
	POPJ	P,
	HRRZ	A,(T)		;FIRST LOC IN CHAIN
	JUMPN	B,.+3		;EXPLICIT ADDRS?
	HLRZ	X2,(T)		;YES.  COMPUTE IT
	ADD	X2,C
	JUMPE	A,LNKP3		;SPECIAL CASE--CHAIN VOID

LNKP2:	HRR	X1,A		;ONE LINK IN CHAIN
	HRRZ	A,@X1
	HRRM	X2,@X1
	JUMPN	A,LNKP2

LNKP3:	JUMPN	B,.+2		;EXPLICIT ADDRS?
	AOJA	T,LNKP1		;YES, JUST BUMP ROLL PNTR
	ADD	T,B		;NO, ADD EXPLICIT INCREMENT
	ADD	X2,B		;  (ALSO TO DEST ROLL)
	JRST	LNKP1

BLTZER:	HRL	X1,X1		;ZERO OUT CORE
	SETZM	(X1)
	AOJ	X1,
	BLT	X1,-1(X2)
	POPJ	P,

SUBTTL	STATEMENT GENERATORS


;CHAIN STATEMENT.
;
;CHAIN HAS TWO FORMS:
;
;	CHAIN DEV:FILENM.EXT, LINE NO.
;   OR
;	CHAIN <STRING EXPRESSION>, LINE NO.
;
;IN EACH CASE, ",LINE NO." IS OPTIONAL.
;
;XCHAIN IS REACHED FROM XCHAN.

XCHAIN:	PUSHJ	P,QSA
	ASCIZ	/IN/
	JRST	GRONK
	SKIPE	FUNAME
	JRST	.+4
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSHJ	P,BUILDI
	SETZM	VRFSET
        TLNN C,F.DIG+F.LETT
        JRST XCHAI1
        MOVEI A,5
        PUSH P,T
        PUSH P,C
XCHA0:  PUSHJ P,NXCH
        TLNE C,F.DIG+F.LETT
        SOJG    A ,XCHA0
        JUMPN A,XCHA01
        PUSHJ P,NXCH
XCHA01: SETZ A,
        TLNN C,F.COMA+F.TERM+F.PER
        CAIN C,":"
        SETO A,
        POP P,C
        POP P,T
        JUMPE A,XCHAI1
XCHAI2:	PUSHJ	P,FILNAM	;1.
	JUMP	CATFLG
	MOVSI	D,(HRLI N,)	;THE CODE BEING GENERATED
	HLR	D,CATFLG	;IS DESCRIBED IN MEMO
	PUSHJ	P,BUILDI	;#100-365-033-00.
	MOVSI	D,(HRRI N,)
	HRR	D,CATFLG
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,NEWOL1]
	PUSHJ	P,BUILDI
	MOVSI	D,(HRLI N,)
	HLR	D,FILDIR
	PUSHJ	P,BUILDI
	MOVSI	D,(HRRI N,)
	HRR	D,FILDIR
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,FILDIR]
	PUSHJ	P,BUILDI
	MOVSI	D,(HRLZI N,)
	HLR	D,FILDIR+1
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N, FILDIR+1]
	PUSHJ	P,BUILDI
	JRST	XCHAI5		;GO LOOK FOR LINE NO. ARG.
XCHAI1:				;2.
IFE	FTSTR, <
	TLNN	C,F.QUOT
	JRST	COMM1
>
	PUSHJ	P,FORMLS
	PUSHJ	P,EIRGNP
	MOVE	D,[AOS T,MASAPP]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,(T)]
	PUSHJ	P,BUILDI
XCHAI7:	MOVE	D,[PUSHJ P,%CHAHAN]
	PUSHJ	P,BUILDI
XCHAI5:	TLNE	C,F.TERM	;LINE NO. ARG?
	JRST	XCHAI6		;NO.
	TLNN	C,F.COMA
	JRST	COMM1
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLN	;YES.
	PUSHJ	P,EIRGEN
	MOVE	D,[JUMPL N,%CHAERR]
	PUSHJ	P,BUILDI
	MOVE	D,[PUSHJ P,%IFIX]
	PUSHJ	P,BUILDI
	MOVE	D,[CAILE N,303237]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %CHAERR]
	PUSHJ	P,BUILDI
	SKIPA	D,[MOVEM N,RUNLIN]
XCHAI6:	MOVE	D, [SETOM RUNLIN]
	PUSHJ	P,BUILDI
	MOVE	D, [SETOM CHAFLG]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %CHAXIT]
	PUSHJ	P,BUILDI
	JRST	NXTSTA


IFN FTSTR, <

;CHANGE STATEMENT

; CHANGE <VECTOR> TO <STRING>
;		OR
;CHANGE <STRING> TO <VECTOR>

;COMPILES A FETCH AND PUT WHICH INTERFACE WITH THE "PUTSTR" ROUTINE
>

XCHAN:	PUSHJ	P,QSA		;CHANGE OR CHAIN?
	ASCIZ	/NGE/
	JRST	XCHAIN		;NOT CHANGE.
	TLNN	C,F.LETT
	JRST	XCHAN1
	PUSH	P,C
	PUSH	P,T
	PUSHJ	P,NXCH
	TLNE	C,F.DIG
	PUSHJ	P,NXCH
	PUSHJ	P,QSA
	ASCIZ	/TO/
	JRST	XCHAN3
	POP	P,T
	POP	P,C
	HRLI	F,0
	PUSHJ	P,VECTOR
	JUMPN	A,GRONK
	MOVSI	D,(VECFET)
	PUSHJ	P,BUILDA	;GENERATE VECTOR FETCH
	PUSHJ	P,QSF		;"TO" MUST FOLLOW
	ASCIZ /TO/
	HRLI	F,1
	TLNN	C,F.LETT
	JRST	GRONK
	PUSHJ	P,ATOM
	CAIE	A,5
	CAIN	A,6
	JRST	.+2
	JRST	ILFORM
	MOVSI	D,(STOCHA)
XCHAN2:	PUSHJ	P,BUILDA	;BUILD APPROPRIATE STORE UUO
	JRST	NXTSTA

XCHAN3:	POP	P,T
	POP	P,C
XCHAN1:	PUSHJ	P,FORMLS	;PROCESS STRING NAME
	PUSHJ	P,EIRGNP
	PUSHJ	P,QSF
	ASCIZ /TO/
	HRLI	F,0
	PUSHJ	P,VECTOR	;REGISTER VECTOR NAME
	JUMPN	A,GRONK
	MOVSI	D,(VECPUT)
	JRST	XCHAN2		;GO BUILD STORE UUO
;DATA STATEMENT

;<DATA STA>::= DATA <DEC NBR!STRING> [,<DEC NBR!STRING>...]

;NOTE:	A DATA STRING ::= "  <ANY CHARS EXCEPT CR,LF>  "
;	OR	::= <A LETTER><ANY CHARS EXCEPT COMMA OR APOST,CR,LF>

;NO CODE IS GENERATED FOR A DATA STATEMENT
;RATHER, THE DATA STATEMENT IN THE SOURCE
;TEXT ARE REREAD AT RUN TIME.
XDATA:	ASCIZ	/A/
	SKIPL	DATAFF		;ALREADY SEEN DATA?
	MOVEM	L,DATAFF	;NO.  REMEMBER WHERE FIRST ONE IS
	SETZM	INPFLA
	PUSHJ	P,DATCHK	;CHECK FOR LEGAL DATA
	FAIL	<? DATA NOT IN CORRECT FORM>
	JRST	NXTSTA


;SUBROUTINE TO CHECK DATA LINE
;ALSO CALLED AT RUN TIME TO CHECK INPUT LINE
;(NOTE.. <RETURN> NOT CHECKED AFTER INPUT LINE)

DATCHK:	TLNN	C,F.LETT+F.QUOT	;LETTER OR QUOT SIGN FIRST
	JRST	DATCH2		;NO, EVALUATE NUMBER
	PUSH	P,[DATCH3]	;YES, ASSUME STRING AND SKIP OVER
	JRST	SKIPDA

DATCH2:	PUSH	P,X1
	PUSHJ	P,EVANUM
	JRST	[POP P,X1
		 POPJ	P,]
	POP	P,X1
DATCH4:	CAIE	C,"&"		;IF "&", ASSUME MATINPUT TERM
	TLNE	C,F.CR		;MORE?
	JRST	CPOPJ1		;NO. RETURN
	SKIPE	INPFLA		;FOR READ AND MAT READ
	JRST	.+3		;BUT NOT FOR INPUT OR MAT
	TLNE	C,F.TERM	;INPUOP ALSO ON AN
	JRST	CPOPJ1		;APOSTROPHE.
	TLNN	C,F.COMA	;DID FIELD END CORRECTLY?
	POPJ	P,		;NO. ERROR
	PUSHJ	P,NXCH		;YES. SKIP COMMA
	TLNE	C,F.TERM
	JRST	CPOPJ1
	JRST	DATCHK		;AND GO TO NEXT ITEM.

DATCH3:	POPJ	P,
	JRST	DATCH4
;DEF STATEMENT

;<DEF STA> ::= DEF FN<LETTER>(<ARGUMENT>) = <EXPRESSION>

;GENERATED CODE IS:
;	JRST	<A>		;JUMP AROUND DEF
;	XWD	0,0		;CONTROL WORD
;	MOVEM	N,(B)		;SAVE ARGUMENT IN TEMPORARY
;	...
;	(EVALUATE EXPRESSION)
;	JRST	RETURN		;GO TO RETURN SUBROUTINE
;<A>:	...			;INLINE CODING CONTINUES...

;SEE GOSUB STATEMENT FOR USE OF CONTROL WORD.

;DURING EXPRESSION EVALUATION, LOCATION
;FUNARG CONTAINS ASCII REPRESENTATION OF ARGUMENT NAME.
;ROUTINES CALLED BY FORMLN CHECK FOR USE OF ARGUMENT AND RETURN POINTER
;TO FIRST WORD ON TEMPORARY ROLL.

;PRIOR TO GEN OF FIRST EXPRESSION EVALUATION, THE "REAL" TEMPORARY
;ROLL IS SAVED ON "STMROL" AND AN EMPTY "TEMROL" IS CREATED.
;AFTERWARDS, THE NEW "TEMROL" ENTRIES ARE ADDED TO THE PERMANENT
;TEMPORARY ROLL "PTMROL" AND "TEMROL" IS RESTORED.
;THUS EACH DEFINED FUNCTION HAS ITS OWN SET OF TEMPORARIES
;AND CANNOT CONFLICT WITH TEMPORARIES USED BY THE EXPRESSION
;BEING EVALUATED AT THE POINT OF THE CALL.

;NOTE. SPECIAL CASE:  CHECK FOR FUNCTION DEF AS LAST LINE OF PROGRAM 
;SUPPRESSES GEN OF "JRST" INSTR.  COMPILATION WILL FAIL
;("NO END STATEMENT"); HOWEVER THE WORD AFTER LADROL WOULD BE
;CLOBBERED IF "JRST" WERE GENNED.

XDEF:	ASCIZ	/FN/		;HANDLE THE FN PART AUTOMATICALLY
	SKIPE	FUNAME		;ARE WE IN MIDST OF MULTI-LINE DEF?
	FAIL <? NESTED DEF>
	MOVEI	D,1
	MOVEM	D,VRFSET
	MOVSI	D,(JFCL)	;MAKE SURE NOT FIRST WRD OF CODE
	MOVE	X1,CECOD
	CAMG	X1,FLCOD
	PUSHJ	P,BUILDI
	TLNN	C,F.LETT	;MAKE SURE LETTER FOLLOWS.
	JRST	GRONK
	PUSHJ	P,SCNLT1	;SCAN FCN NAME.
	PUSH	P,A		;SAVE FCN NAME WITH COUNT OF ZERO ARGUMENTS
	MOVEM	A,FUNAME	; FN'NAME IN BODY OF FUNCTION
;ADD FUNCTION NAME TO FCNROL

XDEF1:	MOVEI	R,FCNROL	;LOOK FOR FCN NAME IN FCNROL
	PUSHJ	P,SEARCH
	JRST	.+3
	SETZM	FUNAME
	FAIL	<? FUNCTION DEFINED TWICE>
	MOVEI	E,1		;ADD TO FCNROL
	PUSHJ	P,OPENUP
	ADD	A,CECOD	;CONSTRUCT PNTR TO CONTROL WORD
	SUB	A,FLCOD	;STORE IN FCNROL ENTRY.
	ADDI	A,1		
	MOVEM	A,(B)		

	MOVE	B,L		;GET JRST DESTINATION
	AOBJP	B,.+1		;DONT GEN JRST IF LAST LINE OF SOURCE.
	MOVSI	D,(JRST)
	PUSHJ	P,BUILDI	;GEN JRST INSTR.
	MOVEM	B,FUNSTA	;REMEMBER WHERE THIS JRST IS
	MOVEI	D,0		;BUILD ZERO CONTROL WORD
	PUSHJ	P,BUILDI

;SCAN FOR ARGUMENT NAME.

XDEF2:	CAIE	C,"("	;ANY ARGUMENTS?
	JRST	XDEF4		;NO

XDEF2A:	PUSHJ	P,NXCHK		;SKIP "("
	PUSHJ	P,SCNLT1	;ASSEMBLE ARGUMENT NAME
	TLNN	C,F.DIG
	JRST	.+3
	DPB	C,[POINT 7,A,13]
	PUSHJ	P,NXCHK

	MOVEI	R,ARGROL	;NOW ADD THIS NAME TO THE ARGUMENT LIST
	MOVE	B,FLARG		;NOW CHECK ARGROL, FOR TWO IDENTICAL ARGS
XDEF2C:	CAML	B,CEARG
	JRST	XDEF2D
	CAME	A,(B)
	AOJA	B,XDEF2C
	SETZM	FUNAME
	JRST	GRONK

XDEF2D:	MOVEI	E,1		;ADD NEW ARG TO ROLL
	PUSHJ	P,OPENUP
	MOVEM	A,(B)
	AOS	(P)		;COUNT THE ARGUMENT
	TLNE	C,F.COMA	;ANY MORE ARGS?
	JRST	XDEF2A		;YES

XDEF3:	TLNN	C,F.RPRN	;FOLLOWING PARENTHESIS?
	JRST	[SETZM	FUNAME
		JRST	GRONK]	;NO.
	PUSHJ	P,NXCHK		;YES. SKIP IT.
XDEF4:	PUSHJ	P,ARGCHK	;CHECK FOR RIGHT NUMBER OF ARGUMENTS
;GEN CODE TO EVALUATE EXPRESSION.

	MOVE	X1,FLTMP	;SAVE TEMP ROLL AS STMROL
	MOVEM	X1,FLSTM
	MOVEM	X1,CETMP	;AND EMPTY TMPROL
	MOVE	X1,TMPLOW	;SAVE TEMP POINTER
	MOVEM	X1,FUNLOW
	SETOM	TMPLOW
	SETOM	TMPPNT
	TLNN	C,F.EQAL	;MULTI LINE FN?
	JRST	XDEFM		;YES
	PUSHJ	P,NXCHK		;NO. SKIP EQUAL SIGN
	SETZM	FUNAME		;SIGNAL THAT THIS IS NOT A MULTI-LINE FN

	PUSHJ	P,FORMLN	;GEN THE EXPRESSION
	PUSHJ	P,EIRGNP	;GET IT IN REG

;NOW BUILD AN INSTRUCTION THAT WILL TELL RETURN HOW MANY ARGS TO POP
;OFF THE PUSH LIST
	
	POP	P,B		;ARGCHK PUT THE ADDRESS OF A CONSTANT IN HERE
XDEFE:	MOVSI	D,(MOVE T,)
	PUSHJ	P,BUILDA
	MOVE	X2,CETMP	;RESTORE TMPROL, SAVE TEMPORARIES FOR FCN
	MOVE	X1,CESTM
	MOVEM	X2,CEPTM
	MOVEM	X2,FLTMP
	MOVEM	X1,CETMP
	MOVEM	X1,FLSTM

	HRRE	X1,FUNLOW	;RESTORE TMPLOW
	MOVEM	X1,TMPLOW
	HRRZ	X1,FUNSTA	;-1(X1) IS LOC OF JRST AROUND FUNCTION
	ADD	X1,FLCOD
	HRRZ	X2,CECOD	;JRST TO THE NEXT INST TO BE CODED
	ADDI	X2,1
	HRRM	X2,(X1)

	MOVE	D,[JRST %FRETRN]
	JRST	XRET1		;USE RETURN CODE TO BUILD INST

XDEFM:	POP	P,X1		;MULTI-LINE DEF. SAVE THE ARGCOUNT PARAMETER FOR FNEND
	HRLM	X1,FUNSTA
	MOVE	X1,CEFOR		;SAVE NUMBER OF ACTIVE FORS
	SUB	X1,FLFOR		;FOR A CHECK OF FORS HALF IN DEF
	HRLM	X1,FUNLOW
	JRST	NXTSTA
;DIM STATEMENT
;<DIM STA> ::= DIM <LETTER>[$](<NUMBER>[,<NUMBER>])[,<LETTER>[$](<NUMBER>[,<NUMBER>])...]

;FOR EACH ARRAY, HAVE ONE-WORD ENTRY IN VARROL
;WHICH POINTS TO THREE-WORD ENTRY IN ARAROL
;WHOSE FORMAT IS:
;	(<LENGTH OF ARRAY>)<PNTR>
;	(<LEFT DIM>+1)<RIGHT DIM>+1
;THE THIRD WORD IS < 0 IF THE MATRIX IS SET EQUAL TO ITS OWN TRN,
;>0 IF THIS IS THE FAKE MATRIX USED FOR TMP STORAGE DURING MATA=
;TRN(A), OTHERWISE IT IS 0.

;DURING COMPILATION, <PNTR> IS CHAIN OF REFERENCES.
;DURING EXECUTION, <PNTR> IS ADDRS OF FIRST WORD.

XDIM:	SETZI	F,		;ALLOW STRING VECTORS.
	PUSHJ	P,ARRAY		;REGISTER ARRAY NAME
	CAIE	A,5		;STRING VECTOR? ELSE..
	JUMPN	A,GRONK		;NON-0 RESULT FLAG-SYNTAX ERROR.
	CAIE	C,"("	;CHECK OPENING PAREN
	JRST	GRONK
	ADD	B,FLOOR(F)	;COMPUTE LOC OF ROLL ENTRY
	SKIPLE	X1,1(B)		;DIMENSION FLAG SHOULD BE 0 OR -1 OR -2.
	FAIL	<? VARIABLE DIMENSIONED TWICE>
	MOVEM	X1,TEMLOC
	PUSHJ	P,NXCHK		;SKIP PARENTHESIS
	PUSHJ	P,GETNU	;FIRST DIMENSION
	JRST	GRONK		;NOT A NUMBER
	JUMPN	N,.+2
	SETZM	TEMLOC
	HRRZ	D,N		;SAVE FIRST DIM
	AOBJN	D,.+1		;D::= XWD <FIRST DIM+1>,1
	MOVSM	D,1(B)		;STORE IN ARAROL (IN CASE 1 DIM)
	MOVEI	N,1		;IN CASE ONE DIMENSION
	TLNN	C,F.COMA	;TWO DIMS?
	JRST	XDIM1		;NO
	PUSHJ	P,NXCHK		;YES. SKIP COMMA.
	JUMPN	A,GRONK		;STRING VECTOR HAS TWO DIMS?
	PUSHJ	P,GETNU	;GET SECOND DIM
	JRST	GRONK		;NOT A NUMBER
	JUMPN	N,.+2
	SETZM	TEMLOC
	ADDI	N,1
	HRL	D,N		;NOW D HAS XWD <COLS+1>,<ROWS+1>
	MOVSM	D,1(B)		;STORE IN ROLL SWAPPED
	MOVNI	X1,2
	CAMN	X1,TEMLOC
	FAIL	<? VECTOR CANNOT BE ARRAY>
XDIM1:	IMULI	N,(D)		;COMPUTE LENGTH OF ARRAY
	HRLM	N,0(B)		;STORE IN ROLL

XDIMFN:	TLNN	C,F.RPRN	;CHECK CLOSING PAREN
	JRST	GRONK
	PUSHJ	P,NXCHK		;LOOK FOR COMMA
	TLNN	C,F.COMA
	JRST	NXTSTA		;NO. DONE WITH THIS STATEMENT.
	PUSHJ	P,NXCHK		;SKIP THE COMMA.
	JRST	XDIM		;KEEP SCANNING.
;END STATEMENT

;<END STA> ::= END

XEND:	MOVE	X1,FLLIN	;CHECK THAT IT IS LAST STA
	ADDI	X1,1(L)
	CAME	X1,CELIN
	FAIL	<? END IS NOT LAST>

	SKIPN	FUNAME
	JRST	XEND1
	PUSHJ	P,INLMES
	ASCIZ	/
? NO FNEND FOR DEF FN/
	MOVEI	T,FUNAME
	SETZ	D,
	PUSHJ	P,PRINT
	SKIPE	CHAFL2		;CHAINING?
	JRST	ERRMS2		;YES.
	PUSHJ	P,INLMES
	ASCIZ/
/
        GO (1,UXIT)

XEND1:	MOVE	D,[JRST %UXIT]	;COMPILE TERMINAL EXIT
	PUSHJ	P,BUILDI
	JRST	LINKAG		;GO FINISH UP AND EXECUTE
;FOR STATEMENT

;CALCULATE INITIAL, STEP, AND FINAL VALUES
;
;SET INDUCTION VARIABLE TO INITIAL VALUE
;AND JUMP TO END IF IND VAR > FINAL
;INCREMENTING IS HANDLED AT CORRESPONDING NEXT.

;FIVE WORD ENTRY PLACED ON FORROL FOR USE
;BY CORRESPONDING NEXT STATEMENT:

;	CURRENT VALUE OF L (FOR "FOR WITHOUT NEXT" MESSAGE)
;<REL.  ADRS IN CODROL OF JUST TO END OF-NEXT>
;	<POINTER TO INDUCTION VARIABLE>
;	<POINTER TO INCREMENT>
;	<CURRENT VALUE OF TMPLOW>


XFOR:	TLNN	C,F.LETT	;MAKE SURE VARIABLE IS FIRST.
	JRST	GRONK
	MOVE	A,L		;SAVE L FOR POSSIBLE ERROR MSG
	MOVEI	R,FORROL
	PUSHJ	P,RPUSH
	HRLI	F,777777
	PUSHJ	P,REGLTR	;REGISTER ON SCAROL
	CAIN	A,1		;BETTER BE SCALAR
	TLNN	C,F.EQAL	;BETTER HAVE EQUAL
	JRST	GRONK
	PUSHJ	P,NXCHK		;SKIP EQUAL SIGN.
	PUSH	P,B		;SAVE THE VARIABLE POINTER
	PUSHJ	P,FORMLN	;GEN THE INITIAL VALUE
	PUSHJ	P,EIRGNP
	MOVSI	D,(MOVEM N,)	;GEN STORE INITIAL IN VARIABLE
	MOVE	B,(P)
	PUSHJ	P,BUILDA
	PUSHJ	P,QSF		;LOOK FOR "TO"
	ASCIZ /TO/
	PUSHJ	P,FORMLN	;GEN THE UPPER BOUND.
	JUMPL	B,XFOR4		;EXCEPT FOR THE SPECIAL
	HLRZ	X1,B		;CASE OF A POSITIVE
	ANDI	X1,ROLMSK	;CONSTANT, FORCE THE
	CAIN	X1,CADROL	;UPPERBOUND TO BE
	JRST	.+3		;STORED IN A
XFOR4:	PUSHJ	P,EIRGEN	;PERMANENT
	PUSHJ	P,SIPGEN	;TEMPORARY.
	PUSH	P,B		;REMEMBER WHERE IT IS
	TLNN	C,F.TERM	;IS THERE A STEP CLAUSE?
	JRST	XFOR2		;LOOK FOR EXPLICIT "STEP"
	MOVE	T,[POINT 7,[BYTE (35)"STEP1"(7)15]]
	PUSHJ	P,NXCHK		;GET "S" IN CASE OF CR		;IMPLICIT "STEP1"
XFOR2:	PUSHJ	P,QSA		;LOOK FOR "BY"
	ASCIZ	/BY/
	JRST	.+2
	JRST	.+3
	PUSHJ	P,QSF		;LOOK FOR "STEP"
	ASCIZ	/STEP/

	PUSHJ	P,FORMLN	;XLATE AND GEN INCREMENT
	SETZM	CATFLG		;CATFLG=0 SAYS STEP IS NOT A CONSTANT.
	HLRZ	X1,B
	ANDI	X1,ROLMSK
	CAIE	X1,CADROL
	JRST	XFOR6
	SETOM	CATFLG		;EXCEPT FOR THE SPECIAL
	JRST	.+3		;CASE OF A CONSTANT,
XFOR6:	PUSHJ	P,EIRGEN	;SAVE THE STEP VALUE
	PUSHJ	P,SIPGEN	;IN A PERMANENT TEMP.

	EXCH	B,0(P)		;EXCH WITH TOP OF PDL
	PUSH	P,B		;SAVE LOC OF UPPER BOUND
	MOVE	B,-2(P)		;GET INDUCTION VAR IN REG
	PUSHJ	P,EIRGEN
	SKIPE	CATFLG
	JRST	XFOR3
	MOVE	B,-1(P)		;GET THE INCREMENT POINTER
	MOVSI	D,(DONFOR)	;BUILD DONFOR EXCEPT FOR A
	PUSHJ	P,BUILDA	;CONSTANT STEP.

XFOR3:	MOVE	X1,-1(P)
	POP	P,B		;BUILD COMPARE INSTR (IT
	MOVSI	D,(CAMLE N,)	;DOESN'T MATTER WHAT IT
	SKIPGE	X1		;IS IF DONFOR IS THERE).
	MOVSI	D,(CAMGE)
	PUSHJ	P,BUILDA
	MOVSI	D,(JRST)	;DUMMY JRST INSTRUCTION
	PUSHJ	P,BUILDI

	MOVE	A,CECOD
	SUB	A,FLCOD		;SAVE LOC FOR NEXT'S JRST
	SKIPE	RUNFLA		;WAS JRST ACTUALLY 
	MOVEI	A,-2(A)		;NO. DONT ALLOW SPACE FOR IT.
	MOVEI	R,FORROL
	PUSHJ	P,RPUSH
	POP	P,A
	EXCH	A,(P)
	PUSHJ	P,RPUSH		;SAVE INDUCTION VARIABLE
	EXCH	A,(P)		;GET INCREMENT
	PUSHJ	P,RPUSH
	POP	P,B		;GET POINTER TO INDUCTION VARIABLE.
	MOVSI	D,(MOVEM N,)	;BUILD THE STORE THAT WILL BE USED
	PUSHJ	P,BUILDA	;BY NEXT.

	MOVEI	R,FORROL
	MOVE	A,TMPLOW	;SAVE THIS LEVEL OF PROTECTION TO BE RESTORED BY NEXT
	PUSHJ	P,RPUSH
	MOVE	A,TMPPNT	;PROTECT TEMPS USED BY THIS "FOR"
	MOVEM	A,TMPLOW	;IN THE RANGE OF THE FOR.
	JRST	NXTSTA
;FNEND STATEMENT

;<FNEND STA> ::= FNEND

XFNEND:	ASCIZ /ND/
	SKIPN	A,FUNAME	;MUST FOLLOW A MULTI-LINE FN DEF
	FAIL <? FNEND BEFORE DEF>
	SETZM	FUNAME		;SIGNAL END OF FN
	TLO	A,(177B13)	;ASSEMBLE THE SCALAR NAME OF THE RESULT
	HRLI	F,-1
	PUSHJ	P,SCAREG		;REGISTER IT AS A SCALAR
	PUSHJ	P,EIRGNP	;GET THE RESULT IN REG
	HLRZ	B,FUNSTA	;RECOVER THE ADDRESS OF THE ARGUMENT COUNT
	HRLI	B,CADROL
	HLRZ	X1,FUNLOW	;THIS IS # OF WDS IN FORROL AT START OF DEF
	ADD	X1,FLFOR
	CAME	X1,CEFOR	;ARE ALL NEXTS INSIDE OF DEF COMPLETE?
	FAIL <? FNEND BEFORE NEXT>
	JRST	XDEFE		;FINISH UP END OF FN

;GOSUB STATEMENT XLATE

XGOSUB:	ASCIZ	/UB/
	SKIPE	FUNAME
	FAIL	<? GOSUB WITHIN DEF>
	PUSHJ	P,GETNUM	;READ STATEMENT NUMBER
	JRST	GRONK
	HRLZ	A,N
	MOVEI	R,LINROL	;LOOK UP LINE NO
	PUSHJ	P,SEARCH
	FAIL	<? UNDEFINED LINE NUMBER >,1
	SUB	B,FLLIN	;SUCCESS.  SAVE REL LOC IN LINROL
	HRLZ	A,B
	MOVEI	R,GSBROL
	PUSHJ	P,SEARCH
	JRST	.+2
	JRST	XGOS1
	MOVEI	E,1
	PUSHJ	P,OPENUP
	MOVEM	A,(B)
XGOS1:	SUB	B,FLGSB
	HRLI	B,GSBROL
	MOVSI	D,(GOSUB)
	PUSHJ	P,BUILDA
	JRST	NXTSTA



;GOTO STATEMENT

XGOTO:	ASCIZ	/O/
XGOFIN:	PUSH	P,[Z NXTSTA]	;BUILD GOTO AND END STA
XGOFR:	PUSHJ	P,GETNUM	;BUILD GOTO AND RETURN
	FAIL	<? ILLEGAL LINE REFERENCE >
	HRLZ	A,N		;LOOK FOR DESTINATION
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	FAIL	<? UNDEFINED LINE NUMBER >,1

	SUB	B,FLLIN	;NOW CHECK FOR JUMP INTO/OUTOF FUNCTION
	MOVE	X1,FLREF
	ADD	X1,B
	MOVE	X1,(X1)
	CAME	X1,FUNAME	;BOTH MUST BE ZERO OR SAME FUNCTION.
	FAIL	<? ILLEGAL LINE REFERENCE >,1
	MOVE	D,CECOD
	CAME	D,FLCOD
	JRST	XGO1
	PUSH	P,B		;SPECIAL FIX FOR LOADER,
	MOVSI	D,(JFCL)	;IN CASE GO IS FIRST INSTRUCTION.
	PUSHJ	P,BUILDI
	POP	P,B

XGO1:	HRLI	B,LADROL
	MOVSI	D,(JRST)
	PUSHJ	P,BUILDA	;BUILD INSTR
	POPJ	P,
;IF STATEMENT

;<IF STA> ::= IF <EXPRESSION> <RELATION> <EXPRESION> THEN <NUMBER>
;	OR
;	::= IF <STRING EXPRESSION><RELATION><STRING EXPESSION> THEN <NUMBER>

; WHERE <STRING EXPRESSION>::= <LETTER>$[(EXPRESSION)]
; OR	::= " <ANY CHARS EXCEPT CR,LF> "

;RELATION IS LOOKED UP IN TABLE (RELROL)
;WHICH RETURNS INSTRUCTION TO BE EXECUTED
;IF ONE OF THE EXPRESSIONS BEING COMPARED IS
;IN THE REG, THAT ONE WILL BE COMPARED AGAINST
;THE OTHER IN MEMORY.  IF NECESSARY, THE
;INSTRUCTION IS CHANGED TO ITS CONTRAPOSITIVE
;BY FUDGING BUTS IN THE OP CODE

;IF STATEMENT

XIF:	PUSHJ	P,QSA
	ASCIZ/END/
	JRST	IFSX7		;HERE FOR NORMAL IF STATEMENTS.
	CAIE	C,":"		;HERE FOR IF END STATEMENT.
	JRST	XIF1		;SEQ. ACCESS IF END.
        PUSHJ   P,GETCNA        ;R.A. IF END
	MOVNI	A,4
XIF2:	MOVE	D,IFNCOD+4(A)
	PUSHJ	P,BUILDI
	AOJL	A,XIF2
	JRST	IFSX5

IFNCOD:	SKIPL	ACTBL-1(LP)	;CODE GENERATED.
	JRST	FNMXER
	MOVE	N,LASREC-1(LP)
	CAMGE	N,POINT-1(LP)

XIF1:	CAIE	C,"#"        ;MUST BE #
	JRST	GRONK
        PUSHJ   P,GETCNA        ;GET CHANNEL NUMBER
        MOVE    D,[PUSHJ P,%EOF2]  ;RUNTIME IF END ROUTINE
        PUSHJ   P,BUILDI
	JRST	IFSX5
IFSX7:	PUSHJ	P,FORMLB	;LEFT SIDE, MAY BE A STRING.
	HLLZM	F,IFFLAG	;SAVE TYPE.
	PUSHJ	P,GPOSGE	;MAKE SURE IT IS POSITIVE
	PUSHJ	P,PUSHPR	;SAVE IT
	PUSHJ	P,SCNLT1	;FIRST CHAR OF RELATION IN A.
	MOVEI	X1,">"
	CAIE	X1,(C)		;NEXT CHAR ">"?
	TLNE	C,F.EQAL	;OR "="?
        JRST    IFSX8           ;YES
        MOVEI   X1,"<"          ;
        MOVEI   X2,"#"          ;
        CAIE    X1,(C)          ;NEXT CHAR "<" ?
        CAIN    X2,(C)          ;NEXT CHAR "#" ?
IFSX8:	PUSHJ	P,SCN2		;PUT TWO CHAR RELATION IN A(SIXBIT)
	JFCL
	MOVEI	R,RELROL	;RELATION TABLE
	PUSHJ	P,SEARCH
	FAIL	<? ILLEGAL RELATION>
	HRLZ	D,(B)		;SAVE RELATION INSTR
	PUSH	P,D
	PUSHJ	P,FORMLB	;RIGHT SIDE, MAY ALSO BE A STRING
	XOR	F,IFFLAG
	JUMPGE	F,IFSX2
	FAIL <? MIXED STRINGS AND NUMBERS>
IFSX2:	PUSHJ	P,GPOSGE
        HLRZ    F,(P)           ;RELATION INSTR.
        CAIG    F,3             ;>3?
        JRST    IFSX9           ;NO, MUST BE >>,<< OR =#
	TLNN	B,ROLMSK	;IS RIGHT SIDE IN REG?
	JRST	IFSX4		;YES, LEAVE IT
	PUSHJ	P,EXCHG		;NO. SWAP WITH LEFT SIDE.
	MOVE	D,0(P)		;FUDGE INSTRUCTION FOR CONTRAPOSITIVE RELATION.
	TLNE	D,1000		;(EQUAL, NOT EQUAL DON'T CHANGE.)
	TLC	D,6000		;(OTHERS DO).
	MOVEM	D,0(P)

IFSX4:
IFN FTSTR,<
	SKIPL	IFFLAG		;NUMERIC COMPARE?
	JRST	IFSX6		;NO, STRING.
>
	PUSHJ	P,EIRGNP	;MOVE TO REG
	PUSHJ	P,POPPR		;GET OTHER SIDE BACK
	POP	P,D		;GET STASHED OP CODE
	PUSHJ	P,BUILDA	;BUILD COMPARE INSTRUCTION
IFSX5:	TLNE	C,F.COMA	;SKIP OPTIONAL COMMA.
	PUSHJ	P,NXCH
	PUSHJ	P,THENGO	;LOOK FOR "THEN" OR "GOTO"
	JRST	XGOFIN		;USE GOTO CODE TO GEN JRST INSTR

IFN FTSTR,<
IFSX6:	PUSHJ	P,EIRGNP	;SETUP ONE STRING
	PUSHJ	P,POPPR		;GET OTHER ONE BACK
	MOVSI	D,(STRIF)	;STRING COMPARE UUO
	PUSHJ	P,BUILDA	;COMPARE UUO WITH OTHER STRING ADDRESS
	POP	P,D
	PUSHJ	P,BUILDI	;BUILD THE RELATION
	JRST	IFSX5		;FINISH UP (THE OTHER STR POINTER WILL BE IN N)
>;ASSEMBLE ABOVE IF INCLUDING STRING FACILITY
IFSX9:  SKIPL   IFFLAG
        FAIL    <? STRING(S) WITH NUMERIC OPERATOR>
        POP     P,D             ;GET RELATION VECTOR
        JRST    .(F)            ;BRANCH ON RELATION
        JRST    IFSX91          ;>>
        JRST    IFSX92          ;<<

        ;A=#B DEFINED TO BE TRUE IFF ABS(A/B-1)<EPS (B#0) AND
        ;A<EPS (B=0). CODE IS GENERATED FOR THE TEST:
        ;ABS(A-B)<EPS*B WITH A SPECIAL TEST FOR B=0

        PUSHJ   P,EIRGNP        ;MOVE RIGHT SIDE TO REGISTER
        MOVE    D,[MOVE 1,EPSER]        ;EPS INTO REG
        PUSHJ   P,BUILDI        ;BUILD IT
        MOVE    D,[SKIPE N,]    ;SPECIAL TEST FOR B=0
        PUSHJ   P,BUILDI        ;BUILD IT
        MOVE    D,[FMPR 1,N]    ;EPS*B
        PUSHJ   P,BUILDI        ;BUILD IT
        PUSHJ   P,POPPR         ;GET RIGHT SIDE(A) BACK
        MOVE    D,[FSBR N,]     ;B-A
        PUSHJ   P,BUILDA        ;BUILD INSTR.
        MOVE    D,[MOVM N,N]    ;ABS(B-A) WHICH IS EQUIV. TO ABS(A-B)
        PUSHJ   P,BUILDI        ;
        MOVE    D,[CAMGE N,1]   ;COMPARE ABS(A-B) WITH EPS*B
        PUSHJ   P,BUILDI        ;
        JRST    IFSX5           ;

IFSX91: PUSHJ   P,EIRGNP        ;>> MOVE RIGHT TO REG
        PUSHJ   P,POPPR         ;GET OTHER SIDE BACK
        MOVSI   D,144000        ;FADR
        PUSH    P,B             ;SAVE ADDR
        PUSHJ   P,BUILDA        ;BUILD INSTR.
        MOVSI   D,316000        ;CAMN
        POP     P,B             ;ADDR
        PUSHJ   P,BUILDA        ;
        JRST    IFSX5           ;

IFSX92: PUSHJ   P,EXCHG         ;<< SWAP SIDES
        JRST    IFSX91          ;

;INPUT STATEMENT

;<INPUT STA> ::= INPUT (<SCALAR> ! <ARRAY REF>)[,(<SCALAR>!<ARRAY REF>)...]


XINPUT:	ASCIZ /UT/
	CAIN	C,":"		;INPUT, INPUT#, AND INPUT: STATEMENTS.
	JRST	XINRAN
	CAIE	C,"#"             ; # ?
	JRST	XINP5
	SETZM	WRREFL
	JRST	.+2
XINPT0:	SETOM	WRREFL		;READ# STATEMENTS.
        PUSHJ P,XINPT1
        JRST XIN6
XINPT1: PUSHJ   P,GETCNA        ;GET CHANNEL NUMBER
        MOVE    D,[PUSHJ P,%INST2]  ;RUNTIME INPUT SETUP ROUTINE
        PUSHJ   P,BUILDI
	CAIN	C,":"
	JRST	.+3
	TLNN	C,F.COMA
	JRST	GRONK
	PUSHJ	P,NXCH
	MOVE	D,[SKIPN REAINP-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[SETOM REAINP-1(LP)]
	SKIPN	WRREFL
	MOVE	D,[AOS REAINP-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[SKIPL REAINP-1(LP)]
	SKIPN	WRREFL
	MOVE	D,[SKIPG REAINP-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %REINER]
	PUSHJ	P,BUILDI
	POPJ P,

XINP5:	MOVSI	D,(DATA 1,)
	PUSHJ	P,BUILDI
XIN6:	MOVE	D,[PUSHJ P,%DOINPT];FETCH SETUP INSTR.
	JRST	XINP0

;ENTER HERE FROM READ STATEMENT.


INUUO:	DATA (DATA 6,)
	ADATA1 (DATA 7,)
	ADATA2 (DATA 10,)
	STRIN (DATA 11,)

XINP0:	SETZM	WRREFL
	PUSHJ	P,BUILDI	;CONSTRUCT SETUP INSTR

XINP1:	TLNN	C,F.LETT	;CHECK THAT LETTER IS NEXT.
	JRST	GRONK
	SETZI	F,		;STRINGS MAY BE INPUT
	PUSHJ	P,REGLTR	;GET VARIABLE
	SKIPN	IFFLAG
	MOVEM	F,IFFLAG
	SKIPN	WRREFL
	JRST	XINP9
	XOR	F,IFFLAG
	JUMPGE	F,XINP9
	FAIL	<? MIXED STRINGS AND NUMBERS>
XINP9:	JUMPE	A,XINP2		;JUMP IF ARRAY
	CAIG	A,4		;STRING VARIABLE?
	JRST	XINP1A		;NO
IFN FTSTR,<
	CAIG	A,6		;VARIABLE?
	JRST	XINP6		;YES
>
	JRST	ILFORM		;NO, ATTEMPT TO BOMB A LITERAL

XINP1A:	CAILE	A,1		;ONLY ARRAY AND SCALAR ALLOWED
	JRST	ILVAR
	HRLZ	D,INUUO
	SKIPN	WRREFL
	HLLZ	D,INUUO
	PUSHJ	P,BUILDA
	JRST	XINP3

XINP2:	PUSH	P,B		;SAVE VARIABLE POINTER
	PUSHJ	P,XARG		;XLATE ARGS
	HRLZ	D,INUUO+1
	SKIPN	WRREFL
	HLLZ	D,INUUO+1
	JUMPE	B,XINP2A
	HRRZ	X1,(P)		;GET ADDRESS OF VARIABLE 2-WD BLOCK
	ADD	X1,FLARA
	SKIPN	1(X1)		;MARK	2-DIM
	SETOM	1(X1)
	HRLZ	D,INUUO+2
	SKIPN	WRREFL
	HLLZ	D,INUUO+2
XINP2A:	EXCH	B,(P)		;SAVE NO OF ARGS, GET VARIABLE
	PUSHJ	P,BUILDA	;BUILD DATA INSTR
	POP	P,B		;GET NO OF ARGS
	PUSHJ	P,GENARG

XINP3:	TLNN	C,F.COMA	;MORE?
	CAIN	C,";"
	JRST	.+2
	JRST	NXTSTA          ;NO
	PUSHJ	P,NXCHK		;YES. SKIP COMA
	JRST	XINP1

IFN FTSTR,<
XINP6:	PUSHJ	P,FLET2		;STRING. FINISH REGISTERING
	HRLZ	D,INUUO+3
	SKIPN	WRREFL
	HLLZ	D,INUUO+3
	PUSHJ	P,BUILDA	;BUILD, WITH ADDRESS
	JRST	XINP3
>


XINRAN: PUSHJ   P,GETCNA        ;R.A. STATEMENT
	MOVE	D,[SKIPL ACTBL-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %FNMXER]
	PUSHJ	P,BUILDI
	TLNN	C,F.COMA
	CAIN	C,":"
	JRST	.+2
	JRST	GRONK		;MUST BE >= 1 ARG.
	PUSHJ	P,NXCH
	SETZM	IFFLAG
	SETOM	WRREFL
        SKIPE MATFLG
        POPJ P,
	JRST	XINP1
;LET STATEMENT

;<LET STA> ::= [LET] (<SCALAR>!<ARRAY REF>) = <EXPRESSION>
;		OR
;<LET STA> ::= [(LET)] <LETTER>$[EXPRESSION] = <STRING EXPRESSION>
XLET:   SETOM   LETSW           ;LOOK FOR A LHS.
        PUSHJ   P,QSA           ;LOOK FOR EPS AS LHS.
        ASCIZ   /EPS/           ;
        JRST    XLETA           ;NOT FOUND
        PUSH    P,[EXP 2]       ;FOUND SET FLAG ON PLIST
        PUSH    P,0             ;DUMMY 2ND WORD
        SETOM   IFFLAG          ;SET FLAG TO NUMERIC
        TLNN    C,F.EQAL        ;EQUAL MUST BE NEXT
        JRST    GRONK           ;FAIL IF NOT
        JRST    XLET1           ;

XLETA:  PUSHJ   P,FORMLB        ;LOOK FOR A VARIABLE
        MOVEM   F,IFFLAG        ;STORE TYPE (STR OR NUM) IN IFFLAG.
        TLNN    C,F.EQAL        ;MUST BE A RHS OR ANOTHER LHS.
        JRST    GRONK           ;FAIL IF NOT

XLET0:  SKIPL   LETSW           ;FAIL IF THIS FORMULA IS NOT A VARIABLE.
        JRST    GRONK           ;
        SKIPGE  IFFLAG          ;STR?
        JRST    XLET0A          ;NO.
        PUSHJ   P,PUSHPR        ;YES. REMEMBER ADDR OF RESULT POINTER.
        JRST    XLET1           ;

XLET0A: CAIE    A,1             ;FOR NUM LETS, IF THE LHS IS A LIST OR
        JRST    XLET1           ;TABLE, FORMLA HAS STORED AC B AND A
        PUSH    P,[EXP 1]       ;FLAG ON PLIST. IF THE LHS IS A SCALAR,
        PUSH    P,B             ;PUT THE FLAG AND AC B ON PLIST HERE.

XLET1:  PUSHJ   P,NXCHK         ;SKIP EQUAL SIGN
        SOS     LETSW           ;COUNT THIS LHS,AND LOOK FOR ANOTHER.
        PUSHJ   P,QSA           ;LOOK FOR EPS AS A LHS
        ASCIZ   /EPS/           ;
        JRST    XLETB           ;EPS NOT FOUND
        SETOI   F               ;EPS IS NUMERIC
        XOR     F,IFFLAG        ;XOR WITH PREVIOUS
        JUMPGE  F,XLET0B        ;SAME
        FAIL    <?MIXED STRINGS AND NUMBERS>
XLET0B: TLNE    C,F.EQAL        ;= NEXT?
        JRST    XLET0C          ;YES
        MOVE    C,X2            ;RESTORE C
        MOVE    T,2(P)          ;AND T
        JRST    XLETB           ;
XLET0C: PUSH    P,[EXP 2]       ;PUT EPS FLAG ON PLIST
        PUSH    P,0             ;DUMMY 2ND WORD
        JRST    XLET1           ;

XLETB:  PUSHJ   P,FORMLB        ;LOOK FOR VARIABLE
        XOR     F,IFFLAG        ;XOR N OR S FLAG W/ PREVIOUS
        JUMPGE  F,XLET1A        ;CONSISTENT
        FAIL    <? MIXED STRINGS AND NUMBERS>


XLET1A: TLNE    C,F.EQAL        ;IF NO =, TEMP. ASSUME THIS IS A RHS.
        JRST    XLET0           ;IF =, LOOK FOR ANOTHER 
        MOVMS   LETSW           ;FINISHED SCANNING
        SOS     LETSW           ;
        SKIPL   IFFLAG          ;STRING LET STA?
        JRST    XLET4           ;YES
        PUSHJ   P,EIRGEN        ;NO, GET RESULT IN REG.
        MOVEM   B,TEMP1         ;SAVE THE NEGATIVE RESULT CHECK
XLET1B: MOVE    D,[MOVEM N, (MOVNM N,)]
        SKIPG   -1(P)           ;FLAGS ON PLIST ARE --
        MOVE    D,[ARSTO1 N, (ARSTN1 N,)]       ;0 FOR LIST
        SKIPL   -1(P)                           ;1 FOR SCALAR
        JRST    XLET5                           ; -1 FOR TABLE.
        MOVE    D,[ARSTO2 N, (ARSTN2 N,)]       ;2 FOR EPS
        MOVE    X1,0(P)         ;DEFAULT ARRAY SIZE (10,10)
        ADD     X1,FLARA        
        SKIPN   1(X1)
        SETOM   1(X1)
XLET2:  SKIPGE  TEMP1           ;CHECK FOR NEGATIVE RESULT
        MOVS    D,D             ;NEGATIVE. GET CORRECT INSTR.
        POP     P,B             ;RESTORE RESULT POINTER
        PUSHJ   P,BUILDA        ;BUILD STORE INSTR
        POP     P,B             ;CHUCK TRASH FROM PLIST.
        JUMPG   B,XLET2B        ;ARRAY REF?
        PUSHJ   P,GENARG        ;YES. GEN ARGS FIRST

XLET2B: SOSLE   LETSW           
        JRST    XLET1B          ;THERE IS ANOTHER LHS.
        JRST    NXTSTA          ;DONE W/ STATEMENT

XLET4:  PUSHJ   P,EIRGNP        
        PUSHJ   P,POPPR         ;GET ADDRESS OF LEFT HALF POINTER BACK
        PUSH    P,B
        MOVSI   D,(STRSTO)      ;BUILD THE STRING MOVE INSTRUCTION.
        PUSHJ   P,BUILDA
        POP     P,B             ;POP TRASH
        SOSLE   LETSW
        JRST    XLET4           ;THERE IS ANOTHER LHS.
        JRST    NXTSTA          ;DONE W/ STATEMENT.

XLET5:  MOVEI   B,2             
        CAME    B,-1(P)         ;EPS ?
        JRST    XLET2           ;NO
        SKIPGE  TEMP1           ;NEGATIVE RESULT ?
        MOVS    D,D             ;YES 
        HRRI    D,EPSER         ;INSERT ADDR OF EPS
        PUSHJ   P,BUILDI        ;BUILD INSTRUCTION.
        POP     P,B             ;CHUCK TRASH
        POP     P,B             ;
        JRST    XLET2B          ;



;MARGIN AND MARGIN ALL STATEMENTS.
;
;THIS ROUTINE IS ALSO USED BY THE PAGE AND PAGE ALL STATEMENTS,
;SINCE THEY GENERATE IDENTICAL CODE, EXCEPT FOR THE PUSHJ AT
;THE END OF THE CODE FOR EACH ARGUMENT.  FOR A DESCRIPTION OF THE
;CODE GENERATED, SEE MEMO #100-365-033-00.

XMAR:	ASCIZ	/GIN/
	SETZM	TABLE		;TELLS THAT THIS IS REALLY MARGIN (ALL).
XMAR0:	PUSHJ	P,QSA		;ENTRY POINT FOR PAGE (ALL).
	ASCIZ	/ALL/
	JRST	XMAR6		;MARGIN OR PAGE.
	TLNE	C,F.TERM	;MARGIN ALL OR PAGE ALL.
	JRST	GRONK		;ALL MUST HAVE ARG.
	PUSHJ	P,FORMLN	;GENERATE CODE FOR THE ARG.
	PUSHJ	P,EIRGEN
	MOVE	D,[PUSHJ P,%MARGAL]
	SKIPE	TABLE
	MOVE	D,[PUSHJ P,%PAGEAL]
	PUSHJ	P,BUILDI
	JRST	NXTSTA

XMAR6:	TLNE	C,F.TERM
	JRST	GRONK
XMAR1:	HRRZ	A,C
	CAIE	A,"#"		;CHANNEL SPECIFIER?
	JRST	XMAR2		;NO, MUST BE TTY.
        PUSHJ   P,GETCNA        ;GET CHANNEL CODE
	TLNE	C,F.COMA	;DELIM MUST BE , OR :
	JRST	XMAR3
	CAIE	C,":"
	JRST	GRONK
XMAR3:	PUSHJ	P,NXCH
XMAR5:	PUSHJ	P,FORMLN
	PUSHJ	P,EIRGEN
	MOVE	D,[PUSHJ P,%PAGE]
	SKIPN	TABLE
	MOVE	D,[PUSHJ P,%MARGN]
	PUSHJ	P,BUILDI
	TLNE	C,F.COMA	;DELIM AFTER ARG MUST BE , OR ;
	JRST	XMAR4
	CAIE	C,";"
	JRST	NXTSTA
XMAR4:	PUSHJ	P,NXCH
	JRST	XMAR1
XMAR2:	HRLZI	D,(MOVEI LP,)
	PUSHJ	P,BUILDI
	JRST	XMAR5
IFN FTMAT,<
;MAT STATEMENT

;MAT STATEMENTS DIVIDE INTO A NUMBER OF DIFFERENT
;STATEMENTS (MAT READ, ...)   THESE POSSIBILITIES ARE TESTED
;ONE AT A TIME BY CALLS TO QSA.

;<MAT READ STA> ::= MAT READ <LETTER>[(<EXP>,<EXP>)] [,<LETTER>[(<EXP>,<EXP>...]]

XMAT:	HLLI	F,		;ALLOW STRINGS FOR READ,PRINT,INPUT
	PUSHJ	P,QSA		;MAT READ?
	ASCIZ /READ/
	JRST	XMAT2		;NO.  GO TRY MAT PRINT
        CAIN C,"#"              ;SEQ ?
        JRST MATDSK
        CAIN C,":"
        JRST MATRRE
XMAT1:	HRLI	F,0
	PUSHJ	P,ARRAY		;GET ARRAY NAME
	CAIE	A,5		;STRING VECTOR?
	JUMPN	A,GRONK
        SKIPE RANFLG
        JRST [MOVSI D,(DATA 14,)
                JRST XMAT1A]
        SKIPE MATFLG
        JRST [MOVSI D,(MATRD 1,)
                JRST XMAT1A]
	MOVSI	D,(MATRD)
	SKIPL	DATAFF		;DATA SEEN?
	HLLOS	DATAFF		;NO.  SET NO DATA FLAG
XMAT1A:	PUSHJ	P,XMACOM		;GO CHECK DIMENSIONS AND BUILD UUO.
	TLNN	C,F.COMA	;IS THERE ANOTHER ARRAY TO READ?
	JRST	NXTSTA		;NO.
	PUSHJ	P,NXCHK		;YES. SKIP COMMA
	TLNE	C,F.TERM	;END OF ARRAY LIST?
	JRST	NXTSTA		;YES.
	JRST	XMAT1

;<MAT PRINT STA>::= MAT PRINT <LETTER>[(<EXP>,<EXP>)] [[;!,] <LETTER>[(<EXP>,<EXP>)...]

XMAT2:	PUSHJ	P,QSA		;MAT PRINT?
	ASCIZ	/PRINT/
	JRST	XMAT3		;NO. MUST HAVE VARIABLE NAME.
        JRST MATPRT
XMAT2A:	HRLI	F,0
	PUSHJ	P,ARRAY		;REGISTER NAME
	CAIE	A,5		;STRING VECTOR?
	JUMPN	A,GRONK
        SKIPE RANFLG
        JRST [MOVSI D,(DATA 13,)
                JRST XMAT2C]
        MOVSI D,(DATA 12,)
        SKIPE MATFLG
        JRST XMAT2C
	MOVSI D,(MATPR)
	PUSHJ	P,CHKFMT	;CHECK FORMAT CHARACTER
XMAT2B:	TLNN	D,140
	JRST	GRONK		;FAIL IF ILLEGAL
XMAT2C:	PUSHJ	P,XMACOM	;GO CHECK DIMENSIONS AND BUILD UUO
        TLNE C,F.COMA
        PUSHJ P,NXCHK
	TLNE	C,F.TERM	;IS FORMAT CHAR FOLLOWED BY END OF STA?
	JRST	XMAT2E		;YES.
	JRST	XMAT2A		;PROCESS NEXT ARRAY NAME
XMAT2D: TLNN C,F.COMA
        JRST XMAT2E
        PUSHJ P,NXCHK
        JRST XMAT2C

XMAT2E: SKIPE RANFLG
        JRST NXTSTA
         SKIPN MATFLG
        JRST NXTSTA
        MOVE D,[PUSHJ P,%ENDIMG]
        PUSHJ P,BUILDI
        JRST NXTSTA

;<MAT SCALE STA> ::= MAT <LETTER>=(<EXPRESSION>)*<LETTER>

XMAT3:  PUSHJ P,QSA
        ASCIZ/WRITE/
        SKIPA
        JRST MATWRT
        PUSH P,[Z NXTSTA]       ;ALL REMAINING MAT STATES. MAY HAVE
				;ONE OPERAND, BUT NOT A LIST OF THEM.
	PUSHJ	P,QSA
	ASCIZ /INPUT/
	JRST	XMAT3A
        CAIN C,"#"              ;SEQ ?
        JRST MATDS1
        CAIN C,":"
        JRST MATRRE
	PUSHJ	P,VECTOR	;REGISTER VECTOR NAME 
	CAIE	A,5		;STRING VECTOR?
	JUMPN	A,GRONK		;OR NUMBER VECTOR?
	MOVSI	D,(MATINP)	;YES. BUILD MAT INPUT
	JRST	BUILDA


MATPRT: SETZM WRREFL
        SKIPA
MATWRT: SETOM WRREFL
        SETOM MATFLG
        SETZM RANFLG
        PUSHJ P,XPRIN1
        JRST XMAT2A


MATRRE: SETOM MATFLG
        PUSHJ P,XINRAN
        SETOM RANFLG
        SETZM MATFLG
        JRST XMAT1

MATDS1: SETZM WRREFL
        SKIPA
MATDSK: SETOM WRREFL
        PUSHJ P,XINPT1
        MOVE D,[PUSHJ P,%DOINPT]
        PUSHJ P,BUILDI
        SETZM WRREFL
        TLNE C,F.COMA
        PUSHJ P, NXCH
        SETOM MATFLG
        JRST XMAT1

XMAT3A:	HRLI	F,-1		;REMAINING MATOPS CANT HAVE STRINGS.
	PUSHJ	P,ARRAY		;REGISTER THE VARIABLE
	JUMPN	A,GRONK		;CHECK FOR ILLEGAL ARRAY NAME.
	TLNN	C,F.EQAL	; CHECK FOR EQUAL SIGN.
	JRST	GRONK
	PUSHJ	P,NXCHK		;SKIP EQUAL.
	CAIE	C,"("	;SCALAR MULTIPLE?
	JRST	XMAT4		;NO
	PUSHJ	P,NXCHK		;SKIP PARENTHESIS
	PUSH	P,B
	PUSHJ	P,FORMLN	;YES.  GEN MULTIPLE
	PUSHJ	P,EIRGNP
	PUSHJ	P,QSF		;SKIP MULTIPLY SIGN
	ASCIZ	/)*/
	PUSH	P,[MATSCA]	;GET OP CODE.
	JRST	XMAT9A
;<MAT SETUP STA> ::= MAT ZER!CON!IDN <LETTER>[(<EXPRESSION>,<EXPRESSION>)]

XMAT4:	PUSHJ	P,QSA		;MAT ZER?
	ASCIZ /ZER/
	JRST	XMAT5		;NO.
	MOVSI	D,(MATZER)	;YES.
	JRST	XMACOM

XMAT5:	PUSHJ	P,QSA		;MAT CON?
	ASCIZ /CON/
	JRST	XMAT6
	MOVSI	D,(MATCON)	;YES.
	JRST	XMACOM

XMAT6:	PUSHJ	P,QSA		;MAT IDN?
	ASCIZ /IDN/
	JRST	XMAT7		;NO
	MOVSI	D,(MATIDN)	;YES.

;COMMON GEN FOR MAT ZER,CON,IDN,REA

XMACOM:	CAIE	C,"("		;EXPLICIT DIMENSIONS?
	JRST	XMAT9D		;NO.
	PUSH	P,B		;SAVE B,D.
	PUSH	P,D
	PUSHJ	P,XARG		;TRANSLATE ARGUMENTS
	PUSH	P,B		;SAVE COUNT OF ARGUMENTS
	MOVE	B,-2(P)		;GET BACK THE REGISTRY OF THE ARRAY.
	MOVSI	D,(SDIM)		;BUILD SDIM INSTR.
	PUSHJ	P,BUILDA
	POP	P,B		;GET THE ARGUMENT COUNT.
	JUMPN	B,XMACO1	;ONE ARG OR TWO?
        PUSHJ   P,GENAFN        ;ONE. FAKE DIMENSIONS OF (N,0).
	MOVE	D,[JUMP 2,ONCESW] ;
	PUSHJ	P,BUILDI
        JRST    XMAT9C          ;

XMACO1:	PUSHJ	P,GENAR0		;GEN ARGS
	JRST	XMAT9C		;RESTORE AC,S AND BUILD.

XMACMI:		

;<MAT FCN STA> ::= MAT<LETTER> = INV!TRN (<LETTER>)

XMAT7:	PUSHJ	P,QSA		;MAT INV?
	ASCIZ	/INV(/
	JRST	XMAT8		;NO
	MOVSI	D,(MATINV)	;YES. GET OP CODE.
	JRST	XMITCM

XMAT8:	PUSHJ	P,QSA		;MAT TRN?
	ASCIZ	/TRN(/
	JRST	XMAT9		;NO.
	MOVSI	D,(MATTRN)	;YES. GET OP CODE.
	MOVEM	B,TRNFLG
XMITCM:	PUSH	P,B		;FINISH MAT INV,TRN.
	PUSH	P,D
	HRLI	F,777777
	PUSHJ	P,ARRAY
	JUMPN	A,GRONK
	PUSHJ	P,QSF
	ASCIZ	/)/
	CAME	B,TRNFLG
	JRST	XMAT9B
	ADD	B,FLOOR(F)	;THIS IS MAT A = TRN (A).
	SETOM	2(B)		;MARK A.
	MOVE	B,TRNFLG	;FAKE IT OUT BY USING AN
	MOVSI	D,(MOVEI T1,)	;INVISIBLE MATRIX FOR TEMPORARY
	PUSHJ	P,BUILDA	;STORAGE.
	HRLZI	A,552640
	PUSHJ	P,ARRAY0
	POP	P,D
	PUSH	P,B
	ADD	B,FLOOR(F)
	AOS	2(B)
	MOVE	B,(P)
	PUSHJ	P,BUILDA
	JRST	XMAT11
;<MAT OPERATOR STA>::=MAT <LETTER>=<LETTER>+!-!*<LETTER>

XMAT9:	PUSH	P,B		;SAVE RESULT LOCATION
	HRLI	F,777777
	PUSHJ	P,ARRAY
	JUMPN	A,GRONK
	MOVEI	D,0		;LETTER FOLLOWED BY OPERATOR
	TLNN	C,F.PLUS+F.MINS+F.STAR
	JRST	XMAT10		;NO OPERATOR. MUST BE MAT COPY
	TLNN	C,F.MINS+F.STAR
	MOVSI	D,(MATADD)
	TLNN	C,F.PLUS+F.STAR
	MOVSI	D,(MATSUB)
	TLNN	C,F.PLUS+F.MINS
	MOVSI	D,(MATMPY)
	PUSH	P,D		;SAVE OPERATION
	PUSHJ	P,NXCHK		;SKIP OPERATOR
	MOVSI	D,(MOVEI T,)	;GEN T:= ADRS OF FIRST ARRAY

	PUSHJ	P,BUILDA	;ENTER HERE FROM SCALAR MULTIPLE

XMAT9A:	HRLI	F,777777
	PUSHJ	P,ARRAY		;SECOND ARRAY
	JUMPN	A,GRONK		;NOT ARRAY NAME

;ENTER HERE FROM MAT INV, TRN

XMAT9B:	MOVSI	D,(MOVEI T1,)
	PUSHJ	P,BUILDA
XMAT9C:	POP	P,D
	POP	P,B
XMAT9D:	PUSHJ	P,BUILDA
	POPJ	P,		;RETURN TO NXTSTA (OR TO PROCESS NEXT ITEM IN PRINT,READ, OR INPUT LIST.)

XMAT10:	PUSH	P,B		;FOR MAT COPY, FAKE MAT B=(1)*A
XMAT11:	MOVE	D,[MOVSI N,(1.0)];PUT CONSTANT 1.0 IN REG FOR SCALE
	PUSHJ	P,BUILDI	;BUILD INST TO GET SCAL FACTOR
	POP	P,B		;GET SOURCE MAT BACK
	PUSH	P,[MATSCA]
	JRST	XMAT9B

>;ASSEMBLE ABOVE IF INCLUDING MATRIX FACILITY
;NEXT STATEMENT

;<NEXT STA> ::= NEXT <SCALAR>

;EXPECT TO FIND 5-WORD ENTRY ON TOP OF FORROL
;DISCRIBING INDUCTION VARIABLE AND LOOP ADDRESS

;WORD IS PUSHED ON NXTROL OF FOLLOWING FORM:
;	(<REL ADRS OF TOP OF LOOP>) <REL ADRS OF JRST TO IT>
;THIS WORD USED TO FIX UP REFERENCE AT END OF
;COMPILATION.
XNEXT:	ASCIZ /T/
	HRLI	F,777777
	PUSHJ	P,REGLTR
	CAIE	A,1		;BETTER BE SCALAR
	JRST	GRONK
	MOVE	X1,CEFOR	;UNSAT FOR?
	CAMG	X1,FLFOR
	FAIL	<? NEXT WITHOUT FOR>
	CAME	B,-3(X1)	;CHECK INDUCTION VARIABLE
	FAIL	<? NEXT WITHOUT FOR>

XNEX1:	PUSHJ	P,POPFOR
	MOVEM	B,TMPLOW	;RESTORE PREVIOUS LEVEL OF TEMPORARY PROTECTION
	MOVEM	B,TMPPNT	;BECAUSE THIS IS THE END OF THE "FOR" RANGE .
	PUSHJ	P,POPFOR	;GEN INCREMENT TO REG
	PUSHJ	P,EIRGEN
	PUSHJ	P,POPFOR	;FADR TO INDUCTION VAR
	MOVSI	D,(FADR)
	PUSHJ	P,BUILDA
	PUSHJ	P,POPFOR	;GET LOC OF RETURN

	MOVEI	X1,1(B)		;ADD TO ADDRS CHAIN OF NEXT WORD
	ADD	X1,FLCOD
	MOVE	X2,L
	AOBJP	X2,XNEX2	;DONT LINK IF LAST STATEMENT!
	ADD	X2,FLLAD
	MOVE	A,(X2)
	HRRM	A,(X1)
	MOVEI	A,1(B)
	HRRM	A,(X2)

XNEX2:	MOVSI	A,(B)		;ADD WORD TO NXTROL FOR LINKAGE
	MOVEI	R,NXTROL
	PUSHJ	P,RPUSH
	SUB	B,FLNXT
	HRLI	B,NXTROL
	MOVSI	D,(JRST)	;BUILD JRST INSTR
	PUSHJ	P,BUILDA
	PUSHJ	P,POPFOR	;POP OFF THE SAVED VALUE OF L
	JRST	NXTSTA
;SUBR TO POP TOP OF FORROL. USED ONLY BY XNEXT.


POPFOR:	SOS	X1,CEFOR	;POP TOP OF FORROL
	MOVE	B,(X1)
	POPJ	P,


;NOPAGE AND NOPAGE ALL STATEMENTS.
;
;THIS ROUTINE IS ALSO USED BY THE (NO)QUOTE(ALL) STATEMENTS
;SINCE THEY GENERATE PRACTICALLY IDENTICAL CODE TO NOPAGE(ALL).
;FOR A DESCRIPTION OF THE CODE GENERATED, SEE
;MEMO #100-365-033-00.
;"TABLE" TELLS THE ROUTINE WHAT THE DIFFERENCES ARE.


XNOP:	ASCIZ	/AGE/
	MOVE	N,[SETOM PAGLIM] ;NOPAGE(ALL).
	MOVEM	N,TABLE
XNOP8:	PUSHJ	P,QSA		;(NO)QUOTE(ALL) ENTERS HERE.
	ASCIZ	/ALL/
	JRST	.+2
	JRST	XNOP1
	SETZM	TTYPAG		;ONLY SET THE TTY ONCE PER STATEMENT.
	TLNN	C,F.TERM
	JRST	XNOP2
XNOP0:	SKIPE	TTYPAG
	JRST	NXTSTA
	MOVE	D,TABLE
	PUSHJ	P,BUILDI
	JRST	NXTSTA
XNOP2:	TLNE	C,F.COMA	;DELIMITER?
	JRST	XNOP5
	CAIN	C,";"
	JRST	XNOP5
XNOP6:  CAIN    C,"#"           ;## SEEN ?
        PUSHJ   P,NXCH          ;YES, GET DIGIT
XNOP4:  PUSHJ   P,GETCN2        ;GET CHANNEL CODE
        MOVE    D,TABLE         
        TLO     D,000016        ;AND IN (LP).
        PUSHJ   P,BUILDI
	TLNE	C,F.TERM	;FINISHED?
	JRST	NXTSTA		;YES.
	TLNE	C,F.COMA	;DELIMITER?
	JRST	XNOP3
	CAIE	C,";"
	JRST	GRONK
XNOP3:	PUSHJ	P,NXCH		;HERE WHEN DELIMITER SEEN.
	TLNE	C,F.TERM	;FINISHED?
	JRST	XNOP0		;YES, ALMOST.
        TLNN    C,F.COMA        ;DELIMITER?
        CAIN    C,";"           ;NO, OTHER DELIMITER ?
        JRST    XNOP5           ;YES
        JRST    XNOP6           ;NO
XNOP5:	SKIPN	TTYPAG
	PUSHJ	P,XNOP7
	JRST	XNOP3
XNOP7:	MOVE	D,TABLE
	PUSHJ	P,BUILDI
	SETOM	TTYPAG
	POPJ	P,
XNOP1:	TLNN	C,F.TERM	;(ALL) STATEMENTS
	JRST	GRONK
	MOVE	D,[MOVEI LP,9]
	PUSHJ	P,BUILDI
	MOVE	D,TABLE
	TLO	D,000016	;AND IN (LP).
	PUSHJ	P,BUILDI
	ADD	B,FLCOD
	HRLZI	D,(SOJG LP,)	;"SOJG LP,.-1"
	HRR	D,B
	PUSHJ	P,BUILDI
	JRST	NXTSTA

;NOQUOTE AND NOQUOTE ALL STATEMENTS.
;
;THESE STATEMENTS USE THE NOPAGE ROUTINE, XNOP, WHICH SEE.

XNOQ:	ASCIZ	/UOTE/
	MOVE	N,[SETZM QUOTBL]
	MOVEM	N,TABLE
	JRST	XNOP8


;ON STATEMENT

;<ON STA> ::= ON <EXPRESSION> GOTO!THEN <STA NUMBER> [,<STA NUMBER>...]

;CREATES A CALL TO A RUNTIME ROUTINE THAT CHECKS THE RANGE OF THE ARGUMENT
;AND RETURNS TO THE APPROPRIATE JRST:
;	JSP	A,XCTON
;	Z	(ADDRESS OF NEXT STATEMENT)
;	<NEST OF>
;	<GOTO'S >

XON:	PUSHJ	P,FORMLN	;EVALUATE INDEX
	PUSHJ	P,EIRGNP	;GET IN REG
	MOVE	D,[JSP A,%XCTON]
	PUSHJ	P,BUILDI	;BUILD THE RUNTIME CALL
	SETZI	D,		;BUILD ADDRESS OF NEXT STATEMENT
	MOVE	B,L
	AOBJP	B,.+3		;DONT BUILD IF LAST STATEMENT
	HRLI	B,LADROL
	PUSHJ	P,BUILDA
	TLNE	C,F.COMA	;SKIP OPTIONAL COMMA.
	PUSHJ	P,NXCH
	PUSHJ	P,THENGO	;TEST FOR "THEN" OR "GOTO"
	
XON1:	PUSHJ	P,XGOFR		;BUILD A JRST TO THE NEXT NAMED STATEMENT
	TLNN	C,F.COMA	;MORE?
	JRST	NXTSTA		;NO
	PUSHJ	P,NXCHK		;YES. SKIP COMMA
	JRST	XON1		;PROCESS NEXT LINE NUMBER

;THE FOLLOWING CODE IS THE MAJORITY OF THE CODE FOR DISK FILE HANDLING
	EXTERN	DREL
	EXTERN INITO,FILD,ACTBL,LOK,LOKUP,LINB0,OUTDSK,STADSK
	EXTERN	OBDSK,ENT,OUTDSK,ENTDSK,BA

;FILE AND FILES STATEMENTS.
;
;FILES STATEMENTS SET UP INFORMATION FOR THE LOADER, AS FOLLOWS:
;THE ACTBL ENTRY IS +1 FOR SEQ. ACCESS FILES, -1 FOR R.A. FILES.
;THE STRLEN ENTRY CONTAINS THE RECORD LENGTH FOR STRING R.A.
;FILES (OR 0 IF THE STRING R.A. FILE DID NOT SPECIFY A
;RECORD LENGTH) AND 400000,,0 FOR NUMERIC R.A. FILES.  THE
;BLOCK ENTRY CONTAINS THE SOURCE STATEMENT LINE NUMBER IN CASE THE
;LOADER NEEDS IT FOR AN ERROR MESSAGE.

XFILE:	ASCIZ	/E/
	PUSHJ	P,QSA
	ASCIZ	/S/		;FILE OR FILES?
	JRST	FILEE		;FILE.
XFIL1:	MOVEI	B,";"		;FILES.
	CAIE	B,(C)
	TLNE	C,F.COMA
	JRST	XFIL10
	PUSHJ	P,FILNMO	;GET FILENAME.
	JUMP	SAVE1
	AOS	A,FILCNT
	CAILE	A,9
	FAIL	<? TOO MANY FILES>
	MOVEI	D,9
	MOVE	X1,FILDIR
	MOVE	X2,FILDIR+1
	CAMN	X1,FILD-1(D)	;SEARCH FOR DUPLICATE NAME.
	JRST	.+3
	SOJG	D,.-2
	JRST	XFIL35
	CAME	X2,EXTD-1(D)
	JRST	.-3
	PUSHJ	P,INLMES
	ASCIZ	/
? FILE /
	PUSHJ	P,PRNNAM
	PUSHJ	P,INLMES
	ASCIZ	/ ON MORE THAN ONE CHANNEL/
	PUSH	P,C
	PUSHJ	P,FAIL2
	POP	P,C
XFIL35:	MOVEM	X1,FILD-1(A)
	MOVEM	X2,EXTD-1(A)
        SKIPN FILDIR+3
        JRST XFIL40
        MOVE X1,[FILUSN,,FUSE]
        MOVE X2,A
        SOJ X2,
        IMULI X2,2
        ADDI X2,FUSE
        HRRM X2,X1
        AOJ X2,
        BLT X1,(X2)
XFIL40:	MOVE	X2,L		;SAVE SOURCE LINE
	ADD	X2,FLLIN	;NUMBER IN CASE THE
	HLRZ	X2,(X2)		;LOADER NEEDS IT.
	MOVEM	X2,BLOCK-1(A)
	MOVEI	B,"%"		;TYPE OF FILE--
	CAIE	B,(C)
	JRST	XFIL36
	HRLZI	B,400000	;R.A. NUMERIC.
	MOVEM	B,STRLEN-1(A)
	PUSHJ	P,NXCH
	JRST	XFIL39
XFIL36:	TLNN	C,F.DOLL
	JRST	XFIL37
	PUSHJ	P,NXCH		;R.A. STRING.
	SETZ	B,
	TLNN	C,F.DIG		;GET THE RECORD LENGTH.
	JRST	XFIL32
	PUSHJ	P,XFIL30
	JRST	XFIL38
	CAILE	B,^D132
	JRST	XFILER
	PUSHJ	P,NXCH
	JRST	XFIL38
XFIL30:	HRRZI	B,-60(C)
	PUSHJ	P,NXCH
	TLNN	C,F.DIG
	POPJ	P,
	IMULI	B,^D10
	ADDI	B,-60(C)
	PUSHJ	P,NXCH
	TLNN	C,F.DIG
	POPJ	P,
	IMULI	B,^D10
	ADDI	B,-60(C)
	JRST	CPOPJ1
XFIL38:	JUMPE	B,XFILER
XFIL32:	MOVEM	B,STRLEN-1(A)
	JUMPE	B,XFIL39
	MOVEI	X1,4(B)
	IDIVI	X1,5
	ADDI	X1,1
	HRLM	X1,STRLEN-1(A)
XFIL39:	SETOM	ACTBL-1(A)	;MAKE ACTBL ENTRY = -1 FOR R.A.
	JRST	XFIL7
XFIL37:	AOS	ACTBL-1(A)	;MAKE ACTBL ENTRY = +1 FOR SEQ. ACCESS.
XFIL7:	TLNE	C,F.TERM
	JRST	NXTSTA
	MOVEI	B,";"
	CAIE	B,(C)
	TLNE	C,F.COMA
	JRST	XFIL8
	JRST	GRONK
XFIL10:	AOS	B,FILCNT
	CAILE	B,9
	FAIL	<? TOO MANY FILES>
XFIL8:	PUSHJ	P,NXCH
	TLNN	C,F.TERM
	JRST	XFIL1
XFIL9:	AOS	B,FILCNT
	CAILE	B,9
	FAIL	<? TOO MANY FILES>
	JRST	NXTSTA


FILEE:	MOVE	D,FLLIN
	ADDI	D,(L)
	MOVS	D,(D)
	HRLI	D,(MOVEI L,)
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM L,SORCLN]
	PUSHJ	P,BUILDI
	SKIPE	FUNAME
	JRST	FILEE0
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSHJ	P,BUILDI
	SETZM	VRFSET
FILEE0:	CAIN	C,":"		;TYPE OF ARG IS?
	JRST	FILEE1		;R.A.
	CAIE	C,"#"         ;# ?
	JRST	GRONK
	SETZM	FILTYP		;SEQ. ACCESS.
	JRST	FILEE2
FILEE1:	SETOM	FILTYP
FILEE2:	PUSHJ	P,NXCH
	TLNN	C,F.DIG		;GET CHAN NO.
	JRST	GRONK
	HRRZI	D,-60(C)
	JUMPE	D,GRONK		;CHAN. 0 NOT ALLOWED.
	HRLI	D,(MOVEI LP,)
	PUSHJ	P,BUILDI
	PUSHJ	P,NXCH
	CAIE	C,":"		;SKIP DELIMITER.
	TLNE	C,F.COMA
	JRST	.+2
	JRST	GRONK
	PUSHJ	P,NXCH
	MOVE	D,[SETZM FILTYP]
	SKIPE	FILTYP
	MOVE	D,[SETOM FILTYP]
	PUSHJ	P,BUILDI
	MOVE	D,[SKIPE ACTBL-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[PUSHJ P,%CLSFIL]
	PUSHJ	P,BUILDI
	TLNN	C,F.QUOT
	JRST	FILE21
	PUSH	P,C
	PUSH	P,T
	PUSHJ	P,QSKIP
	JRST	GRONK
	TLNN	C,F.COMA
	TLNE	C,F.TERM
	JRST	FILEE4
	CAIN	C,";"
	JRST	FILEE4
	POP	P,T
	POP	P,C
FILE21:	PUSHJ	P,FORMLS	;GET FILENM ARG.
	PUSHJ	P,EIRGNP
	MOVE	D,[AOS T,MASAPP]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,(T)]
	PUSHJ	P,BUILDI
	MOVE	D,[PUSHJ P,%OPNFIL]
	PUSHJ	P,BUILDI
	CAIE	C,";"		;SKIP DELIMITER.
	TLNE	C,F.COMA
	JRST	FILEE3
	JRST	NXTSTA
FILEE3:	PUSHJ	P,NXCH
	JRST	FILEE0		;PROCESS NEXT ARG.

FILEE4:	POP	P,T		;CHECK SYNTAX OF ARG NOW, SINCE IT IS A CONSTANT.
	POP	P,C
	PUSH	P,T
	PUSH	P,C
	PUSHJ	P,NXCH
	PUSHJ	P,FILNMO	;FILENM.EXT FORM?
	JUMP	SAVE1
	TLNE	C,F.QUOT
	JRST	FILEE7
	TLNE	C,F.DOLL	;TYPE $ OR %?
	JRST	FILE45		;$.
	CAME	C,[1000000045]
	JRST	GRONK
	PUSHJ	P,NXCH		;%.
	TLNN	C,F.QUOT
	JRST	GRONK
	JRST	FILEE7
FILE45:	MOVEI	A,3
	SETZ	B,
	PUSHJ	P,NXCH
	TLNN	C,F.DIG
	JRST	XFILR1
FILEE5:	TLNN	C,F.DIG
	JRST	FILEE6
	SOJL	A,GRONK
	IMULI	B,^D10
	ADDI	B,-60(C)
	PUSHJ	P,NXCH
	JRST	FILEE5
FILEE6:	CAIL	A,3
	JRST	GRONK
	JUMPE	B,XFILER
	CAILE	B,^D132
XFILER:	FAIL	%? STRING RECORD LENGTH > 132 OR < 1%
XFILR1:	TLNN	C,F.QUOT
	JRST	GRONK
FILEE7:	POP	P,C		;RESTORE BYTE POINTER AND
	POP	P,T		;CHARACTER IN C.
	JRST	FILE21		;BACK TO MAIN CODE.


	DEFINE	R(A)
<IRP	A
<	EXP	OPS'A
	EXTERN	OPS'A>>
FILMOD:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+1	>>
OUTPT:	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<	EXP	DO'A+2
	EXTERN	DO'A	>>
OUTCNT:	R<1,2,3,4,5,6,7,8,9>
	DEFINE R(A)
<	IRP	A
<	EXP	DI'A+1
	EXTERN	DI'A	>>
INPT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE	R(A)
<	IRP	A
<	EXP	DI'A+2	>>
INCNT:	R<1,2,3,4,5,6,7,8,9>

	DEFINE R(A)
<	IRP	A
<	POINT 7,LINB'A
	EXTERN	LINB'A	>>
LINPT:	R<0,1,2,3,4,5,6,7,8,9>


	EXTERN	IFIFG,ODF



;SCRATCH STATEMENT
;FORMAT
;     SCRATCH Q4,Q7,Q8
;WHERE Q IS # OR :. Q MAY BE OMITTED, IN WHICH CASE 3 IS ASSUMED.

XSCRAT:	ASCIZ /ATCH/
SRAER5:	CAIN	C,":"
	JRST	SRAER3		;R.A. ARGUMENT.
	CAIN	C,"#"             ;SEQ. ACCESS ARGUMENT
	PUSHJ	P,NXCH
        PUSHJ   P,GETCN2        ;GET CHANNEL NUMBER
        MOVE    D,[PUSHJ P,%SCTH2]  ;RUNTIME SCRATCH # ROUTINE
SRAER4:	PUSHJ	P,BUILDI	;BUILD SCRATCH
	TLNN	C,F.COMA	;SKIP DELIMITER.
	CAIN	C,";"
	JRST	.+2
	JRST	NXTSTA
	PUSHJ	P,NXCH
	JRST	SRAER5

SRAER3: PUSHJ   P,GETCNA        ;R.A. ARGUMENT
	MOVE	D,[PUSHJ P,%RANSCR]
	JRST	SRAER4



;SET STATEMENT
;
;FORMAT
;	SET :N,NUMERIC FORMULA, :N,NUMERIC FORMULA...
;
;WHERE N IS A DIGIT FROM 1 TO 9, THE ":" IS OPTIONAL, THE COMMA
;FOLLOWING N MAY BE REPLACED BY A COLON, AND THE COMMA 
;FOLLOWING THE FORMULA MAY BE REPLACED BY A SEMICOLON.

XSET:	CAIN	C,":"		;SKIP OPTIONAL COLON.
	PUSHJ	P,NXCH
	PUSHJ	P,GETCN2
	MOVE	D,[SKIPL ACTBL-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %FNMXER]
	PUSHJ	P,BUILDI
	CAIE	C,":"		;SKIP DELIMITER.
	TLNE	C,F.COMA
	JRST	.+2
	JRST	GRONK
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLN	;GET VALUE FOR POINTER.
	PUSHJ	P,EIRGNP
	MOVNI	A,5
XSET2:	MOVE	D,SETCOD+5(A)
	PUSHJ	P,BUILDI
	AOJL	A,XSET2
	TLNN	C,F.COMA	;ANOTHER ARG.?
	CAIN	C,";"
	JRST	.+2		;BETTER BE.
	JRST	NXTSTA
	PUSHJ	P,NXCH
	JRST	XSET

SETCOD:	JUMPLE	N,%SETERR	;SOME OF THE CODE GENERATED.
	PUSHJ	P,%IFIX
	CAIGE	N,1
	JRST %SETERR
	MOVEM	N,POINT-1(LP)

SETERR:	PUSHJ	P,INLMES
	ASCIZ	/
? SET ARGUMENT/
	JRST	OUTBND
;THIS ROUTINE SORTS THE BOUNDARIES OF THE DISK BUFFERS INTO THE
;TABLE SRTDBA, FROM THE TABLE BA. SRTDBA IS IN ASCENDING ORDER,
;EXCEPT THAT ANY ZEROES ARE AT THE TOP, SO THAT IF NO BUFFERS
;ARE PRESENT SRTDBA CAN BE USED AS A FLAG WORD.
;BASORT DESTROYS AC'S C,E,X1, AND X2.

BASORT:	MOVE	X1,[XWD BA,SRTDBA]
	BLT	X1,SRTDBA+8
	MOVEI	E,8
BASOR1:	MOVE	X1,SRTDBA(E)
	MOVEI	C,(E)
BASOR2:	MOVE	X2,SRTDBA-1(C)
	CAMG	X2,X1
	JRST	BASOR3
	MOVEM	X2,SRTDBA(E)
	MOVEM	X1,SRTDBA-1(C)
	MOVE	X1,X2
BASOR3:	SOJG	C,BASOR2
	SOJG	E,BASOR1

BASOR4:	SKIPE	SRTDBA(C)
	JRST	BASOR5
	AOJ	C,.+1
	CAIG	C,8
	JRST	BASOR4
	POPJ	P,
BASOR5:	MOVEI	E,10
	JRST	PAKBL0


;WRITE AND PRINT STATEMENTS
;CAUSES DATA TO BE OUTPUT TO THE DISK OR TTY.

XWRIT:	ASCIZ /TE/
	SETOM	WRREFL
	JRST	.+3
XPRINT:	ASCIZ	/NT/
	SETZM	WRREFL
XPRIN1:	CAIN	C,":"
	JRST	XPRRAN		;R.A. STATEMENT.
	PUSHJ	P,QSA
	ASCIZ	/USING/
	JRST	XWRI1
	CAIE	C,"#"             ;## ?
	JRST	XWRI2
	PUSHJ	P,XWRCHA
	TLNN	C,F.COMA
	CAIN	C,":"
	JRST	.+2
	JRST	GRONK
	PUSHJ	P,NXCH
	PUSHJ	P,XWRIMG
	JRST	XWRI5
XWRI2:	PUSHJ	P,XWRIMG
	JRST	XWRI6

XWRI1:	CAIE	C,"#"       ;# ?
	JRST	XPRI1
	PUSHJ	P,XWCHA
	TLNE	C,F.TERM
	JRST	XPRI0
	TLNN	C,F.COMA
	CAIN	C,":"
	PUSHJ	P,NXCH
	TLNE	C,F.TERM
	JRST	XPRI0
	PUSHJ	P,QSA
	ASCIZ	/USING/
	JRST	XPRI0
	MOVE	D,[PUSHJ P,%IMGLIN]
	PUSHJ	P,BUILDI
	PUSHJ	P,XWRIMG
	JRST	XWRI5

XWRIMG:	TLNE	C,F.DIG		;HANDLE IMAGE.
	JRST	XWRIM2
XWRIM1:	PUSHJ	P,FORMLS
	PUSHJ	P,EIRGNP
	TLNN	C,F.COMA
	JRST	GRONK
	PUSHJ	P,NXCH
	JRST	XWRIM4
XWRIM2:	PUSH	P,C
	PUSH	P,T
	PUSHJ	P,GETNUM
	JRST	.+1
	TLNN	C,F.COMA
	JRST	GRONK
XWRIM3:	POP	P,D
	POP	P,D
	HRLZ	A,N
	MOVEI	R,LINROL
	PUSHJ	P,SEARCH
	FAIL	<? UNDEFINED LINE NUMBER >,1
	PUSH	P,T
	MOVE	B,(B)
	HRRZI	T,(B)
	HRLI	T,440700
XWRIM7:	ILDB	C,T
	CAIN	C,":"
	JRST	XWRIM8
	CAIE	C," "
	CAIN	C,11
	JRST	XWRIM7
	FAIL	<? SPECIFIED LINE IS NOT AN IMAGE>
XWRIM8:	SETZ	A,
	PUSHJ	P,NXCHD
	PUSH	P,C
	PUSH	P,T
	TLNE	C,F.CR
	FAIL	<? NO CHARACTERS IN IMAGE>
	AOJ	A,.+1
	PUSHJ	P,NXCHD
	TLNN	C,F.CR
	AOJA	A,.-2
	MOVEI	E,4(A)
	MOVN	A,A
	HRLI	A,(A)
	MOVE	T,CESLT
	SUB	T,FLSLT
	HRRI	A,(T)
	MOVEI	R,LITROL
	PUSH	P,E
	PUSHJ	P,RPUSH
	POP	P,E
	IDIVI	E,5
	MOVEI	R,SLTROL
	PUSHJ	P,BUMPRL
	POP	P,T
	POP	P,C
	HRLI	B,440700
XWRIM9:	CAIN	C,15
	JRST	XWRM10
	IDPB	C,B
	ILDB	C,T
	JRST	XWRIM9
XWRM10:	MOVEI	R,SADROL
	MOVEI	A,
	PUSHJ	P,RPUSH
	SUB	B,FLSAD
	HRLI	B,SADROL
	MOVSI	D,(MOVE N,)
	PUSHJ	P,BUILDA
	POP	P,T
	PUSHJ	P,NXCH
XWRIM4:	MOVE	D,[PUSHJ P,%CHKIMG]
	JRST	BUILDI

XWRCHA:	TDZA	D,D
XWCHA:	SETO	D,
	PUSH	P,D
        PUSHJ   P,GETCNA        ;GET CHANNEL CODE
        MOVE    D,[PUSHJ P,%OUTST2]     ;RUNTIME OUTPUT SETUP ROUTINE
        PUSHJ   P,BUILDI
	MOVE	D,[SKIPN WRIPRI-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[SETOM WRIPRI-1(LP)]
	SKIPN	WRREFL
	MOVE	D,[AOS WRIPRI-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[SKIPL WRIPRI-1(LP)]
	SKIPN	WRREFL
	MOVE	D,[SKIPG WRIPRI-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %WRPRER]
	PUSHJ	P,BUILDI
	SKIPN	WRREFL
	JRST	XWCHA1
	MOVE	D,[MOVE N,MARGIN(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[CAMGE N,SEVEN]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %MARERR]
	PUSHJ	P,BUILDI
XWCHA1:	POP	P,D
	JUMPE	D,.+2
	POPJ	P,
	MOVE	D,[PUSHJ P,%IMGLIN]
	JRST	BUILDI

XWRI6:	MOVSI	D,(DATA 5,)
	PUSHJ	P,BUILDI
	MOVE	D,[PUSHJ P,%IMGLIN]
	PUSHJ	P,BUILDI

;CHECK THE VARIABLE LIST AFTER A PRINT USING TO THE TTY
;AND BUILD SUCCESSIVE CALLS TO THE IMAGE SCANNER AFTER
;EACH FORMULA IS CALLED
XWRI5:  SKIPE MATFLG
        POPJ P,
	TLNE	C,F.CR		;IF C.R. THEN END OF LIST (THIS ALSO
	JRST	XWRI7		;ALLOWS USING W/O VAR LIST)
	PUSHJ	P,FORMLB
	PUSHJ	P,EIRGNP
	MOVE	D,[PUSHJ P,%SCNIN]
	JUMPL	F,.+2
	MOVE	D,[PUSHJ P,%SCNIS]
	PUSHJ	P,BUILDI
	TLNN	C,F.COMA
	CAIN	C,";"
	JRST	.+2
	JRST	XWRI7
	PUSHJ	P,NXCH
        TLNE    C,F.CR
        JRST    .+2
	JRST	XWRI9
        SKIPE   XLFLG1
        JRST    XWRI8
        MOVE    D,[SETOM        XLFLG1]
        PUSHJ   P,BUILDI
        JRST    XWRI8
XWRI9:  SKIPE   XLFLG1
        JRST    XWRI5
        MOVE    D,[SETZM        XLFLG1]  ;TAKES CARE OF A,A,A;
        PUSHJ   P,BUILDI
        JRST    XWRI5
XWRI7:  SKIPE   XLFLG1
        JRST    XWRI8
        MOVE    D,[SETZM        XLFLG1]
        PUSHJ   P,BUILDI
XWRI8:	MOVE	D,[PUSHJ P,%ENDIMG]
	PUSHJ	P,BUILDI
        SETZM   XLFLG1
	JRST	NXTSTA

XPRRAN: SKIPE MATFLG
        SETOM RANFLG
        PUSHJ   P,GETCNA        ;GET CHANNEL FOR R.A. STATEMENT.
	MOVE	D,[SKIPL ACTBL-1(LP)]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %FNMXER]
	PUSHJ	P,BUILDI
	TLNN	C,F.COMA
	CAIN	C,":"
	JRST	.+2
	JRST	GRONK
	PUSHJ	P,NXCH
        SKIPE MATFLG
        POPJ P,
	PUSHJ	P,FORMLB
	MOVEM	F,IFFLAG
	JRST	XPRRN2
XPRRN1:	PUSHJ	P,NXCH
	PUSHJ	P,FORMLB
	XOR	F,IFFLAG
	JUMPGE	F,XPRRN2
	FAIL	<? MIXED STRINGS AND NUMBERS>
XPRRN2:	PUSHJ	P,EIRGNP
	MOVE	D,[PUSHJ P,%RNNUMO]
	SKIPL	IFFLAG
	HRRI	D,%RNSTRO
	PUSHJ	P,BUILDI
	TLNN	C,F.COMA
	CAIN	C,":"
	JRST	XPRRN1
	JRST	NXTSTA



XPRI1:	SKIPE	WRREFL
	JRST	GRONK
	MOVSI	D,(DATA 5,)	;TTY.
	PUSHJ	P,BUILDI
XPRI0:  SKIPE MATFLG
        JRST [SETZM MATFLG
                POPJ P,]
        	TLNE	C,F.TERM	;NON-USING STATEMENTS FROM HERE ON.
	JRST	XPCRLF
XPRI2:	PUSHJ	P,QSA
	ASCIZ /TAB/		;TAB FIELD?
	JRST	.+2		;NO, ASSUME EXPRESSION OR DELIMITER.
	JRST	XPRTAB		;YES, DO THE TAB
	TLNN	C,F.COMA
	CAIN	C,";"
	JRST	PRNDEL
	CAIE	C,"<"
	JRST	PRNEXP

;PRINT DELIMITER.

PRNDEL:	MOVSI	D,(PRDL)
	PUSHJ	P,CHKFMT
	PUSHJ	P,BUILDI
	JRST	XPRFIN

;PRINT EXPRESSION

PRNEXP:	PUSHJ	P,FORMLB	;GEN THE EXPRESSION
	JUMPL	F,.+3		;STR?
	MOVSI	D,(PRSTR)	;YES.
	JRST	.+3
	PUSHJ	P,GPOSNX	;MOVE TO REG IF UNCOMPLEMENTED OR INDEXED.
	MOVSI	D,(PRNM)	;SET UP OP CODE
	PUSHJ	P,CHKFMT	;SET FORMAT CODE
	PUSHJ	P,BUILDA	;GEN PRINT UUO
	JRST	XPRFIN		;GO FOR MORE


;PRINT TAB

XPRTAB:	PUSHJ	P,FORMLN	;EVALUATE TAB SUBEXPRESSION
	PUSHJ	P,EIRGNP	;MOVE IT INTO REG
	MOVSI	D,(PRNTB)	;CALL THE TAB INTERPRETER
XPRTA1:	PUSHJ	P,CHKFMT
	PUSHJ	P,BUILDI	;YES, BUILD THE INST.
XPRFIN:	TLNE	C,F.TERM	;CR AT END OF LINE?
	JRST	NXTSTA
	JRST	XPRI2		;NO.  GO FOR MORE

;HERE FOR PRINT WITH NO ARGUMENTS.  GEN CARRIAGE RETURN.

XPCRLF:	MOVE	D,[PUSHJ P,%CRLF]
	PUSHJ	P,BUILDI
	JRST	NXTSTA

;CHECK FORMAT CHAR (PRINT AND MAT PRINT)

CHKFMT:	TLNE	C,F.TERM
	TLO	D,40		;CR ... AC = 1
	CAIN	C,";"		;SC ... AC = 2
	TLO	D,100		;CMA ... AC = 3
	TLNE	C,F.COMA	;<PA> ... AC = 4
	TLO	D,140
	CAIE	C,"<"
	JRST	CHKFM2
	HRRZ	C,(P)
	CAIN	C,XMAT2B	;MAT STATEMENT CANNOT USE
	JRST	GRONK		;<PA>.
	PUSHJ	P,NXCH
	PUSHJ	P,QSA
	ASCIZ	/PA>/
	JRST	GRONK
	TLO	D,200
	POPJ	P,
CHKFM2:	TLNN	D,140		;WAS THERE A FMT CHAR?
	TLO	D,100		;NO. ASSUME ";"
	CAIE	C,";"
	TLNE	C,F.COMA	;SKIP FMT CHAR IF THERE WAS ONE.
	JRST	NXCHK		;YES.  SKIP
	POPJ	P,



;PAGE AND PAGE ALL STATEMENTS.
;
;CODE FOR THESE STATEMENTS IS COMPILED BY THE MARGIN AND
;MARGIN ALL ROUTINE, XMAG, WHICH SEE.

XPAG:	ASCIZ	/E/
	SETOM	TABLE
	JRST	XMAR0


;QUOTE AND QUOTE ALL STATEMENTS.
;
;CODE FOR THESE STATEMENTS IS COMPILED BY THE NOPAGE AND NOPAGE ALL
;ROUTINE, XNOP, WHICH SEE.

XQUO:	ASCIZ	/TE/
	MOVE	N,[SETOM QUOTBL]
	MOVEM	N,TABLE
	JRST	XNOP8

;RANDOM IZE STATEMENT

IFN FTRND,<
XRAN:	ASCIZ /DOM/
	PUSHJ	P,QSA
	ASCIZ	/IZE/
	JFCL
	TLNN	C,F.TERM
	JRST	ILLINS
	MOVE	D,[PUSHJ P,%RANDER]
	PUSHJ	P,BUILDI		;BUILD CALL TO RUNTIME RANDOMIZER
	JRST	NXTSTA			
>;ASSEMBLE ABOVE IF INCLUDING RANDOM FACILITY



;READ STATEMENT

XREAD:	ASCIZ /D/
	CAIN	C,":"
	JRST	XINRAN
	CAIN	C,"#"            ;# ?
	JRST	XINPT0
	SKIPL	DATAFF		;DATA SEEN YET?
	HLLOS	DATAFF	;NO.  SET NO DATA FLAG.
	MOVSI	D,(DATA 1,)
	PUSHJ	P,BUILDI
	MOVE	D,[PUSHJ P,%DOREAD]
	JRST	XINP0		;GO FINISH WITH INPUT CODE




;RESTORE STATEMENTS.

XREST:	ASCIZ	/TORE/
	TLNN	C,F.DOLL+F.STAR+F.TERM    ;$ OR * OR END OF STATEMENT ?
        CAMN    C,[XWD F.STR,"%"]       ;NO, %?
	JRST	XREST1    ;YES
XRES3:	CAIN	C,":"
	JRST	XRES5		;R.A. ARG.
	CAIN	C,"#"            ;# ?
        PUSHJ   P,NXCH         
        PUSHJ   P,GETCN2        ; RESTORE # STATEMENT
        MOVE    D,[PUSHJ P,%XRES2]  ;RUNTIME RESTORE # ROUTINE
        PUSHJ   P,BUILDI
XRES6:  TLNN    C,F.COMA
	CAIN	C,";"
	JRST	.+2
	JRST	NXTSTA
	PUSHJ	P,NXCH
	JRST	XRES3

XRES5:  PUSHJ   P,GETCNA        ;R.A. ARG
	MOVNI	A,4
XRES7:	MOVE	D,RESCOD+4(A)
	PUSHJ	P,BUILDI
	AOJL	A,XRES7
	JRST	XRES6

RESCOD:	SKIPL	ACTBL-1(LP)	;SOME OF THE CODE GENERATED.
	JRST	FNMXER
	MOVEI	N,1
	MOVEM	N,POINT-1(LP)


XREST1:	MOVE	D,[PUSHJ P,%RESTON] ;DATA RESTORE STATEMENT.
IFN FTSTR,<
        CAMN    C,[XWD F.STR,"%"]       ;% ?
        JRST    XRES2           ;YES
	TLNN	C,F.STAR+F.DOLL
	SOJA	D,XRES1
	TLNE	C,F.DOLL	;RESTORE ONLY STRINGS?
	ADDI	D,1
XRES2:	PUSHJ	P,NXCHK		;SKIP $ OR * OR %
>
XRES1:	PUSHJ	P,BUILDI
	JRST	NXTSTA



;RETURN STATEMENT XLATE

XRETRN:	ASCIZ	/URN/
	SKIPE	FUNAME
	FAIL	<? RETURN WITHIN DEF>
	MOVE	D,[JRST %RETURN]
XRET1:	PUSHJ	P,BUILDI	;XDEF ENTERS HERE TO COMPLETE A FN DEF.
	JRST 	NXTSTA



;STOP STATEMENT

XSTOP:	ASCIZ	/P/
	MOVE	D,[JRST %UXIT]
	PUSHJ	P,BUILDI
	JRST	NXTSTA
;GEN CODE TO EVALUATE FORMULA
;POINTER TO (POSSIBLY NEGATIVE) RESULT RETURNED IN B

;THIS LOOP HANDLES SUMS OF TERMS, CALLS TERM TO HANDLE PRODUCTS
;AND SO ON
;THE ENTRY POINT FORMLN REGARDS ONLY NUMERIC FORMULAS AS LEGAL.
;THE ENTRY POINT FORMLS REGARDS ONLY STRING FORMULAS AS LEGAL.
;THE ENTRY POINT FORMLB WILL ACCEPT EITHER A STRING OR A NUMERIC FORMULA.
;THE ENTRY POINT FORMLU EXPECTS THE LEGALITY TO BE DEFINED EXTERNALLY.

FORMLS:	HRLZI	F,1
	JRST	FORMLU
FORMLB:	TDZA	F,F
FORMLN:	SETOI	F,
FORMLU:	PUSHJ	P,TERM		;GET FIRST TERM

;ENTER HERE FOR MORE SUMMANDS

FORM1:	TLNN	C,F.PLUS+F.MINS	;IS BREAK PLUS OR "-"?
	POPJ	P,		;NO, SO DONE WITH FORMULA
	MOVMS	LETSW		;THIS CANT BE LH(LET)
	TLNN	C,F.MINS
	JRST	FORM2
	JUMPL	F,FORM3
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	JRST	FORM3
FORM2:	JUMPL	F,FORM3
FORM21:	PUSHJ	P,EIRGNP
	SKIPL	VRFSET
	JRST	FORM4
	SKIPE	FUNAME
	JRST	FORM4
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSHJ	P,BUILDI
	SETZM	VRFSET
FORM4:	MOVE	D,[AOS T,MASAPP]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,(T)]
	PUSHJ	P,BUILDI
	PUSHJ	P,TERM
	PUSHJ	P,EIRGNP
	MOVE	D,[PUSHJ P,%APPEND]
	PUSHJ	P,BUILDI
	SETZ	B,
	TLNN	C,F.PLUS
	POPJ	P,
	JRST	FORM21
FORM3:	PUSHJ	P,PUSHPR	;PART RESLT TO SEXROL
	PUSHJ	P,TERM		;GEN SECOND TERM
	TLNE	B,ROLMSK	;IS SECOND TERM IN REG?
	PUSHJ	P,EXCHG		;NO.  LETS DO FIRST TERM FIRST
	PUSHJ	P,EIRGEN	;FIRST SUMMAND TO REG
	PUSH	P,B		;SAVE SIGN INFORMATION
	PUSHJ	P,POPPR		;GET SECOND SUMMAND
	SKIPGE	(P)		;IS CONTENT OR REG NEGATIVE?
	TLC	B,MINFLG	;YES, NEGATE SECOND SUMMAND
	MOVSI	D,(FADR N,)	;FETCH INSTRUCTION
	PUSHJ	P,BUILDS	;BUILD ADD OR SUB INSTR
	POP	P,B		;REG PNTR WITH SIGN
	AND	B,[XWD MINFLG,0]
	JRST	FORM1		;GO LOOK FOR MORE SUMMANDS
;LOOP TO GEN CODE FOR MULTIPLY AND DIVIDE
;CALLS FACTOR TO HANDLE EXPRESSIONS INVOLVING ONLY INFIX OPS AND "^"

TERM:	PUSHJ	P,FACTOR	;GEN FIRST FACTOR

;ENTER HERE FOR MORE FACTORS

TERM1:	TLNN	C,F.STAR+F.SLSH	;MUL OR DIV FOLLOWS?
	POPJ	P,		;NO, DONE WITH TERM.
	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	MOVMS	LETSW		;THIS CANT BE LH(LET)
	HRRZS	0(P)		;SET MUL FLAG.
	TLNN	C,F.STAR	;IS IT MULTIPLY?
	HRROS	0(P)		;NO. SET DIV FLAG
TERM2:	PUSHJ	P,NXCHK		;SKIP OVER CONNECTIVE
	PUSHJ	P,PUSHPR	;STASH PARTIAL RESULT ON SEXROL
	PUSHJ	P,FACTOR	;GEN NEXT FACTOR
	SKIPGE	(P)		;IS SECOND FACTOR A DIVISOR?
	PUSHJ	P,SITGEN	;YES. IT CANNOT STAY IN REG.
	TLNE	B,ROLMSK	;IS SECOND FACTOR IN REG?
	PUSHJ	P,EXCHG		;NO. LETS GET FIRST FACTOR.
	MOVE	X1,CESEX	;PEEK AT DIVISOR OR SECOND FACTOR.
	MOVE	X2,-1(X1)
	TLZE	X2,MINFLG	;IS IT MINUS?
	TLC	B,MINFLG	;YES. CHANGE SIGNS OF BOTH.
	MOVEM	X2,-1(X1)	;NOW DIVISION OR SECOND FACTOR IS PLUS.
	PUSHJ	P,EIRGEN	;GEN FIRST FACTOR OR DIVIDEND
	PUSH	P,B		;SAVE SIGN INFORMATION
	PUSHJ	P,POPPR		;GET SECOND OPERAND
	MOVSI	D,(FMPR N,)	;GET CORRECT INSTRUCTION
	SKIPGE	-1(P)
	MOVSI	D,(FDVR N,)
	PUSHJ	P,BUILDA	;BUILD MUL OR DIV INSTR
	POP	P,B		;REG PNTR WITH SIGN
	JRST	TERM1		;GO LOOK FOR MORE FACTORS
;GEN CODE FOR ATOMIC FORMULAS, EXPONENTIATION, AND INFIX SIGNS
;SIGN IS STASHED IN LH OF PUSH-DOWN LIST WORD WITH RETURN ADDRS
;EXPLICIT SIGN IS NOT USED UNTIL AFTER EXPONENTIATION
;IS CHECKED FOR.


FACTOR:	PUSH	P,C		;STASH SIGN IN PUSH LIST.
	TLNN	C,F.MINS	;EXPLICIT MINUS SIGN?
	JRST	FACT2		;NO.
	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	TLC	C,F.PLUS+F.MINS	;YES. PRETEND IT WAS PLUS CALLING ATOM.
	MOVMS	LETSW		;AND THIS CANNOT BE LH OF LET.

FACT2:	PUSHJ	P,ATOM		;GEN FIRST ATOM


FACT2A:	CAIN	C,"^"		;EXPONENT FOLLOWS?
	JRST	FACT3A		;YES.
	TLNN	C,F.STAR	;MAYBE.
	JRST	SNOEXI		;NO.  GO NOTE SIGN AND RETURN.
	MOVEM	T,X1
	PUSHJ	P,NXCHK
	TLNE	C,F.STAR
	JRST	FACT3A		;YES.
	MOVE	T,X1		;NO.  GO NOTE SIGN AND RETURN.
	MOVE	C,[XWD F.STAR, "*"]
	JRST	SNOEXI
FACT3A:	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	MOVMS	LETSW		;THIS CANT BE LH(LET)
	PUSHJ	P,NXCHK		;YES.  SKIP EXPONENTIATION SIGN
	PUSHJ	P,PUSHPR	;STASH BASE ON SEXROL
	PUSHJ	P,ATOM		;GEN THE EXPONENT
	PUSHJ	P,EXCHG		;EXCHANGE BASE AND EXPONENT
	PUSHJ	P,EIRGNP	;GET POSITIVE BASE IN REG
	PUSHJ	P,POPPR		;GET EXPONENT IN AC1
	MOVSI	D,(MOVE 1,)
	PUSHJ	P,BUILDS
	MOVE	D,[PUSHJ 17,%EXP3.0]
	PUSHJ	P,BUILDI	;BUILD CALL TO EXPONENTIATION ROUTINE
	MOVEI	B,0		;ANSWER LANDS IN REG
	JRST	FACT2A


;SIGN NOTE AND EXIT
;COMPLEMENT SIGN IF "-" AND APPROPRIATE FLAGS ON PD LIST.
;THEN RETURN FROM SUBROUTINE.

SNOEXI:	POP	P,X1
	TLNE	X1,F.MINS		;IS SAVED SIGN MINUS?
	TLC	B,MINFLG		;YES. COMPLEMENT
	POPJ	P,
;GEN CODE FOR SIGNED ATOM.

ATOM:	PUSH	P,C		;SAVE SIGN INFO.
	TLNE	C,F.PLUS	;EXPLICIT SIGN?
	JRST	ATOM1
	TLNN	C,F.MINS
	JRST	ATOM2
	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
ATOM1:	PUSHJ	P,NXCHK		;YES. SKIP SIGN
ATOM2:	TLNE	C,F.LETT	;LETTER?
	JRST	FLETTR		;YES. VARIABLE OR FCN CALL.
	TLNE	C,F.DIG+F.PER	;NUMERAL OR DECIMAL POINT?
	JRST	FNUMBR		;YES. LITERAL OCCURRENCE OF NUMBER
	TLNE	C,F.QUOT
	JRST	REGSLT		;STR CONSTANT.
	CAIE	C,"("		;SUBEXPRESSION?
	JRST	ILFORM		;NO.  ILLEGAL FORMULA

FSUBEX:	PUSHJ	P,NXCHK		;SUBEXPR IN PARENS.  SKIP PAREN
	PUSHJ	P,FORMLU	;GEN THE SUBEXPRESSION
	TLNN	C,F.RPRN	;BETTER HAVE MATCHING PAREN
	JRST	ILFORM		;NO.  GRONK.
	PUSHJ	P,NXCHK		;SKIP PARENTHESIS
	JRST	SNOEXI		;GO TEST SIGN AND RETURN.


;HERE WHEN ATOMIC FORMULA IS A NUMBER

FNUMBR:	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	MOVMS	LETSW
	PUSH	P,F
	PUSHJ	P,EVANUM	;EVALUATE NUMBER (IN N)
	FAIL	<? ILLEGAL CONSTANT>
	POP	P,F
	MOVE	X1,0(P)		;GET SIGN FLAG
	CAIE	C,"^"		;EXPONENT FOLLOWS?
	TLNN	X1,F.MINS	;OR IS IT PLUS ANYWAY?
	JRST	FNUM1		;YES.  DONT FUDGE SIGN
	TLNN	C,F.STAR	;CHECK FOR OTHER KIND OF EXPONENT.
	JRST	FNUM5		;NO, NOT THIS KIND OF EXP EITHER.
	MOVEM	T,B
	PUSHJ	P,NXCH
	MOVE	T,B
	TLNE	C,F.STAR
	JRST	FNUM1		;YES, EXPONENT.
	MOVE	C,[XWD F.STAR,"*"]
FNUM5:	MOVN	N,N		;NEGATE NUMBER
	SETZM	0(P)		;AND CLEAR SIGN INFO.

FNUM1:	MOVE	B,FLCON	;SEARCH CONSTANT ROLL
FNUM2:	CAML	B,CECON	;(UNSORTED--CANT USE SEARCH)
	JRST	FNUM3		;NOT FOUND
	CAME	N,(B)		;THIS ONE?
	AOJA	B,FNUM2		;NO. GO TO NEXT.
	SUB	B,FLCON	;FOUND. CALC REL ADDRESS IN CONROL.
	JRST	FNUM4

FNUM3:	MOVEI	R,CONROL	;PUSH ON CONROL
	MOVE	A,N
	PUSHJ	P,RPUSH
	MOVEI	R,CADROL	;PUT ADDRS ON CONST ADDRS ROLL
	MOVEI	A,0
	PUSHJ	P,RPUSH
	SUB	B,FLCAD	;GET REL ADDRS

FNUM4:	HRLI	B,CADROL	;MAKE POINTER
	JRST	SNOEXI		;GO LOOK AT SIGN AND RETURN.

NNUM:	PUSH	P,[EXP 1]	;REGISTER THE CONSTANT IN "N"
	JRST	FNUM1
;XLATE AND GEN ATOMIC FORMULA BEGINNING WITH LETTER

FLETTR:	PUSHJ	P,REGLTR
FLET1:	JRST	.+1(A)
	JRST	XARFET		;ARRAY REF
	JRST	SNOEXI		;SCALAR.  JUST RETURN
	JRST	XINFCN		;INTRINSIC FCN
	JRST	XDFFCN		;DEFINED FCN
	JRST	ILVAR
IFN FTSTR,<
	JRST	XARFET		;STRING VECTOR. PROCESS WITH ARRAY CODE!
	JRST	SNOEXI		;POINTER IS IN B FOR BUILDING.
>
FLET2:	PUSH	P,[EXP 1]	;PUSH AN IMPLICIT PLUS SIGN ON PLIST
	JRST	FLET1		;FINISH REGISTERING VARIABLE.

XARFET:	PUSH	P,A
	PUSH	P,B
	PUSHJ	P,REGFRE	;FREE REG
	PUSHJ	P,XARG
	JUMPG	F,XARF1		;STRING VECTOR?
	SKIPL	LETSW		;NO, IS IT LH OF ARRAY-LET?
	JRST	XARF1		;DO A FETCH AS USUAL.
	TLNN	C,F.EQAL	;IS IT DEFINITELY LH OF ARRAY-LET?
	JRST	XARF1		;NO.

	POP	P,X1		;YES. DON'T FETCH! RETURN TO LH(LET)
	POP	P,A
	SUB	P,[XWD 6,6]	;ADJUST THE PUSHLIST TO ESC FORMLS
	MOVE	A,1(P)
	PUSH	P,B		;SAVE THE ARGUMENT FLAG
	PUSH	P,X1		;SAVE THE ARRAY POINTER
	JRST	(A)

XARF1:	MOVSI	D,(ARFET1)
IFN	FTSTR,<
	JUMPL	F,.+2		;STR VECTOR?
	MOVSI	D,(SVRADR)	;YES. FETCH STRING POINTER ADDRESS.
>
	JUMPE	B,XARFFN
	JUMPL	F,.+2
	FAIL <? STRING VECTOR HAS 2 DIMS>
	MOVSI	D,(ARFET2)
	MOVE	X1,-1(P)	;MARK DOUBLE ARRAY
	ADD	X1,FLOOR(F)
	SKIPN	1(X1)
	SETOM	1(X1)
XARFFN:	EXCH	B,0(P)
	PUSHJ	P,BUILDA
	POP	P,B
	PUSHJ	P,GENARG
	MOVEI	B,0		;REG POINTER
	JUMPL	F,.+2		;STRING VECTOR?
	PUSHJ	P,SITGEN	;YES,SAVE ADDRESS POINTER
	POP	P,A
	JRST	SNOEXI
;GEN FUNCTION CALLS

XDFFCN:	PUSH	P,D		;SAVE FCN NAME
	PUSHJ	P,REGFRE	;SAVE ANY SUBEXPRESSION
	PUSHJ	P,PUSHPR	;SAVE FUNCTION LOCATION
	MOVE	D,[PUSHJ P,%SAVACS]
	PUSHJ	P,BUILDI
	CAIE	C,"("	;ANY ARGS?
	JRST	XDFF2		;NO
	SETZM	PSHPNT		;INITIALIZE COUNT OF PUSH INSTS GENNED
XDFF1:	PUSHJ	P,NXCHK
	PUSH	P,LETSW
	MOVMS	LETSW
	PUSHJ	P,FORMLN	;GEN THE ARGUMENT IN REG
	POP	P,LETSW
	JUMPGE	B,.+2
	PUSHJ	P,EIRGP1
	MOVSI	D,(PUSH Q,)	;BUILD ARGUMENT PUSH
	PUSHJ	P,BUILDA
	AOS	PSHPNT		;COUNT THE PUSH
	AOS	(P)		;ALSO SAVE THE COUNT FOR CHECK OF ARGS
	TLNE	C,F.COMA		;MORE ARGS?
	JRST	XDFF1		;YES

	TLNN	C,F.RPRN		;CHECK FOR MATCHING PAREN
	JRST	GRONK
	SETZM	PSHPNT		;RESET THE PUSH COUNT AGAIN
	PUSHJ	P,NXCHK		;SKIP PAREN

XDFF2:	PUSHJ	P,ARGCHK	;CHECK FOR RIGHT NUMBER OF ARGUMENTS
	POP	P,X1		;GET RID OF POINTER TO ARG# CONSTANT
	PUSHJ	P,POPPR		;GET BACK FUNCTION LOC
	MOVSI	D,(GOSUB)
	PUSHJ	P,BUILDA	;GEN THE CALL
	MOVEI	B,0		;ANSWER IS IN REG
	JRST	SNOEXI

;ROUTINE TO CHECK NUMBER OF ARGUMENTS AND CREATE A CONSTANT TO POP THEM
;OFF THE PUSH LIST.  CALLED WITH	XWD FCNAME,# OF ARGS
;AT LOCATION -1(P)	RETURNS WITH A POINTER TO CONSTANT
;AT THAT LOCATION.

ARGCHK:	HRRZ	N,-1(P)
	HRL	N,N		;N NOW CONTAINS THE CONSTANT TO SUBTRACT FROM P
	PUSHJ	P,NNUM		;REGISTER THIS CONSTANT
	MOVE	N,-1(P)		;GET FCN NAME
	MOVEM	B,-1(P)		;SAVE ADDRESS OF CONSTANT
	HRR	N,B		;ASSEMBLE FADROL ENTRY...
	HLLZ	A,N		;SETUP SEARCH ARGUMENT
	MOVEI	R,FADROL	; XWD FCNAME,CONSTANT ADDRESS
	PUSHJ	P,SEARCH
	JRST	ARGCH1		;FIRST TIME FCN SEEN. PUT ENTRY IN ROLL
	CAMN	N,(B)		;FCN SEEN BEFORE. SAME NUMBER OF ARGS?
	POPJ	P,
	SETZM	FUNAME
ARGCH0:	FAIL	<? INCORRECT NUMBER OF ARGUMENTS>

ARGCH1:	MOVEI	E,1		;ADD FCN REF TO FADROL
	PUSHJ	P,OPENUP
	MOVEM	N,(B)
	POPJ	P,

;INTRINSIC FUNCTION GENERATOR.
XINFCN:	PUSH	P,B		;SAVE FCN LOC
	PUSHJ	P,REGFRE	;PROTECT ANY PARTIAL RESULT
	POP	P,B
	PUSH	P,B
	TLNE	B,777777
	JRST	XINF2		;>= 1 ARG, LIB. ROUTINE.
	CAIGE	B,%FN
	JRST	XINF4		;INLINE CODE.
	CAIE	C,"("		;OP. ARG, LIB. ROUTINE.
	JRST	XINF1
	PUSHJ	P,NXCH		;DO NOT PUT A STR
	PUSH	P,F
	PUSHJ	P,FORMLB	;ARG IN MASAPP, BECAUSE
	POP	P,F		;THESE LIB. ROUTINES DO NOT
XINF0:	TLNN	C,F.RPRN	;CLEAR IT.
	JRST	ILFORM
	PUSHJ	P,NXCH
XINF1:	POP	P,D
	HRLI	D,(PUSHJ P,)
XINF11:	PUSHJ	P,BUILDI
	MOVEI	B,0
	JRST	SNOEXI

XINF2:	CAIE	C,"("		;>= 1 ARG, LIB. ROUTINE.
	JRST	ARGCH0
	HLRE	D,B
	MOVM	D,D
	PUSH	P,F
	CAIE	D,1
	JRST	XINF21
	HLLZ	F,B
	MOVEI	X1,1
	JRST	XINF22
XINF21:	HLRZ	D,B
	MOVE	X1,(D)
	CAIN	X1,3
	JRST	XINF3
XINF20:	HLLZ	F,1(D)		;NOT MID$ OR INSTR.
XINF22:	PUSH	P,X1		;ALL ARGS ARE REQUIRED.
	PUSH	P,D
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLU
	PUSHJ	P,EIRGNP
	JUMPL	F,XINF23	;STR?
	MOVE	D,[AOS T,MASAPP]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,(T)]
	PUSHJ	P,BUILDI
XINF23:	POP	P,D
	POP	P,X1
	SOJN	X1,.+3
	POP	P,F
	JRST	XINF0
        HRLE    F,1(D)          ; TYPE OF 1ST ARG
        JUMPGE  F,XINF24        ;STRING
        PUSH    P,D             ;NUMERIC MUST BE ROUND
        MOVE    D,[PUSH P,N]    ;BUILD INSTRUCTION TO SAVE 1ST ARG
        PUSHJ   P,BUILDI        ;
        MOVEI   X1,1            ;ONE MORE TO GO
        POP     P,D             ;RESTORE D
        TLNE    C,F.COMA        ;COMMA NEXT?
        AOJA    D,XINF20        ;YES
        MOVE    D,[MOVEI N,0]   ;NO, USE DEFAULT SECOND (0)
        PUSHJ   P,BUILDI        ;BUILD INSTRUCTION
        POP     P,F             ;
        JRST    XINF0           ;
XINF24: TLNN    C,F.COMA        ;COMMA NEXT
        JRST    ILFORM          ;NO, ERROR
        AOJA    D,XINF20        ;

XINF3:	SKIPG	1(D)
	JRST	XINF31
	PUSHJ	P,XINST1	;MID$.
	PUSHJ	P,XINNUM
	POP	P,F		;RESTORE F.
	TLNN	C,F.COMA
	JRST	XINF0
	MOVE	D,[PUSH P,N]
	PUSHJ	P,BUILDI
	PUSHJ	P,XINNM1
	HRLI	F,1		;RESTORE F.
	JRST	XINF01
XINF31:	PUSHJ	P,NXCH		;INSTR.
	SKIPN	FUNAME
	SKIPL	VRFSET
	JRST	.+4
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSHJ	P,BUILDI
	SETZM	VRFSET
	PUSHJ	P,FORMLB
	PUSHJ	P,EIRGNP
	JUMPG	F,XINF34
	MOVE	D,[PUSH P,N]
	PUSHJ	P,BUILDI
	JRST	XINF32
XINF34:	MOVE	D,[AOS T,MASAPP]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,(T)]
	PUSHJ	P,BUILDI
	PUSHJ	P,XINSTR
	POP	P,F
	JRST	XINF0
XINF32:	PUSHJ	P,XINSTR
	PUSHJ	P,XINSTR
	POP	P,F
XINF01:	TLNN	C,F.RPRN
	JRST	ILFORM
	PUSHJ	P,NXCH
	POP	P,D
	HRRZI	D,(D)
	ADD	D,[PUSHJ P,3]
	JRST	XINF11

XINSTR:	TLNN	C,F.COMA	;SUBR FOR STR ARG.
	JRST	ILFORM
XINST1:	PUSHJ	P,NXCH
	PUSHJ	P,FORMLS
	PUSHJ	P,EIRGNP
	MOVE	D,[AOS T,MASAPP]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVEM N,(T)]
	JRST	BUILDI

XINNUM:	TLNN	C,F.COMA	;SUBR FOR NUMERIC ARGUMENT.
	JRST	ILFORM
XINNM1:	PUSHJ	P,NXCH
	PUSHJ	P,FORMLN
	JRST	EIRGNP

XINF4:	POP	P,B
	JRST	.(B)		;IN LINE CODE.
	JRST	ABSBI
	JRST	ASCBI
	JRST	DETBI
        JRST    EPSBI
	JRST	LOCBI
	JRST	LOFBI
	JRST	NUMBI
	JRST	SGNBI

;IN LINE FUNCTION GENERATORS.

ABSBI:	CAIE	C,"("		;ABS FUNCTION.
	JRST	ARGCH0
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLN
	PUSHJ	P,EIRGNM
	TLNN	C,F.RPRN
	JRST	ILFORM
	JRST	INLIO2
INLIOU:	TLNN	C,F.RPRN
	JRST	ILFORM
INLIO0:	PUSHJ	P,BUILDI
INLIO2:	PUSHJ	P,NXCH
INLIO1:	MOVEI	B,0
	JRST	SNOEXI


ASCBI:	CAIE	C,"("		;ASC FUNCTION.
	JRST	ARGCH0
	SETZ	X2,
	PUSHJ	P,NXCHD
	TLNN	C,F.RPRN
	JRST	ASCB11
	PUSH	P,T
	PUSHJ	P,NXCH
	TLNN	C,F.RPRN
	JRST	ASCBI0
	POP	P,T
	JRST	ASCBI3
ASCB11:	TLNN	C,F.SPTB
	JRST	ASCBI3
	MOVE	X1,C		;BLANKS AND TABS.
ASCBI1:	PUSHJ	P,NXCHD		;IF ONLY BLANKS ARE
	TLNE	C,F.RPRN	;PRESENT, THE ARG IS A
	JRST	ASCBI2		;BLANK.  IF ONLY BLANKS
	TLNE	C,F.CR		;AND TABS ARE PRESENT, THE
ASCBI0:	FAIL	<? ILLEGAL ARGUMENT FOR ASC FUNCTION> ;ARG IS
	TLNN	C,F.SPTB	;A TAB. O'E, THE BLANKS
	JRST	ASCBI3		;AND TABS ARE IGNORED.
	CAME	C,X1
	CAMN	C,X2
	JRST	ASCBI1
	MOVE	X2,C
	JRST	ASCBI1
ASCBI2:	MOVE	C,X1
	JUMPE	X2,.+2
	MOVE	C,[XWD F.SPTB,11]
	PUSH	P,T
	HRRZ	A,C
	PUSHJ	P,NXCH
	TLNE	C,F.RPRN
	JRST	ASCB21
	POP	P,T
	ROT	A,-7
	JRST	ASCBI5
ASCB21:	POP	P,T
	HRLZI	A,500000
	JRST	ASCBI5

ASCBI3:	PUSHJ	P,SCNLT1
	TLNE	C,F.RPRN
	JRST	ASCBI5		;1 CHAR ARG.
	TLNE	C,F.TERM
	JRST	ILFORM
	PUSHJ	P,SCN2
	JUMP
	TLNE	C,F.RPRN
	JRST	ASCBI6		;2 CHAR CODE.
	TLNE	C,F.TERM
	JRST	ILFORM
	PUSHJ	P,SCN3
	JUMP
	TLNN	C,F.RPRN
	JRST	ILFORM
	JRST	ASCBI6		;THREE CHAR CODE.

ASCBI5:	PUSH	P,N		;SET UP IN LINE CODE.
	LDB	N,[POINT 7,A,6]
ASCB51:	PUSHJ	P,IFLOAT
	HLRZ	D,N
	POP	P,N
ASCB52:	HRLI	D,(HRLZI N,)
	JRST	INLIO0		;EXIT.

ASCBI6:	PUSH	P,N		;SEARCH.
	HLRZ	A,A
	MOVEI	X1,ASCFLO
	ADDI	X1,1
ASCBI7:	HLRZ	X2,-1(X1)
	CAIN	A,(X2)
	JRST	ASCBI8
	HRRZ	X2,-1(X1)
	CAIN	A,(X2)
	JRST	ASCBI9
	CAIGE	X1,ASCCEI
	AOJA	X1,ASCBI7
	JRST	ASCBI0
ASCBI8:	SUBI	X1,ASCFLO
	MOVEI	N,2(X1)
	CAIG	X1,^D10
	MOVEI	N,-1(X1)
	JRST	ASCB51
ASCBI9:	SUBI	X1,ASCFLO
	MOVEI	N,22(X1)
	CAIN	X1,^D15
	MOVEI	N,^D127
	JRST	ASCB51


;TABLE OF CODES FOR THE ASC FUNCTION.

ASCFLO:	SIXBIT	/NULDC3/
	SIXBIT	/SOHDC4/
	SIXBIT	/STXNAK/
	SIXBIT	/ETXSYN/
	SIXBIT	/EOTETB/
	SIXBIT	/ENQCAN/
	SIXBIT	/ACKEM /
	SIXBIT	/BELSUB/
	SIXBIT	/BS ESC/
	SIXBIT	/HT FS /
	SIXBIT	/CR GS /
	SIXBIT	/SO RS /
	SIXBIT	/SI US /
	SIXBIT	/DLESP /
	SIXBIT	/DC1DEL/
	SIXBIT	/DC2   /
ASCCEI:


DETBI:	CAIE	C,"("		;DET FUNCTION.
	JRST	DETBI1
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLB
	HRLI	F,777777	;RESTORE F.
	MOVE	D,[MOVE N,DETER]
	JRST	INLIOU
DETBI1:	MOVE	D,[MOVE N,DETER]
	PUSHJ	P,BUILDI
	JRST	INLIO1

EPSBI:  CAIE    C,"("           ;EPS FUNCTION
        JRST    EPSBI1          ;NO ()
        PUSHJ   P,NXCH          ;NEXT CHAR (FOR FORMLB)
        PUSHJ   P,FORMLB        ;TRANSLATE FORMULA
        HRLI    F,777777        ;RESTORE F
        MOVE    D,[MOVE N,EPSER]        ;GENERATE CODE FOR EPS
        JRST    INLIOU          ;
EPSBI1: MOVE    D,[MOVE N,EPSER]        ;GENERATE CODE FOR EPS
        PUSHJ   P,BUILDI        ;BUILD INSTRUCTION
        JRST    INLIO1          ;

LOCBI:	SETZM	LOCLOF		;LOC FUNCTION.
LOCBI1:	CAIE	C,"("		;LOF ENTERS HERE.
	JRST	ARGCH0
	PUSHJ	P,NXCH
	CAIN	C,":"
	PUSHJ	P,NXCH
        PUSHJ   P,GETCN0        ;GET CHANNEL CODE
        HRLZI   D,(MOVE X1,)    
	PUSHJ	P,BUILDI
	MOVE	D,[SKIPL ACTBL-1(X1)]
	PUSHJ	P,BUILDI
	MOVE	D,[JRST %FNMX0]
	PUSHJ	P,BUILDI
	MOVE	D,[MOVE N,POINT-1(X1)]
	SKIPE	LOCLOF
	MOVE	D,[MOVE N,LASREC-1(X1)]
	PUSHJ	P,BUILDI
	MOVE	D,[PUSHJ P,%IFLOAT]
	JRST	INLIOU

LOFBI:	SETOM	LOCLOF		;LOF FUNCTION.
	JRST	LOCBI1


NUMBI:	CAIE	C,"("		;NUM FUNCTION.
	JRST	NUMBI1
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLB
	HRLI	F,777777	;RESTORE F.
	MOVE	D,[MOVE	N,NUMRES]
	JRST	INLIOU
NUMBI1:	MOVE	D,[MOVE N,NUMRES]
	PUSHJ	P,BUILDI
	JRST	INLIO1

SGNBI:	CAIE	C,"("		;SGN FUNCTION.
	JRST	ARGCH0
	PUSHJ	P,NXCH
	PUSHJ	P,FORMLN
	PUSHJ	P,EIRGNP
	HRRZ	D,CECOD
	ADDI	D,5
	HRLI	D,(JUMPE N,)	;0 FOR 0.
	PUSHJ	P,BUILDI
	MOVE	D,[HRLZI T,201400]
	PUSHJ	P,BUILDI
	HRRZ	D,CECOD
	ADDI	D,2
	HRLI	D,(JUMPG N,)	;1.0 FOR > 0.
	PUSHJ	P,BUILDI
	MOVE	D,[MOVN T,T]	;-1.0 FOR < 0.
	PUSHJ	P,BUILDI
	MOVE	D,[MOVE N,T]
	JRST	INLIOU
;ROUTINE TO XLATE ARGUMENTS
;RETURNS WITH ARGS ON SEXROL.  B IS O IF ONE ARG, -1 IF TWO.

XARG:	PUSHJ	P,NXCHK		;SKIP PARENTHESIS.
	PUSH	P,LETSW		;SAVE LETSW WHILE TRANSL ARGS
	MOVMS	LETSW		;THE COMMA FOLLOWING AN ARG IS NOT LH(LET)!
	PUSH	P,F
        PUSHJ P,FORMLB
	JUMPL	F,XARG0
XARG3:	FAIL	<? NESTED STRING VECTORS>
XARG0:	POP	P,F
	PUSHJ	P,GPOSNX
	PUSHJ	P,SITGEN
	PUSHJ	P,PUSHPR
	MOVEI	B,0
	TLNN	C,F.COMA	;COMMA FOLLOWS?
	JRST	XARG1		;NO. ONE ARG.
	PUSHJ	P,NXCHK		;YES GEN AND SAVE SECOND ARG
	PUSH	P,F
	PUSHJ	P,FORMLB
	JUMPG	F,XARG3
	POP	P,F
	PUSHJ	P,GPOSNX
	PUSHJ	P,SITGEN
	PUSHJ	P,PUSHPR
	MOVNI	B,1		;DBL ARG FLAG
XARG1:	POP	P,LETSW		;RESTORE LETSW
	TLNN	C,F.RPRN	;MUST HAVE PARENTHESIS
	JRST	ILFORM
	JRST	NXCHK		;IT DOES. SKIP PAREN AND RETURN.


;ROUTINE TO GEN ARGUMENTS

GENARG:	JUMPE	B,GENAFN		;ONE OR TWO ARGS?
GENAR0:	PUSHJ	P,POPPR		;TWO
	PUSHJ	P,EXCHG
	PUSHJ	P,GENAF1

GENAFN:	PUSHJ	P,POPPR
GENAF1:	MOVSI	D,(JUMP 2,)
	JRST	BUILDA
;ROUTINE TO ANALYZE NEXT ELEMENT
;CALL:	PUSHJ	P,REGLTR
;RETURNS ROLL PNTR IN B, CODE IN A
;CODE IS: 0-ARRAY, 1-SCALAR, 2-INTRINSIC FCN, 3-DEFINED FCN, 4-FAIL
;		5-STRING VECTOR, 6-STRING VARIABLE, 7-STRING LITERAL.

REGLTR:	PUSHJ	P,SCNLT1	;LTR TO A, LEFT JUST 7 BIT
	HRRI	F,SCAROL	;ASSUME SCALAR
	TLNE	C,F.LETT	;ANOTHER LETTER?
	JRST	REGFCN		;YES.  GO LOOK FOR FCN REF
	TLNN	C,F.DIG		;DIGIT FOLLOWS?
	JRST	REGARY		;NO, GO CHECK FOR ARRAY
	DPB	C,[POINT 7,A,13];ADD DIGIT TO NAME
	PUSHJ	P,NXCHK		;GO ON TO NEXT CHAR
IFN FTSTR,<
	TLNE	C,F.DOLL	;STRING VARIABLE?
	JRST	REGSTR		;YES. REGISTER IT.
>
	CAIN	C,"("
	JRST	REGARY
	JUMPL	F,REGL1
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777

;RETURN HERE IF REGARY SAYS NOT ARRAY
;RETURN HERE IF REGFCN SAYS FOLLOWED BY KEYWORD.

REGL1:	TLNE	A,17		;IS THIS A SCALAR?
	JRST	REGL1A		;NO. DON'T LOOK FOR FCN ARGUMENT
	MOVE	B,FLARG		;IS THIS A FN ARG?
	CAML	B,CEARG		;SEARCH UNORDERED ARGROL
	JRST	REGL1A		;NOT A FN ARG
	CAME	A,(B)
	AOJA	B,.-3		;TRY NEXT ROLL ENTRY.

	JRST	FARGRF		;YES
REGL1A:	MOVEI	R,VARROL	;NO. SCALAR
	PUSHJ	P,SEARCH	;IN VARIABLE ROLL?
	JRST	REGL2		;NO

	HRRZ	D,(B)		;YES.  GET PNTR TO SCAROL
	JRST	REGL3

REGL2:	MOVEI	E,1		;ADD TO SCALAR ROLL OR VSPROL
	PUSHJ	P,OPENUP
	ADD	A,CEIL(F)	;COMPUTE PNTR TO ROLL
	SUB	A,FLOOR(F)
	HRRZ	D,A		;SAVE ROLL POINTER
	MOVEM	A,(B)
	MOVEI	R,(F)	;PUT NULL ENTRY ON ROLL
	MOVEI	A,0
	PUSHJ	P,RPUSH

;	B ::= REL LOC OF ROLL ENTRY

REGL3:	MOVE	B,D		;B ::= REL LOC OF ROLL ENTRY
	TLO	B,(F)	;MAKE ROLL POINTER AND SKIP
	JRST	REGSCA

;COME HERE ON REF TO FCN ROL

;CALCULATE ADDRESS OF THIS FUNCTION ARGUMENT.
FARGRF:	SUB	B,CEARG	;NOW ADDRESS IS -NN FOR FIRST ARG, -1 FOR NNTH ARG, ETC.
	HRLI	B,PSHROL

REGSCA:	MOVEI	A,1		;CODE SAYS SCALAR
	POPJ	P,		;RETURN

SCAREG:	HRRI	F,SCAROL	;REGISTER THE CONTENTS OF A AS SCALAR
	JRST	REGL1A
REGARY:	CAIE	C,"("
	TLNE	C,F.DOLL	;ARRAY OR POSSIBLE SRVECTOR REF?
	JRST	REG1
	JUMPL	F,REGL1
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	JRST	REGL1		;NO.  TREAT AS SCALAR
REG1:	TLNN	C,F.DOLL	;STRING VARIABLE?
	JRST	REG2
	JUMPL	F,ILFORM
	HRLI	F,1
	JRST	REGSTR
REG2:	JUMPL	F,REGA0
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
REGA0:	HRRI	F,ARAROL	;NUMERICAL ARRAY GOES ON ARAROL.

REGA1:	TLO	A,1		;MAKE ARRAY NAME DIFFERENT FROM SCALAR
	MOVEI	R,VARROL	;LOOK FOR VARIABLE NAME
	PUSHJ	P,SEARCH
	JRST	REGA2		;NOT ALREADY USED
	HRRZ	D,(B)		;GET POINTER TO ARAROL
	JRST	REGA3		;ALREADY USED

REGA2:	MOVEI	E,1		;ADD NEW ARRAY NAME TO VARIABLE ROLL
	PUSHJ	P,OPENUP
	ADD	A,CEIL(F)	;COMPUTE ARRAY OR STRING VECTOR ROLL POINTER
	SUB	A,FLOOR(F)
	ORI	A,400000	;SET ARRAY FLAG
	MOVEM	A,(B)
	HRRZ	D,A		;SAVE ARAROL POINTER
	MOVEI	R,(F)		;THREE ZEROS ON ARAROL (NULL ENTRY)
	MOVEI	A,0
	PUSHJ	P,RPUSH		
	PUSHJ	P,RPUSH
	PUSHJ	P,RPUSH

REGA3:	MOVE	B,D		;RECONSTRUCT PNTR
	ANDI	B,377777	;B := REL ADDRS IN ARRAY ROLL
	HRLI	B,(F)	;B := POINTER TO ENTRY ON ROLL
	MOVEI	A,0		;ARRAY CODE
	POPJ	P,


;SUBROUTINE TO REGISTER ARRAY NAME.
;(USED BY DIM,MAT)

ARRAY:	HRRI	F,ARAROL		;ASSUME ITS NOT A STRING
	TLNN	C,F.LETT
	JRST	REGFAL
	PUSHJ	P,SCNLT1	;NAME TO A
	TLNE	C,F.DOLL	;STRING VECTOR?
	JRST	ARRAY2		;YES, HANDLE DIFFERENTLY
	TLNE	C,F.DIG
	JRST	ARRAY4
ARRAY0:	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	PUSHJ	P,REGA0		;FINISH REGISTERING
ARRAY1:	MOVE	X1,B		;SET DEFAULT TO 2-DIM ARRAY
	ADD	X1,FLOOR(F)
	SKIPN	1(X1)
	SETOM	1(X1)
	POPJ	P,

ARRAY4:	DPB	C,[POINT 7,A,13]
	PUSHJ	P,NXCHK
	TLNN	C,F.DOLL
	JRST	ARRAY0
ARRAY2:	JUMPL	F,ILFORM
	HRLI	F,1
	PUSHJ	P,NXCHK		;SKIP THE DOLLAR SIGN.
	PUSHJ	P,REGSVR	;REGISTER STRING VECTOR
	JRST	ARRAY1		;SET DEFAULT, IF NECESSARY

VECTOR:	PUSHJ	P,ARRAY		;REGISTER VECTOR
	CAIE	A,5		;WAS A STRING REGISTERED?
	JUMPN	A,CPOPJ		;WAS AN ARRAY REGISTERED?
	MOVE	X2,1(X1)
	JUMPG	X2,.+4		;EXPLICIT DIMENSION?
	MOVNI	X2,2		;NO.  CALL IT A VECTOR OF UNKNOWN DIM.
	MOVEM	X2,1(X1)
	POPJ	P,
	TLNE	X2,777776	;IS THIS A ROW VECTOR?
	TRNN	X2,777776	;OR A COLUMN VECTOR?
	POPJ	P,		;YES.
	FAIL <? USE VECTOR, NOT ARRAY,>

IFN FTSTR,<
REGSTR:	JUMPL	F,ILFORM	;REGISTER STRING, IF STRING IS LEGAL
	HRLI	F,1
	TLO	A,10		;MAKE STRING NAME DIFFERENT FROM OTHER NAMES.
	HRRI	F,VSPROL	;POINTER WILL GO ON VARIABLE SPACE ROLL
	TLNE	C,F.DOLL	;SKIP DOLLAR SIGN?
	PUSHJ	P,NXCHK		;SKIP DOLLAR SIGN
	CAIN	C,"("	;IS IT A STRING VECTOR?
	JRST	REGSVR		;YES.
	PUSHJ	P,REGL1		;REGISTER STRING.
	JRST	REGS1		;FIX VARIABLE TYPE CODE.

REGSLT:	MOVMS	LETSW		;STR LIT.
	JUMPL	F,ILFORM
	HRLI	F,1
	PUSHJ	P,NXCHD
	PUSH	P,C
	PUSH	P,T
	SETZ	A,
REGSL1:	TLNE	C,F.QUOT	;COUNT CHARACTERS.
	JRST	REGSL2
	TLNE	C,F.CR
	JRST	GRONK
	PUSHJ	P,NXCHD
	AOJA	A,REGSL1
REGSL2:	MOVEI	E,4(A)
	MOVN	A,A
	HRLI	A,(A)
	MOVE	T,CESLT
	SUB	T,FLSLT
	HRRI	A,(T)
	MOVEI	R,LITROL
	PUSH	P,E
	PUSHJ	P,RPUSH		;PUSH POINTER ONTO LITERAL ROLL
	POP	P,E
	IDIVI	E,5
	JUMPE	E,REGSL3
	MOVEI	R,SLTROL	;SET UP SLTROL.
	PUSHJ	P,BUMPRL
REGSL3:	POP	P,T
	POP	P,C
	TLZ	C,777777
	HRLI	B,440700
REGSL4:	CAIN	C,42
	JRST	REGSL5
	IDPB	C,B
	ILDB	C,T
	JRST	REGSL4
REGSL5:	PUSHJ	P,NXCH
	MOVEI	R,SADROL	;MOVE LITROL ADDRESS ON STR-LIT-ADR ROLL
	MOVEI	A,0
	PUSHJ	P,RPUSH
	SUB	B,FLSAD	;GET REL ADRESS
	HRLI	B,SADROL	;SET UP POINTER.
	MOVEI	A,7
	JRST	SNOEXI
>

QSKIP:	PUSHJ	P,NXCH		;SKIP TO NEXT QUOTE CHAR.
	TLNE	C,F.CR		;TERMINAL QUOTE MISSING?
	POPJ	P,		;YES
	TLNN	C,F.QUOT	;END OF STRING?
	JRST	QSKIP		;NO, GO ON.
	PUSHJ	P,NXCH		;YES. GET NEXT CHAR AND RETURN.
	JRST	CPOPJ1

IFN FTSTR,<
REGSVR:	HRRI	F,SVRROL	;REGISTER STRING VECTOR
	TLO	A,11		;MAKE NAME DIFFERENT FROM THE OTHERS
	TLNE	C,F.DOLL	;DOLLAR SIGN?
	PUSHJ	P,NXCHK		;YES, SKIP IT

	PUSHJ	P,REGA1		;REGISTER AS AN ARRAY

REGS1:	CAIE	A,4		;DID REGISTRATION FAIL?
	ADDI	A,5		;NO. FIX TYPE CODE.
	POPJ	P,
>

;NOTE:  IF THE SAME VARIABLE NAME IS USED AS A SCALAR, ARRAY,
;	STRING VECTOR, AND STRING, IT WILL BE DISTINGUISHED IN "VARROL"
;	BY THE FOLLOWING 4-BIT ENDINGS:
;	SCALAR 0;  ARRAY 1;  STRING 10;  STRING VECTOR 11.
;TABLE OF MIDSTATEMENT KEYWORDS:

KWTBL:	ASCII /BY/
	ASCII /GOTO/
	ASCII /STEP/
	ASCII /THEN/
	ASCII /TO/
	ASCII /USING/
KWTTOP:

;REGISTER FUNCTION NAME
;FIRST LETTER HAS BEEN SCANNED

;IT IS POSSIBLE THAT WE HAVE SCANNED A ONE-LETTER VARIABLE NAME
;FOLLOWED BY ONE OF THE KEYWORDS "TO" , "THEN", OR "STEP".
;FIRST WE LOOK AHEAD TO SEE IF THIS IS SO;
;IF IT IS WE GO BACK TO SCALAR CODE.

REGFCN:	PUSH	P,C		;SAVE T,C AROUND LOOK-AHEAD.
	PUSH	P,T
	MOVEI	X1,KWTBL	;TBL OF KEYWORDS

REGF1:	PUSHJ	P,QST	;TEST THIS KEYWORD.
	JRST	REGF2
	POP	P,T
	POP	P,C		;KEYWORD FOUND; ASSUME ONE-LETTER SCALAR.
	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	JRST	REGL1

REGF2:	MOVEI	X1,1(X1)	;NOT CURRENT KEYWORD
	MOVE	T,(P)		;RESTORE POINTERS DESTROYED BY QST
	MOVE	C,-1(P)
	CAIGE	X1,KWTTOP	;MORE TO TEST?
	JRST	REGF1	;YES
	POP	P,T	;NO, NOT KEYWORD.
	POP	P,C
;HAVE DETERMINED THAT WE MUST BE SCANNING A FUNCTION NAME
;IF SYNTAX IS LEGAL.

;WE SCAN THE SECOND LETTER AND CHECK FOR
;INTRINSIC OR DEFINED FUNCTION.

	PUSHJ	P,SCNLT2
	JRST	REGFAL		;NOT A LETTER
	CAMN	A,[SIXBIT /FN/]		;DEFINED FUNCTION?
	JRST	REGDFN		;YES. GO REGISTER DEFINED NAME.

;HERE WE HAVE FN NAME NOT BEGINNING WITH "FN"
;LOOK FOR IT IN TABLE OF INTRINSIC FUNCTIONS.

	MOVE	X1,[POINT 6,A,11] ;CONSTRUCT WHOLE NAME.
	MOVEI	R,4
REGF4:	TLNN	C,F.LETT
	JRST	REGF5
REGF41: PUSH    P,X1            ;LOOK AHEAD TO SEE IF WE HAVE
        PUSH    P,C             ;RUN INTO A KEYWORD
        PUSH    P,T             
        MOVEI   X1,KWTBL
REGF3:  PUSHJ   P,QST
        JRST    REGF31
        POP     P,T             ;FOUND
        POP     P,C
        POP     P,X1
        JRST    REGF9
REGF31: MOVEI   X1,1(X1)
        MOVE    T,(P)
        MOVE    C,-1(P)
        CAIGE   X1,KWTTOP
        JRST    REGF3
        POP     P,T
        POP     P,C
        POP     P,X1
	TLNN	C,F.LCAS
	TRC	C,40
	IDPB	C,X1
	PUSHJ	P,NXCH
	SOJG	R,REGF4
REGF9:	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	JRST	REGF6
REGF5:	TLNN	C,F.DIG             ;CURRENT = DIGIT?
        JRST    REGF51          ; NO
        CAME    A,[SIXBIT/LOG   /]  ;PARTIAL LOG10?
        CAMN    A,[SIXBIT/LOG1  /]
        JRST    REGF41          ;YES
REGF51: TLNN    C,F.DOLL        ;CURRENT = "$" ?
	JRST	REGF9
	SKIPN	FUNAME
	SKIPL	VRFSET
	JRST	REGF10
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSH	P,X1
	PUSHJ	P,BUILDI
	POP	P,X1
	SETZM	VRFSET
REGF10:	MOVEI	C,4
	IDPB	C,X1
	PUSHJ	P,NXCH
	JUMPL	F,ILFORM
	HRLI	F,1
REGF6:	CAME	A,[SIXBIT/VAL   /]
	JRST	REGF0
	SKIPN	FUNAME
	SKIPL	VRFSET
	JRST	REGF0
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSHJ	P,BUILDI
	SETZM	VRFSET
REGF0:	MOVEI	R,IFNFLO
REGF7:	CAMN	A,(R)
	JRST	REGF8		;FOUND FN.
	AOJ	R,.+1
	CAIGE	R,IFNCEI
	JRST	REGF7
	JRST	REGFAL
REGF8:	SUBI	R,IFNFLO
	MOVE	B,IF2FLO(R)	;GET ENTRY IN 2ND TABLE.
	MOVMS	LETSW		;CAN'T BE LH(LET)
	MOVEI	A,2		;INTRINSIC FCN CODE.
	POPJ	P,		;RETURN "XINFCN" DOES ITS OWN ")" CHECK.
;HERE TO REGISTER DEFINED FUNCTION NAME
;THE "FN" HAS ALREADY BEEN SCANNED

;SCAN IDENTIFYING LETTER AND PUTTING ENTRY IN
;FUNCTION CALL ROLL

REGDFN:	JUMPL	F,.+4
	TLNE	F,777777
	JRST	ILFORM
	HRLI	F,777777
	SKIPN	FUNAME
	SKIPL	VRFSET
	JRST	.+4
	MOVE	D,[PUSHJ P,%SETCOR]
	PUSHJ	P,BUILDI
	SETZM	VRFSET
	PUSHJ	P,SCNLT1	;PUT FUNCTION NAME IN A
	CAMN	A,FUNAME	;IS THIS THE NAME OF THE CURRENT MULTI-LINE FN?
	JRST	REGFNA		;YES. REGISTER IT AS A SCALAR
	MOVE	D,A		;NO, REAL FUNCTION CALL.  SAVE NAME FOR ARGCHK
	MOVMS	LETSW
	MOVEI	R,FCLROL	;FUNCTION CALL ROLL
	PUSHJ	P,SEARCH	;USED THIS ONE YET?
	JRST	.+2
	JRST	REGFC1		;ALREADY SEEN A REF
	MOVEI	E,1
	PUSHJ	P,OPENUP
	MOVEM	A,(B)
	PUSHJ	P,REGFC1	;SET B UP FOR KLUDGE TEST
	MOVE	X1,FLSEX	;FIX UP SAVED FCN REFS
REGFC0:	CAML	X1,CESEX	;KLUDGE!!!
	JRST	REGFC1+1
	HLRZ	X2,(X1)		;GET THE ROLL NUMBER
	CAIN	X2,FCLROL	;FCLROL?
	CAMLE	B,(X1)		;YES. IS SEXREF NOW WRONG?
	AOJA	X1,REGFC0	;NO
	AOS	(X1)		;YES. CORRECT IT
	AOJA	X1,REGFC0

REGFC1:	SUB	B,FLFCL
	HRLI	B,FCLROL
	MOVEI	A,3		;DEFINED FCN CODE
	POPJ	P,		;DON'T CHECK FOR () YET

CHKPRN:	CAIE	C,"("
REGFAL:	MOVEI	A,4		;FAIL IF NO PAREN
	POPJ	P,

REGFNA:	TLO	A,(177B13)	;CREATE SPECIAL NAME FOR CURRENT FUNCTION
	JRST	SCAREG		;REGISTER IT AS A SCALAR

	SUBTTL	SUBROUTINES USED BY GEN ROUTINES

;PUSHPR - PUSH PARTIAL RESULT ON SEXROL

PUSHPR:	MOVEI	R,SEXROL
	MOVE	A,B		;SAVE POINTER IN A
	PUSHJ	P,RPUSH
	SUB	B,FLSEX	;MAKE POINTER
	TLNN	A,ROLMSK	;IS IT A POINTER TO REG?
	HRROM	B,REGPNT	;YES, SET POINTER FOR SITGEN TO USE
	POPJ	P,

;POPPR - POP PARTIAL RESULT FROM SEXROL

POPPR:	MOVEI	R,SEXROL
	MOVE	B,CESEX
	SUBI	B,1		;COMPUTE ADDRS OF TOP OF SEXROL
	PUSH	P,(B)		;SAVE THE CONTENT
	MOVEI	E,1
	PUSHJ	P,CLOSUP
	POP	P,B		;POPPED POINTER TO B
POPPFN:	TLNN	B,ROLMSK	;POINTER TO REG?
	SETZM	REGPNT		;YES.  CLEAR MEMORY
	POPJ	P,
;EXCHG - EXCHANGE CURRENT PNTR WITH TOP OF SEXROL

EXCHG:	MOVE	X1,CESEX
	MOVEI	X2,-1(X1)	;FIX PNTR IF REG SAVED
	SUB	X2,FLSEX
	TLNN	B,ROLMSK
	HRROM	X2,REGPNT
	EXCH	B,-1(X1)
	JRST	POPPFN		;GO FIX PNTR IF REG POPPED

;REGFRE - GUARANTEE THAT NO PART RESULT IS IN REG

REGFRE:	SKIPN	REGPNT	;SUBEXP IN THE REG?
	POPJ	P,		;NO
	MOVE	X1,FLSEX	;YES.  COMPUTE WHERE
	ADD	X1,REGPNT
	EXCH	B,(X1)		;GET THE POINTER, SAVE CURR PNTR
	PUSHJ	P,SITGEN	;STORE IN TEMP
	MOVE	X1,FLSEX	;RECOMPUTE LOC IN SEXROL
	ADD	X1,REGPNT
	EXCH	B,(X1)
	SETZM	REGPNT		;CLOBBER REGPNT SINCE REG IS EMPTY
	POPJ	P,
;GPOSGE - GUARANTEE POSITIVE GEN

GPOSGE:	JUMPGE	B,CPOPJ		;RETURN IF ALREADY POSITIVE
				;FALL INTO EIRGEN

;EIRGEN - EXP IN REG GEN

EIRGEN:	TLNN	B,ROLMSK	;ALREADY IN REG?
	POPJ	P,		;DO NOTHING
ERGNFN:	PUSHJ	P,REGFRE	;FREE UP REG
	MOVSI	D,(MOVE N,)	;GET MOVE INSTR
EIRGM2:	PUSHJ	P,BUILDS	;BUILD MOVE INSTR
	MOVEI	B,0		;POSITIVE REG POINTER
	POPJ	P,

;EIRGNP - EXP IN REG GEN POSITIVE

EIRGNP:	JUMPGE	B,EIRGEN	;POSITIVE?
EIRGP1:	TLNE	B,ROLMSK	;NO. IN REG?
	JRST	ERGNFN		;NO.  GO MOVE
	MOVSI	D,(MOVN N,)	;YES,NEGATIVE N
EIRGM3:	PUSHJ	P,BUILDI
	MOVEI	B,0		;POSITIVE REG PNTR
	POPJ	P,

;EIRGNM -- GEN MAG.
EIRGNM:	TLNN	B,ROLMSK
	JRST	EIRGM1
	TLZ	B,400000
	PUSHJ	P,REGFRE
	MOVSI	D,(MOVM N,)
	JRST	EIRGM2
EIRGM1:	MOVSI	D,(MOVM N,)
	JRST	EIRGM3

;SIPGEN - STORE IN PERMANENT TEM GEN

SIPGEN:	MOVEI	R,PTMROL
	JRST	SITGN1

;SITGEN - STORE IN TEMP GEN

SITGEN:	MOVEI	R,TMPROL
SITGN1:	TLNE	B,ROLMSK	;IS EXPR IN REG?
	POPJ	P,		;NO.  DONT DO ANYTHING
	MOVEI	A,0		;PREPARE ZERO TO PUSH ON ROLL
	MOVSI	D,(MOVEM N,)	;GET CORRECT INSTR
	JUMPGE	B,.+2
	MOVSI	D,(MOVNM N,)
	CAIE	R,TMPROL	;STORE ON TMPROL?
	JRST	SITG2		;NO. USE PTMROL
	AOS	B,TMPPNT	;WHICH TEMP TO USE?
	MOVE	X1,FLTMP
	ADD	X1,B
	CAML	X1,CETMP	;NEED MORE TMP SPACE?
	PUSHJ	P,RPUSH	;YES.  PUSH A ZERO ONTO TMPROL
	MOVE	B,TMPPNT	;CONSTRUCT TMP ROLL POINTER
SITG1:	HRLI	B,(R)
	PUSH	P,B	;SAVE ADRESS POINTER
	PUSHJ	P,BUILDA	;BUILD STORE INSTR
	POP	P,B		;RECONSTRUCT POINTER
	POPJ	P,

SITG2:	PUSHJ	P,RPUSH		;PUSH A ZERO ONTO PTMROL
	SUB	B,FLPTM
	JRST	SITG1		;FINISH CONSTRUCTING ADRESS POINTER
;GPOSNX - GUARANTEE POSITIVE AND UNINDEXED GEN

GPOSNX:	TLNE	B,400000+PSHROL	;NEGATIVE OR INDEXED BY (P)?
	PUSHJ	P,EIRGNP	;YES. FORCE INTO REG
	POPJ	P,
BUILDP:	TLO	D,Q		;INSTRUCTION IS INDEXED BY PLIST POINTER
	SUB	B,PSHPNT	;ADJUST THE ADDRESS FOR ANY PUSH INSTS GENNED BY 
	ADDI	B,1
	HRR	D,B		;	A CURRENT FN CALL

;ROUTINE TO ADD CODE TO CODROL.
;A WORD IS ASSUMED IN D
;RETURN REL ADDRS IN B

BUILDI:	SKIPN	RUNFLA		;ARE WE GOING TO RUN?
	POPJ	P,		;NO.  DONT GEN CODE
	MOVEI	E,1
	MOVEI	R,CODROL
	PUSHJ	P,BUMPRL
	MOVEM	D,(B)
	SUB	B,FLCOD
	POPJ	P,


;BUILD SIGNED INSTRUCTION WITH ADDRESS
;CHECK SIGN IN B AND CHANGE UP CODE BITS

BUILDS:	JUMPGE	B,BUILDA	;POSITIVE?
	TLC	D,010000	;NO.  CHANGE MOVE TO MOVN,ETC.
				;FALL INTO BUILDA


;BUILDA - BUILD INSTRUCTION WITH LINKED ADDRESS
;INSTRUCTION SKELETON IS IN D, ADDRESS POINTER IS IN B

BUILDA:	SKIPN	RUNFLA		;ARE WE GOING TO RUN?
	POPJ	P,		;NO.  DONT BUILD
	TLZE	B,PSHROL		;SPECIAL TEST FOR ROLL WITH ABSOLUTE ADDRESSES
	JRST	BUILDP		;YES, PSHROL. DO BUILDI INDEXED BY (Q)
	TLZ	B,400000
	JUMPE	B,BUILDI	;ITEM IS IN REG . USE ADDRESS ZERO

	PUSH	P,B		;SAVE THE POINTER
	PUSHJ	P,BUILDI	;ADD INSTR WITH 0 ADDRS TO CODE
	MOVE	X1,CECOD	;LOC+1 OF THE INSTR
	POP	P,X2		;COMPUTE ADDRS LOCATION
	LDB	R,[POINT 17,X2,17]
	ADD	X2,FLOOR(R)
	MOVE	R,(X2)		;GET NEXT ADDRS IN CHAIN
	HRRM	R,-1(X1)	;STORE IT IN THE INSTR
	SUB	X1,FLCOD
	SUBI	X1,1
	HRRM	X1,(X2)		;STORE CURR ADDRS IN ROLL PNTD TO
	POPJ	P,
	SUBTTL UTILITY SUBROUTINES
;SUBROUTINES FOR GENERAL ROLL MANIPULATION

CLOSUP:	MOVN	X1,E		;COMPUTE NEW END OF ROLL
	ADDB	X1,CEIL(R)	;AND STORE IT
	MOVE	X2,B		;CONSTRUCT BLT WORD
	ADD	X2,E
	MOVS	X2,X2
	HRR	X2,B
	BLT	X2,-1(X1)		;MOVE DOWN TOP OF ROLL
	POPJ	P,

CLOB:	MOVEI	T1,COMTOP	;ROUTINE TO CLOBBER ALL MOVEABLE ROLLS
	MOVEM	T,FLOOR(T1)		;T CONTAINS CLOBBER VALUE.
	MOVEM	T,CEIL(T1)
	CAILE	T1,1(X1)	;DO NOT CLOBBER ROLLS <=(X1)
	SOJA	T1,.-3
	POPJ	P,



OPEN2:	MOVE	X2,E		;IS THERE ROOM ABOVE THIS STODGY ROLL?
	ADD	X2,CEIL(R)	;THE NEW CEILING
	CAMLE	X2,FLOOR+1(R)
	JRST	OPENU0		;NO ROOM, PACK OTHER ROLLS UP
	ADDM	E,CEIL(R)	;THERE IS ROOM, INCREMENT CEILING
	POPJ	P,

OPENU0:	SUB	B,FLOOR(R)
	PUSHJ	P,PANIC
	ADD	B,FLOOR(R)

OPENUP:	CAMG	R,TOPSTG		;OPEN UP THE TOP STODGY ROLL?
	JRST	OPEN2		;YES. OPEN UPWARDS, NOT DOWN
	MOVN	X2,E
	MOVE	X1,TOPSTG	;DO NOT MOVE STODGY ROLLS
	ADD	X2,FLOOR+1(X1)
	CAMGE	X2,CEIL+0(X1)
	JRST	OPENU0		;NEED MORE ROOM
	HRL	X2,FLOOR+1(X1)	;CONSTRUCT BLT WORD
	SUB	B,E		;FIRST WORD OF GAP
	BLT	X2,-1(B)	;MOVE ROLLS DOWN

	MOVEI	X1,1(X1)		;ADJUST POINTERS FOR ROLLS JUST BLT'D.
	MOVN	X2,E
OPEN1:	ADDM	X2,FLOOR(X1)
	CAML	X1,R
	POPJ	P,
	ADDM	X2,CEIL(X1)
	AOJA	X1,OPEN1


;RPUSH - PUSH A ON TOP OF DESIGNATED ROLL

RPUSH:	MOVEI	E,1
	PUSHJ	P,BUMPRL	;MAKE ROOM
	MOVEM	A,(B)		;STORE WORD
	POPJ	P,

;ROUTINE TO ADD TO END OF ROLL
;E CONTAINS SIZE, R CONTAINS ROLL NUMBER

BUMPRL:	MOVE	B,CEIL(R)
	ADD	B,E
	CAIE	R,ROLTOP
	SKIPA	X1,FLOOR+1(R)
	HRRZ	X1,JOBREL
	CAMLE	B,X1
	JRST	BUMP1
	EXCH	B,CEIL(R)
	POPJ	P,

BUMP1:	MOVE	B,CEIL(R)
	CAIE	R,CODROL
	CAIN	R,SEXROL
	JRST	.+2
	JRST	OPENUP
	ADDI	E,^D10		;***EXTRA 10 LOCS
	PUSHJ	P,OPENUP
	MOVNI	X1,^D10	;TAKE BACK THE 10 LOCS
	ADDM	X1,CEIL(R)
	POPJ	P,


;BINARY SEARCH OF SORTED ROLL
;CALL WITH KEY IN A
;RETURN IN B ADDRS OF FIRST
;ENTRY NOT LESS THAN KEY
;SKIP RETURN IF LEFT SIDES EQUAL

SEARCH:	MOVE	B,FLOOR(R)
	SKIPA	X1,CEIL(R)
SEAR1:	MOVEI	B,1(X2)
	CAIGE	B,(X1)
	JRST	SEAR2
	CAML	B,CEIL(R)
	POPJ	P,
	JRST	SEAR3

SEAR2:	MOVEI	X2,@X1
	ADD	X2,B
	ASH	X2,-1
	CAMLE	A,(X2)
	JRST	SEAR1
	HRRI	X1,0(X2)
	CAIGE	B,(X1)
	JRST	SEAR2

SEAR3:	HLLZ	X2,(B)
	CAMN	X2,A
	AOS	(P)
	POPJ	P,
;ROUTINE TO QSA FOR "THEN" OR "GOTO" (USED IN "IF", "ON" STATEMENTS)
THENGO:	PUSHJ	P,QSA
	ASCIZ /THEN/
	CAIA
	POPJ	P,
	PUSHJ	P,QSA
	ASCIZ /GOTO/
	FAIL <? ILLEGAL FORMAT>
	POPJ	P,

;COMMON SUBROUTINE RETURNS

CPOPJ1:	AOS	(P)
CPOPJ:	POPJ	P,

;ERROR RETURNS

ILFORM:	FAIL	<? ILLEGAL FORMULA>
ILVAR:	FAIL	<? ILLEGAL VARIABLE>
GRONK:	FAIL	<? ILLEGAL FORMAT>
ILLINS:	FAIL	<? ILLEGAL INSTRUCTION>


;COMPILATION ERROR


FAILER:	SKIPN	RUNFLA		;IS THIS THE FIRST ERROR IN COMPILATION?
	JRST	FAIL0		;NO.
	PUSHJ	P,INLMES	;YES. SETUP <CRLF> TO FOLLOW HEADING.
	ASCIZ /
/
FAIL0:	PUSHJ	P,FAIL1
	JRST	NXTST1

FAIL1:	MOVE	T,40
FAILR:	MOVEI	D,0
	PUSHJ	P,PRINT
	LDB	X1,[POINT 4,40,12]	;IS AC FIELD NONZERO?
	JUMPE	X1,FAIL2
	MOVE	T,N			;ATTACH NUMBER IN 'N' TO MSG
	PUSHJ	P,PRTNUM
FAIL2:	PUSHJ	P,INLMES
	ASCIZ / IN LINE /
	MOVE	T,L
	ADD	T,FLLIN
	HLRZ	T,(T)
	PUSHJ	P,PRTNUM
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3
	PUSHJ	P,INLMES
	ASCIZ	/
/
	SETZM	RUNFLA
	POPJ	P,

;ROUTINES TO ALLOW AND DELAY REENTRY.
;LOCKON TEMPORARILY PREVENTS REENTRY
;LOCKOF ALLOWS REENTRY AND REENTERS IF THERE IS A STANDING REQUEST
;REENTR MAKES A REENTRY OR MAKES A REQUEST AND CONTINUES
LOCKON:	SKIPGE	RENFLA
	SETZM	RENFLA		;TURN ON REENTER PROTECT
	POPJ	P,

LOCKOF:	SKIPLE	RENFLA
        EXTERN REENT2
        JRST REENT2
	SETOM	RENFLA		;ALLOW REENTER
	POPJ	P,

;ROUTINE TO READ CHARACTER, SKIPPING BLANKS
;CALL:	MOVE	T,<POINTER TO CHAR BEFORE FIRST>
;	PUSHJ	P,NXCH
;	...	RETURN, C:= (<FLAGS>)CHARACTER

NXCHS:	ILDB	C,T		;DOESNT SKIP TAB OR BLANK
	CAIE	C," "
	CAIN	C,11
	POPJ	P,
	JRST	.+2		;SKIP INTO NXCH

NXCH:	ILDB 	C,T		;FETCH NEXT CHARACTER
	HLL	C,CTTAB(C)	;GET FLAGS FROM CTTAB
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	TLNE	C,F.SPTB	;SPACE OR TAB?
	JRST	NXCH		;YES. IGNORE
	POPJ	P,

NXCHD:	ILDB	C,T
NXCHD2:	HLL	C,CTTAB(C)
	TRNE	C,100
	HRL	C,CTTAB-100(C)
	POPJ	P,

;GET NEXT CHAR, BUT CHECK FOR ILLEGAL CHARS (CHARS THAT COULD ONLY BE IN A STRING)
NXCHK:	PUSHJ	P,NXCH
	TLNE	C,F.STR
	FAIL	<? ILLEGAL CHARACTER>
	POPJ	P,

;SCAN INITIAL LETTER, LETTER IS PLACED LEFT
;JUSTIFIED IN A, 7-BIT ASCII.

SCNLT1:	HRRZ	A,C
	ROT	A,-7
	JRST	NXCH

;SCAN SECOND LETTER, NON-SKIP RETURN IF NOT LETTER.
;MAKE 7-BIT LETTER LEFT JUST IN A
;INTO 6-BIT. THAN PUT 6-BIT CURRENT LETTER IN A.

SCNLT2:	TLNN	C,F.LETT
	POPJ	P,
SCN2:	TLNN	A,400000	;ENTER HERE TO PROCESS NON-LETTER CHARS
	TLZA	A,200000
	TLO	A,200000
	LSH	A,1
	MOVE	X1,[POINT 6,A,5]
	JRST	SCNLTN	

;ENTER HERE TO SCAN SECOND CHAR EVEN IF BOTH ARE NOT LETTERS.


;SCAN THIRD LETTER, NON-SKIP IF NOT LETTER.
;PUT 6-BIT LETTER TO 3RD 6-BIT FIELD IN A.

SCNLT3:	TLNN	C,F.LETT
	POPJ	P,
SCN3:	MOVE	X1,[POINT 6,A,11]

;NOW PUT 6-BIT LETTER INTO A, ADJUSTING LOWER CASE, INCREMENTING POINTER.

SCNLTN:	TLNN	C,F.LCAS
	TRC	C,40
	IDPB	C,X1
	AOS	(P)
	JRST	NXCH


;THIS ROUTINE IS USED AT RUNTIME BY THE READ# STATEMENTS.
;DELAWY SKIPS THROUGH DELIMITERS AND STOPS ON THE FIRST
;NON-TAB, NON-SPACE, NON-COMMA.

DELAWY:	LDB	C,T
	JUMPE	C,.-1
	PUSHJ	P,NXCHD2
	TLNN	C,F.COMA+F.SPTB
	POPJ	P,
	PUSHJ	P,NXCH
	JRST	.-3


;QUOTE SCAN AND TEST
;CALL WITH PATTERN ADDRS IN X1
;SKIP IF EQUAL.	C,T UPDATED TO LAST CHAR SCANNED.
QST:	HRLI	X1,440700	;MAKE BYTE PNTR TO PATTERN
QST1:	ILDB	X2,X1		;GET PATTERN CHAR
	JUMPE	X2,CPOPJ1	;DONE ON NULL
	SUBI	X2,(C)
	JUMPE	X2,.+4		;DO CHARACTERS MATCH?
	TLNE	C,F.LCAS	;NO. LOWER CASE LETTER?
	CAME	X2,[ EXP -40]	;YES. SAME LETTER OF ALPHABET?
	JRST	QST2		;NO. MATCH FAILS
	PUSHJ	P,NXCH
	JRST	QST1
QST2:	ILDB	X2,X1		;ON FAIL
	JUMPN	X2,.-1		;SKIP TO NULL
	POPJ	P,


;QUOTE SCAN OR FAIL
;CALL WITH INLINE PATTERN
;GO TO GRONK IF NO MATCH

QSF:	POP	P,X1
	PUSHJ	P,QST
	JRST	GRONK
	JRST	1(X1)

;QUOTE SCAN UNTIL FAIL.
;CALL WITH INLINE PATTERN.

QSAX:	POP	P,X1
	PUSHJ	P,QST
	JRST	1(X1)
	JRST	1(X1)

;QUOTE SCAN WITH ANSWER
;CALL WITH INLINE PATTERN
;SKIP ON SUCCESS		;ON FAIL, RETURN WITH C,T RESTORED

QSA:	POP	P,X1		;GET PATTERN ADDRESS
	PUSH	P,C		;SAVE C,T
	PUSH	P,T
	PUSHJ	P,QST		;SAVE STRING
	JRST 	.+2
	JRST	QSA1		;MATCH
	POP	P,T		;NO MATCH.  BACK UP
	POP	P,C
	JRST	1(X1)

QSA1:	POP	P,X2
	POP	P,X2
	JRST	2(X1)

;ROUTINE TO READ NEXT INTEGER FROM SCANNED LINE
;CALL:	MOVE	T,POINTER TO FIRST CHAR
;	PUSHJ	P,GETNUM
;	...	FAIL RETURN
;	...	SUCCESS RETURN, INTEGER IN N

GETNU:	TDZA	X1,X1		;GET A NUMBER OF ANY LENGTH.
GETNUM:	MOVEI	X1,5		;GET A NUMBER OF AT MOST 5 DIGS
	TLNN	C,F.DIG		;NUMERAL?
	POPJ	P,		;NO.  FAIL RETURN
	MOVEI	N,-60(C)	;YES.  ACCUMULATE FIRST DIGIT
GETN1:	MOVE	G,T		;SAVE PNTR FOR USE BY INSERT
	PUSHJ	P,NXCH		;GET NEXT CHAR
	SOJE	X1,CPOPJ1	;EXIT IF FIVE DIGITS ALREADY
	TLNN	C,F.DIG		;NUMERAL?
	JRST	CPOPJ1		;NO.  RETURN.
	IMULI	N,^D10		;YES.  ACCUMULATE NUMBER
	ADDI	N,-60(C)
	JRST	GETN1		;GO FOR MORE
;ROUTINES TO GENERATE CODE FOR THE CHANNEL SPECIFIER.

GETCN0: PUSHJ   P,FORMLN
        PUSHJ   P,EIRGNP
        MOVE    D,[PUSHJ P,%IFIX]
        PUSHJ   P,BUILDI
        MOVSI   D,(CAILE N,)
        PUSHJ   P,BUILDI
        MOVE    D,[CAILE N,9]
        PUSHJ   P,BUILDI
        MOVE    D,[JRST %CNER1] ;C.N. MUST BE >0 & <10
        JRST    BUILDI

GETCNA: PUSHJ   P,NXCH
GETCN2: PUSHJ   P,GETCN0
        MOVE    D,[MOVE LP,N]
        JRST    BUILDI
	EXTERN	STODSK
;ROUTINE TO READ A LINE INTO LINB0
;CALL:	PUSHJ	P,INLINE

INLINE:	PUSH	P,X1
	SETZB	X1,T1
	SKIPE	IFIFG
	SKIPA	T,LINPT(LP)
	MOVE	T,LINPT
	JRST	INLI1A


INLI1:	ILDB	C,TYI+1		;GET CHAR
	JRST	INLB
INLA:	SOSGE	@INCNT-1(LP)
	JRST	DSKIN
	ILDB	C,@INPT-1(LP)
INLB:	CAIE	C,15		;CR??
	CAIN	C,0
	SOJA	T1,INLI1A
	CAIN	C,"_"		;DELETE?
	JRST	INLI3		;YES
	CAIE	C,21		;IGNORE XON,XOFF
	CAIN	C,23
	SOJA	T1,INLI1A
	CAIG	C,14		;LINE TERMINATOR?
	CAIGE	C,12
	CAIA
	JRST	INLI2		;YES.  GO FINISH UP
	CAIG	T1,<%LOL>	;ROOM FOR CHAR+1 MORE?
	JRST	INLB1		;YES.
	SKIPE	IFIFG		;DISK?
	JRST	INERR		;YES, ERROR EXIT.
	MOVEI	T,INERR1	;NO, ERROR EXIT.
	JRST	ERRMSG
INLB1:	IDPB	C,T		;STORE CHAR
INLI1A:	SKIPE	IFIFG
	AOJA	T1,INLA
	SOSLE	TYI+2		;MORE INPUT?
	AOJA	T1,INLI1	;YES.  BUMP COUNT AND GO GET MORE
	INPUT 0,
	STATZ  0,	20000
	JRST	[SKIPN CHAFLG
        GO (1,BASIC)
                GO (3,RUNNH)]
	STATO 0 ,	740000
	AOJA	T1,INLI1
	MOVEI	T,INLSYS
	JRST	ERRMSG
INLSYS:	ASCIZ /
? SYSTEM ERROR/

INLI2:	MOVEI	C,15		;DONE.  PUT CR IN BFR.
	IDPB	C,T
	POP	P,X1
RESCAN:	SKIPN	IFIFG
	SKIPA	T,LINPT
	MOVE	T,LINPT(LP)
	SKIPE	IFIFG
	JRST	INLI8
	SETZM	HPOS		;CARRIAGE POSITION := LFT MRGN
	JRST	NXCH		;GET FIRST CHAR AND RETURN
INLI8:	SETZM	HPOS(LP)
	JRST	NXCH

INLI3:	SOJE	T1,INLI1A	;BACKARROW HANDLER, IGNORE IF AT LEFT
	MOVEI	C,4
	IBP	T		;BACK UP BYTE POINTER A LA JHB
	SOJG	C,.-1
	SUBI	T1,1
	SOJA	T,INLI1A

;ROUTINE TO START READING NEXT LINE OF PROGRAM
NXLINE:	MOVE	T,FLLIN
	ADDI	T,(L)
	MOVE	T,(T)
	MOVS	D,T		;SAVE LINE START
	HRLI	T,440700
	MOVE	G,FLREF	;SETUP REFROL REFERENCE.
	ADDI	G,(L)
	JRST	NXCH


DSKIN:  DPB     LP,[POINT 4,INDSK,12] ;DISK INPUT
	XCT	INDSK
	DPB	LP,[POINT 4,STADSK,12]
	XCT	STADSK
	JRST	[HRRZ T,-2(P)
                JRST EOFFAL]
	DPB	LP,[POINT 4,STODSK,12]
	XCT	STODSK
	JRST	INLA
	MOVEI	T,INLSYS
	JRST	ERRMSG
	EXTERN	INDSK
;PRINTING SUBROUTINES

;PRINT TO QUOTE CHAR
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;CALL:	MOVE	T,<ADDRS OF MSG>
;	MOVE	D,<QUOTE CHAR>
;	PUSHJ	P,PRINT
;ALTERNATE CALL: PRINT1, IF BYTE PNTR IN T.


PRINT:	HRLI	T,440700
PRINT1:	ILDB	C,T
	CAMN	C,D
	POPJ	P,
	PUSHJ	P,OUCH		;OUTPUT THE CHAR
	JRST	PRINT1


OUCH0:	PUSH	P,C
	AOS	HPOS(LP)
	MOVE	C,MARGIN(LP)
	SKIPGE	QUOTBL(LP)	;QUOTE MODE?
	JRST	OUCH4		;YES.
	CAML	C,HPOS(LP)	;NO.
	JRST	OUCH3
	PUSHJ	P,PCRLF
	JUMPN	LP,.+2
	OUTPUT 0,
	JRST	OUCH5
OUCH4:	CAML	C,HPOS(LP)
	JRST	.+3
	POP	P,C
	JRST	PTXER2
OUCH3:	SOS	HPOS(LP)
OUCH5:	POP	P,C
OUCH:	SKIPE	ODF		;DISK?
	JRST	DSKOT		;YES.
	SKIPLE	TYO+2		;NO.
	JRST	OUCH1
	OUTPUT 0,
	MOVEM	N,TEMLOC
	GETSTS	  0,N
	TRNE	N,740000
	JRST	OUTERR
	MOVE	N,TEMLOC
OUCH1:	SOS	TYO+2
	IDPB	C,TYO+1
	AOS	HPOS
	POPJ	P,
DSKOT:	SKIPG	@OUTCNT-1(LP)
	JRST	DOS
	SOS	@OUTCNT-1(LP)
	IDPB	C,@OUTPT-1(LP)
	AOS	HPOS(LP)
	POPJ	P,
DOS:	DPB	LP,[POINT 4,OUTTDS,12]
	XCT	OUTTDS
	JRST	DSKOT
	DPB	LP,[POINT 4,GTSTS,12]
	XCT	GTSTS
	JRST	OUTERR

;ROUTINE TO PRINT SIXBIT CHARACTERS IN ACCUM "T".
;IGNORES BLANKS.


PRNSIX:	MOVE	T1,[POINT 6,T]
	ILDB	C,T1
	JUMPE	C,PRNS1		;SKIP A BLANK
	ADDI	C,40
	PUSHJ	P,OUCH
PRNS1:	TLNE	T1,770000		;ALL SIX PRINTED?
	JRST	PRNSIX+1
	POPJ	P,


;UTILITY ROUTINE TO PRINT OUT "DEV:FILENM.EXT".
;FOR USE BY VARIOUS ERROR MESSAGES.
;DEV IS IN SAVE1, FILENM IN FILDIR, AND EXT IN FILDIR+1.
;IF LH(SAVE1)=0, DEV IS NOT PRINTED. DSK: AND .BAS ARE
;OMITTED.

PRNNAM:	PUSH	P,C
	PUSH	P,T
	PUSH	P,ODF
	SETZM	ODF
	HLRZ	T,SAVE1
	JUMPE	T,PRNAM1
	CAIN	T,<SIXBIT /   DSK/>
	JRST	PRNAM1
	MOVE	T,SAVE1
	PUSHJ	P,PRNSIX
	MOVSI	T,320000
	PUSHJ	P,PRNSIX
PRNAM1:	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,FILDIR+1
	CAIN	T,<SIXBIT /   BAS/>
	JRST	PRNAM2
	TLO	T,16
	PUSHJ	P,PRNSIX
PRNAM2:	POP	P,ODF
	POP	P,T
	POP	P,C
	POPJ	P,
;SPECIAL DECIMAL PRINT ROUTINE.  PRINTS X1,X2 AS DECIMAL NUMBERS
;SEPARATED BY THE CHARACTER IN ACCUM "A".
;IF X1 OR X2 ARE ZERO, THEY PRINT AS "00".

PRDE2:	MOVE	T,X1
	PUSHJ	P,PRDE1
	MOVE	C,A
PRDE2A:	PUSHJ	P,OUCH
	MOVE	T,X2
	MOVEI	A,177
PRDE1:	MOVEI	C,"0"		;A ONE DIGIT NUMBER?
	CAIG	T,^D9
	PUSHJ	P,OUCH		;YES. PUT OUT LEADING ZERO.
	JRST	PRTNUM

;SPECIAL RUNTIME PRINTER
RTIME:	PUSHJ	P,INLMES
	ASCIZ /
/
	SETZM	MTIME
	OUTPUT 0,
	POPJ	P,

;NUMBER PRINTER (PRINTS INTEGER IN T)


PRTNUX:	MOVEI	X1,3
	SKIPE	STRFCN
	JRST	PRTNX4
	JRST	PRTNX3
PRTNX1:	MOVE	X1,B		;CHECK ROOM FOR INT. OF THIS SIZE " "
	MOVEI	X1,4(X1)
PRTNX3:	PUSHJ	P,CHROOM
PRTNX4:	PUSHJ	P,PSIGN
PRTNX2:	IDIVI	T,^D10
	JUMPE	T,PRTN0
	PUSH	P,T1
	PUSHJ	P,.-3
	POP	P,T1
PRTN0:	MOVEI	C,60(T1)
	AOS	NUMCOT
	SKIPE	STRFCN
	JRST	DPBSTR
	JRST	OUCH0

PRTNUM:	IDIVI	T,^D10
	JUMPE	T,PRTN1
	PUSH	P,T1
	PUSHJ	P,PRTNUM
	POP	P,T1
PRTN1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH


;OCTAL NUMBER PRINTER.
PRTOCT:	IDIVI	T,10
	JUMPE	T,PRTOC1
	PUSH	P,T1
	PUSHJ	P,PRTOCT
	POP	P,T1
PRTOC1:	MOVEI	C,60(T1)
	AOS	NUMCOT
	JRST	OUCH


;ROUTINE USED BY OUTNUM FOR STRB.

DPBSTR:	EXCH	T,STRPTR
	IDPB	C,T
	EXCH	T,STRPTR
	SOS	STRCTR
	POPJ	P,



PSIGN:	MOVEI	C," "		;PRINT "SIGN" (BLANK OR MINUS)
	JUMPL	N,PSIGN2
	SKIPE	STRFCN
	POPJ	P,
	JRST	OUCH0
PSIGN2:	SKIPE	STRFCN
	JRST	PSIGN4
	SKIPL	QUOTBL(LP)
	JRST	PSIGN3
	MOVEI	C," "
	PUSHJ	P,OUCH0
PSIGN3:	MOVEI	C,"-"
	JRST	OUCH0
PSIGN4:	MOVEI	C,"-"
	JRST	DPBSTR


;MESSAGE PRINTER

INLMES:	PUSHJ	P,TTYIN
INLME1:	SETZM	HPOS
	EXCH	T,(P)	;GET MSG ADR AND SAVE T.
	PUSH	P,C
	PUSH	P,ODF
	SETZM	ODF
	MOVEI	D,0	;END ON NULL
	PUSHJ	P,PRINT	;PRINT THE MESSAGE
	POP	P,ODF
	POP	P,C
	EXCH	T,(P)
	SETZM	HPOS
	JRST	CPOPJ1	;RTN AFTER MSG.
	SUBTTL CORE COMPRESSION AND EXPANSION
;PANIC - ROUTINE TO COMPRESS CORE

PANIC:	PUSHJ	P,PRESS		;COMPRESS MEMORY
	MOVE	X2,TOPSTG	;IS THERE ROOM BETWEEN STODGY AND
	MOVE	X1,FLOOR+1(X2)	;MOVEABLE ONES?
	SUB	X1,CEIL(X2)
	CAML	X1,E		;ENOUGH ROOM?
	POPJ	P,

	MOVE	X1,JOBREL	;EXPAND BY 1K
	ADDI	X1,2000
	CALL	X1,[SIXBIT /CORE/]
	JRST	[MOVEI T,PANIC1
		JRST ERRMSG]	;CANT
	JRST	PANIC		;OK.  GO MOVE ROLLS

PANIC1:	ASCIZ	/
? OUT OF ROOM/


PRESS:	PUSH	P,G		;SAVE AC
	PUSH	P,A
	SKIPN	PAKFLA		;ARE LINES PACKED?
	JRST	PRESS5		;YES
	SETZM	PAKFLA

	MOVE	X1,FLTXT	;LOOK FOR EMPTY SPACE
PRESS2:	CAML	X1,CETXT	;THROUGH LOOKING?
	JRST	PRESS5
	SKIPE	(X1)		;A FREE WORD?
	AOJA	X1,PRESS2	;NO

	MOVEI	X2,1(X1)	;YES
PRESS3:	CAML	X2,CETXT
	JRST	PRESS4		;FREE TO END
	SKIPN	(X2)
	AOJA	X2,PRESS3	;LOOK FOR NON-FREE WORD

	SUB	X1,X2		;X1 :=-LNG OF MOVE
	MOVE	A,FLLIN
PRES3A:	CAML	A,CELIN		;MOVE DOWN THE REFERENCES
	JRST	PRES3B		;IN THE LINE ROLL.
	HRRZ	G,(A)
	CAML	G,X2
	ADDM	X1,(A)
	AOJA	A,PRES3A

PRES3B:	MOVE	G,CETXT		;MOVE DOWN THE TEXT ROLL.
	ADD	G,X1
	MOVEM	G,CETXT
	ADD	X1,X2
	HRL	X2,X1
	MOVSS	X2
	BLT	X2,-1(G)
	JRST	PRESS2

PRESS4:	MOVEM	X1,CETXT

;ROUTINE TO MOVE ROLLS UP

PRESS5:	MOVEI	G,ROLTOP	;HIGHEST MOVABLE ROLL
	MOVE	X1,JOBREL	;X1 IS PREVIOUS FLOOR
				;NOTE: TOP WORD OF USR CORE IS LOST

PRESS6:	MOVE	X2,CEIL(G)	;GET OLD CEIL AND FLOOR
	MOVE	A,FLOOR(G)
	SUBI	X2,1		;SET UP X2 FOR POP LOOP
	ORCMI	X2,777777
	MOVEM	X1,CEIL(G)	;NEW CEILING

PRESS7:	CAILE	A,(X2)		;DONE?
	JRST	PRESS8
	POP	X2,-1(X1)	;MOVE ONE WORD
	SOJA	X1,PRESS7

PRESS8:	MOVEM	X1,FLOOR(G)	;NEW FLOOR
	SOS	G		;GO TO NEXT LOWER ROLL
	CAMLE	G,TOPSTG	;IS THIS ROLL MOVEABLE?
	JRST	PRESS6		;YES. GO PRESS IT.
	POP	P,A
PRESS9:	POP	P,G	;RESTORE G
	POPJ	P,	;RETURN


;UTILITY ROUTINE TO SET UP VRFBOT AND VRFTOP.
SETCOR:	PUSH	P,X2
	SETZM	VRFBOT
	SKIPN	SRTDBA
	JRST	SETCO3
	PUSH	P,T1
	PUSH	P,T
	PUSH	P,A
	PUSH	P,C
SETCO1:	MOVE	X2,VARFRE
	MOVEI	T1,^D200(X2)
	MOVEI	T,^D200
	SETZ	A,
	PUSHJ	P,VSUB1
	CAMG	T1,JOBREL
	JRST	SETCO2
	PUSHJ	P,VPANIC
	JRST	SETCO1
SETCO2:	MOVEM	T1,VRFBOT
	MOVEM	T1,VRFBTB
	POP	P,C
	POP	P,A
	POP	P,T
	POP	P,T1
	JRST	SETCO5
SETCO3:	MOVE	X2,VARFRE
	ADDI	X2,^D200
	CAMG	X2,JOBREL
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	SETCO3
	MOVEM	X2,VRFBOT
	MOVEM	X2,VRFBTB
SETCO5:	HRRZ	X2,JOBREL
	MOVEM	X2,VRFTOP
	POP	P,X2
	POPJ	P,

;THIS ROUTINE OBTAINS SPACE IN THE "FREE CORE AREA" FOR REAL STRINGS,
;APPEND BLOCKS, THE TEMPORARY STRINGS WHICH ARE THE RESULTS OF
;STRING FUNCTIONS, AND BUFFERS FOR DATA FILES. IT HAS SIX ENTRY POINTS:
;VCHCKC AND VCHCKW FOR REAL STRINGS, VCHTSC AND VCHTSW FOR TEMPORARY
;STRINGS, VCHAPP FOR APPEND BLOCKS, AND VCHBUF FOR DATA FILES.
;STRINGS HAVE TWO ENTRY POINTS SO THAT THEY MAY REQUEST SPACE IN UNITS
;OF EITHER CHARACTERS OR WORDS.  THE REQUEST IS IN AC T.  NO OTHER
;AC'S ARE DESTROYED. THE LOCATION OF THE LOWER BOUND OF THE OBTAINED
;SPACE IS RETURNED IN AC T.


LITLEN=^D27

VCHCKC:	PUSH	P,T1		;ENTRY POINT--REAL STRINGS.
	JUMPE	T,VCHCK1
	ADDI	T,4
	IDIVI	T,5
	JRST	VCHCK2
VCHCKW:	PUSH	P,T1		;ENTRY POINT--REAL STRINGS.
	JUMPN	T,.+2
VCHCK1:	MOVEI	T,LITLEN
VCHCK2:	MOVE	T1,VARFRE
	ADDI	T1,(T)
	SKIPN	VRFBOT
	JRST	VCHCK5
	CAMG	T1,VRFBTB
	JRST	VCHCK7
	JRST	VCHCK6
VCHCK5:	CAMG	T1,JOBREL
	JRST	VCHCK7
VCHCK6:	PUSHJ	P,VPANIC
	JRST	VCHCK2
VCHCK7:	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHCK3		;YES.
	MOVE	T,VARFRE	;NO.
	MOVEM	T1,VARFRE
	JRST	VOUT
VCHCK3:	PUSH	P,X2
	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHCK4:	MOVE	X2,VARFRE	;GET OUT OF THE WAY OF THE BUFFERS,
	MOVEI	T1,(X2)
	ADDI	T1,(T)
	SETZ	A,		;BY MOVING UP.
	PUSHJ	P,VSUB1
	SKIPN	VRFBOT
	JRST	VCHCK8
	CAMG	T1,VRFBTB
	JRST	VCHCK0
	JRST	VCHCK9
VCHCK8:	CAMG	T1,JOBREL
	JRST	VCHCK0
VCHCK9:	PUSHJ	P,VPANIC
	JRST	VCHCK4
VCHCK0:	MOVEM	T1,VARFRE
VOUT2:	MOVEI	T,(X2)
VOUT0:	POP	P,C
	POP	P,A
	POP	P,X1
VOUT1:	POP	P,X2
VOUT:	POP	P,T1
	POPJ	P,

VCHAPP:	PUSH	P,T1		;ENTRY POINT--APPEND BLOCKS.
VCHAP2:	MOVE	T1,VRFBOT
	ADDI	T1,^D47
	CAMG	T1,VRFTOP
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHAP2
	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHAP1		;YES.
	MOVE	T,VRFBOT	;NO.
	MOVEM	T1,VRFBOT
	JRST	VOUT		;NO.
VCHAP1:	PUSH	P,X2
	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHAP3:	MOVE	X2,VRFBOT
	MOVEI	T1,(X2)
	ADDI	T1,^D47
	HRRZI	T,^D47
	SETZ	A,
	PUSHJ	P,VSUB1		;GET OUT OF THEIR WAY BY MOVING UP.
	CAMG	T1,VRFTOP
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHAP3
	MOVEM	T1,VRFBOT
	JRST	VOUT2

VCHBUF:	PUSH	P,T1		;ENTRY POINT--DATA FILE BUFFERS.
	PUSH	P,X2
VCHBF4:	SKIPN	T1,VRFBOT	;LOWER BOUND IS VRFBOT, IF IT
	MOVE	T1,VARFRE	;EXISTS, OTHERWISE IT IS VARFRE.
	MOVEI	T,406
	ADDI	T1,(T)
	MOVE	X2,VRFTOP
	SKIPN	VRFBOT
	MOVE	X2,JOBREL
	CAIG	T1,(X2)
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHBF4
	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHBF2		;YES.
	SKIPE	T,VRFBOT	;NO.
	JRST	VCHBF3
	MOVE	T,VARFRE
	MOVEM	T1,VARFRE
	JRST	VOUT1
VCHBF3:	MOVEM	T1,VRFBOT
	JRST	VOUT1
VCHBF2:	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHBF5:	SETZ	A,
	SKIPN	T1,VRFBOT
	MOVE	T1,VARFRE
	MOVEI	X2,(T1)
	ADDI	T1,(T)
	PUSHJ	P,VSUB1		;GET OUT OF THEIR WAY BY MOVING UP.
	MOVE	X1,VRFTOP
	SKIPN	VRFBOT
	MOVE	X1,JOBREL
	CAIG	T1,(X1)
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHBF5
	SKIPN	VRFBOT
	JRST	.+3
	MOVEM	T1,VRFBOT
	JRST	VOUT2
	MOVEM	T1,VARFRE
	JRST	VOUT2

VCHTSC:	PUSH	P,T1		;ENTRY POINT--TEMP. STRINGS.
	JUMPE	T,VCHTS1
	ADDI	T,4
	IDIVI	T,5
	JRST	VCHTS2
VCHTSW:	PUSH	P,T1
	JUMPN	T,.+2
VCHTS1:	MOVEI	T,LITLEN
VCHTS2:	MOVE	T1,VRFTOP
	ADDI	T1,1
	SUBI	T1,(T)
	CAML	T1,VRFBOT
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHTS2
	SKIPE	SRTDBA		;ANY BUFFERS?
	JRST	VCHTS3		;YES.
	MOVEI	T,(T1)		;NO.
	SUBI	T1,1
	MOVEM	T1,VRFTOP
	JRST	VOUT
VCHTS3:	PUSH	P,X2
	PUSH	P,X1
	PUSH	P,A
	PUSH	P,C
VCHTS4:	MOVE	T1,VRFTOP
	ADDI	T1,1
	HRRZI	X2,(T1)
	SUBI	X2,(T)
	MOVE	A,T
	SETZ	T,
	PUSHJ	P,VSUB1		;GET OUT OF THE WAY OF THE BUFFERS BY MOVING DOWN.
	MOVE	T,A
	CAML	X2,VRFBOT
	JRST	.+3
	PUSHJ	P,VPANIC
	JRST	VCHTS4
	MOVEI	X1,-1(X2)
	MOVEM	X1,VRFTOP
	JRST	VOUT2

;SUBROUTINE TO GET OUT OF THE WAY OF THE BUFFERS.

VSUB1:	SETZ	C,		;X2 HAS LOWER BOUND.
VSUB11:	HRRZ	X1,SRTDBA(C)	;T1 HAS UPPER BOUND.
	JUMPE	X1,CPOPJ	;T OR A HAS LENGTH, DEPENDING ON
	CAIG	X1,(X2)		;DIRECTION OF TRAVEL.
	JRST	VSUB12
	HLRZ	X1,SRTDBA(C)
	CAIL	X1,(T1)
	JRST	VSUB12
	JUMPN	A,VSUB13	;GOING DOWN OR UP?
	HRRZ	T1,SRTDBA(C)	;GOING UP.
	HRRZI	X2,(T1)
	ADDI	T1,(T)
	JRST	VSUB12
VSUB13:	HLRZ	T1,SRTDBA(C)	;GOING DOWN.
	HRRZI	X2,T1
	SUBI	X2,(A)
VSUB12:	AOJ	C,.+1
	CAIGE	C,9
	JRST	VSUB11
	POPJ	P,


VPANIC:	PUSH	P,R
	PUSH	P,X1
	PUSH	P,X2
	PUSH	P,G
	PUSH	P,A
	PUSH	P,C
	PUSH	P,E
	PUSH	P,T1
	PUSH	P,T
	SKIPN	VPAKFL
	PUSHJ	P,VPRESS
VPAN3:	MOVEI	R,^D18
	MOVE	G,VRFBTB
	SKIPN	VRFBOT
	MOVE	G,JOBREL
	MOVE	X2,VARFRE
	MOVEI	T,^D27
	SETZ	A,
VPAN31:	MOVEI	T1,^D27(X2)
	PUSHJ	P,VSUB1
	MOVEI	X2,(T1)
	SOJG	R,VPAN31
	SOJ	T1,.+1
	CAIG	T1,(G)
	JRST	VPN1
	SKIPE	X2,VRFBOT
	CAME	X2,VRFBTB
	JRST	VPAN32
	CAMLE	T1,VRFTOP
	JRST	VPAN32
VPAN30:	ADDI	T1,1
	MOVEM	T1,VRFBTB
	MOVEM	T1,VRFBOT
	JRST	VPN1
VPAN32:	PUSH	P,T1
	PUSHJ	P,VPAN16
	SKIPE	VRFBOT
	JRST	VPAN33
	POP	P,T1
	CAMLE	T1,JOBREL
	JRST	VPAN32
	JRST	VPAN92
VPAN33:	PUSHJ	P,VPRES1
	POP	P,T1
	SKIPN	A,APPLST
	JRST	VPAN30
	SETZ	E,
VPAN34:	MOVE	C,APPLST(A)
	CAILE	C,(T1)
	JRST	.+3
	AOJ	E,.+1
	SOJG	A,VPAN34
	JUMPE	E,VPAN30
	MOVE	X2,VRFBOT
	MOVEI	T,^D47
	SETZ	A,
	MOVEI	T1,^D47(X2)
	PUSHJ	P,VSUB1
	MOVEI	X2,(T1)
	SOJG	E,.-3
	SUBI	T1,1
VPAN35:	CAMG	T1,VRFTOP
	JRST	VPAN36
	PUSH	P,T1
	PUSHJ	P,VPAN16
	POP	P,T1
	JRST	VPAN35
VPAN36:	MOVEI	E,1
	ADDI	T1,1
	MOVEM	T1,VRFBOT
VPAN37:	SUBI	T1,^D47
	HRL	T1,APPLST(E)
	BLT	T1,^D46(T1)
	MOVE	C,MASAPP
	SUBI	C,MASAPP
	JUMPE	C,VPAN38
	HRRZ	A,MASAPP(C)
	CAMN	A,APPLST(E)
	HRRM	T1,MASAPP(C)
	SOJG	C,.-3
VPAN38:	AOJ	E,.+1
	CAMLE	E,APPLST
	JRST	VPAN39
	MOVEI	T1,(T1)
	MOVEI	X2,-^D47(T1)
	SETZ	T,
	MOVEI	A,^D47
	PUSHJ	P,VSUB1
	JRST	VPAN37
VPAN39:	MOVEM	T1,VRFBTB
	JRST	VPN2
VPN1:	SKIPN	VRFBOT
	JRST	VPAN92
VPN2:	MOVEI	R,^D10
	MOVEI	T,^D47
	SETZ	A,
	MOVE	X2,VRFBOT
	MOVEI	T1,^D47(X2)
	PUSHJ	P,VSUB1
	MOVEI	X2,(T1)
	SOJG	R,.-3
	SUBI	T1,1
VPN3:	CAMG	T1,VRFTOP
	JRST	VPAN92
	PUSH	P,T1
	PUSHJ	P,VPAN16
	POP	P,T1
	JRST	VPN3

VPAN16:	MOVE	X2,JOBREL	;GET MORE CORE AND MOVE UP TEMP STRS.
	MOVEI	C,2000(X2)
	CORE	C,
	JRST	[MOVEI T,PANIC1
		JRST ERRMSG]
	SKIPN	VRFBOT
	POPJ	P,
	MOVE	C,VRFTOP
	CAIE	C,(X2)
	JRST	.+4
	MOVE	C,JOBREL
	MOVEM	C,VRFTOP
	POPJ	P,
	PUSHJ	P,VPRES1
	MOVE	X1,JOBREL
	MOVEI	T,10
VPAN41:	HRRZ	T1,SRTDBA(T)
        JUMPN   T1,VPAN42
        SOJGE   T,VPAN41
        JRST    VPAN43
VPAN42: MOVEI   T1,-1(T1)
        CAMLE   T1,VRFTOP
        JRST    VPAN44
        SETO    T,
VPAN43: MOVE T1,VRFTOP
VPAN44:	MOVEI	R,(X1)
	SUBI	R,(X2)
	SKIPN	C,NUMMSP
	JRST	VPAN5
VPAN45:	HRRZ	E,MASAPP(C)	;UPDATE MASTER APP BLK.
	CAILE	E,(T1)
	CAILE	E,(X2)
	JRST	.+3
	ADDI	E,(R)
	HRRM	E,MASAPP(C)
	SOJG	C,VPAN45
VPAN5:	SKIPN	C,APPLST
	JRST	VPAN56
VPAN51:	MOVE	A,APPLST(C)	;UPDATE OTHER APP BLKS.
	HRRZ	E,(A)
	HRRZI	G,(A)
	ADDI	E,(G)
VPAN55:	HRRZ	A,(E)
	CAILE	A,(T1)
	CAILE	E,(X2)
	JRST	.+3
	ADDI	A,(R)
	HRRM	A,(E)
	SOJ	E,.+1
	CAIE	E,(G)
	JRST	VPAN55
	SOJG	C,VPAN51
VPAN56:	HRLI	T1,1(T1)
	ADDI	R,1(T1)
	HRRI	T1,(R)
	BLT	T1,(X1)
	MOVEI	X1,-1(T1)
	JUMPL	T,VPAN6
VPAN58:	HLRZ	X2,SRTDBA(T)
	SUBI	X2,1
	CAMG	X2,VRFTOP
	JRST	VPAN6
	SOJL	T,VPAN57
	HRRZ	T1,SRTDBA(T)
	CAIN	T1,1(X2)
	JRST	VPAN58
        SOJA    T1,VPAN44
VPAN57:	MOVE	T1,VRFTOP
	JRST	VPAN44
VPAN6:	HRRZM	X1,VRFTOP
	POPJ	P,
VPAN92:	POP	P,T
	POP	P,T1
	POP	P,E
	POP	P,C
	POP	P,A
	POP	P,G
	POP	P,X2
	POP	P,X1
	POP	P,R
	POPJ	P,

;PACK DOWN ROUTINE.

VPRESS:	PUSH	P,[Z VPR4]
VPRES1:	MOVE	A,MASAPP
	SUBI	A,MASAPP
	MOVEM	A,NUMMSP	;COUNT OF KEYS IN MASTER APPEND BLOCK.
	SETZM	NUMAPP		;COUNT OF KEYS IN ALL OTHER APP. BLKS.
	SETZM	APPLST		;COUNT OF OTHER APP. BLKS.
	SKIPN	A,VRFBOT
	POPJ	P,
	SETZB	G,E		;E IS INDEX FOR APPLST.
	SKIPN	SRTDBA		;BUFFERS IN THE WAY?
	JRST	VLOPF1		;NO.
VLOOP:	HLRZ	C,SRTDBA+10(G)	;FIND THE APPEND BLKS, WHICH ARE
	JUMPE	C,VLOPFN
	CAIL	C,(A)		;BETWEEN VRFBTB AND VRFBOT.
	JRST	VLOPFN
	HRRZ	C,SRTDBA+10(G)
	CAMG	C,VRFBTB
	JRST	VLOPFN
	PUSHJ	P,VCHPBK	;A BUFFER IS IN THE APP BLK SPACE.
	HLRZ	A,SRTDBA+10(G)
	CAMGE	A,VRFBTB
	JRST	VLOOP4		;NO APP BLKS. LEFT.
VLOPFN:	SOJ	G,.+1
	CAML	G,[777777777770]
	JRST	VLOOP
VLOPF1:	MOVE	C,VRFBTB	;POSSIBLY NO BUFFERS WERE SEEN.
	PUSH	P,[Z VLOOP4]
VCHPBK:	SUBI	A,^D47		;CUT UP THIS KNOWN SPACE.
	CAIGE	A,(C)
	POPJ	P,
	MOVEM	A,APPLST+1(E)
	AOJ	E,.+1
	JRST	VCHPBK

VLOOP4:	MOVEM	E,APPLST	;STORE COUNT OF APP BLKS.
	SETZ	A,		;FIND NO. OF KEYS.
	JUMPE	E,VLOOP5
	MOVE	X1,APPLST(E)
	HLRZ	X1,(X1)
	ADDI	A,(X1)
	SOJG	E,.-3
VLOOP5:	MOVEM	A,NUMAPP
	POPJ	P,


VPR4:	MOVE	G,SVRTOP	;SET UP LOWER BOUND.
	SETZ	C,
	MOVEI	E,10
	SKIPN	SRTDBA		;ANY BUFFERS?
	JRST	VPR0		;NO.
VPR5:	HLRZ	A,SRTDBA(C)
	CAIN	G,(A)		;GET ABOVE THE BUFFERS.
	JRST	.+3
	PUSHJ	P,PAKBLK
	JRST	VPR0
	HRRZ	G,SRTDBA(C)
	AOJ	C,.+1
	CAIG	C,10
	JRST	VPR5
	SETZM	SRTDBA(E)	;ABOVE ALL THE BUFFERS, SO "ERASE" THEM.
	SOJGE	E,.-1
	JRST	VPR0
PAKBLK:	JUMPE	C,CPOPJ
PAKBL0:	SETZ	X1,		;SET UP SRTDBA SO THAT
	SUBI	E,(C)		;THE NEXT HIGHEST BUFFER
PAKBL1:	MOVE	X2,SRTDBA(C)	;IS IN THE FIRST LOCATION,
	MOVEM	X2,SRTDBA(X1)	;AND "ERASE" THE LOWER BUFFERS.
	SETZM	SRTDBA(C)
	AOJ	X1,.+1
	AOJ	C,.+1
	SOJGE	E,PAKBL1
	CAILE	X1,10
	POPJ	P,
	SETZM	SRTDBA(X1)
	AOJA	X1,.-3

VPR0:	HRRZI	X2,-1		;THE LOWEST ADDRESS WILL GO INTO X1
	MOVE	A,FLVSP		;A POINTS TO EACH ENTRY ON THE ROLL.
	SETZI	X1,		;X1 WILL GET THE LOC OF NEXT LOWEST POINTER

VPR1:	CAMN	A,CEVSP		;STARTING TO SCAN SVRROL, OR STILL IN VSPROL?
	MOVE	A,SVRBOT
	CAML	A,SVRTOP
	JRST	VPR2		;SEARCH FOR MINIMUM IS OVER.
	HRRZ	E,(A)		;GET POINTER ADDRESS.
	JUMPE	E,VPR11		;NULL POINTER?
	CAIL	E,(G)		;HAVE WE MOVED THIS STRING ALREADY?
	CAIG	X2,(E)		;NO, IS IT A LOWER STRING ADDRESS?
VPR11:	AOJA	A,VPR1		;NO. LOOK AT NEXT STRING.

	MOVE	X1,A		;WE HAVE FOUND A STRING WITH LOWER ADDRESS.
	MOVE	X2,E
	AOJA	A,VPR1

VPR2:	JUMPE	X1,VPR3		;ANY MORE STRINGS TO MOVE?
	HLRE	E,(X1)		;CALCULATE WORD LENGTH..
	JUMPN	E,.+3		;IS THIS A NULL STRING?
	SETZM	(X1)		;YES. IGNORE IT.
	JRST	VPR0
	HRL	G,(X1)		;GET THE OLD ADDRESS OF THIS STRING
	MOVN	E,E		;GET WORD LENGTH
	ADDI	E,4
	PUSH	P,G
	IDIVI	E,5
	POP	P,G
	ADDI	E,-1(G)
	HRRZI	X2,(G)
	CAIN	X2,(X1)
	JRST	VPR28
	SKIPN	SRTDBA		;POSSIBLY BUFFERS IN THE WAY?
	JRST	VPR23		;NO.
	SETZ	C,
VPR21:	HLRZ	X2,SRTDBA(C)
	JUMPE	X2,VPR22
	CAILE	X2,(E)
	JRST	VPR22
	SUBI	E,-1(G)
	HRR	G,SRTDBA(C)
	ADDI	E,-1(G)
	AOJ	C,.+1
	CAIG	C,10
	JRST	VPR21
	MOVEI	E,10
	SETZM	SRTDBA(E)
	SOJGE	E,.-1
	JRST	VPR23
VPR22:	JUMPE	C,VPR23
	PUSH	P,E
	PUSH	P,X1
	MOVEI	E,10
	PUSHJ	P,PAKBL0	;WIND DOWN THE BUFFERS.
	POP	P,X1
	POP	P,E

VPR23:	HRRZ	X2,(X1)		;GET THE OLD STRING ADDRESS
	HRRM	G,(X1)		;STORE THE NEW ADDRESS IN THE MAIN KEY.
	BLT	G,(E)		;MOVE THE STRING DOWN
	SKIPN	X1,NUMMSP	;UPDATE MASTER APP BLK?
	JRST	VPR25		;NO NEED.
VPR24:	HRRZ	A,MASAPP(X1)	;POSSIBLY.
	CAIE	A,(X2)
	JRST	.+3
	HRRM	G,MASAPP(X1)
	SOS	NUMMSP
	SOJG	X1,VPR24
VPR25:	SKIPN	NUMAPP		;UPDATE OTHER APP BLKS?
	JRST	VPR28		;NO NEED.
	PUSH	P,E		;POSSIBLY.
	MOVE	X1,APPLST
VPR26:	HRRZ	A,APPLST(X1)
	HLRZ	C,(A)
	ADDI	C,(A)
VPR27:	HRRZ	E,(C)
	CAIE	E,(X2)
	JRST	.+3
	HRRM	G,(C)
	SOS	NUMAPP
	SOJ	C,.+1
	CAILE	C,(A)
	JRST	VPR27
	SOJG	X1,VPR26
	POP	P,E
VPR28:	AOS	G,E		;LOOK FOR A HIGHER ADDRESS NEXT TIME
	MOVEM	E,VARFRE
	JRST	VPR0

VPR3:	PUSHJ	P,BASORT	;RESTORE SRTDBA
	SETOM	VPAKFL		;STRINGS ARE TIGHTLY PACKED
	POPJ	P,


SUBTTL DECIMAL NUMBER EVALUATE/PRINT
;ROUTINE TO EVALUATE NUMBER
;T: PNTR TO FIRST CHAR, C: FIRST CHAR
;NON-SKIP IS FAIL RETURN
;RETURN NUMBER IN N

;N: ACCUM NBMR, B: SCA FAC, D: DIG CNT, USE FLGS IN LEFT OF F

EVANUM:	SETZB	N,B		;CLEAR ACS
	MOVEI	D,8
	MOVEI	F,(F)		;CLEAR LH OF F

	TLNE	C,F.PLUS	;SKIP +
	JRST	EVAN1
	TLNN	C,F.MINS	;CHECK FOR -
	JRST	EVAN2		;NO
	TLO	F,F.MIN		;SET MINUS FLG
EVAN1:	SKIPN	IFIFG
	JRST	EV1
	PUSHJ	P,NXCHD
	JRST	.+2
EV1:	PUSHJ	P,NXCH
EVAN2:	TLNN	C,F.DIG		;DIGIT?
	JRST	EVAN3		;NO

	TLO	F,F.NUM		;DIGIT SEEN FLAG
	JUMPE	N,EVAN2A	;DONT COUNT LEADING ZEROS
	SOJG	D,EVAN2A	;COUNT DIGIT,  GO ACCUM IF OK
;			REST OF DIGITS ARE INSIGNIFIGANT.
	AOJA	B,EVAN2B	;LEAD OR TRAIL 0, FUDGE SCA FAC

EVAN2A:	IMULI	N,^D10		;ACCUMULATE DIGIT
	ADDI	N,-60(C)
EVAN2B:	TLNE	F,F.DOT		;DECIMAL SEEN?
	SUBI	B,1		;YES.  COUNT DOWN SCALE FACT
	JRST	EVAN1		;GO TO NEXT CHAR

EVAN3:	TLNN	C,F.PER		;NOT DIGIT.  DEC PNT?
	JRST	EVAN4		;NO.
	TLOE	F,F.DOT		;YES, SET FLG & CHK ONLY ONE
	POPJ	P,		;2 DEC PNTS
	JRST	EVAN1
EVAN4:	TLNN	F,F.NUM		;DID WE SEE A DIGIT?
	POPJ	P,		;NO.  WHAT A LOUSY NUMBER

	MOVEI	X1,"E"
	CAIE	X1,(C)		;EXPLICIT SCALE FACTOR?
	JRST	EVAN8		;NO
	SKIPN	IFIFG
	JRST	EV2
	PUSHJ	P,NXCHD
	JRST	.+2
EV2:	PUSHJ	P,NXCH		;DO LOOK AHEAD
	TLNE	C,F.PLUS	;SCALE FACTOR SIGN
	JRST	EVAN5
	TLNN	C,F.MINS
	JRST	EVAN6
	TLO	F,F.MXP
EVAN5:	SKIPN	IFIFG
	JRST	EV3
	PUSHJ	P,NXCHD
	JRST	.+2
EV3:	PUSHJ	P,NXCH
EVAN6:	TLNN	C,F.DIG		;CHK FOR DIGIT
	POPJ	P,
	MOVEI	A,-60(C)	;SAVE FIRST EXPON DIGIT
	SKIPN	IFIFG
	JRST	EV4
	PUSHJ	P,NXCHD
	JRST	.+2
EV4:	PUSHJ	P,NXCH
	TLNN	C,F.DIG		;IS THERE A SECOND DIGIT
	JRST	EVAN7		;NO
	IMULI	A,^D10		;YES.  ACCUMULATE IT
	ADDI	A,-60(C)
	SKIPN	IFIFG
	JRST	EV5
	PUSHJ	P,NXCHD
	JRST	.+2
EV5:	PUSHJ	P,NXCH		;DO LOOK AHEAD

EVAN7:	TLNE	F,F.MXP		;NEG EXPON?
	MOVN	A,A		;YES.  NEGATE IT
	ADD	B,A		;ADD TO SCALE FACTOR
EVAN8:	JUMPE	N,CPOPJ1	;IGNORE SCALE IF NUMBER IS 0
EVAN8A:	MOVE	X1,N		;)
	IDIVI	X1,^D10		;)REMOVE ANY TRAILING ZEROS
	JUMPN	X2,EVAN8B	;)  IN MANTISSA.  (REASON:
	MOVE	N,X1		;)  SO THAT, E.G., .1,
	AOJA	B,EVAN8A	;)  .10, .100, ..., ARE THE SAME)
EVAN8B:	TLO	N,233000	;FLOAT N
	FAD	N,[0]
	SETZM	LIBFLG		;CLEAR OVER/UNDERFLOW FLAG.
EVAN8C:	CAIGE	B,^D15		;SCALE UP IF .GE. 10^15
	JRST	EVAN8D
	SUBI	B,^D14		;SUBTRACT 14 FROM SCALE FACTOR
	FMPR	N,D1E14		;MULTIPLY BY 10^14
	JRST	EVAN8C		;GO LOOK AT SCALE AGAIN
EVAN8D:	CAML	B,[EXP -^D4]	;SCALE DOWN IF .LT. 10^-4
	JRST	EVAN8E
	ADDI	B,^D18		;ADD 18 TO SCALE
	FMPR	N,D1EM18	;MULTIPLY BY 10^-18
	JRST	EVAN8D		;GO LOOK AT SCALE AGAIN
EVAN8E:	FMPR	N,DECTAB(B)	;SCALE N
	TLNE	F,F.MIN		;MINUS?
	MOVN	N,N		;YES.  NEGATE IT
	SKIPE	LIBFLG		;SKIP IF NO OVER/UNDERFLOW.
	JRST	CPOPJ
	JRST	CPOPJ1		;SUCCESS RETURN, NUMBER IN N
;ROUTINE TO PRINT NUMBER


;POWER-OF-TEN TABLE.

D1EM18:	OCT	105447113564	;10^-18

DECFLO:
D1EM4:	OCT	163643334273	;10^-4
	OCT	167406111565
	OCT	172507534122
	OCT	175631463146
DECTAB:	DEC	1.0		;10^0
	DEC	1.0E1
	DEC	1.0E2
	DEC	1.0E3
	DEC	1.0E4
	DEC	1.0E5
	DEC	1.0E6
	DEC	1.0E7
	OCT	233575360401
	DEC	1.0E9
	DEC	1.0E10
	DEC	1.0E11
	OCT	250721522451	;10^12
	OCT	254443023471
D1E14:	OCT	257553630410	;10^14
DECCEI:

MAXEXP=^D38
DECFIX:	EXP 225400000000
FIXCON:	EXP 233400000000

;FLAGS USED BY DECIMAL READER/PRINTER

F.NUM=200000	;DIGIT SEEN
F.MIN=100000	;MINUS SEEN
F.MXP=40000	;MINUS EXPONENT
F.DOT=20000	;DECIMAL POINT SEEN
;SEMI-IFIX ROUTINE.
;IFIX EXPECTS A NON-NEGATIVE FLOATING POINT NUMBER IN AC N
;AND RETURNS A FIXED POINT INTEGER IN AC N.

IFIX:	PUSH	P,T
	PUSH	P,T1
	MOVE	T,N
	MULI	T,400
	SETZM	LIBFLG
	ASH	T1,-243(T)
	MOVE	N,T1
	POP	P,T1
	POP	P,T
	SKIPN	LIBFLG
	POPJ	P,
	HRLOI	N,377777
	POPJ	P,


;SEMI-IFLOAT ROUTINE.
;IFLOAT EXPECTS A NON-NEGATIVE FIXED POINT NUMBER IN AC N AND
;RETURNS A FLOATING POINT NUMBER IN AC N.

IFLOAT:	PUSH	P,T
	SETZ	T,
	LSHC	N,-^D8
	LSH	T,-^D9
	TLO	N,243000
	TLO	T,210000
	FADR	N,T
	POP	P,T
	POPJ	P,
SUBTTL	COMMAND SUBROUTINES

;ROUTINE TO PICK UP FILE NAME AND SET UP FOR DSK ACTION.
;THE FLAG COPFLG IS EXPLAINED AT THE COPY ROUTINE COPER.

FILNAM:	SETZM	COPFLG
FILNM1:	POP	P,B		;COPER ENTERS HERE, WITH COPFLG = -1.
	MOVEI	A,<SIXBIT /   DSK/>
	HRLI	A,<SIXBIT /   BAS/>
	HRLZM	A,@(B)
	HLLZM	A,FILDIR+1
	SETZM	FILDIR+2
	SETZM	FILDIR+3
	MOVEI	X2,FILDIR

        SETZM FILUSN
;CHECK FOR A LUSER NAME AND IF IT IS THERE THEN
;SET UP THE LUSER NAME BUFFER
	MOVEI	X1,"("		;BEG. OF USERNAME SPEC
	CAIE	X1,(C)		;DOES IT MATCH LAST CHAR?
	JRST	FILNU		;NO-NOT USERNAME
        PUSHJ P,ID
        JRST FILENU
;GOT A USER NAME - SET UP BUFFER
ID:	HRRZI	X1,FILUSN	;USER NAME BUFFER
	MOVEM	X1,FILDIR+3	;POINTER IS:  0,,BUFFER
	MOVEI	X1,-12		;12 CHARS
	MOVE	N,[POINT 6,FILUSN]
	SETZM	FILUSN
	SETZM	FILUSN+1	;RESET THE USERNAME BUFFER
FILRNN:	PUSHJ	P,NXCH		;GET NEXT CHARACTER
	TLNE	C,F.TERM	;TERMIMNATED?
	JRST	COMM2		;YES-THE GUY CANT TYPE
	MOVEI	D,")"		;CLOSING OF SPEC?
	CAIN	D,(C)
        POPJ P, ;FINISH
	AOJL	X1,FILRNN	;IGNORE PAST 12TH CHAR
	SUBI	C,40		;CONVERT TO 6-BIT
	IDPB	C,N		;SAVE CHAR IN BUFFER
	JRST	FILRNN		;ALL DONE
;END OF USER NAME SPEC
FILENU:	PUSHJ	P,NXCH		;NEXT CHARACTER FOR ATOM FINDER
FILNU:	PUSHJ	P,ATOMSZ
FILN7:	MOVEI	X1,":"		;DEVICE INDICATOR.
	CAIE	X1,(C)
	JRST	FILN1
	JUMPE	A,COMM2
	MOVEM	A,@(B)		
	PUSHJ	P,NXCH
	PUSHJ	P,ATOMSZ
	SKIPL	COPFLG
	JRST	FILN1
	JUMPN	A,FILN1
FILN8:	SETZM	COPFLG
	JRST	1(B)
FILNMO:	POP	P,B		;ENTRY POINT FOR NO DEVICE ALLOWED.
	MOVEI	A,<SIXBIT/   DSK/>
	HRLZM	A,@(B)
	SETZM	COPFLG
	HRRI	A,<SIXBIT /   BAS/>
	HRLZM	A,FILDIR+1
	MOVEI	X2,FILDIR
        SETZM FILUSN
        MOVEI X1,"("
        CAIE X1,(C)
        JRST .+3
        PUSHJ P,ID
        PUSHJ P,NXCH
	PUSHJ	P,ATOMSZ
FILN1:	TLNN	C,F.PER		;PERIOD SEEN?
	JRST	FILN2
	JUMPE	A,COMM2
	MOVEM	A,FILDIR
	MOVEI	X2,FILDIR+1
	PUSHJ	P,NXCH
	PUSHJ	P,ATOMSZ
FILN2:	JUMPN	A,FILN3
	CAIE	X2,FILDIR
	JRST	FILN3
	HRRZ	A,B
FILN9:	SKIPN	A,CURNAM
	JRST	COMM2
	MOVEM	A,FILDIR
	HLLZ	A,CUREXT
	MOVEM	A,FILDIR+1
	JRST	FILN5
FILN3:	CAIN	X2,FILDIR
	JRST	FILN4
FILN6:	TRNE	A,777777	;ONLY 3 CHARACTERS ALLOWED
	JRST	COMM2		;IN THE EXT.
FILN4:	MOVEM	A,(X2)
FILN5:	MOVEI	A,DRMBUF
	MOVEM	A,JOBFF
	JRST	1(B)

COMM2:	SKIPN	COMTIM		;COMMAND TIME?
	JRST	COMM1		;YES.
	SKIPL	COMTIM		;EXECUTION TIME?
	JRST	CHAER1		;YES.
	FAIL	<? ILLEGAL FILENAME> ;MUST BE COMPILE TIME.


;ROUTINE TO CONVERT NEXT ATOM TO SIXBIT

ATOMSZ:	HRLZI	D,F.LETT+F.DIG	;IT HAS SEVERAL
	JRST	ATOMS2		;ENTRY POINTS.
ALPHSX:	SKIPA	D,[Z (F.LETT)]
ATOMSX:	HRLZI	D,F.DIG+F.LETT	
ATOMS2:	TLZ	B,777777	;SET LH OF A+1 TO 0
	MOVEI	A,0
	MOVE	X1,[POINT 6,A]
ATOMS1:	TDNN	C,D
	POPJ	P,
	PUSHJ	P,SCNLTN	;PACK THIS LETTER INTO A.
	JFCL			;SCNLTN HAS SKIP RETURN.
	TLNE	X1,770000
	JRST	ATOMS1
	POPJ	P,
CHROOM:	MOVE	B,TABVAL(LP)
	ADD	X1,B		;TOTAL SPACE NEEDED FOR FIELD
	ADD	X1,HPOS(LP)
	CAML	X1,MARGIN(LP)
	JRST	PCRLF		;NO ROOM, GO TO NEXT LINE.
	JUMPL	B,PCRLF
	JUMPE	B,CPOPJ		;NO SPACING TO DO.
	MOVEI	C," "		;HERE TO PUT OUT SPACES
	PUSHJ	P,OUCH
	SOJG	B,.-2
	SETZM	TABVAL(LP)
	POPJ	P,
PCRLF:	MOVEI	C,15		;ROUTINE TO END A LINE AND
	PUSHJ	P,OUCH		;POSSIBLY BEGIN A NEW LINE.
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZM	TABVAL(LP)
	SETZM	HPOS(LP)
	SKIPG	C,PAGLIM(LP)
	JRST	PCRLF2
	AOS	PAGCNT(LP)
	CAME	C,PAGCNT(LP)
	JRST	PCRLF2
	MOVEI	C,14
	PUSHJ	P,OUCH
	SETZM	HPOS(LP)
	SETZM	PAGCNT(LP)
PCRLF2:	SKIPE	C,MARWAI(LP)
	MOVEM	C,MARGIN(LP)
	JUMPE	LP,FINPT3
	MOVE	C,MARGIN(LP)
	CAIL	C,^D7
	JRST	.+3
	SKIPGE	WRIPRI-1(LP)
	JRST	MARERR
FINPT3:	HRRZ	X2,(P)
	CAIN	X2,CRLF8
	POPJ	P,
	PUSHJ	P,NUMINS
	POPJ	P,

CRLF:	MOVE	C,HPOS(LP)	;ROUTINE USED BY "EMPTY" OUTPUT
	ADD	C,TABVAL(LP)	;STATEMENTS, AND RESTORE AND UXIT.
	JUMPE	C,CRLF4
	JUMPE	LP,CRLF5
	CAIN	C,^D6
	SKIPL	WRIPRI-1(LP)
	JRST	.+2
	JRST	CRLF3
CRLF5:	PUSHJ	P,PCRLF
CRLF8:	JRST	CRLF2
CRLF4:	PUSHJ	P,PCRLF2
CRLF3:	MOVEI	C,15
	PUSHJ	P,OUCH
	MOVEI	C,12
	PUSHJ	P,OUCH
	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	SKIPG	T,PAGLIM(LP)
	JRST	CRLF2
	AOS	PAGCNT(LP)
	CAME	T,PAGCNT(LP)
	JRST	CRLF2
	MOVEI	C,14
	PUSHJ	P,OUCH
	SETZM	PAGCNT(LP)
CRLF2:	SETZM	HPOS(LP)
CRLF1:	SETZM	TABVAL(LP)
	SETZM	FMTPNT(LP)
	JUMPN	LP,.+2
	OUTPUT 0,
	SETOM	FIRSFL(LP)
	POPJ	P,
;RESTORE DATA POINTER

RESTOR:	PUSHJ	P,RESTOS	;RESTORE BOTH NUMBERS AND STRINGS
RESTON:	TDZA	X1,X1		;RESTORE NUMERIC DATA
RESTOS:	MOVEI	X1,1		;RESTORE STRINGS
	MOVE	T,DATAFF
	ADD	T,FLLIN
	SUB	T,[XWD 1,1]
	MOVEM	T,DATLIN(X1)
	SETZM	PREAD(X1)		;CLEAR CURRENT LINE POINTER
	POPJ	P,


INERR:	PUSHJ	P,INLMES
	ASCIZ/
? DATA FILE LINE TOO LONG/
	JRST	GOSR2

PTXER1:	PUSHJ	P,INLMES
	ASCIZ	/
? ILLEGAL CHARACTER IN STRING/
	JRST	GOSR2

FNMX0:	MOVEI	LP,(X1)
FNMXER:	SKIPN	ACTBL-1(LP)
	JRST	FNR
FNMX1:	PUSHJ	P,INLMES
	ASCIZ	/
? MIXED RANDOM & SEQ. ACCESS/
	JRST	GOSR2

PTXER2:	PUSHJ	P,INLMES
	ASCIZ	/
? OUTPUT ITEM TOO LONG FOR LINE/
	JRST	GOSR2


FNR:	PUSHJ	P,INLMES
	ASCIZ/
?  FILE NEVER ESTABLISHED - REFERENCED/
	JRST	GOSR2

EOFFAL:         POP P,X1
        PUSHJ P,INLMES
        ASCIZ/
? EOF/
        JRST GOSR2
CHAER1:	PUSHJ	P,INLMES
	ASCIZ	/
? ILLEGAL FILENAME/
	JRST	GOSR2

MARERR:	PUSHJ	P,INLMES
	ASCIZ	/
? MARGIN TOO SMALL/
	JRST	GOSR2

OUTBND:	PUSHJ	P,INLMES
	ASCIZ	/ OUT OF BOUNDS/
	JRST	GOSR2

PAGERR:	PUSHJ	P,INLMES
	ASCIZ	/
? PAGE LENGTH/
	JRST	OUTBND

SUBTTL ERROR MESSAGES

;ERROR MESSAGE ROUTINE.
;
;AC T ENTERS WITH THE LOC OF THE MESSAGE.
;ALL OTHER AC'S, EXCEPT P, CAN BE DESTROYED.

ERRMSG:	SETZM	ODF
	SETZM	HPOS
	PUSHJ	P,TTYIN
	SETZ	D,		;END ON NULL.
	PUSHJ	P,PRINT		;PRINT MESSAGE.
	SKIPE	CHAFL2		;CHAINING?
	JRST	.+3
	OUTPUT 0,
        GO (1,UXIT)
ERRMS2: JFCL
ERRMS3:	PUSHJ	P,INLMES
	ASCIZ	/ IN /
	PUSH	P,ODF
	SETZM	ODF
	HLRZ	T,CURDEV
	CAIN	T,<SIXBIT/   DSK/>
	JRST	ERRMS4
	MOVE	T,CURDEV	;DEV MAY BE > 3 LETTERS.
	PUSHJ	P,PRNSIX
	MOVEI	T,32
	PUSHJ	P,PRNSIX
ERRMS4:	MOVE	T,CURNAM
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	POP	P,ODF
	OUTPUT 0,
	SETZM	HPOS
	GO (1,UXIT)

NOOUT:	ASCIZ	/
? CANNOT OUTPUT TO THIS DEVICE/
NOIN:	ASCIZ	/
? CANNOT INPUT FROM THIS DEVICE/
COMM1:	PUSHJ	P,INLMES
	ASCIZ /
? WHAT?
/
COMM1A:	SKIPE	CURNAM		;HAS A NEW OR OLD FILE BEEN SPECIFIED YET?
        GO (1,FIXUP)
        GO (1,ASKNEW)

NOSAVE:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	"
? CANNOT OUTPUT "
	MOVE	T,FILDIR
	PUSHJ	P,PRNSIX
	HLRZ	T,CUREXT
	CAIN	T,<SIXBIT/   BAS/>
	JRST	.+3
	TLO	T,16
	PUSHJ	P,PRNSIX
	OUTPUT 0,
	SETZM	HPOS
        GO (1,BASIC)

INERR1:	ASCIZ	/
? LINE TOO LONG/

NOGETF:	PUSHJ	P,QNTFND
        GO (1,BASIC)

TTYIN:	PUSH	P,T
	MOVEI	T,TTYBUF	;SET UP TTY BUFFS
	MOVEM	T,JOBFF
	INIT 0 ,	1
	SIXBIT	/TTY/
	XWD	TYO,TYI
	HALT	.-3
	INBUF 0 ,	1
	OUTBUF 0 ,	1
	POP	P,T
	POPJ	P,

	EXTERN BADGNN,BADMSG,CRLFMS,FILUSN


NOGETD:	SETZM	ODF
	PUSH	P,T
	PUSHJ	P,INLMES
	ASCIZ	/
? NO SUCH DEVICE /
	POP	P,T
	PUSHJ	P,PRNSIX
	OUTPUT 0,
        GO (1,UXIT)

NOLIN:	ASCIZ	/
? NO SUCH LINE IN RUN(NH) OR CHAIN/

ILLIN:	ASCIZ	/
? ILLEGAL LINE REFERENCE IN RUN(NH) OR CHAIN/

OUTERR:	MOVEI	T,INLSYS	;OUTERR EXPECTS THE STATUS BITS IN N.
	TRNE	N,040000
	MOVEI	T,OUTQMS
	TRNE	N,400000
	MOVEI	T,OUTLMS
	JRST	ERRMSG
OUTLMS:	ASCIZ	/
? DEVICE IS WRITE LOCKED/
OUTQMS:	ASCIZ	/
? QUOTA EXCEEDED OR BLOCK NO. TOO LARGE ON OUTPUT DEVICE/


NUMINS:	JUMPE	LP,CPOPJ
	SKIPGE	WRIPRI-1(LP)	;NEED A LINE NUMBER?
	SKIPE	HPOS(LP)
	POPJ	P,		;NO.
	MOVEI	X2,12		;YES.
	ADDB	X2,LINNUM-1(LP)
	CAILE	X2,^D99999
	JRST	NUMLRG
	PUSH	P,T
	MOVE	T,@OUTCNT-1(LP)
	JUMPLE	T,NUMIN2
	IDIVI	T,5
	JUMPE	T1,NUMIN2
	SETZ	C,		;PAD WITH NULLS SO THAT THE LINE
	PUSHJ	P,OUCH		;NUMBER STARTS IN A NEW WORD.
	SOJG	T1,.-2
NUMIN2:	MOVE	T,LINNUM-1(LP)
	SETZM	NUMCOT
	PUSHJ	P,PRTNUM
	MOVEI	T,5
	MOVEM	T,HPOS(LP)
	MOVE	T,NUMCOT
	SUBI	T,5
	MOVE	T1,@OUTPT-1(LP)
	MOVE	T1,(T1)
	JUMPE	T,NUMIN3
NUMIN4:	LSH	T1,-7		;PAD WITH LEADING ZEROES (RE-
	TLO	T1,300000	;QUIRED BY THE LINED CUSP).
	IBP	@OUTPT-1(LP)
	SOS	@OUTCNT-1(LP)
	AOJL	T,NUMIN4
NUMIN3:	TRO	T1,1		;SET THE "SEQ. NO." BIT.
	MOVE	T,@OUTPT-1(LP)
	MOVEM	T1,(T)
	POP	P,T
	MOVEI	C,11		;TAB.
	PUSHJ	P,OUCH
	POPJ	P,

EXTERN	NUMCOT


NUMLRG:	PUSHJ	P,TTYIN
	PUSHJ	P,INLMES
	ASCIZ	/
? ATTEMPT TO WRITE A LINE NUMBER > 99,999/
	JRST	GOSR2
;UTILITY ROUTINE TO INPUT A BLOCK FOR A R.A. FILE. THE DESIRED
;BLOCK NUMBER IS IN X2.

GOSR2: JFCL
GOSR3:	PUSHJ	P,INLMES
	ASCIZ	/ IN LINE /
	MOVE	T,SORCLN	;PRINT LINE NUMBER AND CONTINUE EXECUTION.
	PUSH	P,ODF
	SETZM	ODF
	PUSHJ	P,PRTNUM
	POP	P,ODF
	SKIPE	CHAFL2		;CHAINING?
	PUSHJ	P,ERRMS3
GOSR6:	PUSHJ	P,INLMES
	ASCIZ	/
/
	OUTPUT 0,
        GO (1,UXIT)

MAKNUZ: SETZM @SEQPNT ;CLEAR JUNK BEFORE LINE NO CALC
MAKNUM:	IDIVI	X1,^D10
	JUMPE	X1,MAKN1
	PUSH	P,X2
	PUSHJ	P,MAKNUM
	POP	P,X2
MAKN1:	MOVEI	X2,60(X2)
	IDPB	X2,SEQPNT
	POPJ	P,
QNTFND:	PUSHJ	P,INLMES	;HERE WHEN FILE NOT FOUND
	ASCIZ/
? FILE /
	PUSHJ	P,PRNNAM
	PUSHJ	P,INLMES
	ASCIZ	/ NOT FOUND/
	OUTPUT 0,
	SETZM	HEDFLG
	POPJ	P,
;TABLE OF INTRINSIC FUNCTIONS

DEFINE ZZZ. (X) <
	OPDEF ZZZZ. [SIXBIT /X/]
		ZZZZ.
>

IFNFLO:
	ZZZ.	(ABS)
	ZZZ.	(ASC)
	ZZZ.	(ATN)
	ZZZ.	(CHR$)
        ZZZ.    (CLOG)
	ZZZ.	(COS)
	ZZZ.	(COT)
	ZZZ.	(DET)
        ZZZ.    (EPS)
	ZZZ.	(EXP)
	ZZZ.	(INSTR)
	ZZZ.	(INT)
	ZZZ.	(LEFT$)
	ZZZ.	(LEN)
        ZZZ.    (LN)
	ZZZ.	(LOC)
	ZZZ.	(LOF)
	ZZZ.	(LOG)
        ZZZ.    (LOGE)
        ZZZ.    (LOG10)
	ZZZ.	(MID$)
	ZZZ.	(NUM)
	ZZZ.	(RIGHT$)
IFN FTRND,<
	ZZZ.	(RND)
>
        ZZZ.    (ROUND)
	ZZZ.	(SGN)
	ZZZ.	(SIN)
	ZZZ.	(SPACE$)
        ZZZ.    (SQRT)
	ZZZ.	(SQR)
	ZZZ.	(STR$)
	ZZZ.	(TAN)
	ZZZ.	(VAL)
IFNCEI:

%FN=1
	DEFINE ZZZ. (X) <
	OPDEF ZZZZ. [%FN]
	ZZZZ.
	%FN=%FN+1
>

IF2FLO:
	ZZZ.	(ABS)
	ZZZ.	(ASC)
	XWD	-1,%ATANB
	XWD	-1,%CHRB
        XWD     -1,%CLOGB
	XWD	-1,%COSB
	XWD	-1,%COTB
	ZZZ.	(DET)
        ZZZ.    (EPS)
	XWD	-1,%EXPB
	XWD	IF31,%INSTRB
	XWD	-1,%INTB
	XWD	IF32,%LEFTB
	XWD	+1,%LENB
        XWD     -1,%LOGB
	ZZZ.	(LOC)
	ZZZ.	(LOF)
	XWD	-1,%LOGB
        XWD     -1,%LOGB
        XWD     -1,%CLOGB
	XWD	IF33,%MIDB
	ZZZ.	(NUM)
	XWD	IF32,%RIGHTB
	XWD	0,%RNDB
        XWD     IF34,%ROUNDB
	ZZZ.	(SGN)
	XWD	-1,%SINB
	XWD	-1,%SPACEB
	XWD	-1,%SQRTB
        XWD     -1,%SQRTB
	XWD	-1,%STRB
	XWD	-1,%TANB
	XWD	+1,%VALB
IF2CEI:


IF31:	XWD 3		;ARG BLOCK FOR INSTR
	XWD -1,-1
	XWD 0,+1
	XWD 0,+1

IF32:	XWD 2		;ARG BLOCK FOR LEFT$, RIGHT$.
	XWD 0,+1
	XWD 0,-1

IF33:	XWD 3		;ARG BLOCK FOR MID$
	XWD 0,+1
	XWD 0,-1
	XWD -1,-1

IF34:   XWD 2
        XWD 0,-1
        XWD 0,-1
;TABLE OF RELATIONS FOR IFSXLA

DEFINE ZZZ. (X,Y)<
OPDEF ZZZZ.	[X]
		ZZZZ.	(Y)>
RELFLO: XWD     343400,2        ;<<
	ZZZ.	3435B11,CAML
	ZZZ.	3436B11,CAME
        XWD     350300,3        ;=#
	ZZZ.	   74B6,CAMLE
	ZZZ.	3635B11,CAMG
        XWD     363600,1        ;>>
	ZZZ.	75B6,CAMN
	ZZZ.	   76B6,CAMGE
RELCEI:
;ROUTINE THAT SKIPS OVER ONE DATA FIELD
SKIPDA:	TLNE	C,F.QUOT	;QUOTE STRING?
	JRST	QSKIP		;YES, USE QSKIP ROUTINE
	TLNE	C,F.COMA+F.TERM	;FIELD TERMINATOR?
	JRST	CPOPJ1
	PUSHJ	P,NXCH	
	JRST	.-3

IFE FTSTR,<
SKIPDA:	POPJ	P,	;STRINGS NOT ALLOWED. DATA ERROR
SSKIP:	ADD	P,[XWD -2,-2]	;CLEAN UP PUSHLIST
	JRST	INPERR
>

CTTAB:
	XWD	F.NU,	F.STR	;NULL	, @
	XWD	F.STR,	F.LETT	;	, A
	XWD	F.STR,	F.LETT	;	, B
	XWD	F.STR,	F.LETT	;	, C
	XWD	F.STR,	F.LETT	;	, D
	XWD	F.STR,	F.LETT	;	, E
	XWD	F.STR,	F.LETT	;	, F
	XWD	F.STR,	F.LETT	;	, G
	XWD	F.STR,	F.LETT	;	, H
	XWD	F.SPTB,	F.LETT	;TAB	, I
	XWD	F.CR,	F.LETT	;LF	, J
	XWD	F.CR,	F.LETT	;VER.TAB, K
	XWD	F.CR,	F.LETT	;FFEED	, L
	XWD	F.CR,	F.LETT	;CR	, M
	XWD	F.STR,	F.LETT	;	, N
	XWD	F.STR,	F.LETT	;	, O
	XWD	F.STR,	F.LETT	;	, P
	XWD	F.STR,	F.LETT	;	, Q
	XWD	F.STR,	F.LETT	;	, R
	XWD	F.STR,	F.LETT	;	, S
	XWD	F.STR,	F.LETT	;	, T
	XWD	F.STR,	F.LETT	;	, U
	XWD	F.STR,	F.LETT	;	, V
	XWD	F.STR,	F.LETT	;	, W
	XWD	F.STR,	F.LETT	;	, X
	XWD	F.STR,	F.LETT	;	, Y
	XWD	F.STR,	F.LETT	;	, Z
	XWD	F.ESC,	F.STR	;ESC	, [
	XWD	F.STR,	F.STR	;	, \
	XWD	F.STR,	F.STR	;	, ]
	XWD	F.STR,	F.OTH	;	, ^
	XWD	F.STR,	F.OTH	;	, _
        XWD     F.SPTB, F.STR           ;SPACE  , <ACCENT GRAVE>
	XWD	F.STR,	F.LETT+F.LCAS	; !	, <LOWER CASE> A
	XWD	F.QUOT,	F.LETT+F.LCAS	; "	, <LOWER CASE> B
	XWD	F.OTH,	F.LETT+F.LCAS	; #	, <LOWER CASE> C
	XWD	F.DOLL,	F.LETT+F.LCAS	; $	, <LOWER CASE> D
	XWD	F.STR,	F.LETT+F.LCAS	; %	, <LOWER CASE> E
	XWD	F.OTH,	F.LETT+F.LCAS	; &	, <LOWER CASE> F
	XWD	F.APOS,	F.LETT+F.LCAS	; '	, <LOWER CASE> G
	XWD	F.OTH,	F.LETT+F.LCAS	; (	, <LOWER CASE> H
	XWD	F.RPRN,	F.LETT+F.LCAS	; )	, <LOWER CASE> I
	XWD	F.STAR,	F.LETT+F.LCAS	; *	, <LOWER CASE> J
	XWD	F.PLUS,	F.LETT+F.LCAS	; +	, <LOWER CASE> K
	XWD	F.COMA,	F.LETT+F.LCAS	; , 	, <LOWER CASE> L
	XWD	F.MINS,	F.LETT+F.LCAS	; -	, <LOWER CASE> M
	XWD	F.PER,	F.LETT+F.LCAS	; .	, <LOWER CASE> N
	XWD	F.SLSH,	F.LETT+F.LCAS	; /	, <LOWER CASE> O
	XWD	F.DIG,	F.LETT+F.LCAS	; 0	, <LOWER CASE> P
	XWD	F.DIG,	F.LETT+F.LCAS	; 1	, <LOWER CASE> Q
	XWD	F.DIG,	F.LETT+F.LCAS	; 2	, <LOWER CASE> R
	XWD	F.DIG,	F.LETT+F.LCAS	; 3	, <LOWER CASE> S
	XWD	F.DIG,	F.LETT+F.LCAS	; 4	, <LOWER CASE> T
	XWD	F.DIG,	F.LETT+F.LCAS	; 5	, <LOWER CASE> U
	XWD	F.DIG,	F.LETT+F.LCAS	; 6	, <LOWER CASE> V
	XWD	F.DIG,	F.LETT+F.LCAS	; 7	, <LOWER CASE> W
	XWD	F.DIG,	F.LETT+F.LCAS	; 8	, <LOWER CASE> X
	XWD	F.DIG,	F.LETT+F.LCAS	; 9	, <LOWER CASE> Y
	XWD	F.OTH,	F.LETT+F.LCAS	; :	, <LOWER CASE> Z
	XWD	F.OTH,	F.STR		; ;	, <LEFT BRACE>
	XWD	F.OTH,	F.STR		; <	, <VERTICAL BAR>
	XWD	F.EQAL,	F.STR		; =	, <RIGHT BRACE>
	XWD	F.OTH,	F.STR		; >	, <TILDE>
	XWD	F.STR,	F.STR		; ?	, <RUBOUT>
INTERNAL STAFLO,STACEI
STAFLO:
	Z	XCHAN+20000(SIXBIT /   CHA/)
	Z	XDATA+40000(SIXBIT /   DAT/)
	Z	XDEF+40000(SIXBIT /   DEF/)
	Z	XDIM(SIXBIT /   DIM/)
	Z	XEND(SIXBIT /   END/)
	Z	XFILE+40000(SIXBIT/   FIL/)
	Z	XFNEND+60000(SIXBIT /   FNE/)
	Z	XFOR+20000(SIXBIT /   FOR/)
	Z	XGOSUB+60000(SIXBIT /   GOS/)
	Z	XGOTO+40000(SIXBIT /   GOT/)
	Z	XIF+20000(SIXBIT /   IF /)
	Z	XINPUT+60000(SIXBIT /   INP/)
	Z	XLET+20000(SIXBIT /   LET/)
	Z	XMAR+60000(SIXBIT /   MAR/)
IFN FTMAT,<
	Z	XMAT+20000(SIXBIT /   MAT/)
>
	Z	XNEXT+60000(SIXBIT /   NEX/)
	Z	XNOP+60000(SIXBIT /   NOP/)
	Z	XNOQ+60000(SIXBIT /   NOQ/)
	Z	XON+20000(SIXBIT /   ON /)
	Z	XPAG+60000(SIXBIT /   PAG/)
	Z	XPRINT+60000(SIXBIT /   PRI/)
	Z	XQUO+60000(SIXBIT /   QUO/)
IFN FTRND,<
	Z	XRAN+60000(SIXBIT /   RAN/)
>
	Z	XREAD+60000(SIXBIT /   REA/)
	Z	NXTST1(SIXBIT /   REM/)
	Z	XREST+60000(SIXBIT /   RES/)
	Z	XRETRN+60000(SIXBIT /   RET/)
	Z	XSCRAT+60000(SIXBIT/   SCR/)
	Z	XSET+20000(SIXBIT /   SET/)
	Z	XSTOP+40000(SIXBIT /   STO/)
	Z	XWRIT+60000(SIXBIT/   WRI/)
STACEI:
EXTERN STSTRP
TRPMSG:	HLRZ	T,TRPLOC+3
	SETZM	TRPLOC+2
	SETZM	TRPLOC+3
	DPB	T,[POINT 4,STSTRP,12]
	XCT	STSTRP
	MOVEI	T,TRPMS1
	JRST	ERRMSG
TRPMS1:	ASCIZ	/
? DEVICE OK?
/
        END
 m P