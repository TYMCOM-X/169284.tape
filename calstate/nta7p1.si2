! TITLE: COMMAND DISPATCHER PTCMD.SIM FOR PAPER TAPE HACKAGE
! SUBTTL: OCTOBER 25, 1973 - VERSION 7.00 UPDATE

!  THE PDP-10 WILL DO ILDB'S FOR ANY BYTE SIZE.
DEF BYPT(Y,P,S) AS [6,6,6,18]*[IF P>=0 THEN 36-S*(P MOD(36/S)-1)&
        ELSE 36-S*(36/S-(-P)MOD(36/S)+1),S,0,&
        IF P>=0 THEN Y+P/(36/S) ELSE Y+(P+1)/(36/S)-1]
DEF NBYV AS NCHV
DEF BYV AS CHV
DEF IONEOU(X) AS EXU(OCT 51,OCT 15,4,X) !TTCALL 15,4 OR  IONEOU 4
DEF SLEEP(X) AS EXU(OCT 47,4,OCT 31,X)  !SLEEP 4,
DEF MOUTSTR(X) AS EXU(OCT 51,OCT 3,X)    !TTCALL 3,M  OR  OUTSTR M
DEF OUTHOW AS (IF TELFIL=TEL THEN OUTMSG ELSE OUTPUT)
DEF ENDF AS RETURN FIRK
DEF ENDK AS OK; RETURN EMPTY
DEF C.MAX AS 100 !MAXIMUM SIZE OF CWORDS ARRAY
DEF S.MAX AS 130 ! MAXIMUM SIZE OF SWORDS ARRAY

DEF ENDR AS RETURN EMPTY
DEF TOKEN AS TOKBUF(0)
DEF SETIN AS CSTRING(POINTX(TOKBUF),POINTX(IFILS))
DEF SETOU AS CSTRING(POINTX(TOKBUF),POINTX(OFILS))
DEF MORE AS CKEOL(STR)=FALSE
DEF POINT(X) AS CHPT(X,-1)
DEF POINTX(X) AS CHPT(@X(0),-1)
DEF GIVEUP AS GO UNXERR
DEF ZILCH AS TERMCH=CARRET
DEF CRLF AS PUT(CARRET) !C.R. AND L.F.
DEF NO.CMDF AS 10       !NUMBER OF COMMAND-FILES ALLOWED OPEN
DEF IORDX AS 10         !DEFAULT I-O RADIX (IT'S DECIMAL)
DEF NO.CHAR AS 250      !MULT. OF 5 - NO OF CHARACTER IN READ BUFFER
DEF MINS(X) AS X*1      !NUMBER OF IOCS BUFFERS PER MINUTE [==1]
DEF NO.CRAPS AS MINS(5) !NUMBER OF MINUTES BETWEEN CRASH PROTECTION
DEF NO.IOCB AS 10       !NUMBER OF DIRECT MODE IOCS BUFFERS
DEF SR.SIZE AS OCT 250  !MAX CHARACTER FOR 'SPLICE' COMMAND BUFFER
DEF NO.SPLI AS OCT 60   !# CHARACTERS TO USER IN SPLICE COMMAND
DEF PE.MAX AS 100       !MAX. NO. PARITY ERRORS PER IMAGE LINE (<NOCHAR)
DEF MAX.CHR AS OCT 177  !MAX. CHARACTER THIS PROGRAM CAN HANDLE
DEF MAX.DIG AS 11       !MAX. NO. OF DIGITS
DEF TCHR AS OCT 175     !CHARACTER WHICH TERMINATES TITLE STRING
DEF TRUE AS 1		!TRUE STATEMENT
DEF FALSE AS 0		!FALSE STATEMENT
DEF EMPTY AS -1         !EMPTY EXPRESSION
DEF FIRK AS -2          !A FIRKED UP EXPRESSION
DEF STRING AS 1		!STRING EXPRESSION
DEF NUMBER AS 2		!NUMERIC EXPRESSION
DEF RESWRD AS 3		!RESERVED WORD
DEF DELIMT AS 4         !TERMINATOR
DEF OFF AS 7
DEF EVEN AS 8
DEF ODD AS 9
DEF DATA AS 10
DEF PACKD AS 49
DEF NUMIN AS OCT 1
DEF STRIN AS OCT 2
DEF RESIN AS OCT 4

DEF S.BUFF AS 100               !SUBSTITUTE BUFFER WORD SIZE
FIND SWORDS(0:400),HELPM(0),TWORDS(0:OCT 137),CWORDS(0:400)
FIND SEGB(0:10),S.SIZE,C.SIZE
FIND YESNO(0),COMNDS(0),PRITY(0),TTLE(0),SYMBIN(0),REPIT(0),ECHIT(0),NOTBL(0),SUBIT(0),USETB(0),EDITB(0),RDXE(0),EDITR(0)
FIND %SETTY,%RDTTY,%OPNPTP,%CLSPTP,%WRTPTP,%SETSEG,%RDFIL,%SETSCR
FIND %SETUP
FIND JOBFF,JOBSA,JOBDDT,JOBVER,JOBREN,JOBAPR         !!!JOBDAT, RAH!!!
FIND ALTMOD:,ESCAPE:,BEGIN:,RESADR:
FIND %NCHR,%GETOKEN,%CTOKEN,%STOKEN,%SINC,%INSC,%STRCOMP,%INDEX,%OK
FIND %CSTRING,%FIRKIT,%NCHAR,%TYPCHR,%OUTNUM,%NXLIN,%ERR
FIND %OUTSTR,%PRM,%FIGURE,%DOCMD,%INIT,%HELP,%READ,%PUNCH,%SUBGET
FIND %COPYST,%SUBPUT,%SUBOUT,%OUTTIT,%LEDTRL,%CONFMP,%MAKPAR,%SUBCR
FIND %SUBINI,%SUBPRC,%LEV7,%MAKTMP,%LEV8,%WSTR,%OUCH,%OUCS,%NXCHR
FIND %SUBRD,%PARERR,%SUBWT,%SUBCLN,%WINT,%PAROUT,%CNTER,%SWSTR,%SWOUT
FIND %SUBRED,%CRASHP,%NEWCMD,%OLDCMD,%STRIP,%SEARCH,%SERRD,%CHECK.ARRAY
FIND %OUTIMG,%HELPER,%CKEOL,%NUMOUT,%COPYT,%CBHELP,%GPRM,%NULP
FIND CHAR,TOKBUF(0:50),TERMCH,TYPE,SLEEPY,TITBUF(0:50),TITLE
FIND ECHAR,ELINE,LENGTH,PARITY,STR,SVPLAC,FCORE()
FIND ISUBTAB(0:MAX.CHR),ESUBTAB(0:MAX.CHR)
FIND LASLIN,LASINP,TELFIL,LASPRM,RUNFLG,ECHO,RPTYPE,SYMBN,IFILE,OFILE
FIND SUBPTR,SUBUFF(0:S.BUFF),OFILS(0:10),IFILS(0:10),MTOKS(0:20)
FIND PARNAM(0:5),TAPNAM(0:5),PARTY,CMDFLS(0:NO.CMDF),CURCMD,LINFLG(0:NO.CMDF)
FIND USEFLG,ALWP8T,LASFMP,CIORDX,IRECTAB(0:MAX.CHR),ERECTAB(0:MAX.CHR)
FIND RECPTR,SCRNAM(0:5),MYFID(0:15),CMDNO
GLOBAL %FOO,%GOCMD

! PROCEDURE: FOO
! THIS IS THE MAIN PROCEDURE.. SCANS INPUT LINE AND PERFORMS ONE
! TASK AND EXITS.  THIS SHOULD BE CALLED BY AN INFINITE LOOP.
! ARGUMENTS: NONE
!
%FOO

! TURN ON ESCAPES
        ON.ALT

! MAKE SURE ALL FILES ARE CLOSED
        IF IFILE#TEL THEN CLOSE(IFILE<==TEL)
        IF OFILE#TEL THEN CLOSE(OFILE<==TEL)
        SET.PRMPT(IF TELFIL=TEL THEN %GPRM ELSE %NULP) ! SET PROMPT RTN
        INC CMDNO ! INCREMENT CURRENT COMMAND NO.
        IF TELFIL # TEL THEN GPRM ! IF NOT FROM TEL, EVALUATE PROMPT
        STR_NXLIN; SET.PRMPT(%NULP)

        EIF TYPE_CTOKEN(@STR,COMNDS,RESIN)=DELIMT AND (CHAR=CAR.RET OR CHAR=LN.FEED) THEN ENDF
        ORIF TYPE=NUMBER AND TELFIL#TEL AND TOKEN=62 THEN DO
          COPYT(@STR); ENDR
          END
        ORIF TYPE=FIRK OR TYPE=EMPTY THEN ENDF
        FIF TYPE#RESWRD THEN [ERR('COMMAND REQUIRED$');ENDF]

        RETURN GOCMD(TOKEN)

END FOO

! PROCEDURE: GOCMD
! TAKES AS ARGUMENT A COMMAND NUMBER TO BE EXECUTED
!
! IT EXPECTS THAT IT HAS JUST BEEN TAKEN BY THE 'CTOKEN' CALL
!
%GOCMD(ARG1)

GLOBAL TABLE TELSTR(0:0) ["TERMINAL"]

LOCAL VAL,SAVRET,OPNER1:,VAL1,VAL2,SAVSTR,S1,S2,S3,S4,S5,COMAFL,E25:,E48:,ER46:,E25A

        DO ARG1 OF 0:C.MAX

61:     !PRINT! IF MORE THEN ENDF
        STR_POINT("TERMINAL"); TERMCH_$ ; TYPE_DELIMT
        SAVRET_RETURN
        GOCMD(24)
        RETURN_SAVRET
        ENDR

60:     !DDT! IF MORE THEN ENDF
        IF JOBDDT BAND OCT 777777 # 0 THEN DO
          JOBSA_RESADR           !REENTER
          MSG('$DDT$'); GO ^(VAL_JOBDDT BAND OCT 777777)
          END
        ERR('DDT NOT LOADED!$'); ENDF

59:     !DO! IF ZILCH THEN [PRM('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))
        NEWCMD(OPEN(@TOKEN,SEQUEN+INPUT+CHARACTER,OPNER1,1))
        ENDR

55:     !RADIX! IF ZILCH THEN [PRM('$DEFAULT I-O RADIX: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,RDXE,RESIN+NUMIN)=RESWRD THEN DO
          EIF TOKEN=56 OR TOKEN=58 THEN CIORDX_8
          ORIF TOKEN=57 THEN CIORDX_10
          ELSE GIVEUP
          END
        ORIF TYPE=NUMBER THEN DO
          IF NOT (2<=TOKEN<=16) THEN &
          [ERR('$RADIX MUST BE BETWEEN 2 AND 16, INCLUSIVE$'); ENDF]
          CIORDX_TOKEN
          END
        ELSE GIVEUP
        OK
        ENDR

54:     !CAPABILITIES! HELPER(POINT("CAPABILITIES")); ENDR

53:     !INSTRUCTIONS! HELPER(POINT("INSTRUCTIONS")); ENDR


50:     !USE! IF ZILCH THEN [PRM('$PDP10 OR TERMINAL: ');STR_NXLIN]
        IF TYPE_CTOKEN(@STR,USETB,RESIN)#RESWRD THEN GIVEUP
        IF MORE THEN ENDF
        EIF TOKEN=51 THEN USEFLG_FALSE
        ORIF TOKEN=52 THEN USEFLG_TRUE
        ELSE GIVEUP
        OK
        ENDR

48:     !SPLICE! IF ZILCH THEN&
        [PRM('$WHAT WAS YOUR JOB ID NUMBER? ');STR_NXLIN]
        IF TYPE_CTOKEN(@STR,0,NUMIN)#NUMBER THEN GIVEUP
        STR_POINTX(OFILS); NCHV STR_$B
        IF TOKEN < 10 THEN NCHV STR _ $0
        INSC(TOKEN,@STR,10); PCHV STR
        CSTRING(CHPT("TAP.TMP",-1),STR); STR_POINTX(OFILS)
        NEWCMD(OPEN(@OFILS(0),DIRECT+CHARACTER+INPUT,E48,2))
        LASLIN_0
        ENDR

! ERROR DURING OPEN OF TEMPORARY FILE
E48:    MSG('CANNOT RECOVER CRASH PROTECTION FILE FOR THAT JOB ID$')
        ENDF

46:     !SSPLICEREAD! IF ZILCH THEN [PRM('$FILE TO SPLICE: '); STR_NXLIN]
        SYMBN_1; CSTRING(STR,POINTX(TOKBUF))
        SETOU
        OLDCMD                  !CLOSE CUR.FILE AND OPEN OLD
        IFILE_TEL
        IF SYMBN=1 THEN CHAR_CHARACTER ELSE CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        OFILE_OPEN(@TOKEN,DIRECT+OLD+CHAR+UPDATE,OPNER1,2)

        IF SIZE(OFILE)<OCT 2000 THEN DO
          ERR('ONLY '); OUTNUM(SIZE(OFILE),CIORDX)
          IF SYMBN=1 THEN MSG(' CHARACTERS') ELSE MSG(' WORDS')
          MSG(' WERE READ INTO THE OUTPUT FILE$IT WOULD BE FASTER TO RE-READ THE TAPE$')
          ENDR
          END


! TYPE OUT SOME OF THE FILE
        SETRWE(OFILE,ER46)
        S5_SIZE(OFILE)
        SETCP(OFILE,S5-NO.SPLI)
        MSG('$THE LAST '); OUTNUM(NO.SPLI,CIORDX)
        MSG(' CHARACTERS ON THE FILE ARE:$$"')
        LOOP TTY_R(OFILE)

ER46:   MSG('"$$')

! OK -- READ IN THE STUFF
        WHILE SEARCH(OFILE)#TRUE THEN LOOP DO
          PRM('$TRY AGAIN? '); STR_NXLIN
          IF TYPE_CTOKEN(@STR,YESNO,RESIN)=RESWRD AND TOKEN=12 THEN ENDR
          IF NOT (TYPE=RESWRD AND TOKEN=11) THEN &
          ERR('$ANSWER YES OR NO:')
          WHILE NOT (TYPE=RESWRD AND TOKEN=11)
          END
        IFILE_TEL; SYMBN_1
        OUTNUM(READ(IFILE,@OFILE)-S5,CIORDX)       ! TYPE # CHARACTERS READ
        MSG(' TOTAL CHARACTERS READ$')
        MSG('$SPLICE COMPLETED.$')
        ENDR

43:     !SUMMARY! MSG('$FOR COMPLETE LIST OF COMMANDS, TYPE "HELP"$')
        MSG('$FOR A SUMMARY OF VALID INPUT ARGUMENTS OR COMMANDS AT ANY')
        MSG('$POINT IN A COMMAND STRING, TYPE THE CHARACTER ? (FOR')
        MSG("$EXAMPLE,  :?   OR   :TITLE ?).  THE WORD 'HELP' MAY BE")
        MSG('$GIVEN IN PLACE OF ? FOR A DETAILED LIST OF ARGUMENTS$')
        ENDR

42:     !REPRESENTATION! IF ZILCH THEN [PRM('$LITERAL REPRESENTATION? ');&
        STR_NXLIN]

        EIF TYPE_CTOKEN(@STR,REPIT,RESIN)#RESWRD THEN GIVEUP
        ORIF MORE THEN ENDF
        FIF TOKEN<3 OR TOKEN>7 THEN GIVEUP
        RPTYPE_(IF TOKEN>5 THEN FALSE ELSE TOKEN); OK; ENDR


41:     !ECHO! IF ZILCH THEN [PRM('$ECHO: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,ECHIT,RESIN)#RESWRD THEN GIVEUP
        ORIF MORE THEN ENDF
        ORIF TOKEN=0 OR TOKEN=11 THEN ECHO_TRUE
        ORIF TOKEN=7 OR TOKEN=12 THEN ECHO_FALSE
        ELSE GIVEUP
        OK; ENDR

40:     !TYPE! WHILE EMPTY#TYPE_STOKEN(@STR,0,0)#FIRK THEN DO
          EIF TYPE=NUMBER THEN DO
            EIF TERMCH=$+ THEN [TYPCHR(TOKEN); FIGURE(NCHV STR)]
            ELSE [OUTNUM(TOKEN,CIORDX);FIGURE(TERMCH)]
            END
          ORIF TYPE=STRING THEN [MSG(@TOKEN);FIGURE(TERMCH)]
          ORIF TYPE=DELIMT THEN [TYPCHR(TOKEN); FIGURE(NCHV STR)]
          FIF TYPE=RESWRD THEN [TYPCHR(TOKEN);FIGURE(TERMCH)]
          END
        ENDR

39:     !HELP! IF NOT MORE THEN HELPER(POINT("HELP"))   !GIVE HELP ERROR MESSAGE
        ENDR            !ALL DONE

37:     !CHARGES! IF MORE THEN ENDF
        HELPER(POINT("CHARGES"))
        ENDR

36:     !CREDITS! IF NOT MORE THEN HELPER(POINT("CREDITS"))
        ENDR

35:     !QUIT! IF MORE THEN ENDF
        EXIT

34:     !VERSION! IF MORE THEN ENDF
        MSG('VERSION '); NUMOUT(JOBVER SHR 18 BAND OCT 177,8); PUT($.)
        IF JOBVER BAND OCT 777 <= OCT 7 THEN PUT($0)
        NUMOUT(JOBVER BAND OCT 777,8); CRLF
        ENDR

32:     !LENGTH! IF ZILCH THEN [PRM('$LENGTH OF LEADER AND TRAILER: ');&
        STR_NXLIN]
        IF TYPE_CTOKEN(@STR,0,NUMIN)#NUMBER THEN GIVEUP
        IF MORE THEN ENDF
        LENGTH_TOKEN; OK; ENDR

31:     !TITLE! IF ZILCH THEN [PRM('$TITLE: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,TTLE,RESIN+STRIN)=RESWRD AND TOKEN=17 THEN DO
          IF TYPE_CTOKEN(@STR,0,STRIN)#STRING THEN GIVEUP
          IF MORE THEN ENDF
          IF USEFLG=FALSE THEN CONFMP ELSE OPNPTP(ESCAPE)
          LEDTRL(7); OUTTIT(POINTX(TOKBUF)); LEDTRL(7)
          IF USEFLG#FALSE THEN CLSPTP ! CLOSE PTP 
          ENDR
          END
        ORIF TYPE=EMPTY THEN ENDF
        ORIF MORE THEN ENDF
        ORIF TYPE=RESWRD AND (TOKEN=7 OR TOKEN=12)&
        THEN [TITLE_FALSE; OK; ENDR]
        ORIF TYPE#STRING THEN GIVEUP
        ELSE [CSTRING(POINTX(TOKBUF),POINTX(TITBUF));&
        OK; TITLE_TRUE; ENDR]

30:     !READ! IF ZILCH THEN [PRM('$TO FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        SETOU
        IFILE_TEL; SYMBN_1              !INPUT:TEL, MODE:SYMBOLIC
        OFILE_OPEN(@TOKEN,DIRECT+OUTHOW+CHARACTER,OPNER1,2)
        READ(IFILE,@OFILE)
        RETURN

29:     !BREAD! IF ZILCH THEN [PRM('$TO FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        SETOU
        IFILE_TEL; SYMBN_2              !INPUT:TEL, MODE:BINARY
        CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        OFILE_OPEN(@TOKEN,DIRECT+OUTHOW+CHAR,OPNER1,2)
        READ(IFILE,@OFILE)
        RETURN

27:     !LIST! IF MORE THEN ENDF
        EIF SLEEPY=FALSE THEN MSG('$TALK ON')
        ELSE MSG('$HUSH ON')
        MSG('$SUBSTITUTION:   '); MSG(IF RECPTR=FALSE THEN 'OFF' ELSE 'ON')
        MSG('$USING:          ')
        MSG(IF USEFLG=TRUE THEN 'PDP10' ELSE 'TERMINAL')
        MSG('$ECHO:           '); MSG(IF ECHO=FALSE THEN 'OFF' ELSE 'ON')
        MSG('$REPRESENTATION: '); MSG(IF RPTYPE=FALSE THEN 'NONE' ELSE CWORDS(RPTYPE))
        EIF TITLE=FALSE THEN MSG('$NO TITLE')
        ELSE [MSG('$TITLE:          ');MSG(@TITBUF(0))]
        EIF ECHAR+ELINE=0 THEN MSG('$NO EDITING')
        ELSE DO
          MSG('$EDITING:       ')
          IF ECHAR#0 THEN [MSG(' CHARACTER=');TYPCHR(ECHAR)]
          IF ELINE#0 THEN [MSG(' LINE=');TYPCHR(ELINE)]
          END
        EIF PARITY=7 OR PARITY=12 THEN MSG('$NO PARITY')
        ELSE [MSG('$PARITY:         ');MSG(CWORDS(PARITY))]
        MSG('$LENGTH:         '); OUTNUM(LENGTH,CIORDX); MSG(' INCHES')
        MSG('$RADIX:          ')
          EIF CIORDX=10 THEN MSG('DECIMAL')
          ORIF CIORDX=8 THEN MSG('OCTAL')
          ELSE OUTNUM(CIORDX,10)
        CRLF; ENDR

26:     !RESET! IF MORE THEN ENDF
        INIT; OK; ENDR

25:     !LOAD! IF ZILCH THEN [PRM('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF)); SAVRET_RETURN
        SETIN
        IFILE_OPEN(@TOKEN,CHARACTER+INPUT+SEQUEN,OPNER1,2)
        SETRWE(IFILE,E25)               !ENF OF FILE BUSINESS
        OK; RUNFLG_TRUE
        OFF.ALT; E25A_TELFIL<==-1
        LOOP [LASINP_STR_GETLINE(IFILE);TERMCH_E.O.LIT;GOCMD(23)]

E25:    RETURN_SAVRET; RUNFLG_FALSE; TELFIL_E25A; ON.ALT; ENDR

24:     !SAVE! IF RECPTR=FALSE THEN DO
          MSG('NO SUBSTITUTIONS IN EFFECT$')
          ENDR
          END
        IF ZILCH THEN [PRM('$TO FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE STRING O
        SETOU
        OFILE_OPEN(@TOKEN,CHARACTER+OUTHOW+SEQUEN,OPNER1,2)

        IF OFILE=TEL THEN PRM('$SUBSTITUTE:$FILE,TAPE$$')

! NOW WRITE OUT THE STRING
        VAL_-1
        WHILE INC VAL<RECPTR THEN DO
            VAL1_IRECTAB(VAL); VAL2_ERECTAB(VAL)
            IF COMAFL_SUBOUT(OFILE,VAL1)<2 AND &
            CNTER(VAL2)=TRUE THEN W(OFILE,$,) ELSE DO
             W(OFILE,$ );W(OFILE,$F);W(OFILE,$O);W(OFILE,$R);W(OFILE,$ )
            END
            SUBOUT(OFILE,VAL2)
            W(OFILE,CARRET)
            END
        IF OFILE#TEL THEN OK
        ENDR

23:     !SUBSTITUTE! IF ZILCH THEN [PRM('$SUBSTITUTE:$FILE,TAPE$\G');S4_-1] ELSE S4_0

!MAKE THE LOOP DO STICK
        LOOP DO
          IF S4=-1 THEN [MSG('\A');STR_NXLIN]
        VAL1_SUBGET(@STR,1)             !GET FIRST SUBSTITUTE STRING
          IF TYPE=DELIMT AND ZILCH THEN S4_0 ! RESET ROUND-ABOUT FLAG
          IF TYPE=DELIMT AND TOKEN=$? THEN DO
           MSG('$VALID ARGUMENTS ARE:$$USASCII CHARACTER NAMES$STRING INPUT$NUMERIC INPUT$')
           ENDF
           END

!VALID TERMINATION IS EITHER A COMMA OR A SPACE AND WORD "FOR"
        EIF VAL1=FIRK THEN ENDF
        ORIF TYPE=RESWRD AND TOKEN=200 THEN DO ! HELP
          TYPE_RESWRD; TOKEN_39 ! FAKE HELP INPUT FOR UNXERR
          GIVEUP ! THE SHIP
          END
        ORIF TERMCH=$, THEN NULL
        ORIF TERMCH=$  THEN DO
          SAVSTR_STR
          IF NOT(TYPE_CTOKEN(@STR,SUBIT,RESIN)=RESWRD AND TOKEN=28) THEN&
          STR_SAVSTR
        END
        ORIF TYPE=RESWRD THEN [ERR('ILLEGAL WORD IN INPUT$');ENDF]
        ELSE GIVEUP
        VAL2_SUBGET(@STR,0)             !GET SECOND SUBSTITUTE STRING
          EIF VAL2=FIRK THEN ENDF
          ORIF TYPE=RESWRD AND TOKEN=200 THEN DO ! HELP
            TYPE_RESWRD; TOKEN_39; GIVEUP
            END
          ORIF TYPE=RESWRD AND TERMCH#CARRET THEN&
          [ERR('ILLEGAL WORD IN INPUT');ENDF]
          FIF TERMCH#CARRET THEN GIVEUP

        VAL1_SUBPUT(VAL1); VAL2_SUBPUT(VAL2)            !COPY TO SUB STORAGE
! NOW MAKE ENTRY INTO SUBSTITUTION TABLE
        S1_NCHAR(VAL1)          !GET VALUE OF GO-TO STRING
        IF S2_ESUBTAB(S1)#0 THEN DO
          ERR('CONFLICT WITH LEFT PART.  "')
          IF S1=EOLIT THEN MSG('NOTHING') ELSE PUT(S1)
          MSG('" ALREADY SUBSTITUTES TO:$'); SUBOUT(TEL,S2); CRLF
        END ELSE ESUBTAB(S1)_VAL2            !MAKE ENTRY
        S1_NCHAR(VAL2)
        IF S2_ISUBTAB(S1)#0 THEN DO
          ERR('CONFLICT WITH RIGHT PART.  "')
          IF S1 = EOLIT THEN MSG('NOTHING') ELSE PUT(S1)
          PRM('" ALREADY SUBSTITUTES FROM:$'); SUBOUT(TEL,S2); CRLF
        END ELSE ISUBTAB(S1)_VAL1            !MAKE ENTRY

! MAKE ENTRY INTO RECONSTRUCTION TABLE
        IRECTAB(RECPTR)_VAL1; ERECTAB(RECPTR)_VAL2
        INC RECPTR

        WHILE S4=-1
        END
        OK
        IF RUNFLG=TRUE THEN ENDF ELSE ENDR

22:     !EDITING! IF ZILCH THEN [PRM('$EDITING: ');STR_NXLIN]

        WHILE TYPE_CTOKEN(@STR,EDITB,RESIN)=RESWRD AND (TOKEN=13 OR TOKEN=14 OR TOKEN=39)&
        THEN DO
          IF TOKEN=39 THEN GIVEUP ! HELP I PRESUME
          IF TERMCH # $= THEN [TYPE_DELIMT;GIVEUP]
          SVPLAC_TOKEN
          IF TYPE_STOKEN(@STR,0,0)=FIRK THEN ENDF
          VAL_(IF TYPE=STRING THEN&
          NCHAR(POINTX(TOKBUF)) ELSE TOKEN)
          IF TYPE = DELIMT AND TERMCH # CARRET THEN TERMCH _ NCHV STR
          IF SVPLAC=13 THEN ECHAR_VAL ELSE ELINE_VAL
          IF ZILCH THEN [OK;ENDR]
          END
! HANDLE ERROR CONDITION
        IF TYPE#RESWRD THEN GIVEUP ! TELL HIM OFF FAST
        IF TOKEN=7 OR TOKEN=12 THEN DO
          ECHAR_ELINE_0; OK; ENDR
          END
        IF TERMCH=CARRET OR TYPE=EMPTY THEN [OK; ENDR] ELSE ENDF

21:     !PARITY! IF ZILCH THEN [PRM('$PARITY: ');STR_NXLIN]
        EIF TYPE_CTOKEN(@STR,PRITY,RESIN)#RESWRD THEN GIVEUP
        ORIF MORE THEN ENDF
        FIF (TOKEN=39) THEN GIVEUP
        PARITY_(IF TOKEN=6 OR TOKEN=12 THEN 7 ELSE TOKEN); OK; ENDR

20:     !TALK! SLEEPY_FALSE; OK; ENDR

19:     !HUSH! SLEEPY_TRUE; OK; ENDR

62:     !PROMPT! SAVRET_RETURN; RUNFLG_TRUE
        IF MORE THEN ENDF

        DOCMD(1)                !SET UP SYMBOLIC OR BINARY MODE
        DOCMD(21)               !SET UP PARITY JUNK

        RETURN_SA          !RESET RETURN LOCATION
        PRM('$INPUT FROM:  '); STR_NXLIN
        CSTRING(STR,POINTX(IFILS))

        IF SYMBN=1 THEN CHAR_CHARACTER ELSE CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        IF INDEX(STR,CHPT(TELSTR(0),-1))=TRUE&
        THEN IFILE_TEL ELSE&
        [IFILE_OPEN(@IFILS(0),DIRECT+INPUT+CHAR,OPNER1,2)]

        PRM('$OUTPUT TO:   '); STR_NXLIN
        CSTRING(STR,POINTX(OFILS))
        IF INDEX(STR,CHPT(TELSTR(0),-1))=TRUE&
        THEN OFILE_TEL ELSE&
        [OFILE_OPEN(@OFILS(0),DIRECT+OUTHOW+CHAR,OPNER1,2)]
        IF IFILE=OFILE THEN [ERR('$BOTH SOURCES CANNOT BE SAME$'); ENDF]
        IF IFILE#TEL AND OFILE#TEL THEN&
        [ERR('$DISK TO DISK CONVERSION NOT IMPLEMENTED$');ENDF]
        IF SYMBN=1 THEN DOCMD(42)       !SET UP REPRESENTATION
        IF SYMBN=1 AND IFILE=TEL THEN DOCMD(22)     !EDITING
        IF SYMBN=1 THEN DOCMD(23)       !SET UP SUBSTITUTION
        IF OFILE=TEL THEN DOCMD(31)     !SET UP TITLE
        IF IFILE=TEL THEN DOCMD(41)     !SET UP ECHOING
        IF OFILE=TEL THEN DOCMD(32)     !SET UP LENGTH

        IF IFILE=TEL THEN READ(IFILE,@OFILE) ELSE PUNCH(IFILE,OFILE)
        RUNFLG_FALSE; RETURN_SAVRET; ENDR

18:     !BPUNCH! IF ZILCH THEN [PRM('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        OFILE_TEL; SYMBN_2              !OUTPUT:TEL, MODE:BINARY
        SETIN
        CHAR_(IF PARITY=PACKD THEN PACK ELSE WORD)
        IFILE_OPEN(@TOKEN,DIRECT+INPUT+CHAR,OPNER1,2)
        PUNCH(IFILE,OFILE)              !PUNCH IT !!
        RETURN

17:     !PUNCH! IF ZILCH THEN [PRM('$FROM FILE: ');STR_NXLIN]
        CSTRING(STR,POINTX(TOKBUF))     !MAKE SURE AT BEG OF BUF
        OFILE_TEL; SYMBN_1              !OUTPUT:TEL, MODE:SYMBOLIC
        SETIN
        IFILE_OPEN(@TOKEN,DIRECT+INPUT+CHARACTER,OPNER1,2)
        PUNCH(IFILE,OFILE)              !PUNCH IT !!
        RETURN

16:     !RUN! SAVRET_RETURN; RUNFLG_TRUE
        SYMBN_1 !SET SYMBOLIC MODE!
        PARITY_7 !SET NO PARITY!
        IF MORE THEN ENDF ! RUN CANT HAVE MORE ARGUMENTS
        PRM('$INPUT FROM:  '); STR_NXLIN
        CSTRING(STR,POINTX(IFILS))
        IF INDEX(STR,CHPT(TELSTR(0),-1))=TRUE &
        THEN OFILE_TEL ELSE&
        IFILE_OPEN(@IFILS(0),DIRECT+INPUT+CHARACTER,OPNER1,2)
        PRM('$OUTPUT TO:   '); STR_NXLIN
        CSTRING(STR,POINTX(OFILS))
        IF INDEX(STR,CHPT(TELSTR(0),-1))=TRUE &
        THEN OFILE_TEL ELSE &
        OFILE_OPEN(@OFILS(0),DIRECT+OUTHOW+CHARACTER,OPNER1,2)
        IF IFILE=OFILE THEN [ERR('$BOTH SOURCES CANNOT BE SAME$'); ENDF]
        IF IFILE#TEL AND OFILE#TEL THEN &
        [ERR('$DISK TO DISK CONVERSION NOT IMPLEMENTED$'); ENDF]
        IF IFILE=TEL THEN DO
        MSG('$EDITING? ')
        LOOP DO
          STR_NXLIN; TYPE_CTOKEN(@STR,EDITR,RESIN)
          IF NOT (TYPE=RESWRD AND (TOKEN=63 OR TOKEN=12 OR TOKEN=11)) THEN MSG('$TYPE YES, NO, OR B: ')
          WHILE NOT (TYPE=RESWRD AND (TOKEN=63 OR TOKEN=12 OR TOKEN=11))
          END
        EIF TOKEN=11 THEN [ECHAR_$A-OCT 100; ELINE_$Q-OCT 100]
        ORIF TOKEN=12 THEN [ECHAR_ELINE_0]
        FIF TOKEN=63 THEN ECHAR _ $_
        END !OF LOP FOR EDITING
        IF OFILE=TEL THEN DOCMD(31)
        IF IFILE=TEL THEN READ(IFILE,@OFILE) ELSE PUNCH(IFILE,OFILE)
        RUNFLG_FALSE; RETURN_SAVRET; ENDR

15:     !NOTHING - YEA! ENDR

12:     IF ZILCH THEN [PRM('$NO WHAT?? ');STR_NXLIN]
        IF TYPE_CTOKEN(@STR,NOTBL,RESIN)#RESWRD THEN GIVEUP
        IF MORE THEN ENDF
        DO TOKEN OF 0:C.MAX

42:     RPTYPE_FALSE; ENDK
41:     ECHO_FALSE; ENDK
39:     HELP(C.SIZE+1); ENDR
32:     LENGTH _ 5; ENDK
31:     TITLE_FALSE; ENDK
23:     FOR CHAR_0 TO MAX.CHR ISUBTAB(CHAR)_ESUBTAB(CHAR)_IRECTAB(CHAR)_ERECTAB(CHAR)_0
        RECPTR_FALSE; ENDK
22:     ECHAR_ELINE_FALSE; ENDK
21:     PARITY_7; ENDK
20:     IF MORE THEN ENDF
        SLEEPY_TRUE; ENDK
19:     IF MORE THEN ENDF
        SLEEPY_FALSE; ENDK

        END

        GIVEUP

1:      !SYMBOLIC! IF ZILCH THEN [PRM('$SYMBOLIC OR BINARY? ');STR_NXLIN]
        SYMBN_1        !INIT TO SYMBOLIC MODE INCASE C.R. [FOR SYMBOLIC]
        EIF TYPE_CTOKEN(@STR,SYMBIN,RESIN)=RESWRD AND 1<=TOKEN<=2 THEN&
        [SYMBN_TOKEN;ENDR]
        ORIF TYPE=RESWRD AND TOKEN=7 OR TOKEN=7 OR TOKEN=12 THEN [SYMBN_1;ENDR]
        ELSE GIVEUP

        END

! BRANCH HERE WHEN FED UP WITH THE WORLD
!
UNXERR: EIF TYPE=RESWRD AND TOKEN=39 THEN [HELP(ARG1);ENDF]
        ELSE FIRKIT(TYPE)
        EIF TYPE=DELIMT AND ZILCH THEN RETURN EMPTY
        ELSE ENDF

! HERE ON OPEN FILE ERRORS
!
OPNER1: EIF ERRNUM<1 OR ERRNUM>13 THEN ERR('SYSTEM ERROR ON FILE:')
        ELSE DO
        ERR('$CANNOT OPEN '); OUTSTR(STR)
        DO ERRNUM OF 1:13
1:      ERR(' - TOO MANY FILES OPEN')
2:      ERR(' - BAD ARGUMENTS TO OPEN **SYSTEM ERROR**')
3:      ERR(' - ILLEGAL FILE NAME')
4:      ERR(' - NEW/OLD FILE MESSAGE NOT CONFIRMED')
5:      ERR(' - FILE NOT FOUND')
6:      ERR(' - INVALID USER NAME OR PPN')
7:      ERR(' - PROTECTION FAILURE')
8:      ERR(' - FILE BUSY')
9:      ERR(' - RENAME ERROR **SYSTEM ERROR**')
10:     ERR(' - END OF FILE **SYSTEM ERROR**')
11:     ERR(' - LINE TOO LONG **SYSTEM ERROR**')
12:     ERR(' - ILLEGAL OPERATION ON THE TERMINAL')
13:     ERR(' - OUT OF CORE **SYSTEM ERROR**')

        END

        CRLF; ENDF
        END


END GOCMD
  @@¼