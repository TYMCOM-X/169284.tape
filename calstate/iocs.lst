IOCS - SIMPL VERS 2.00 27-OCT 1974 13:39



     1	DEF ALT.NAME(A,B) AS B
     2	DEF ALT.ENTRY(A,B) AS NULL
     3	!  IOCS - VERSION 14 - 6/74
     4	!  I/O PACKAGE FOR THE PDP-10              CAROLINE DIEHL AND FRIENDS
     5	
     6	
     7	ALT.ENTRY("$SETCF",%SETCFN)
     8	ALT.ENTRY("$EXU",%EXU)
     9	ALT.ENTRY("$EXUF",%EXUF)
    10	ALT.ENTRY("$IOCS",%IOCS)
    11	ALT.ENTRY("$OPEN",%OPEN)
    12	ALT.ENTRY("$SETFI",%SETFID)
    13	ALT.ENTRY("$TELCH",%TELCHK)
    14	ALT.ENTRY("$WFID",%WFID)
    15	ALT.ENTRY("$CLOSE",%CLOSE)
    16	ALT.ENTRY("$CANCE",%CANCEL)
    17	ALT.ENTRY("$BUFDU",%BUF.DUMP)
    18	ALT.ENTRY("$OPENP",%OPENP)
    19	ALT.ENTRY("$SETFP",%SETFIP)
    20	ALT.ENTRY("$SETMO",%SETMODE)
    21	ALT.ENTRY("$CLALL",%CLOSE.ALL)
    22	ALT.ENTRY("$CAALL",%CANC.ALL)
    23	ALT.ENTRY("$PLNCH",%PLNCHK)
    24	ALT.ENTRY("$PLNW",%PLNW)
    25	ALT.ENTRY("$SETTA",%SET.TAB)
    26	ALT.ENTRY("$SETTE",%SET.TERM)
    27	ALT.ENTRY("$SETPR",%SET.PRMPT)
    28	ALT.ENTRY("$TABOF",%TAB.OFF)
    29	ALT.ENTRY("$R",%R)
    30	ALT.ENTRY("$GETLI",%GETLINE)
    31	ALT.ENTRY("$W",%W)
    32	ALT.ENTRY("$WX",%WX)
    33	ALT.ENTRY("$ERASE",%ERASE)
    34	ALT.ENTRY("$SETCP",%SETCP)
    35	ALT.ENTRY("$CP",%CP)
    36	ALT.ENTRY("$SIZE",%SIZE)
    37	ALT.ENTRY("$WB",%WB)
    38	ALT.ENTRY("$RB",%RB)
    39	ALT.ENTRY("$FIXBUF",%FIXBUF)
    40	ALT.ENTRY("$DELET",%DELETE)
    41	ALT.ENTRY("$RENAM",%RENAME)
    42	ALT.ENTRY("$CLIBU",%CLIBUF)
    43	ALT.ENTRY("$CLOBU",%CLOBUF)
    44	ALT.ENTRY("$TTYLE",%TTYLEN)
    45	ALT.ENTRY("$GET",%GET)
    46	ALT.ENTRY("$PUT",%PUT)
    47	ALT.ENTRY("$PUTX",%PUTX)
    48	ALT.ENTRY("$PUTC",%PUTC)
    49	ALT.ENTRY("$PRINT",%PRINT)
    50	ALT.ENTRY("$PRINC",%PRINTC)
    51	ALT.ENTRY("$MSG",%MSG)
    52	ALT.ENTRY("$SETRW",%SETRWE)
    53	ALT.ENTRY("$FPMSG",%F.P.MSG)
    54	ALT.ENTRY("$FPRNT",%F.P.PRINT)
    55	ALT.ENTRY("$OFFAL",%OFFALT)
    56	ALT.ENTRY("$ONALT",%ONALT)
    57	ALT.ENTRY("$ONALC",%ONALT.C)
    58	ALT.ENTRY("$XTOUT",%EX.TOUT)
    59	ALT.ENTRY("$EXCFN",%EX.CFN)
    60	ALT.ENTRY("$TDEST",%TT.DEST)
    61	ALT.ENTRY("$CECHO",%CF.ECHO)
    62	ALT.ENTRY("$TECHO",%TT.ECHO)
    63	ALT.ENTRY("$RSBRK",%RS.BRK)
    64	ALT.ENTRY("$RSALT",%RS.ALT)
    65	ALT.ENTRY("$DDOVR",%DDTOVR)
    66	ALT.ENTRY("$ARTHV",%ARTHOV)
    67	
    68	!  IOCS DEFS OF INTEREST TO USER
    69	
    70	!  FILE DESCRIPTORS PASSED TO %OPEN
    71	
    72	!MAINTAIN ORDER OF FILE TYPES (SEE %OPEN1)
    73	
    74	DEF INPUT AS 0
    75	DEF UPDATE AS 1
    76	DEF OUTPUT AS 2
    77	DEF OUTMSG AS 3
    78	
    79	!FILE TYPE MODIFIERS
    80	
    81	DEF NEW AS OCT 100
    82	DEF OLD AS OCT 200
    83	
    84	!FILE MODES
    85	
    86	DEF SEQUEN AS 0
    87	DEF DIRECT AS OCT 10
    88	
    89	!FILE ORGANIZATIONS
    90	
    91	DEF WORD AS 0
    92	DEF CHARACTER AS OCT 20
    93	DEF PACK AS OCT 40
    94	DEF ORGIND(FN) AS (ORG(FN) SHR 4)     !0,1,2,...
    95	DEF ORGINDLIM AS 0:2
    96	
    97	!  FILE NUMBERS  (FNMIN IS MIN CHANNEL WHICH WILL BE USED)
    98	
    99	DEF FNMIN AS 1            !MIN AND MAX FILE NUMBERS
   100	DEF FNMAX AS 15           !AVAILABLE, EXCLUDING TEL
   101	DEF TEL AS (FNMIN-1)        !FILE NO. INDICATING TERMINAL 
   102	
   103	!  ERROR NUMBERS (ERRNUM VALUES)
   104	
   105	DEF TMFERR AS 1     !TOO MANY FILES OPEN (OPEN)
   106	DEF FMDERR AS 2     !BAD FILE MODE OR TYPE FOR ATTEMPTED OPERATION
   107	                    !(OPEN SEQUEN UPDATE, SETCP OR ERASE SEQUEN,
   108	                    !WRITE OR ERASE INPUT, READ SEQUEN OUTPUT)
   109	DEF IFDERR AS 3     !ILLEGAL FILE IDENTIFIER (SETFID, OPEN, DELETE, RENAME)
   110	DEF CNFERR AS 4     !NEW/OLD FILE MESSAGE NOT CONFIRMED (OPEN OUTMSG)
   111	                    !OR TYPE MODIFIER CONFLICT - FILE NOT NEW/OLD (OPEN OUTPUT OR UPDATE)
   112	
   113	!ORDER OF FOLLOWING 5 NOS. SHALL BE MAINTAINED. (ALL BUT LAST MAY
   114	!OCCUR DURING OPEN, DELETE, OR RENAME)
   115	
   116	DEF FNFERR AS 5     !FILE NOT FOUND
   117	DEF IUSERR AS 6     !INVALID USER NAME (BAD PPN)
   118	DEF PRTERR AS 7     !PROTECTION VIOLATION ATTEMPT
   119	DEF FBSERR AS 8     !FILE BUSY
   120	DEF AEFERR AS 9     !NEW NAME BELONGS TO ALREADY EXISTING FILE  (RENAME)
   121	
   122	DEF EOFERR AS 10    !END OF FILE (R, RB, GETLINE)
   123	DEF LNGERR AS 11    !LINE TOO LONG (GETLINE FROM FILE)
   124	DEF TELERR AS 12    !ILLEGAL OPERATION ON TEL (OPEN, DELETE, RENAME,
   125	                    !CP, SIZE)
   126	DEF ARGERR AS 13    !BAD ARGUMENT VALUE - SUCH AS:
   127	                    !NEGATIVE CURSOR POSITION (SETCP, ERASE),
   128	                    !NEG. COUNT (RB, WB, OPEN NSBUFS)
   129	DEF CORERR AS 14    !OUT OF CORE (OPEN SEQUEN)
   130	
   131	
   132	
   133	!  MACHINE DEPENDENT MACROS
   134	
   135	DEF MKCTRL(CHAR) AS (CHAR-OCT 100)
   136	DEF UNCTRL(CHAR) AS (CHAR+OCT 100)
   137	DEF CTRLCH(CHAR) AS CHAR<=OCT 37     !ALL CTRL CHARS, INCL. BEYOND ZCTRL
   138	DEF PRCHAR(CHAR) AS OCT 40<=CHAR<=OCT 174  !??
   139	DEF PUT.CR   AS TTY _ CARRET     !CR W/O LF
   140	DEF PUT.LF   AS TTY _ LNFEED     !LF W/O CR
   141	DEF PUT.CRLF AS [PUT.CR; PUT.LF]
   142	DEF PUT.LFCR AS [PUT.LF; PUT.CR]
   143	DEF RUBOUT AS OCT 177
   144	DEF EOLITWD AS 0
   145	
   146	
   147	GLOBAL ALT.NAME("$STS",STS)
   148	GLOBAL ALT.NAME("$SETCF",%SETCFN)
   149	GLOBAL ALT.NAME("$CFN",CFN)
   150	GLOBAL ALT.NAME("$EXU",%EXU)
   151	GLOBAL ALT.NAME("$EXUF",%EXUF)
   152	GLOBAL ALT.NAME("$IOCS",%IOCS)
   153	GLOBAL ALT.NAME("$OPEN",%OPEN)
   154	GLOBAL ALT.NAME("$SETFI",%SETFID)
   155	GLOBAL ALT.NAME("$TELCH",%TELCHK)
   156	GLOBAL ALT.NAME("$WFID",%WFID)
   157	GLOBAL ALT.NAME("$CLOSE",%CLOSE)
   158	GLOBAL ALT.NAME("$CANCE",%CANCEL)
   159	GLOBAL ALT.NAME("$BUFDU",%BUF.DUMP)
   160	GLOBAL ALT.NAME("$OPENP",%OPENP)
   161	GLOBAL ALT.NAME("$SETFP",%SETFIP)
   162	GLOBAL ALT.NAME("$SETMO",%SETMODE)
   163	GLOBAL ALT.NAME("$CLALL",%CLOSE.ALL)
   164	GLOBAL ALT.NAME("$CAALL",%CANC.ALL)
   165	GLOBAL ALT.NAME("$PLNCH",%PLNCHK)
   166	GLOBAL ALT.NAME("$PLNW",%PLNW)
   167	GLOBAL ALT.NAME("$SETTA",%SET.TAB)
   168	GLOBAL ALT.NAME("$SETTE",%SET.TERM)
   169	GLOBAL ALT.NAME("$SETPR",%SET.PRMPT)
   170	GLOBAL ALT.NAME("$TABOF",%TAB.OFF)
   171	GLOBAL ALT.NAME("$R",%R)
   172	GLOBAL ALT.NAME("$GETLI",%GETLINE)
   173	GLOBAL ALT.NAME("$W",%W)
   174	GLOBAL ALT.NAME("$WX",%WX)
   175	GLOBAL ALT.NAME("$ERASE",%ERASE)
   176	GLOBAL ALT.NAME("$SETCP",%SETCP)
   177	GLOBAL ALT.NAME("$CP",%CP)
   178	GLOBAL ALT.NAME("$SIZE",%SIZE)
   179	GLOBAL ALT.NAME("$WB",%WB)
   180	GLOBAL ALT.NAME("$RB",%RB)
   181	GLOBAL ALT.NAME("$FIXBUF",%FIXBUF)
   182	GLOBAL ALT.NAME("$DELET",%DELETE)
   183	GLOBAL ALT.NAME("$RENAM",%RENAME)
   184	GLOBAL ALT.NAME("$CLIBU",%CLIBUF)
   185	GLOBAL ALT.NAME("$CLOBU",%CLOBUF)
   186	GLOBAL ALT.NAME("$TTYLE",%TTYLEN)
   187	GLOBAL ALT.NAME("$GET",%GET)
   188	GLOBAL ALT.NAME("$PUT",%PUT)
   189	GLOBAL ALT.NAME("$PUTX",%PUTX)
   190	GLOBAL ALT.NAME("$PUTC",%PUTC)
   191	GLOBAL ALT.NAME("$PRINT",%PRINT)
   192	GLOBAL ALT.NAME("$PRINC",%PRINTC)
   193	GLOBAL ALT.NAME("$MSG",%MSG)
   194	GLOBAL ALT.NAME("$SETRW",%SETRWE)
   195	GLOBAL ALT.NAME("$FPMSG",%F.P.MSG)
   196	GLOBAL ALT.NAME("$FPRNT",%F.P.PRINT)
   197	GLOBAL ALT.NAME("$OFFAL",%OFFALT)
   198	GLOBAL ALT.NAME("$ONALT",%ONALT)
   199	GLOBAL ALT.NAME("$ONALC",%ONALT.C)
   200	GLOBAL ALT.NAME("$ALTLO",ALTLOC)
   201	GLOBAL ALT.NAME("$ERRNU",ERRNUM)
   202	GLOBAL ALT.NAME("$XTOUT",%EX.TOUT)
   203	GLOBAL ALT.NAME("$EXCFN",%EX.CFN)
   204	GLOBAL ALT.NAME("$TDEST",%TT.DEST)
   205	GLOBAL ALT.NAME("$CECHO",%CF.ECHO)
   206	GLOBAL ALT.NAME("$TECHO",%TT.ECHO)
   207	GLOBAL ALT.NAME("$RSBRK",%RS.BRK)
   208	GLOBAL ALT.NAME("$RSALT",%RS.ALT)
   209	
   210	GLOBAL ALT.NAME("$FIDP",FIDP())
   211	GLOBAL ALT.NAME("$DDOVR",%DDTOVR)
   212	GLOBAL ALT.NAME("$ARTHV",%ARTHOV)
   213	DEF LOCWPF AS 5
   214	DEF MAXARG AS 27
   215	DEF MINARG AS 5
   216	DEF WPF AS (LOCWPF+1+MINARG)
   217	DEF MAXWPF AS (LOCWPF+1+MAXARG)
   218	! EXTENDED ARGUMENT BLOCK:
   219	DEF ARGCNT(TBL) AS TBL(LOCWPF)
   220	DEF PPNARG(TBL) AS TBL(LOCWPF+1)
   221	DEF NAMARG(TBL) AS TBL(LOCWPF+2)
   222	DEF EXTARG(TBL) AS TBL(LOCWPF+3)
   223	DEF PRVARG(TBL) AS TBL(LOCWPF+4)
   224	DEF FILSIZ(TBL) AS TBL(LOCWPF+5)
   225	DEF EXTQ(TBL) AS TBL(0)
   226	DEF USRNAM(TBL) AS TBL(1)
   227	DEF DEVNAM(TBL) AS TBL(3)
   228	DEF CONFWD(TBL) AS TBL(4)
   229	
   230	!  GETLINE 
   231	
   232	DEF LLEN AS 256                !MAX. LINE LENGTH
   233	DEF GLBCMX AS (LLEN+1)         !MAX. CHAR CAPACITY
   234	DEF CPW AS CHARS.PER.WORD
   235	DEF GLBSZ AS (GLBCMX+CPW-1)/CPW   !SIZE IN WORDS
   236	GLOBAL ALT.NAME("$FREE",FREE(0:GLBSZ-1))        !GETLINE INTERNAL BUFFER (AVAILABLE
   237	                               !BETWEEN GETLINE CALLS)
   238	GLOBAL ALT.NAME("$IMAGE",IMAGE(0:GLBSZ-1))       !GETLINE IMAGE LINE BUFFER
   239	GLOBAL ALT.NAME("$GLCNT",GLCNT)                   !GETLINE CHAR COUNT
   240	
   241	FIND ALT.NAME("$DSA",%DSA)
   242	FIND ALT.NAME("$GETMEM",%GETMEM)
   243	FIND ALT.NAME("$RLSMEM",%RLSMEM)
   244	
   245	FIND ALT.NAME("JOBHCU",JOBHCU)
   246	FIND ALT.NAME("JOBJDA",JOBJDA(1))
   247	FIND ALT.NAME(".JBFF",JOBFF)
   248	FIND ALT.NAME(".JBAPR",JOBAPR)
   249	FIND ALT.NAME(".JBTPC",JOBTPC)
   250	FIND ALT.NAME(".JBREL",JOBREL)
   251	
   252	LOCAL %INIT.R, %RBLK, %WBLK, %GETCHK, %SETCPI, %SET.NXCHAR
   253	DEF WBUF(BPTR) AS WBLK(FN.ID(BPTR),BUFSZ,BGNADR(BPTR),BLK.ID(BPTR))
   254	DEF CLEAN(BPTR) AS [WBUF(BPTR); DIRTY(BPTR) _ NO]
   255	LOCAL %S.RBLK, %S.WBLK, %DSIZE, %DCP, %DSETCP
   256	LOCAL %TTYIO, %IOERR, %SETALT, %ABNERR, %SET.ARTHOV
   257	LOCAL %SET.CTRL, %UNSET.CTRL, %OFF.ECHO, %ON.ECHO, %GET.BRK
   258	LOCAL %PUTTY, %PUTTYC, %PUTTYX, %PRNTTY, %PRNTTC, %MSGTTY
   259	LOCAL %L.OFFALT,  %L.ONALT, L.ALTLEV
   260	DEF ERR(N) AS [ERRNUM _ N; GO ERLAB]
   261	DEF FNERR(N) AS IOERR(FN,N)
   262	
   263	LOCAL I
   264	DEF YES AS 1
   265	DEF NO AS 0
   266	DEF BPW AS BITS.PER.WORD
   267	
   268	!     BUFFER PARAMETERS
   269	
   270	DEF BUFSZ AS 128           !SIZE OF DUMP-MODE DISK BUFFER
   271	DEF BBUFSZ AS 131          !SIZE OF BUFFERED-MODE DISK BUFFER
   272	TABLE BPE(ORGINDLIM) [36, 7, 8]     !BITS PER ELEMENT
   273	TABLE EBUFS(ORGINDLIM) [BUFSZ, BUFSZ*CPW, BUFSZ*BPW/8]
   274	DEF EBUFSZ(FN) AS EBUFS(ORGIND(FN))
   275	DEF WPB(C) AS (BUFSZ-(EBUFSZ(FN)-(C))*BUFSZ/EBUFSZ(FN))
   276	  !NO. OF WDS C BUFFER ELEMENTS OCCUPY
   277	
   278	! WHEN FILE MODE IS DIRECT:
   279	
   280	LOCAL BUF()               !MASTER BUFFER, TO CONSIST OF NBUFS BUFFERS,
   281	                          !BUFSZ WDS. EACH
   282	LOCAL NXBUF               !INDICATES FIRST BUFFER TO BE EXAMINED IN NEXT
   283	                          !SEARCH FOR ONE INTO WHICH TO READ FILE BLOCK
   284	
   285	! NXBUF & THE SUBSCRIPT OF THE FOLLOWING ARRAYS INDICATE AN
   286	! INDIVIDUAL BUFFER (OF BUFSZ WDS.) WITHIN BUF AS FOLLOWS:  VALUE I
   287	! INDICATES BUFFER STARTING AT BUF+I*BUFSZ. THUS, 0 POINTS TO 1ST,
   288	! 1 TO 2ND, ..., NEXT-TO-LAST TO LAST BUFFER
   289	
   290	BASE 0
   291	LOCAL FN.ID()    !-1 INDICATES BUFFER UNUSED
   292	                 !ELSE VALUE IS FILE NO. WHOSE BLOCK IS THERE
   293	LOCAL BLK.ID()   !NUMBER OF BLOCK IN BUFFER
   294	LOCAL DIRTY()    !YES IF BLOCK IN BUFFER WAS WRITTEN ON
   295	
   296	DEF BGNADR(X) AS (BUF+(X)*BUFSZ)        !ADDR OF 1ST WORD OF BUFFER X
   297	
   298	!     FILE PARAMETERS
   299	
   300	LOCAL FIDTBL(0:MAXWPF-1)
   301	
   302	! THE FOLLOWING ARE UNDEFINED IF NO FILE OPEN WITH SPECIFIED NUMBER
   303	!  (EXCEPT FTYP, WHICH IS <0)
   304	
   305	BASE TEL
   306	LOCAL FTYP(FNMAX),MODE(FNMAX),ORG(FNMAX)     !FILE DESCRIPTORS
   307	BASE FNMIN
   308	LOCAL EPTR(FNMAX),ECNT(FNMAX)       !ELEMENT POINTER & COUNT OF
   309	                          !REMAINING ELEMENTS
   310	LOCAL CP1(FNMAX)           !USED IN CURSOR POSITION CALCULATION
   311	LOCAL OPNSZ(FNMAX)        !FILE SIZE IN ELEMENTS, USED IN
   312	                          !SIZE CALCULATION.
   313	LOCAL SZFG(FNMAX)         !NEGATIVE IF OPNSZ IS APPROXIMATE (CHARACTER
   314	                          !FILES ON PDP-10)
   315	LOCAL SUBCNT(FNMAX), PKA, PKB       !USED IN PACK I/O
   316	
   317	!IF MODE(FN) IS DIRECT:
   318	
   319	LOCAL CPBUF(FNMAX)        !BUFFER CONTAINING FILE CURSOR (<0 IF NONE,
   320	                          !OR IF CP SET AND NO I/O DONE)
   321	LOCAL MXACP(FNMAX)        !MAXIMUM ABANDONED CURSOR POSITION
   322	LOCAL ENDCNT(FNMAX)       !USED IN DIRECT EOF CHECK IN %R
   323	
   324	!     READ & WRITE LABELS
   325	
   326	! LABEL MANIPULATION BETWEEN %R, AND %W AND OTHER PROCEDURES
   327	! REQUIRES THESE DECLARATIONS
   328	
   329	LOCAL RINIT:, WINIT:, WXLAB:
   330	LOCAL R.ERR:, RTEL:, W.ERR:, WSET:, WTEL:, YCHAR:, YTEL:
   331	LOCAL RADR(ORGINDLIM), WADR(ORGINDLIM), ENDRADR(ORGINDLIM)
   332	LOCAL RWD:, RCH:, WWD:, WCH:, ENDRWD:, ENDRCH:
   333	LOCAL RPK:, WPK:, ENDRPK:
   334	BASE TEL
   335	LOCAL RLAB(FNMAX), WLAB(FNMAX), YLAB(FNMAX)
   336	LOCAL RWELAB(FNMAX)     !ERROR LABELS
   337	BASE 1
   338	
   339	!     CONTROL CHARACTER CODES
   340	
   341	DEF ACTRL AS MKCTRL($A)
   342	DEF BCTRL AS MKCTRL($B)
   343	DEF CCTRL AS MKCTRL($C)
   344	DEF DCTRL AS MKCTRL($D)
   345	DEF ECTRL AS MKCTRL($E)
   346	DEF FCTRL AS MKCTRL($F)
   347	DEF GCTRL AS MKCTRL($G)
   348	DEF HCTRL AS MKCTRL($H)
   349	DEF ICTRL AS MKCTRL($I)
   350	DEF JCTRL AS MKCTRL($J)
   351	DEF KCTRL AS MKCTRL($K)
   352	DEF LCTRL AS MKCTRL($L)
   353	DEF MCTRL AS MKCTRL($M)
   354	DEF NCTRL AS MKCTRL($N)
   355	DEF OCTRL AS MKCTRL($O)
   356	DEF PCTRL AS MKCTRL($P)
   357	DEF QCTRL AS MKCTRL($Q)
   358	DEF RCTRL AS MKCTRL($R)
   359	DEF SCTRL AS MKCTRL($S)
   360	DEF TCTRL AS MKCTRL($T)
   361	DEF UCTRL AS MKCTRL($U)
   362	DEF VCTRL AS MKCTRL($V)
   363	DEF WCTRL AS MKCTRL($W)
   364	DEF XCTRL AS MKCTRL($X)
   365	DEF YCTRL AS MKCTRL($Y)
   366	DEF ZCTRL AS MKCTRL($Z)
   367	
   368	DEF BELL AS GCTRL
   369	
   370	!     MACHINE EXCLUSIVE
   371	
   372	! INSTRUCTION CODES PASSED TO %EXU
   373	
   374	DEF JRSTCD AS OCT 254 !JRST
   375	DEF OPNCD AS OCT 50   !OPEN
   376	DEF ENTCD AS OCT 77   !ENTER
   377	DEF LKPCD AS OCT 76   !LOOKUP
   378	DEF RNMCD AS OCT 55   !RENAME
   379	DEF CLSCD AS OCT 70   !CLOSE
   380	DEF RLSCD AS OCT 71   !RELEASE
   381	DEF STZCD AS OCT 63   !STATZ
   382	DEF INCD  AS OCT 56   !IN
   383	DEF OUTCD AS OCT 57   !OUT
   384	DEF UGFCD AS OCT 73   !UGETF
   385	DEF USICD AS OCT 74   !USETI
   386	DEF USOCD AS OCT 75   !USETO
   387	DEF STSCD AS OCT 60   !SETSTS
   388	DEF GTSCD AS OCT 62   !GETSTS
   389	DEF TTCD  AS OCT 51   !TTCALL
   390	DEF CLICD AS OCT 47   !CALLI
   391	
   392	DEF JSR   AS OCT 264000.000000   !JSR INSTRUCTION
   393	DEF JFCL  AS OCT 255000.000000   !JFCL INSTRUCTION
   394	
   395	!IF MODE(FN) IS SEQUEN:
   396	GLOBAL ALT.NAME("$HEAD",HEAD(FNMIN*3:FNMAX*3+2))   !BUFFER RING HEADER AREA - 3 WDS. PER FN
   397	DEF USEBIT(FN) AS BYT(HEAD(FN*3),1,35)     !RING USE BIT
   398	DEF CURBUF(FN) AS RH(HEAD+FN*3)        !CURRENT BUFFER
   399	DEF S.EPTR(FN) AS HEAD(FN*3+1)            !ELEMENT POINTER
   400	DEF S.ECNT(FN) AS HEAD(FN*3+2)            !ELEMENT COUNT
   401	
   402	LOCAL %DO.ERR
   403	LOCAL MINFID(FNMIN*4:FNMAX*4+3)   !FOR %ERASE
   404	DEF LH(X) AS HW(X)
   405	DEF RH(X) AS HW(X,1)
   406	
   407	DEF TO.TERM AS 1
   408	DEF TO.TOUT AS 2
   409	DEF TO.BOTH AS 3
   410	DEF TO.NEITHER AS 4
   411	
   412	
   413	LOCAL TOUT.FILE     ! THE NUMBER OF OPEN TOUT.FILE
   414	LOCAL TERM.DEST     ! DESCRIBES DESTINATION OF TERMINAL OUTPUT.
   415	LOCAL COM.ECHO.DEST ! DESTINATION OF COMMANDS FILE ECHOING.
   416	LOCAL TERM.ECHO.P   ! IF TRUE, THEN TERMINAL INPUT IS COPIED TO TOUT.
   417	
   418	
   419	!     *****  THE I/O CONTROL SYSTEM  *****
   420	
   421	%IOCS (NBUFS)
   422	
   423	! IOCS MUST BE CALLED TO INITIALIZE THIS PACKAGE; RH(NBUFS) SPECIFIES
   424	! THE NUMBER OF BUFFERS TO BE USED IN DIRECT MODE I/O OPERATIONS.
   425	! LH(NBUFS) IF NONZERO IS THE LOCATION AT WHICH THE BUFFERS ARE TO
   426	! BE ALLOCATED; IF ZERO, BLOCK IS USED TO OBTAIN SPACE.
   427	LOCAL %NULLP, %OPEN1
   428	LOCAL J,K
   429	LOCAL EROUT:, QUIT:, ALT:, ALTNIL:
   430	LOCAL ALTLEV, ALTBLK(0:2), TRPFG, DDTFLG, ARTHOV.ADDR
   431	
   432	DEF BIT18 AS OCT 400000     !REPETITIVE ENABLE
   433	DEF BIT25 AS OCT 2000       !ESCAPE
   434	DEF TRPBITS AS (BIT18+BIT25)
   435	TABLE ALTJUMP [OCT 254120.000127]       ! JRSTF @JOBTPC I HOPE
   436	
   437	EXU(CLICD,0,0)     !RESET
   438	
   439	
   440	ARTHOV(NO)   !DO NOT ALLOW ARITHMETIC OVERFLOW TO TRAP UNTIL REQUESTED.
   441	
   442	ALTLEV _ 0; L.ALTLEV _ 0; L.OFFALT
   443	
   444	DSA
   445	BUF _ LH(@NBUFS)
   446	IF NBUFS _ RH(@NBUFS) >0 THEN DO
   447	  IF BUF=0 THEN BUF _ GETMEM(NBUFS*BUFSZ);  IF BUF=0 THEN GO EROUT
   448	  IF (FN.ID  _ GETMEM(NBUFS))=0 THEN GO EROUT
   449	  IF (BLK.ID _ GETMEM(NBUFS))=0 THEN GO EROUT
   450	  IF (DIRTY  _ GETMEM(NBUFS))=0 THEN GO EROUT
   451	  MOVE NBUFS FROM ALL -1 TO FN.ID
   452	END
   453	NXBUF _ 0
   454	
   455	MODE(TEL) _ SEQUEN; ORG(TEL) _ CHARACTER
   456	WLAB(TEL) _ WTEL; YLAB(TEL) _ YTEL          !TEL OUTPUT 
   457	RLAB(TEL) _ RTEL          !TEL INPUT
   458	SETMODE(-1)	!SET DEFAULT
   459	INIT.R
   460	SET.TERM(EOLIT); SET.PRMPT(%NULLP)
   461	SET.TAB(0); TAB.OFF(%NULLP)
   462	
   463	FOR I _ FNMIN TO FNMAX DO
   464	  FTYP(I) _ -1
   465	END
   466	!REPLACE WITH TABLE WHEN IMPLEMENTED:
   467	RADR(0) _ RWD; RADR(1) _ RCH; RADR(2) _ RPK
   468	WADR(0) _ WWD; WADR(1) _ WCH; WADR(2) _ WPK
   469	ENDRADR(0) _ ENDRWD; ENDRADR(1) _ ENDRCH; ENDRADR(2) _ ENDRPK
   470	
   471	TTYIO; ALTLOC _ QUIT
   472	L.ONALT
   473	
   474	%%NULLP
   475	RETURN 0
   476	
   477	QUIT:    CLOSE.ALL; EXIT
   478	
   479	AOVTRP:  SET.ARTHOV; GO ^ALTLOC
   480	
   481	ALT:     ALTBLK(0) _ TRPBITS; ALTBLK(1) _ AOVTRP  !SHORT STOP BEFORE ALTLOC.
   482	         ALTBLK(2) _ ^14 <== ALTBLK; EXU(CLICD,14,-OCT 23)  !DISMIS
   483	ALTNILC TRPFG; GO ^@ALTJUMP        ! WHAT A KLUDGE!!!!!!!!
   484	
   485	EROUT:   MSG('$TOO MANY IOCS BUFFERS$'); L.ONALT; HALT
   486	
   487	
   488	%EXU (CODE, ACC, ADDR, SKPLAB)
   489	
   490	! SAME AS EXUF BUT WITH NO INDIRECT OR INDEX
   491	
   492	LOCAL INDIRECT, INDEX
   493	
   494	INDIRECT _ INDEX _ 0
   495	
   496	%%EXUF (CODE, ACC, INDIRECT, INDEX, ADDR, SKPLAB)
   497	
   498	! THIS IS THE PRIMITIVE EXECUTE FUNCTION WHICH TAKES A FULL SET OF ARGUMENTS.
   499	
   500	! MACHINE DEPENDENT.
   501	! EXECUTES MONITOR CALLS OR OTHER INSTRUCTIONS. RETURNS UNLESS SKIP RETURN
   502	! IS GENERATED BY MONITOR, IN WHICH CASE GO TO SKPLAB. LAST ARGUMENT 
   503	! OMITTED IF INSTRUCTION NEVER SKIPS.
   504	
   505	DEF GOCD AS OCT 254000.000000      !JRST (BRANCH)
   506	LOCAL OPWORD(0:2), FOO:
   507	
   508	OPWORD(0) _ [9,4,1,4,18] * [CODE,ACC,INDIRECT,INDEX,ADDR]
   509	OPWORD(1) _ GOCD BOR FOO
   510	OPWORD(2) _ GOCD BOR RH(@SKPLAB)
   511	GO ^OPWORD
   512	FOO:  RETURN
   513	
   514	END EXU
   515	
   516	
   517	!     *****  FILE OPEN & CLOSE & UTILITY OPERATIONS
   518	
   519	
   520	%OPENP (%NNCH,FDESCR,ERLAB:,NSBUFS)
   521	
   522	! OPEN FILE. FID=ADDRESS OF FILE IDENTIFYING STRING IF >=0, ELSE
   523	!  IS -(FID TABLE ADDR) (I.E., SETFID HAS BEEN CALLED PREVIOUSLY).
   524	!  FDESCR=TYPE+MODE+ORGANIZATION.
   525	!  ERLAB:=ERROR LABEL. NSBUFS=IF SEQ. MODE, NO. OF BUFFERS IN RING.
   526	!  CALLED WITHOUT THIS ARGUMENT IF DIRECT MODE.
   527	!  INITIALIZES CURSOR POSITION (AND MXACP, IF DIRECT).
   528	!  RETURNS FILE NUMBER.
   529	! IF NAME IS SUBSET OF "TELETY", RETURN TEL.
   530	
   531	LOCAL %NXTFN,%ST.DESCR,%INIT.SCP
   532	LOCAL FN, PTR, TEMP, HERE:
   533	LOCAL FISPEC(0:2), TYPMOD
   534	
   535	DEF KF.NO AS  1
   536	DEF KF.YES AS 2
   537	DEF FWDCNT AS KF.YES
   538	DEF KF.ANY AS 3
   539	DEF KF.EXSTS AS 4
   540	DEF KF.NEW AS 5
   541	DEF CNFTBLCNT AS KF.NEW-KF.YES
   542	
   543	TABLE FWD(FWDCNT+1) ['NO', 'YES', '[[[[[']
   544	
   545	TABLE CONFTBL(CNFTBLCNT+1) ['ANY', 'EXISTING', 'NEW', '[[[[[']
   546	
   547	L.OFFALT; SETFIP(FIDTBL,%NNCH,0,ERLAB); GO BELOW
   548	
   549	%%OPEN (FID,FDESCR,ERLAB:,NSBUFS)
   550	
   551	L.OFFALT
   552	IF FID<0 THEN FIDP _ -FID ELSE &
   553	  [PTR _ CHPT(FID,-1); SETFID(FIDTBL,@PTR,0,ERLAB)]
   554	
   555	BELOW: &
   556	IF TELCHK THEN DO
   557	  RWELAB(FN_TEL) _ ERLAB; ST.DESCR
   558	  IF MODE(TEL)=DIRECT OR ORG(TEL)#CHARACTER THEN DO
   559	    MODE(TEL) _ SEQUEN; ORG(TEL) _ CHARACTER; FNERR(TELERR)
   560	  END
   561	END ELSE DO
   562	
   563	! NOT TELETYPE
   564	  RWELAB(FN_NXTFN) _ HERE; ST.DESCR
   565	  IF MODE(FN)=SEQUEN AND FTYP(FN)=UPDATE THEN FNERR(FMDERR)
   566	  OPEN1
   567	  IF MODE(FN)=SEQUEN THEN INIT.SCP ELSE SETCPI(FN,MXACP(FN)_0)
   568	  YLAB(FN) _ IF ORG(FN)=CHARACTER THEN YCHAR ELSE WXLAB
   569	  RWELAB(FN) _ ERLAB
   570	END
   571	
   572	L.ONALT; RETURN FN
   573	
   574	HERE:    FTYP(FN) _ -1; GO ERLAB
   575	
   576	
   577	%NXTFN
   578	! MACHINE DEPENDENT.
   579	! RETURNS NEXT AVAILABLE FILE NUMBER.
   580	! (JOBHCU IS 0 EVEN IF NO CHANNEL IS IN USE)
   581	! USES CHANNELS FNMIN TO FNMAX.
   582	! NOTE: THESE JOB DATA LOCATIONS ARE 'SUBJECT TO CHANGE W/O NOTICE'.
   583	
   584	        I _ RH(@JOBHCU) MAX (FNMIN-1)
   585	        LOOP DO
   586	          IF INC I>FNMAX THEN I_FNMIN
   587	          IF RH(JOBJDA+I)=0 THEN RETURN I
   588	          IF I=RH(@JOBHCU) THEN ERR(TMFERR)
   589	        END
   590	
   591	END NXTFN
   592	
   593	
   594	%ST.DESCR
   595	! UNPACKS FDESCR TO GET TYPE, MODE & ORGANIZATION OF FN
   596	
   597	TYPMOD _ FDESCR BAND OCT 300
   598	ORG(FN) _ FDESCR BAND OCT 60
   599	MODE(FN) _ FDESCR BAND OCT 10
   600	FTYP(FN) _ FDESCR BAND 7
   601	RETURN
   602	
   603	END ST.DESCR
   604	
   605	
   606	%SET.CTRL
   607	! MACHINE DEPENDENT
   608	! SET BREAK TABLE (OR DO WHATEVER) FOR GETLINE SO THAT CTRL
   609	! CHARACTERS WILL BE ACCEPTED AS DESIRED (AND NOT PERFORM
   610	! SPECIAL FUNCTIONS)
   611	
   612	LOCAL TEMP, SVLCH, SVTMC
   613	DEF BIT29 AS OCT 100     !FULL CHAR SET
   614	DEF BIT28 AS OCT 200     !NO ECHO
   615	DEF BIT26 AS OCT 1000     !BREAK ON ALL BUT LETTERS, DIGITS
   616	DEF BIT17 AS OCT 1000000    !NO FORM FEED
   617	DEF BIT14 AS OCT 10000000    !NO TAB
   618	DEF BIT10 AS OCT 200000000   !NO CRLF
   619	DEF BIT4  AS OCT 20000.000000    !SUPPRESS TAB
   620	DEF STSBITS AS (BIT29+BIT26)
   621	DEF LCHBITS AS (BIT17+BIT14+BIT10)
   622	
   623		^14 _ -1; EXU(CLICD, 14, -OCT 16)    !GETTMC
   624		SVTMC _ ^14
   625		SVLCH _ -1; EXU(TTCD, 6, @SVLCH)    !GETLCH
   626	%%RS.BRK                ! RESET (RESTORE) BREAK SET.
   627		TEMP _ SVLCH BOR LCHBITS; EXU(TTCD, 7, @TEMP)    !SETLCH
   628	        ^14 _ SVTMC BOR BIT4
   629		EXU(CLICD, 14, -OCT 15)    !SETTMC
   630	
   631	%%ON.ECHO
   632		^14 _ STSBITS
   633	SET:	EXU(CLICD,14,-OCT 26)
   634		RETURN
   635	
   636	%%OFF.ECHO
   637		^14 _ STSBITS+BIT28; GO SET
   638	
   639	%%UNSET.CTRL
   640	
   641		^14 _ SVTMC
   642		EXU(CLICD, 14, -OCT 15)
   643		EXU(TTCD, 7, @SVLCH)
   644		RETURN
   645	
   646	END SET.CTRL
   647	
   648	
   649	%OPEN1
   650	
   651	! MACHINE DEPENDENT
   652	! OPENS FILE WITH FIDTBL ENTRIES AT FIDP AS FILE NUMBER N.
   653	! IF SEQUEN MODE, SETS UP BUFFER RING.
   654	
   655	!  1) INPUT - LOOKUP
   656	!  2) UPDATE - LOOKUP. IF FILE EXISTS, ENTER. IF NOT, 3).
   657	!  3) DIRECT OUTPUT - ENTER, CLOSE, LOOKUP, ENTER
   658	!  4) SEQUEN OUTPUT - ENTER
   659	
   660	LOCAL %SETFISPEC, %INIT.RNG, %FILEP, %NXCHAR, %GETCONF, %GET.ANS, %MAP.TO.UPPER.CASE
   661	LOCAL %ABORT, %ABORT1, %ABORT2
   662	LOCAL INITOK:,STPPN:,GETSZ:, CHKMSG:, ABRT:, FINI:, REASK:
   663	LOCAL PPNHLD, SAVLOC, OLDP, CONF, LPTR
   664	DEF OLDFILE AS EXTARG(FIDP) BAND OCT 40.00.00 #0
   665	
   666	DEF OLDMSG AS 'EXISTING FILE'
   667	DEF NEWMSG AS 'NEW FILE'
   668	
   669	         SETFISPEC
   670	         EXU(OPNCD, FN, FISPEC, INITOK)   !INIT. CHANNEL
   671	         MSG('DISK NOT AVAILABLE$')
   672	         ABNERR(FN)     !DISK NOT AVAILABLE - VERY RARE
   673	INITOK:  SETMODE(-1) !RESET DEFAULT!; OPNSZ(FN) _ SZFG(FN) _ 0
   674	         PPNHLD _ PPNARG(FIDP)     !SAVE PROJ-PROG NO.
   675		 CONF _ CONFWD(FIDP)
   676	         IF FTYP(FN)>UPDATE THEN DO
   677	ENTER:     EXU(ENTCD, FN, @ARGCNT(FIDP), CHKMSG); GO ERROUT
   678	CHKMSG:    EIF FTYP(FN)=OUTMSG THEN DO
   679	             SAVLOC _ ALTLOC <== ABRT; OLDP _ SETPRMPT(%FILEP); L.ONALT
   680		     IF CONF=0 THEN CONF _ GET.ANS(%NXCHAR)+1
   681		     IF CONF=KF.NO OR OLDFILE AND CONF=KF.NEW OR NOT OLDFILE &
   682		       AND CONF=KF.EXSTS THEN DO
   683	ABRT:	       ABORT(CNFERR)
   684		     END
   685	             L.OFFALT; ALTLOC _ SAVLOC; SETPRMPT(OLDP); FTYP(FN) _ OUTPUT
   686	           END
   687	           FIF FTYP(FN)=OUTPUT THEN DO
   688	             IF (OLDFILE AND TYPMOD=NEW) OR (NOT OLDFILE AND TYPMOD=OLD) THEN ABORT1(CNFERR)
   689	           END
   690	           IF MODE(FN)=SEQUEN THEN INIT.RNG ELSE DO
   691	             EXU(CLSCD, FN, 0)
   692	             EXU(LKPCD, FN, @ARGCNT(FIDP), STPPN); HALT  !NO ERROR AS LONG AS ENTER
   693	                                       !INITS. PROTECTION TO READ ALL
   694	           END
   695	         END ELSE DO     !INPUT OR UPDATE
   696	           EXU(LKPCD, FN, @ARGCNT(FIDP), GETSZ)
   697	           IF FTYP(FN)=UPDATE AND (EXTARG(FIDP) BAND 7)=0 !NEWFILE! &
   698	            THEN IF TYPMOD=OLD THEN ABORT2(CNFERR) ELSE GO ENTER
   699	ERROUT:    DO.ERR(FN)
   700	GETSZ:     OPNSZ(FN) _ EBUFSZ(FN)*FILSIZ(FIDP)/BUFSZ
   701	           IF ORG(FN)=CHARACTER THEN SZFG(FN) _ -1   !SIZE IS APPROX.
   702	           EIF FTYP(FN)=UPDATE THEN DO
   703	             IF TYPMOD=NEW THEN ABORT2(CNFERR)
   704	STPPN:       PPNARG(FIDP) _ PPNHLD   !RESTORE PROJ-PROG NO, CLOBBERED BY LOOKUP
   705	             EXU(ENTCD, FN, @ARGCNT(FIDP), FINI); GO ERROUT
   706	           END
   707	           FIF MODE(FN)=SEQUEN THEN INIT.RNG
   708	         END
   709	FINI:    MOVE 4 FROM @ARGCNT(FIDP)+1 TO @MINFID(FN*4)   !FOR %ERASE
   710	         RETURN
   711	
   712	
   713	%DO.ERR (FN)
   714	! CALL AFTER UNSUCCESSFUL LOOKUP, ENTER, RENAME.
   715	
   716	         EXU(RLSCD, FN, 0)
   717	         FTYP(FN) _ -1     !BETTER BE SAFE...
   718	         FNERR(FNFERR+(EXTARG(FIDP) BAND 7))
   719	
   720	END DO.ERR
   721	
   722	
   723	%ABORT (ERNUM)
   724	
   725	L.OFFALT; ALTLOC _ SAVLOC; SETPRMPT(OLDP)
   726	
   727	%%ABORT1 (ERNUM)
   728	
   729	EXU(CLSCD, FN, OCT 40)     !UNDOES ENTER
   730	
   731	%%ABORT2 (ERNUM)
   732	
   733	EXU(RLSCD, FN, 0); FNERR(ERNUM)
   734	
   735	END ABORT
   736	
   737	
   738	%SETMODE (MODE)
   739	
   740	FISPEC(0) _ MODE; RETURN
   741	
   742	END SETMODE
   743	
   744	
   745	%SETFISPEC
   746	! SETS SPECS FOR DEVICE INITIALIZATION 
   747	DEF DSKDEV AS OCT 446353.000000    !SIXBIT /DSK/
   748	
   749	FISPEC(1) _ IF DEVNAM(FIDP)=0 THEN DSKDEV ELSE DEVNAM(FIDP)
   750	FISPEC(2) _ 0
   751	IF MODE(FN)=DIRECT THEN DO
   752	  IF FISPEC(0)<0 THEN FISPEC(0) _ OCT 17     !DUMP (UNBUFFERED)
   753	END ELSE DO
   754	  IF FISPEC(0)<0 THEN FISPEC(0) _ 0  !BUFFERED
   755	  HW(FISPEC+2, [FTYP(FN)=INPUT]) _ HEAD+FN*3  !HEADER
   756	END
   757	
   758	RETURN
   759	
   760	END SETFISPEC
   761	
   762	
   763	%INIT.RNG
   764	! SET UP RING BUFFERS
   765	
   766	LOCAL %GETBUF
   767	
   768	IF NSBUFS<0 THEN ERR(ARGERR)
   769	USEBIT(FN) _ 1
   770	CURBUF(FN) _ TEMP _ GETBUF
   771	REPEAT NSBUFS-1 &
   772	 ^TEMP _ [18,18]*[BUFSZ+1, TEMP <== GETBUF]
   773	^CURBUF(FN) _ [18,18]*[BUFSZ+1, TEMP]
   774	RETURN
   775	
   776	%GETBUF
   777	!ALLOCATES SPACE FOR ONE BUFFER, RETURNS POINTER TO SECOND WORD
   778	
   779	LOCAL P
   780	
   781	P _ GETMEM(BBUFSZ)
   782	IF P=0 THEN GO ERLAB
   783	MOVE BBUFSZ FROM ALL 0 TO P
   784	RETURN P+1
   785	
   786	END GETBUF
   787	
   788	END INIT.RNG
   789	
   790	
   791	%TELCHK
   792	! MACHINE DEPENDENT.
   793	! RETURNS 1 IF FILE NAME DESIGNATES TERMINAL, ELSE RETURNS 0.
   794	
   795	TABLE TELFID(2) [OCT 64.45.54.45.64.71,     !SIXBIT /TELETY/!&
   796	      OCT 64.45.62.55.51.56]     !SIXBIT /TERMIN/
   797	
   798	     FOR J_ 1 TO 2 DO
   799	       TEMP _ NAMARG(FIDP); I _ TELFID(J)
   800	       REPEAT 6 DO
   801	         IF (TEMP _ TEMP ROTL 6) BAND OCT 77 # (I _ I ROTL 6) BAND OCT 77 &
   802	            THEN GO OUT
   803	       END
   804	       RETURN YES
   805	OUT:   IF TEMP BAND OCT 77=0 THEN RETURN YES
   806	     END
   807	     RETURN NO
   808	
   809	END TELCHK
   810	
   811	
   812	%MAP.TO.UPPER.CASE(CHAR)
   813	
   814	! RETURNS, IF CHAR IS A LOWER CASE ALPHABETIC, ITS UPPER CASE VALUE.
   815	! ELSE, RETURNS CHAR.
   816	
   817	IF $A + OCT 40 <= CHAR <= $Z + OCT 40 THEN RETURN (CHAR - OCT 40)
   818	RETURN CHAR
   819	
   820	END MAP.TO.UPPER.CASE
   821	
   822	
   823	%GET.ANS(%NXT)
   824	
   825	! ASSUMES PROMPT IS SET (A QUESTION); GETS A Y OR N ANSWER FROM CFN,
   826	! USING %NXT TO ADVANCE THE CHARACTER POINTER, AND ASKS 'WHAT??'
   827	! UNTIL IT GETS A Y OR N ANSWER.
   828	
   829	   LOCAL %WHAT
   830	
   831	   LOOP DO
   832	      LPTR _ GETLINE(CFN)
   833	      WHILE TEMP _ MAP.TO.UPPER.CASE(NXT) = $  THEN NULL
   834	      IF NOT ($Y#TEMP#$N) THEN RETURN ([TEMP=$Y])
   835	      IF CFN # TEL THEN ABORT(CNFERR)
   836	      SETPRMPT(%WHAT)
   837	   END
   838	
   839	   RETURN
   840	
   841	   %WHAT
   842	
   843	      PRINT('WHAT?? ')
   844	      RETURN
   845	
   846	   END WHAT
   847	
   848	END GET.ANS
   849	
   850	
   851	%FILEP
   852	
   853	PRINT(IF OLDFILE THEN OLDMSG ELSE NEWMSG); PRINT(' - OK?? '); RETURN
   854	
   855	END FILEP
   856	
   857	
   858	%NXCHAR
   859	
   860	RETURN NCHV LPTR
   861	
   862	END NXCHAR
   863	
   864	
   865	%SET.NXCHAR (%NXCHAR)
   866	
   867	LOCAL %PTRNXT, %GETNXT
   868	RETURN
   869	
   870	%SETFIP (FIDTBL, %NNCH, EXTDEF, ERLAB:)
   871	
   872	! MACHINE DEPENDENT.
   873	!  IGNORES LEADING BLANKS.
   874	!  EXAMINES STRING AT (CHAR) PTR FOR VALID FILE IDENTIFIER TERMINATED
   875	!  BY ANY CHAR INVALID IN FILE IDENTIFIER (INCLUDING BLANK,
   876	!  EXCEPT IN USER NAME)
   877	!  IF FINDS, STORES WPF WORDS OF FID INFO AT
   878	!  FIDTBL, AS REQUIRED BY %OPEN1, WITH PTR AT CHAR
   879	!  BEFORE TERMINATOR.  SETS FIDP TO ADDRESS OF 1ST OF FIDTBL ENTRIES.
   880	!  IF DOESN'T FIND VALID FID, GOES TO ERLAB WITH PTR RESET TO
   881	!  ORIGINAL VALUE.
   882	!  EXTDEF IS DEFAULT EXTENSION.
   883	
   884	!  FORM OF FILE ID:
   885	!    NAME  (MAX 6 ALPHA-NUM. CHARS)
   886	!    OPTIONAL:  .EXTENSION  (MAX 3 ALPHA-NUM. CHARS)
   887	!    OPTIONAL:  [PROJ,PROG]  (MAX 6 OCTAL DIGITS EACH)
   888	!  NAME & EXT ARE STORED SIXBIT & LEFT-JUSTIFIED IN 1ST AND 2ND WDS;
   889	!  PROJ STORED AS BINARY INTEGER IN LEFT HALF OF 4TH WD; PROG, IN
   890	!  RIGHT HALF. EXTQ(FIDP) IS 1 IF EXTENSION FOUND, 0 IF USED DEFAULT.
   891	!    OR OPTIONAL (USERNAME) BEFORE FILE NAME, MAX 12 CHARS,
   892	!  IN WHICH CASE STORE USER NAME IN SIXBIT, 0 IN LH OF 4TH
   893	!  WD, AND LOCATION OF USER NAME IN RH.
   894	
   895	!  BECAUSE OF %SETFIP, NO PCHV DURING SCAN.
   896	
   897	DEF SIXBIT(X) AS (X-OCT 40)      !CONVERTS 7-BIT CHAR TO SIXBIT
   898	
   899	LOCAL CHAR, SIXPTR, HOLD
   900	LOCAL %GETNUM
   901	DEF SXPT(X) AS [6,6,24]*[36,6,(X)]
   902	
   903	SET.NXCHAR(%GETNXT); GO BELOW
   904	
   905	%%SETFID (FIDTBL, @PTR, EXTDEF, ERLAB:)
   906	
   907	SET.NXCHAR(%PTRNXT)
   908	
   909	BELOW: &
   910	         MOVE WPF FROM ALL 0 TO FIDP _ FIDTBL
   911	         ARGCNT(FIDP) _ MINARG; EXTARG(FIDP) _ EXTDEF; HOLD _ PTR
   912	         WHILE NXCHAR = $  THEN NULL
   913	NAM:     I _ 6; SIXPTR _ SXPT( @NAMARG(FIDP) )
   914	         LOOP DO
   915	           CHAR _ MAP.TO.UPPER.CASE(CHAR)
   916	           EIF $0<=CHAR<=$9 OR $A<=CHAR<=$Z THEN DO
   917	             IF DEC I>=0 THEN NCHV SIXPTR _ SIXBIT(CHAR)
   918	           END
   919	           ORIF CHAR=$. THEN DO
   920	             I _ 3; SIXPTR _ SXPT(@EXTARG(FIDP))
   921	             EXTARG(FIDP) _ 0; EXTQ(FIDP) _ YES
   922	           END
   923	           ORIF CHAR=$( THEN DO
   924	             I _ 12; SIXPTR _ SXPT(RH(@PPNARG(FIDP))_@USRNAM(FIDP))
   925	             LOOP DO
   926	               WHILE NXCHAR # $)
   927	               IF DEC I<0 THEN GO OUT
   928	               NCHV (SIXPTR) _ SIXBIT(MAP.TO.UPPER.CASE(CHAR))
   929	             END
   930	             NXCHAR; GO NAM
   931	           END
   932	           ORIF CHAR=$[ THEN DO
   933	             LH(@PPNARG(FIDP)) _ GETNUM
   934	             IF CHAR=$, THEN RH(@PPNARG(FIDP)) _ GETNUM
   935	             IF CHAR#$] THEN GO OUT
   936	             GO CONFLB
   937	           END
   938	           ORIF CHAR=$: THEN DO
   939		     DEVNAM(FIDP) _ NAMARG(FIDP); NXCHAR; GO NAM
   940		   END
   941	CONFLB:    ORIF CHAR=$- THEN DO
   942		     CONFWD(FIDP) _ GETCONF(%NXCHAR,OUT)
   943	             IF %NXCHAR=%PTRNXT THEN PCHV PTR
   944		   END
   945	           ELSE GO DONE
   946		   NXCHAR
   947	         END
   948	DONE:    IF NAMARG(FIDP)#0 THEN [IF %NXCHAR=%PTRNXT THEN PCHV PTR; RETURN]
   949	
   950	OUT:     PTR _ HOLD; ERR(IFDERR)
   951	
   952	%GETNUM
   953	
   954	LOCAL I
   955	         I _ 0
   956	         WHILE $0<=NXCHAR<=$7 THEN I_(I SHL 3) BOR (CHAR-$0)
   957	         RETURN I
   958	
   959	END GETNUM
   960	
   961	
   962	%PTRNXT
   963	RETURN CHAR _ NCHV PTR
   964	END PTRNXT
   965	
   966	
   967	%GETNXT
   968	RETURN CHAR _ NNCH
   969	END GETNXT
   970	
   971	
   972	%WFID (FIDP())
   973	
   974	!  TYPES OUT NAME & EXT OF FILE HAVING FID TABLE AT FIDP.
   975	
   976	SIXPTR _ SXPT(@NAMARG(FIDP))
   977	LOOP [REPEAT 6; WHILE CHAR_NCHV SIXPTR#0; PUT(CHAR+OCT 40)]
   978	IF LH(@EXTARG(FIDP))#0 THEN DO
   979	  PUT($.); SIXPTR _ SXPT(@EXTARG(FIDP))
   980	  LOOP [REPEAT 3; WHILE CHAR_NCHV SIXPTR#0; PUT(CHAR+OCT 40)]
   981	END
   982	RETURN
   983	
   984	END WFID
   985	
   986	END SETFIP
   987	
   988	END SET.NXCHAR
   989	
   990	
   991	%INIT.SCP
   992	! INITIALIZE SEQUEN FILE CURSOR POSITION. ANALOGOUS TO SETCP(FN,0)
   993	! FOR DIRECT MODE. USER CAN REQUEST BUT NOT SET CURSOR POSITION IF
   994	! MODE IS SEQUEN.
   995	
   996	! SETS RLAB(FN)/WLAB(FN) TO LABEL IN %R/%W TO BE BRANCHED TO
   997	! ON NEXT READ/WRITE OF FN.
   998	
   999	CP1(FN) _ ECNT(FN) _ 0
  1000	RLAB(FN) _ IF FTYP(FN)=OUTPUT THEN R.ERR ELSE RADR(ORGIND(FN))
  1001	WLAB(FN) _ IF FTYP(FN)= INPUT THEN W.ERR ELSE WADR(ORGIND(FN))
  1002	RETURN
  1003	
  1004	END INIT.SCP
  1005	
  1006	
  1007	%GETCONF (%NXCH, LAB:)
  1008	
  1009	!GET CONFIRMATION KEYWORD. READ UP TO CPW ALPHA CHARS WITH %NXCH.
  1010	! ALLOW SHORTEST UNIQUE ABBREVIATION.
  1011	! GO TO LAB IF NEXT CHAR NOT ALPHA,
  1012	! OR NO MATCH, OR AMBIGUITY.
  1013	
  1014	LOCAL PTR, INWD, CHAR, CNT
  1015	DEF BPC AS (BPW/CPW)
  1016	DEF LESSTR(X,Y) AS (X) SHR 1 < (Y) SHR 1  !STRING COMPARISON
  1017	DEF MASK(CNT) AS (-1 SHL (BPW-BPC*(CPW-CNT)))
  1018	
  1019	INWD _ 0; PTR _ CHPT(@INWD,-1); CNT _ CPW
  1020	LOOP DO
  1021	  WHILE $A<= CHAR _ MAP.TO.UPPER.CASE(NXCH) <=$Z; WHILE DEC CNT>=0
  1022	  NCHV PTR _ CHAR
  1023	END
  1024	IF CNT=CPW THEN GO LAB
  1025	IF CNT < 0 THEN DO  ! STRING OF GREATER THAN FIVE CHARS.
  1026	   CNT _ 0   ! FOR MASKING - IMPLIES FULL WORD TOKEN.
  1027	   LOOP [WHILE $A <= MAP.TO.UPPER.CASE(NXCH) <= $Z]  ! WE ONLY READ A WORD-FULL OF CHARACTERS,
  1028	                                  ! BUT WE MAKE IT LOOK LIKE WE READ THEM ALL.
  1029	END
  1030	! COMPARE
  1031	PTR _ 0
  1032	LOOP DO
  1033	  IF INWD=^CONFTBL(INC PTR) THEN RETURN PTR + FWDCNT
  1034	  WHILE NOT LESSTR(INWD,^CONFTBL(PTR))
  1035	END
  1036	! INWD < ^CONFTBL(PTR)
  1037	IF INWD#^CONFTBL(PTR) BAND MASK(CNT) OR INWD=^CONFTBL(PTR+1) BAND MASK(CNT) &
  1038	  THEN GO LAB
  1039	RETURN PTR + FWDCNT
  1040	
  1041	END GETCONF
  1042	
  1043	END OPEN1
  1044	
  1045	END OPENP
  1046	
  1047	
  1048	
  1049	
  1050	%CLOSE (FN)
  1051	
  1052	! CLOSE FILE FN.  DO NOTHING IF FN=TEL.
  1053	
  1054	! IF DIRECT MODE:
  1055	! *SPECIAL CONSIDERATION IS TAKEN IN WRITING LAST FILE BLOCK,
  1056	! *SINCE IT MAY BE PARTIALLY FULL - MUST ADJUST COUNT.
  1057	!  WRITE OUT ANY DIRTY FN BLOCKS, SET BUFFERS UNUSED
  1058	!  THAT CONTAIN FN BLOCKS, CLOSE & SAVE.
  1059	! A BUFFER IS SET UNUSED BY STORING -1 AS ITS FN.ID
  1060	
  1061	! IF SEQUEN MODE:
  1062	!  IF TYPE OUTPUT, WRITE OUT BLOCK IN CURRENT BUFFER.
  1063	!  RELEASE BUFFERS, CLOSE & SAVE.
  1064	
  1065	DEF SAVE AS 0
  1066	DEF DEL AS 1
  1067	DEF DISCARD AS OCT 40
  1068	
  1069	LOCAL %CLOSE1,%RLS.RNG,TEMP,I,OPTION
  1070	
  1071	OPTION _ SAVE
  1072	
  1073	GO DOIT
  1074	
  1075	%%CANCEL(FN) !  FOR OUTPUT SEQUEN FILES, CLOSES WITHOUT SUPERCEDING.
  1076	
  1077	   OPTION _ DISCARD
  1078	
  1079	DOIT:  IF FN=TEL THEN RETURN
  1080	L.OFFALT
  1081	
  1082	  IF MODE(FN)=DIRECT THEN DO
  1083	   IF FTYP(FN)#INPUT AND TEMP_DSIZE(FN)#0 THEN DO
  1084	    DSETCP(FN,TEMP-1)     !LAST ELEMENT
  1085	    IF TEMP _ WPB(TEMP MOD EBUFSZ(FN))>0 THEN DO
  1086	      I _ GETCHK(FN)
  1087	      WBLK(FN,TEMP,I,BLK.ID(CPBUF(FN)))
  1088	      FN.ID(CPBUF(FN)) _ -1
  1089	    END
  1090	   END
  1091	    FOR I _ 0 TO NBUFS-1 IF FN.ID(I)=FN THEN &
  1092	      [IF DIRTY(I) THEN CLEAN(I); FN.ID(I)_-1]
  1093	  END ELSE [IF FTYP(FN)=OUTPUT THEN S.WBLK(FN)]
  1094	  CLOSE1(OPTION); IF MODE(FN)#DIRECT THEN RLS.RNG; L.ONALT; RETURN
  1095	
  1096	
  1097	%%DELETE (FID, ERLAB:)
  1098	
  1099	!DELETE FILE WITH NAME AT FID
  1100	
  1101	         L.OFFALT
  1102	         FN _ OPEN(FID, INPUT+DIRECT, ERLAB); CLOSE1(DEL)
  1103	         L.ONALT; RETURN
  1104	
  1105	
  1106	%%RENAME (OLDFID, NEWFID, ERLAB:)
  1107	
  1108	! MACHINE DEPENDENT
  1109	! RENAME FILE WITH NAME AT OLDFID TO NAME AT NEWFID
  1110	
  1111	LOCAL OUT:, OLDRLS:, PTR, DATE
  1112	
  1113	         L.OFFALT
  1114	         FN _ OPEN(OLDFID, INPUT+DIRECT, ERLAB)
  1115	         DATE _ PRVARG(FIDP)
  1116	         IF NEWFID<0 THEN FIDP _ -NEWFID ELSE DO
  1117	           PTR _ CHPT(NEWFID,-1); SETFID(FIDTBL,@PTR,0,OLDRLS)
  1118	         END
  1119	         PRVARG(FIDP) _ DATE
  1120	         EXU(RNMCD, FN, @ARGCNT(FIDP), OUT)    !CLOSE IS AUTOMATIC
  1121	         DO.ERR(FN)
  1122	OLDRLS:  CLOSE1(SAVE); FNERR(IFDERR)
  1123	
  1124	OUT:	 EXU(RLSCD, FN, 0)
  1125	         FTYP(FN) _ -1 !SINCE SKIPPED CLOSE!; L.ONALT; RETURN
  1126	
  1127	
  1128	%CLOSE1 (OPT)
  1129	
  1130	! MACHINE DEPENDENT.
  1131	! CLOSE FILE FN. DELETE IF OPT=DEL, OTHERWISE SAVE.
  1132	!  SET FTYP(FN) NEGATIVE.
  1133	
  1134	LOCAL RELEAS:
  1135	
  1136	       IF OPT=DEL THEN DO
  1137	         FIDTBL(0) _ 0
  1138	         EXU(RNMCD, FN, FIDTBL, RELEAS)  !CLOSE IS AUTOMATIC
  1139	         DO.ERR(FN)
  1140	       END ELSE DO
  1141	         EXU(CLSCD, FN, OPT)
  1142	         EXU(STZCD, FN, OCT 740.000, RELEAS)
  1143	         MSG('CAN NOT CLOSE FILE$')
  1144	         ABNERR(FN)      !CAN'T CLOSE FILE
  1145	RELEAS:  EXU(RLSCD, FN, 0)
  1146	       END
  1147	       FTYP(FN) _ -1; RETURN
  1148	
  1149	END CLOSE1
  1150	
  1151	%RLS.RNG
  1152	! RELEASE RING BUFFERS FOR FILE FN
  1153	
  1154	LOCAL LINK
  1155	
  1156	LINK _ RH(CURBUF(FN)); RH(CURBUF(FN)) _ 0  !NO SOFT STORE
  1157	WHILE LINK#0 THEN RLSMEM(BBUFSZ,(LINK<==RH(LINK))-1)
  1158	RETURN
  1159	
  1160	END RLS.RNG
  1161	
  1162	END CLOSE
  1163	
  1164	
  1165	%CANC.ALL   !  LIKE CLOSE ALL, BUT SEQUEN OUTPUT FILES ARE NOT SUPERCEDED.
  1166	
  1167	   LOCAL I
  1168	
  1169	   FOR I _ 0 TO RH(@JOBHCU) IF FTYP(I)>=0 THEN CANCEL(I)
  1170	   RETURN
  1171	
  1172	END CANC.ALL
  1173	
  1174	
  1175	%CLOSE.ALL
  1176	! CLOSE ALL FILES (BUT COMMAND FILE, IF ANY)
  1177	
  1178	LOCAL I
  1179		FOR I _ 0 TO RH(@JOBHCU) IF FTYP(I)>=0 THEN CLOSE(I)
  1180		RETURN
  1181	END CLOSE.ALL
  1182	
  1183	
  1184	%BUF.DUMP
  1185	
  1186	! MACHINE DEPENDENT IN PART (INDICATED).
  1187	! TO BE CALLED AS A PROTECTIVE MEASURE BEFORE DOING SOMETHING THAT
  1188	! MAY DESTROY FILE BUFFERS.  WRITES OUT ALL DIRTY BLOCKS IN DIRECT
  1189	! MODE BUFFERS & SETS THEM CLEAN.  ACTION TO PROTECT SEQUEN FILES 
  1190	! IS MACHINE DEPENDENT.  FOR THIS IMPLEMENTATION, WAIT UNTIL ALL
  1191	! CHANNELS ARE INACTIVE (NO MORE DATA TRANSMISSION). OK IF CHANNEL
  1192	! NOT IN USE.
  1193	
  1194	L.OFFALT
  1195	FOR I _ 0 TO NBUFS-1 IF FN.ID(I)>=0 AND DIRTY(I) THEN CLEAN(I)
  1196	FOR I _ FNMIN TO FNMAX EXU(CLICD, I, OCT 10)
  1197	L.ONALT; RETURN
  1198	
  1199	END BUF.DUMP
  1200	
  1201	
  1202	%FIXBUF(DISP)
  1203	
  1204	! MOVES I/O BUFFERS UP OR DOWN BY THE AMOUNT IN DISP.  USED BY MIGHTYCHAIN.
  1205	! RETURNS DISP.
  1206	
  1207	LOCAL FN, P, FIRSTP
  1208	
  1209	FOR FN _ FNMIN BY 1 TO JOBHCU &
  1210	  IF FTYP(FN)>=0 AND MODE(FN)=SEQUEN THEN DO
  1211	    LH(14) _ FN+(IF FTYP(FN)=INPUT THEN OCT 20 ELSE OCT 40)
  1212	    RH(14) _ DISP
  1213	    EXU(CLICD, 14, - OCT 27)	!MOVBUF
  1214	    S.EPTR(FN) + _ DISP; EPTR(FN) + _ DISP
  1215	    FIRSTP _ P _ CURBUF(FN); CURBUF(FN) _ CURBUF(FN)+DISP
  1216	    LOOP [RH(P) _ RH(P)+DISP; WHILE (P _ RH(P)-DISP) # FIRSTP]
  1217	  END
  1218	
  1219	RETURN DISP
  1220	
  1221	END FIXBUF
  1222	
  1223	
  1224	
  1225	!     *****  FILE CURSOR POSITION & SIZE
  1226	
  1227	
  1228	%SETCPI (FN,POS)
  1229	
  1230	! DIRECT MODE ONLY.  SETS CURSOR POSITION ON FN TO POS.
  1231	! KEEPS TRACK OF MAXIMUM ABANDONED CURSOR POSITION, USED IN %SIZE.
  1232	! SETCPI CALLED AT OPEN TIME, SINCE NO PREVIOUS CP YET.
  1233	
  1234	! NEGATES CPBUF(FN), INDICATING TO %CP THAT CURSOR POSITION
  1235	! CAN BE FOUND IN CP1(FN).  CPBUF UNNEGATED WHEN I/O DONE.
  1236	
  1237	! SETS RLAB(FN) AND WLAB(FN) TO LABEL TO BE BRANCHED TO ON NEXT
  1238	! READ OR WRITE OF FN. SEE %R AND %W.
  1239	
  1240	L.OFFALT; GO HERE
  1241	
  1242	%%SETCP (FN,POS)
  1243	
  1244	IF MODE(FN)=SEQUEN THEN FNERR(FMDERR)
  1245	IF POS<0 THEN FNERR(ARGERR)
  1246	%%DSETCP (FN, POS)
  1247	
  1248	         L.OFFALT
  1249	         IF CPBUF(FN)>=0 THEN MXACP(FN) _ MXACP(FN) MAX DCP(FN)
  1250	HERE:    CP1(FN) _ POS; CPBUF(FN) _ -1
  1251	         RLAB(FN) _ RINIT
  1252	         WLAB(FN) _ IF FTYP(FN)=INPUT THEN W.ERR ELSE WINIT
  1253	         L.ONALT
  1254	         RETURN POS
  1255	
  1256	END SETCPI
  1257	
  1258	
  1259	%CP (FN)
  1260	
  1261	! RETURNS CURSOR POSITION ON FILE FN.
  1262	
  1263	! IF DIRECT MODE:
  1264	! IF NO READ OR WRITE HAS BEEN DONE SINCE LAST SETCP ON FN
  1265	! (CPBUF(FN)<0), POSITION NEED NOT BE CALCULATED (=CP1(FN)).
  1266	! OTHERWISE, MUST BE CALCULATED FROM CPBUF(FN), WHICH INDICATES
  1267	! BUFFER CONTAINING CURSOR POSITION, AND AVAILABLE INFO FOR CPBUF.
  1268	
  1269	! IF SEQUEN MODE:
  1270	! CP1(FN) IS 1ST POSITION ON BLOCK PAST CURRENT BLOCK, S.ECNT IS
  1271	! COUNT OF REMAINING ELEMENTS ON CURRENT BLOCK.
  1272	
  1273	IF FN=TEL THEN FNERR(TELERR)
  1274	
  1275	IF MODE(FN)=SEQUEN THEN RETURN CP1(FN)-ECNT(FN)
  1276	
  1277	%%DCP (FN)       !DIRECT MODE ONLY
  1278	
  1279	RETURN IF CPBUF(FN)<0 THEN CP1(FN) ELSE BLK.ID(CPBUF(FN))*EBUFSZ(FN)-ECNT(FN)
  1280	
  1281	END CP
  1282	
  1283	
  1284	%SIZE (FN)
  1285	
  1286	! MACHINE DEPENDENT IN PART.
  1287	! RETURNS CURRENT SIZE OF FILE IN ELEMENTS, DEFINED AS:
  1288	!
  1289	! DIRECT MODE  - MAX. OF CURRENT CURSOR POS, IF I/O DONE AT  IT,
  1290	!                MAX. ABANDONED CP AT WHICH I/O DONE,
  1291	!                & OPNSZ(FN), WHICH IS REDUCED IF ERASE DONE.
  1292	!                (EXACT OPNSZ CALCULATED IF NECESSARY)
  1293	! SEQUEN INPUT  -  ON PDP-10, LIMITED TO RETURNING ONLY CPW*NO.
  1294	!                  OF WORDS.  (USETI & BUFFERED
  1295	!                  MODE DON'T MIX)
  1296	! SEQUEN OUTPUT -  CP(FN)
  1297	
  1298	LOCAL %OPNSZX
  1299	
  1300	IF FN=TEL THEN FNERR(TELERR)
  1301	IF MODE(FN)=SEQUEN THEN RETURN IF FTYP(FN)=OUTPUT THEN CP(FN) &
  1302	  ELSE OPNSZ(FN)
  1303	
  1304	%%DSIZE (FN)         !DIRECT MODE ONLY
  1305	
  1306	IF CPBUF(FN)>=0 THEN MXACP(FN) _ MXACP(FN) MAX DCP(FN)
  1307	IF MXACP(FN)>=OPNSZ(FN) THEN RETURN MXACP(FN)
  1308	IF SZFG(FN)<0 THEN SZFG(FN) _ OPNSZX(FN)
  1309	RETURN MXACP(FN) MAX OPNSZ(FN)
  1310	
  1311	%OPNSZX (FN)
  1312	
  1313	! ADJUSTS OPNSZ(FN) TO BE EXACT FILE SIZE IN ELEMENTS.
  1314	! CALLED FROM %SIZE.  FOR DIRECT, CHARACTER FILES ONLY.
  1315	
  1316	LOCAL TEMP, I      !'I' IS A FIX AROUND SIMPL BUG
  1317	
  1318	IF OPNSZ(FN)#0 THEN DO
  1319	  L.OFFALT; TEMP _ DCP(FN); SETCP(FN,OPNSZ(FN)-1)  !AT LAST POSITION
  1320	  GETCHK(FN)
  1321	  REPEAT 2 NCHV EPTR(FN)
  1322	  I _ EPTR(FN)
  1323	   LOOP DO
  1324	    REPEAT CPW; WHILE PCHV I=0; DEC OPNSZ(FN)
  1325	    INC ECNT(FN)  !FOR DCP CALL IN SETCP (BELOW)
  1326	  END
  1327	  DSETCP(FN,TEMP); L.ONALT
  1328	END
  1329	RETURN 0     !TO SET SZFG
  1330	
  1331	END OPNSZX
  1332	
  1333	END SIZE
  1334	
  1335	
  1336	!     *****  FILE & TERMINAL INPUT & OUTPUT
  1337	
  1338	
  1339	%INIT.R
  1340	
  1341	LOCAL OBPI, NBPI       !NCHV IS 1ST CHAR OF OLD & NEW LINE BUFFERS
  1342	LOCAL NBP              !CURRENT NEW LINE BUFFER PTR
  1343	LOCAL NBPE             !PTR TO END OF NEW LINE BUFFER
  1344	
  1345	DEF NOTERM(CHAR) AS (CARRET#CHAR#TERMCH)
  1346	DEF TERM(CHAR) AS NOT NOTERM(CHAR)
  1347	
  1348	TABLE DEFTAB(0:8)[8,9,17,25,33,41,49,57,65]
  1349	
  1350	! INITIALIZATION
  1351	
  1352	OBPI _ CHPT(FREE,-1)
  1353	NBPI _ CHPT(IMAGE,-1)
  1354	NBPE _ CHPT(IMAGE,LLEN)    !CHV(NBPE) IS LAST CHAR
  1355	CH(IMAGE) _ EOLIT     !NO EDIT IMAGE
  1356	RETURN
  1357	
  1358	%%SET.TERM(TERMCH)
  1359	LOCAL OLDTERMCH
  1360	RETURN OLDTERMCH <== TERMCH
  1361	
  1362	%%TAB.OFF(%OFF)
  1363	LOCAL OLDOFF
  1364	RETURN OLDOFF <== %OFF
  1365	
  1366	%%SET.PRMPT(%PROMPT)
  1367	LOCAL OLDPROMPT
  1368	RETURN OLDPROMPT <== %PROMPT
  1369	
  1370	%%SET.TAB(TAB())
  1371	LOCAL OLDTAB
  1372	IF TAB=0 THEN TAB _ DEFTAB; RETURN OLDTAB <== TAB
  1373	
  1374	
  1375	%R (FN)
  1376	
  1377	! RETURNS ELEMENT READ FROM CURSOR POSITION ON FILE FN.
  1378	
  1379	! RLAB(FN) IS  RTEL IF FN IS TEL 
  1380	
  1381	!              IF DIRECT MODE:
  1382	!              RINIT IF THIS IS 1ST ACCESS TO FN AFTER SETCP ON FN
  1383	!              OTHERWISE, IS ADDRESS OF CORRESPONDING READ ROUTINE.
  1384	!              SPECIAL ROUTINE TO CHECK FOR EOF IF READING LAST
  1385	!              BLOCK, SINCE DON'T WANT TO REDUCE ECNT(FN)
  1386	!              (WHICH WOULD SCREW UP %CP & %W)
  1387	
  1388	!              IF SEQUEN MODE:
  1389	!              R.ERR IF OUTPUT FILE
  1390	!              OTHERWISE, ADDRESS OF CORRESPONDING READ ROUTINE
  1391	
  1392	DEF WDMAC(X) AS IF DEC ECNT(FN)>=X THEN RETURN ^INC EPTR(FN)
  1393	DEF CHMAC(X) AS IF DEC ECNT(FN)>=X THEN RETURN NCHV EPTR(FN)
  1394	DEF PKMAC(X) BY IF DEC ECNT(FN)>=X THEN DO
  1395		  IF DEC SUBCNT(FN)<0 THEN [EPTR(FN) +_2; SUBCNT(FN)_8]
  1396		  [;PKB] _ [^EPTR(FN);^(EPTR(FN)+1)] DSHR SUBCNT(FN)*8
  1397		  RETURN PKB BAND OCT 377
  1398		END ENDM PKMAC
  1399	
  1400	LOCAL CP.TO.EOF
  1401	
  1402	         GO ^RLAB(FN)
  1403	
  1404	ENDRWD:  WDMAC(ENDCNT(FN)); GO NXBLK
  1405	
  1406	ENDRPK:  PKMAC(ENDCNT(FN))
  1407	         GO NXBLK
  1408	
  1409	ENDRCH:  CHMAC(ENDCNT(FN)); GO NXBLK
  1410	
  1411	RWD:     WDMAC(0); GO NXBLK
  1412	
  1413	RPK:     PKMAC(0)
  1414	         GO NXBLK
  1415	
  1416	RCH:     CHMAC(0)
  1417	
  1418	NXBLK:   IF MODE(FN)=SEQUEN THEN [S.RBLK(FN); GO ^RLAB(FN)]
  1419	         INC ECNT(FN)     !FOR %CP
  1420	RINIT:   IF CP.TO.EOF _ DSIZE(FN)-DCP(FN)<=0 THEN FNERR(EOFERR)
  1421	         L.OFFALT; GETCHK(FN)
  1422	         IF WLAB(FN)#W.ERR THEN WLAB(FN) _ WSET
  1423	         L.ONALT
  1424	         GO ^RLAB(FN) _ IF ENDCNT(FN) _ ECNT(FN)-CPTOEOF>0 THEN &
  1425	           ENDRADR(ORGIND(FN)) ELSE RADR(ORGIND(FN))
  1426	
  1427	RTEL:    RETURN GET
  1428	
  1429	R.ERR:   FNERR(FMDERR)
  1430	
  1431	
  1432	%%PLNCHK (FN)
  1433	
  1434	! CALLED AFTER FILE OPEN; RETURNS 1 IF FIRST WORD ON FILE FN
  1435	! IS A PDP-10 STANDARD LINE NUMBER (BIT 35 ON), ELSE RETURNS 0.
  1436	
  1437	RETURN [^(IF MODE(FN)=SEQUEN THEN S.RBLK(FN) ELSE GETCHK(FN)) BON 1]
  1438	
  1439	
  1440	%RB (FN, CNT, ADR)
  1441	
  1442	DEF GETCH(C) AS TEMP _ CHPT(ADR,-1); REPEAT C [NCHV TEMP _ R(FN); &
  1443	  DEC CNT]
  1444	DEF GETWD(C) AS REPEAT C [^ADR _ R(FN); INC ADR; DEC CNT]
  1445	LOCAL %GETPK
  1446	
  1447	LOCAL HOLD, TEMP, CFRAG, PFRAG, PTR
  1448	LOCAL ULAB, HERE:
  1449	LOCAL %SZAP, %DZAP, I
  1450	
  1451	IF RLAB(FN)=R.ERR THEN FNERR(FMDERR)
  1452	IF FN=TEL THEN FNERR(TELERR)
  1453	IF HOLD _ CNT <0 THEN FNERR(ARGERR)
  1454	IF HOLD=0 THEN RETURN 0
  1455	[PTR;PFRAG] _ CP(FN) DIVMOD EBUFSZ(FN); INC PTR  !BLK NO & ELMT DISPL
  1456	L.OFFALT
  1457	ULAB _ SETRWE(FN,HERE)
  1458	
  1459	DO ORGIND(FN) OF ORGINDLIM
  1460	
  1461	1:         !CHARACTER! &
  1462	  IF PFRAG MOD CPW THEN DO    !CP NOT AT WORD BOUNDARY
  1463	    GETCH(HOLD)
  1464	  END ELSE DO      !CP AT WORD BOUNDARY
  1465	    IF MODE(FN)=SEQUEN THEN DO       !SEQUEN CHARACTER
  1466		CHPT(PTR,PFRAG) _ EPTR(FN); INC PTR
  1467		SZAP
  1468		ECNT(FN) -_ CNT
  1469		[TEMP;CFRAG] _ CNT DIVMOD CPW
  1470		IF TEMP#0 THEN MOVE TEMP FROM PTR TO ADR
  1471		EPTR(FN) _ CHPT(PTR+TEMP,-1); PTR _ CHPT(ADR+TEMP,-1)
  1472		REPEAT CFRAG NCHV PTR _ NCHV EPTR(FN)
  1473	    END ELSE DO       !DIRECT CHARACTER
  1474		IF PFRAG THEN DO       !CP NOT AT BLOCK BOUNDARY
  1475		  GETCH(HOLD MIN BUFSZ*CPW-PFRAG)
  1476		  CHPT(ADR,PFRAG) _ TEMP     !PFRAG IS DUMMY
  1477		  INC ADR
  1478		  INC PTR
  1479		END
  1480		DZAP; GETCH(CFRAG)
  1481	    END
  1482	  END
  1483	
  1484	0:       !WORD! &
  1485	  IF MODE(FN)=SEQUEN THEN DO          !SEQUEN WORD
  1486		PTR _ 1+EPTR(FN)
  1487		SZAP
  1488		IF CNT#0 THEN DO
  1489		  MOVE CNT FROM PTR TO ADR; EPTR(FN) +_ CNT
  1490		  ECNT(FN) -_ CNT
  1491		END
  1492	  END ELSE DO          !DIRECT WORD
  1493		IF PFRAG THEN DO    !CP NOT AT BLOCK BOUNDARY
  1494		  GETWD(HOLD MIN BUFSZ-PFRAG)
  1495		  INC PTR
  1496		END
  1497		DZAP; GETWD(CFRAG)
  1498	  END
  1499	
  1500	2:       !PACK! &
  1501	IF SUBCNT(FN)>0 THEN DO    !CP NOT AT WORD BOUNDARY
  1502		GETPK(HOLD)
  1503	END ELSE DO     !CP AT WORD BOUNDARY
  1504	  IF MODE(FN)=SEQUEN THEN DO      !SEQUEN PACK
  1505		PTR _ 2+EPTR(FN)
  1506		SZAP
  1507		[TEMP;CFRAG] _ CNT DIVMOD 9
  1508		IF TEMP#0 THEN DO
  1509		  MOVE TEMP*2 FROM PTR TO ADR
  1510		  EPTR(FN) +_ TEMP*2; ADR +_ TEMP*2
  1511		END
  1512		ECNT(FN) -_ CNT-CFRAG
  1513		GETPK(CNT _ CFRAG)
  1514	  END ELSE DO       !DIRECT PACK
  1515		IF PFRAG THEN DO     !NOT AT BLOCK BOUNDARY
  1516		  GETPK(HOLD MIN EBUFSZ(FN)-PFRAG)
  1517		  INC PTR
  1518		END
  1519		DZAP; GETPK(CFRAG)
  1520	  END
  1521	END
  1522	
  1523	END
  1524		CNT _ 0     !READ ALL
  1525	HERE:	SETRWE(FN,ULAB); L.ONALT
  1526		IF CNT=HOLD THEN FNERR(EOFERR)
  1527		RETURN HOLD-CNT
  1528	
  1529	%GETPK (C)
  1530	
  1531	LOCAL PKEOF:, PKA, PKB
  1532	
  1533		SETRWE(FN,PKEOF)
  1534		PKA _ PKB _ 0; I _ 9
  1535		WHILE DEC C>=0 THEN DO
  1536		  TEMP _ R(FN)  !SO EOF EXIT BEFORE DSHL
  1537		  [PKA;PKB] _ [PKA;PKB] DSHL 8; PKB BOR_ TEMP
  1538		  IF DEC I=0 THEN DO
  1539		    ^ADR _ PKA <==0; ^INC ADR _ PKB <==0; INC ADR
  1540		    CNT -_ I _ 9
  1541		  END
  1542		END
  1543	PKEOF:	IF I<9 THEN DO
  1544		  CNT -_ 9-I
  1545		  [PKA;PKB] _ [PKA;PKB] DSHL I*8
  1546		  [I;TEMP] _ [BNOT 0; BNOT 0] DSHL I*8
  1547		  ^ADR _ ^ADR BAND BNOT I BOR PKA
  1548		  ^ADR _ ^INC ADR BAND BNOT TEMP BOR PKB
  1549		  INC ADR
  1550		END
  1551		IF C>=0 THEN GO HERE   !HIT EOF
  1552		SETRWE(FN,HERE)
  1553		RETURN
  1554	END GETPK
  1555	
  1556	%SZAP
  1557	! READ FULL WDS FROM PTR INTO BUFFER AT ADR UNTIL CNT<=ECNT(FN).
  1558	! UPDATE ADR AND COUNT.
  1559	
  1560		WHILE CNT>ECNT(FN) THEN DO
  1561		  IF ECNT(FN)#0 THEN DO
  1562		    MOVE I _ WPB(ECNT(FN)) FROM PTR TO ADR
  1563		    ADR +_ I; CNT -_ ECNT(FN) <== 0
  1564		  END
  1565		  PTR _ S.RBLK(FN)
  1566		END
  1567		RETURN
  1568	
  1569	END SZAP
  1570	
  1571	%DZAP
  1572	! READ BLOCKS DIRECTLY FROM FN INTO BUFFER AT ADR
  1573	! STARTING AT BLOCK:  PTR
  1574	! NO. OF BLOCKS:  DETERMINE FROM REMAINING ELEMENT COUNT, CNT,
  1575	! BUT DO NOT READ PAST PENULTIMATE BLOCK.
  1576	! SET CFRAG TO ELEMENT FRAGGLE BEYOND LAST BLOCK READ.
  1577	
  1578		  [TEMP;CFRAG] _ CNT DIVMOD EBUFSZ(FN)
  1579		  EXU(UGFCD,FN,@I)
  1580		  IF TEMP > I_TEMP MIN RH(@I)-PTR THEN DO  !EOF
  1581		    TEMP _ I; CFRAG _ EBUFSZ(FN)
  1582		  END
  1583		  IF TEMP >0 THEN DO
  1584		    FOR J _ PTR TO PTR+TEMP-1 DO        !WRITE OUT IF DIRTY
  1585		      FOR I _ 0 TO NBUFS-1 DO
  1586		        IF FN.ID(I)=FN AND BLK.ID(I)=J AND DIRTY(I) THEN DO
  1587		          CLEAN(I)
  1588		        END
  1589		      END
  1590		    END
  1591		    RBLK(FN,TEMP,ADR,PTR); ADR +_ TEMP*BUFSZ
  1592		    CNT -_ I_TEMP*EBUFSZ(FN)
  1593		    MXACP(FN) _ MXACP(FN) MAX SETCP(FN,DCP(FN)+I)
  1594		  END
  1595		RETURN
  1596	END DZAP
  1597	
  1598	END RB
  1599	
  1600	END R
  1601	
  1602	
  1603	%GETLINE (FN)
  1604	
  1605	! READS A LINE FROM FN AND, IF FN IS TEL:
  1606	!  STORES LINE IN NEW (IMAGE) BUFFER.  HANDLES OVERFLOW LOCALLY BY
  1607	!  REQUESTING NEW LINE.  PERFORMS EDITING SPECIFIED BY CONTROL
  1608	!  CHARACTERS, WITH OLD LINE BEING LINE PASSED IN NEW BUFFER
  1609	!  FOLLOWED BY EOLIT.  ECHO CR AFTER LF.
  1610	!  TERMCH - END OF LINE CHAR IN ADDITION TO CARRET (EOLIT IF NONE))
  1611	!  %PROMPT - PRINTS PROMPT CHARACTERS
  1612	! IF FN IS NOT TEL:
  1613	!  IGNORES EOLITS.  STORES LINE IN OLD (FREE) BUFFER. IGNORES ANY
  1614	!  CHARS AT FILE END NOT FOLLOWED BY CARRET.
  1615	!  ERRORS: EOFERR, LNGERR (LINE TOO LONG), ABNERR.
  1616	!  WHEN EOFERR OCCURS, IF OBP#OBPI, CHARS LIE BETWEEN LAST CR
  1617	!  AND EOF, ELSE EOF FOLLOWS CR IMMEDIATELY.
  1618	!
  1619	! IN EITHER CASE, LINE IS STORED WITH TERMINATOR AND EOLIT AT END
  1620	! AND PTR TO 1 BEFORE FIRST CHAR IS RETURNED.
  1621	! GLOBAL GLCNT CONTAINS NO. OF CHARS STORED (EXCLUDING EOLIT).
  1622	!
  1623	! LF-CR HANDLING IS MACHINE DEPENDENT:
  1624	!  FILE INPUT: CR LF TERMINATES LINES, TRANSLATES TO CR EOLIT.
  1625	!              OTHERWISE, CR AND LF ARE NOT SPECIAL.
  1626	!  TERMINAL INPUT: CR IS ALWAYS FOLLOWED BY LF BY THE SYSTEM. IT TERMINATES
  1627	!                  THE LINE, TRANSLATES TO CR EOLIT.
  1628	!                  CR IS ECHOED AFTER LF IS RECEIVED.
  1629	
  1630	LOCAL OBP              !CURRENT OLD LINE PTR
  1631	LOCAL OBPB, NBPB       !NCHV IS 1ST CHAR OF LINE OR INSERT
  1632	LOCAL OBPLE            !END OF OLD LINE (NCHV IS EOLIT)
  1633	LOCAL OBPE             !LIMIT TO OBP; INITIALLY OBPLE; MOVES PAST
  1634	                       !LINE END WITH OBP WHEN CHARS ARE STORED IN NEW
  1635	
  1636	LOCAL %PNB, %ECHK, %GETTAB, %NLPOS, %NXCH
  1637	LOCAL AFG, E.ON, CHAR, POS, TEMP, J, HOLD
  1638	LOCAL DELFG, EXCFG, SAVLOC, ALTFX:, SAVDEST
  1639	
  1640	DEF NBCHKB AS IF NBP=NBPB THEN GO RING
  1641	DEF OB.END AS OBP=OBPE
  1642	
  1643	!ADVANCE 1 CHAR IN OLD
  1644	DEF FORW.OB AS [IF OB.END THEN NCHV OBPE; NCHV OBP]
  1645	
  1646	!BACKSPACE 1 CHAR IN OLD
  1647	DEF BACK.OB BY DO
  1648	  IF OBP=OBPB THEN GO RING
  1649	  IF OB.END#OBPLE THEN PCHV OBPE; PCHV OBP
  1650	END
  1651	ENDM BACK.OB
  1652	
  1653	!COPY 1 CHAR FROM OLD TO NEW & PRINT IT. EXIT IF TERMINATOR.
  1654	DEF COPRNX AS IF TERM(PUTC(PNB(NCHV OBP))) THEN GO XIT
  1655	
  1656	         IF FN#TEL THEN DO
  1657	           OBP _ OBPI; GLCNT _ 0; CHAR _ NXCH
  1658	           WHILE INC GLCNT<=LLEN THEN DO
  1659		     IF NCHV OBP _ CHAR =CARRET THEN DO
  1660		       EIF NXCH#LNFEED THEN CHAR _ TEMP  !FROM NXCH
  1661		       ELSE DO
  1662	                  NCHV OBP _ EOLIT
  1663	                  IF (FN=CFN) THEN DO
  1664	                     IF (COM.ECHO.DEST BAND TO.TOUT) AND TOUT.FILE THEN DO
  1665	                        TEMP _ TT.DEST(TO.TOUT)
  1666	                        PROMPT   ! PUTS PROMPT TO SAME DEST AS COM ECHO.
  1667	                        F.P.PRINT(TOUT.FILE,OBPI)
  1668	                        TT.DEST(TEMP)
  1669	                     END
  1670	                     IF (COM.ECHO.DEST BAND TO.TERM) THEN DO
  1671	                        TEMP _ TT.DEST(TO.TERM)
  1672	                        PROMPT
  1673	                        PRINT(FREE)
  1674	                        TT.DEST(TEMP)
  1675	                     END
  1676	                  END
  1677	                  RETURN OBPI
  1678	               END
  1679		     END ELSE CHAR _ NXCH
  1680	           END
  1681	! OVERFLOW ON FILE LINE AT CHAR
  1682	           CHV OBP _ CARRET; NCHV OBP _ EOLIT
  1683	           LOOP DO
  1684		     IF CHAR=CARRET THEN DO
  1685		       WHILE NXCH#LNFEED; CHAR _ TEMP
  1686		     END ELSE CHAR _ NXCH
  1687	           END
  1688	           FNERR(LNGERR)
  1689	         END
  1690	
  1691	! TERMINAL INPUT
  1692	         SET.CTRL
  1693	         SAVLOC _ ALTLOC
  1694	         AFG _ E.ON _ NO
  1695	
  1696	RSTRT:   OBP _ OBPB _ OBPE _ OBPI
  1697	         HOLD _ NBP _ NBPB _ NBPI
  1698	
  1699	!  MOVE NEW TO OLD & CLEAR NEW
  1700	         WHILE NCHV OBPE_NCHV HOLD #EOLIT THEN DO
  1701	           IF HOLD=NBPE THEN HALT     !BAD IMAGE LINE
  1702	         END
  1703	         PCHV OBPE; OBPLE _ OBPE
  1704	         ALTLOC _ ALTFX
  1705	         SAV.DEST _ TT.DEST(TO.TERM)
  1706	PCGET:   MOVE GLBSZ FROM ALL EOLITWD TO IMAGE
  1707	
  1708	         PROMPT
  1709	!  GET A CHARACTER. ASSUME LF FOLLOWS CR. IF IN ACTRL/WCTRL MODE,
  1710	!  MUST BREAK ON ALL SO CAN PRINT BACK SLASH IF NEC.
  1711	!  IGNORE RUBOUT.
  1712	CGET:	EIF AFG=NO THEN DO
  1713		  WHILE CHAR_GET=RUBOUT THEN NULL
  1714		  EIF CHAR=CARRET THEN GET
  1715		  FIF CHAR=LNFEED THEN PUTX(CARRET)
  1716		END
  1717		ELSE DO
  1718		  OFF.ECHO; WHILE CHAR _ GET.BRK=RUBOUT THEN NULL; ON.ECHO
  1719		  IF ACTRL#CHAR#WCTRL THEN DO
  1720		    PUT($\); AFG _ NO
  1721		    EIF PUTX(CHAR)=CARRET THEN GET
  1722		    FIF CHAR=LNFEED THEN PUTX(CARRET)
  1723		  END
  1724		END
  1725		 IF TERM(CHAR) THEN [PNB(CHAR); GO XIT]
  1726	         IF CTRLCH(CHAR) THEN GO CTREXU
  1727	CSTOR:   PNB(CHAR); IF NOT E.ON THEN FORW.OB
  1728	         GO CGET
  1729	
  1730	PCRXIT:  PUT(PNB(CARRET))  !STORE & PRINT CR
  1731	XIT:     PNB(EOLIT)        !STORE EOLIT
  1732	         L.OFFALT
  1733	         ALTLOC _ SAVLOC
  1734	         TT.DEST(SAV.DEST)
  1735	         UNSET.CTRL
  1736	         L.ONALT
  1737	         CHPT(HOLD,GLCNT) _ NBP
  1738	         GLCNT +_ (HOLD-IMAGE)*CPW  !EXCLUDE EOLIT FROM COUNT
  1739	         IF (TERM.ECHO.P) AND (TOUT.FILE) THEN DO
  1740	            TEMP _ TT.DEST(TO.TOUT)
  1741	            PROMPT
  1742	            TT.DEST(TEMP)
  1743	            F.P.PRINT(TOUT.FILE,NBPI)
  1744	         END
  1745	         RETURN NBPI
  1746	
  1747	
  1748	!  ALT MODE TYPED.  MOVE OLD BACK TO NEW
  1749	ALTFX:   L.OFFALT
  1750	         IF (TERM.ECHO.P) AND (TOUT.FILE) THEN DO
  1751	            PNB(CARRET)
  1752	            PNB(EOLIT)
  1753	            F.P.MSG(TOUT.FILE,NBPI)
  1754	         END
  1755	         MOVE GLBSZ FROM FREE TO IMAGE
  1756	         ALTLOC _ SAVLOC
  1757	         TT.DEST(SAV.DEST)
  1758	         UNSET.CTRL
  1759	         L.ONALT; GO ^ALTLOC
  1760	
  1761	
  1762	!  EXECUTE CONTROL CHARACTER
  1763	CTREXU:  IF CHAR>ZCTRL THEN GO RING
  1764	         DO CHAR OF ACTRL:ZCTRL
  1765	
  1766	!  CHANGE INSERT MODE; PRINT OPEN OR CLOSE ANGLE BRACKET
  1767	ECTRL:   IF NOT ECHK THEN DO
  1768	           E.ON _ YES; PUT($<)
  1769	           NBPB _ NBP; OBPB _ OBP
  1770	         END
  1771	
  1772	!  BACKSPACE OLD & NEW 1 CHAR; PRINT BACK ARROW
  1773	NCTRL:   IF NOT E.ON THEN BACK.OB
  1774	         NBCHKB; PCHV NBP; PUT($_)
  1775	
  1776	!  BACKSPACE NEW 1 CHAR. PRINT CHAR PRECEDED BY BACK SLASH IF
  1777	!  1ST ACTRL/WCTRL.
  1778	ACTRL:   NBCHKB; IF NO=AFG<==YES THEN PUT($\)
  1779	         PUTC(CHV NBP); PCHV NBP
  1780	
  1781	!  BACKSPACE NEW TO LAST SPACE BEFORE LAST NON-SPACE
  1782	!  PRINT SAME AS WOULD ACTRLS.
  1783	WCTRL:   NBCHKB; IF NO=AFG<==YES THEN PUT($\)
  1784		LOOP [I_PUTC(CHV NBP); PCHV NBP; WHILE I=$  AND NBP#NBPB]
  1785		WHILE NBP#NBPB AND I_CHV NBP#$  THEN [PUTC(I); PCHV NBP]
  1786	
  1787	!  RESTART OLD & NEW AT BEGINNING OF LINE OR INSERT
  1788	!  PRINT UP ARROW & CR
  1789	QCTRL:   NBCHKB; NBP _ NBPB; OBP _ OBPB; PUT($^)
  1790	         IF NOT E.ON THEN [PUT(CARRET); GO PCGET]
  1791	
  1792	!  STORE BLANKS UP TO NEXT TAB
  1793	ICTRL:   REPEAT GETTAB DO
  1794	           PUT(PNB($ ))
  1795	           IF NOT E.ON THEN FORW.OB
  1796	         END
  1797	
  1798	!  COPY OLD TO NEW UP TO NEXT TAB STOP OR TAB CHAR, WHICHEVER COMES FIRST,
  1799	!  PRINTING CHARS COPIED.
  1800	!  IF HIT TERMINATOR OR END OF OLD, STORE BLANKS UP TO TAB.
  1801	UCTRL:   ECHK
  1802	         REPEAT GETTAB DO
  1803	           IF OB.END THEN DO
  1804	             PUT(PNB($ )); NCHV OBPE; NCHV OBP
  1805	           END ELSE DO
  1806	             IF TERM(CHAR _ NCHV OBP) THEN CHAR _ $ 
  1807	             IF PUTC(PNB(CHAR))=ICTRL THEN GO CGET
  1808	           END
  1809	         END
  1810	
  1811	!  COPY 1 CHAR FROM OLD TO NEW & PRINT
  1812	CCTRL:   ECHK; IF OB.END THEN GO RING; COPRNX
  1813	
  1814	!  COPY REST OF OLD TO NEW, PRINTING. ADD CR IF NO TERMINATOR.
  1815	DCTRL:   ECHK
  1816	         WHILE NOT OB.END THEN COPRNX
  1817	         GO PCRXIT   !HERE IF NO TERMINATOR
  1818	
  1819	!  COPY REST OF OLD TO NEW, PRINTING ONLY TERMINATOR (ADD CR IF NONE)
  1820	FCTRL:   ECHK
  1821	         WHILE NOT OB.END THEN DO
  1822	           IF TERM(PNB(I_NCHV OBP)) THEN [PUTC(I); GO XIT]
  1823	         END
  1824	         GO PCRXIT   !HERE IF NO TERMINATOR
  1825	
  1826	!  COPY OLD TO NEW UP TO BUT NOT INCLUDING TERMINATOR 
  1827	!  (UP TO LINE END IF NO TERMINATOR)
  1828	!  IF H, ALSO PRINT CHARS; IF L, PRINT ONLY +
  1829	HCTRL: LCTRL: &
  1830	         ECHK; IF OB.END THEN GO RING
  1831	         IF TERM(I_NCHV OBP) THEN [PCHV OBP; GO RING]
  1832	         HOLD _ NBP
  1833	HCTA:    PNB(I)
  1834	         IF NOT OB.END THEN &
  1835	           IF TERM(I_NCHV OBP) THEN PCHV OBP ELSE GO HCTA
  1836	         IF CHAR=LCTRL THEN PUT($+) ELSE GO RCTB
  1837	
  1838	!  COPY OLD TO NEW UP TO BUT NOT INCLUDING NEXT INPUT CHAR
  1839	OCTRL:   DELFG _ NO; EXCFG _ YES; GO CHMTCH
  1840	
  1841	!  COPY OLD TO NEW UP TO & INCLUDING NEXT INPUT CHAR
  1842	ZCTRL:   DELFG _ EXCFG _ NO; GO CHMTCH
  1843	
  1844	!  DELETE FROM OLD UP TO BUT NOT INCLUDING NEXT INPUT CHAR
  1845	PCTRL:   DELFG _ EXCFG _ YES; GO CHMTCH
  1846	
  1847	!  DELETE FROM OLD UP TO & INCLUDING NEXT INPUT CHAR
  1848	XCTRL:   DELFG _ YES; EXCFG _ NO
  1849	
  1850	!  MATCH NEXT INPUT CHAR IN OLD LINE & PROCESS AS FOLLOWS:
  1851	!   DELFG - YES IF DELETE, NO IF COPY, CHARS PASSED.
  1852	!   EXCFG - YES IF EXCLUDE, NO IF INCLUDE, CHAR MATCHED.
  1853	CHMTCH:  ECHK
  1854	         OFF.ECHO; IF CHAR _ GET.BRK =CARRET THEN GET.BRK   !BREAK ON THIS CHAR
  1855	         ON.ECHO; HOLD _ OBP
  1856	         IF EXCFG THEN IF OB.END THEN GO RING ELSE NCHV HOLD
  1857	         LOOP DO
  1858	           IF HOLD=OBPE THEN GO RING
  1859	           WHILE NCHV HOLD#CHAR
  1860	         END
  1861	         IF EXCFG THEN PCHV HOLD
  1862	         WHILE OBP#HOLD THEN IF DELFG THEN [NCHV OBP; PUT($%)] ELSE &
  1863	          COPRNX
  1864	
  1865	!  DELETE 1 CHAR FROM OLD. IF S, PRINT %; IF K, PRINT CHAR.
  1866	KCTRL: &
  1867	SCTRL:   ECHK; IF OB.END THEN GO RING; NCHV OBP
  1868	         PUTC(IF CHAR=SCTRL THEN $% ELSE CHV OBP)
  1869	
  1870	!  PRINT REST OF OLD (INCLUDING TERMINATOR) & CURRENT NEW
  1871	!  IF NO MORE OLD LINE OR IF TERMINATOR ISN'T CR, PRINT CR
  1872	RCTRL:   ECHK; PUTX(LNFEED)
  1873	RCTA:    HOLD _ OBP; WHILE HOLD#OBPE THEN PUTC(NCHV HOLD)
  1874	         IF CHV(HOLD)#CARRET THEN PUT(CARRET)
  1875	         HOLD _ NBPI
  1876	RCTB:    WHILE HOLD#NBP THEN PUTC(NCHV HOLD)
  1877	
  1878	!  SAME AS RCTRL EXCEPT OLD & NEW ARE LINED UP
  1879	!  NOTE: CTRL CHARS WILL SCREW THIS UP.
  1880	TCTRL:   ECHK; PUT(CARRET); REPEAT NLPOS-1 PUT($ ); GO RCTA
  1881	
  1882	!  DO FCTRL ACTION, THEN
  1883	!  MAKE NEW LINE OLD LINE; PRINT CR
  1884	YCTRL:   ECHK
  1885	         WHILE NOT OB.END THEN DO
  1886	           IF TERM(PNB(I_NCHV OBP)) THEN [PUTC(I); GO Y1]
  1887	         END
  1888	         PUT(PNB(CARRET))
  1889	Y1:      PNB(EOLIT); GO RSTRT
  1890	
  1891	!  STORE CHAR
  1892	GCTRL: MCTRL: JCTRL:   GO CSTOR
  1893	
  1894	!  STORE NEXT INPUT CHAR; TERMINATES IF TERM CHAR
  1895	VCTRL:   OFF.ECHO; CHAR _ GET.BRK; ON.ECHO; PUTC(CHAR); GO CSTOR
  1896	
  1897	!  ILLEGAL CONTROL CHARACTERS
  1898	BCTRL: &
  1899	RING:    PUTX(BELL)
  1900	
  1901	         END
  1902	
  1903	         GO CGET
  1904	
  1905	%ECHK
  1906	!  IF IN ECTRL INSERT MODE, TURNS OFF MODE AND PRINTS >,
  1907	!  RETURNING YES; OTHERWISE, RETURNS NO.
  1908	
  1909	IF E.ON THEN [PUT($>); NBPB _ NBPI; OBPB _ OBPI]
  1910	RETURN E.ON<==NO
  1911	
  1912	END ECHK
  1913	
  1914	%GETTAB
  1915	!  RETURNS NUMBER OF POSITIONS BEFORE NEXT TAB
  1916	!  TABS ARE IN ARRAY TAB, WHOSE 0TH ELEMENT = NO. OF TABS
  1917	
  1918	POS _ NLPOS-OFF; I _ 0
  1919	WHILE INC I<=TAB(0) THEN DO
  1920	  IF TAB(I)>POS THEN RETURN TAB(I)-POS
  1921	END
  1922	GO RING
  1923	
  1924	END GETTAB
  1925	
  1926	%NLPOS
  1927	!  RETURNS WHAT TERMINAL POSITION WOULD BE IF NEW LINE WERE PRINTED
  1928	!  (MORE OR LESS) USING PUT.
  1929	
  1930	TEMP _ NBPI; POS _ 1
  1931	WHILE TEMP#NBP THEN DO
  1932	  EIF I_NCHV TEMP=LNFEED THEN POS _ 1
  1933	  FIF PRCHAR(I) THEN INC POS
  1934	END
  1935	RETURN POS
  1936	
  1937	END NLPOS
  1938	
  1939	
  1940	%PNB (CHAR)
  1941	! PUTS CHAR INTO NEW LINE BUFFER. CALLED BY USER
  1942	! TO SET EDIT IMAGE FOR NEXT GETLINE. CHECKS FOR OVERFLOW.
  1943	! RETURNS CHAR.
  1944	
  1945	IF NBP#NBPE THEN RETURN NCHV NBP_CHAR
  1946	CHV(NBP) _ EOLIT; PCHV NBP _ CARRET   !TRUNCATE
  1947	E.CHK; CLIBUF; MSG('$LINE TOO LONG. TRUNCATED LINE AVAILABLE FOR EDIT.$')
  1948	GO RSTRT
  1949	
  1950	END PNB
  1951	
  1952	
  1953	%NXCH
  1954	  WHILE TEMP _ R(FN) =EOLIT THEN NULL; RETURN TEMP
  1955	END NXCH
  1956	
  1957	END GETLINE
  1958	
  1959	END INIT.R
  1960	
  1961	
  1962	
  1963	%W (FN,VAL)
  1964	
  1965	! WRITES SPECIFIED ELEMENT VALUE AT CURSOR POSITION ON FILE FN.
  1966	! CHAR OUTPUT TO TERMINAL IF FN IS TEL.
  1967	! RETURNS VALUE WRITTEN.
  1968	!
  1969	! MACHINE DEPENDENCY: CR/LF HANDLING.  LF IS WRITTEN AFTER CR
  1970	
  1971	! WLAB(FN) IS  WTEL IF FN IS TEL
  1972	!              W.ERR IF FN IS AN INPUT FILE (CAN'T WRITE)
  1973	
  1974	!              IF DIRECT MODE:
  1975	!              WINIT IF THIS IS 1ST ACCESS TO FN AFTER SETCP ON FN
  1976	!              WSET IF HAVE READ BUT NOT WRITTEN SINCE SETCP ON FN
  1977	!              OTHERWISE, IS ADDRESS OF CORRESPONDING WRITE ROUTINE
  1978	
  1979	!              IF SEQUEN MODE:
  1980	!              W.ERR IF INPUT FILE
  1981	!              OTHERWISE, ADDRESS OF CORRESPONDING WRITE ROUTINE
  1982	
  1983	LOCAL HOLD, CP.TO.EOF, TEMP
  1984	
  1985	         GO ^YLAB(FN)
  1986	
  1987	YTEL:    IF TERM.DEST BAND TO.TERM THEN PUTTY(VAL)
  1988	         IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN GO ^YLAB(FN _ TOUT.FILE)
  1989	         RETURN VAL
  1990	
  1991	YCHAR:   IF VAL=CARRET THEN DO
  1992	           HOLD _ RETURN; WX(FN,CARRET); WX(FN,LNFEED)
  1993	           RETURN _ HOLD; RETURN CARRET
  1994	         END
  1995	
  1996	%%WX (FN, VAL)
  1997	
  1998	WXLAB:   GO ^WLAB(FN)
  1999	
  2000	WWD:     IF DEC ECNT(FN)>=0 THEN RETURN ^INC EPTR(FN) _ VAL
  2001	         GO NXBLK
  2002	
  2003	WPK:     IF DEC ECNT(FN)>=0 THEN DO
  2004	           IF DEC SUBCNT(FN)<0 THEN [EPTR(FN) +_2; SUBCNT(FN)_8]
  2005	           [PKA;PKB] _ [^EPTR(FN);^(EPTR(FN)+1)] DROTR SUBCNT(FN)*8
  2006	           [^EPTR(FN);^(EPTR(FN)+1)] _ [PKA;PKB BAND BNOT &
  2007	             OCT 377 BOR VAL BAND_ OCT 377] DROTL SUBCNT(FN)*8
  2008	           RETURN VAL
  2009	         END
  2010	         GO NXBLK
  2011	
  2012	WCH:     IF DEC ECNT(FN)>=0 THEN RETURN NCHV EPTR(FN) _ VAL
  2013	
  2014	NXBLK:   IF MODE(FN)=SEQUEN THEN [S.WBLK(FN); GO ^WLAB(FN)]
  2015	         INC ECNT(FN)    !FOR %CP
  2016	WINIT:   L.OFFALT
  2017	         IF CP.TO.EOF _ (TEMP _ DSIZE(FN)) - DCP(FN) <0 AND ORG(FN)#WORD THEN DO
  2018		   !BLANK FILL PAST EOF (UGHLY)
  2019		   HOLD _ RETURN
  2020		   DSETCP(FN,TEMP); REPEAT -CP.TO.EOF W(FN,$ )
  2021		   RETURN _ HOLD
  2022		 END
  2023	         GETCHK(FN)
  2024	         ! IF PAST EOF, SPECIAL CASE FOR %R
  2025	         RLAB(FN) _ IF ECNT(FN)>CP.TO.EOF THEN &
  2026	           RINIT ELSE RADR(ORGIND(FN))
  2027	         L.ONALT
  2028	
  2029	WSET:    DIRTY(CPBUF(FN)) _ YES
  2030	         GO ^WLAB(FN) _ WADR(ORGIND(FN))
  2031	
  2032	WTEL:    IF TERM.DEST BAND TO.TERM THEN PUTTYX(VAL)
  2033	         IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN GO ^WLAB(FN _ TOUT.FILE)
  2034	         RETURN VAL
  2035	
  2036	W.ERR:   FNERR(FMDERR)
  2037	
  2038	
  2039	%PLNW (FN, ADR, WCNT)
  2040	
  2041	! MACHINE DEPENDENT.  WRITE SPECIAL FORMAT LINE NO. AT ADR
  2042	! (WCNT WDS) ON FILE FN AFTER WRITING EOLITS TO BEGINNING OF
  2043	! NEXT WORD.  FOR CHARACTER ORGANIZED FILES ONLY.
  2044	
  2045	LOCAL PTR, I, J
  2046	
  2047	  REPEAT (CPW-(CP(FN) MOD CPW)) MOD CPW W(FN,EOLIT)
  2048	  PTR _ CHPT(ADR,-1)
  2049	  REPEAT WCNT DO
  2050	    REPEAT CPW W(FN,NCHV PTR)
  2051	    CHPT(I,J) _ EPTR(FN)
  2052	    ^I BOR_ 1    !BIT 35
  2053	  END
  2054	  W(FN,ICTRL); RETURN
  2055	
  2056	END PLNW
  2057	
  2058	END W
  2059	
  2060	
  2061	%WB (FN, CNT, ADR)
  2062	
  2063	DEF PUTCH(C) AS TEMP _ CHPT(ADR,-1); REPEAT C WX(FN,NCHV TEMP)
  2064	DEF PUTWD(C) AS REPEAT C [W(FN,^ADR); INC ADR]
  2065	LOCAL %PUTPK
  2066	
  2067	LOCAL HOLD, TEMP, CFRAG, PFRAG, PTR
  2068	LOCAL %SZAP, %DZAP, I
  2069	
  2070	IF WLAB(FN)=W.ERR THEN FNERR(FMDERR)
  2071	IF FN=TEL THEN FNERR(TELERR)
  2072	IF HOLD _ CNT <0 THEN FNERR(ARGERR)
  2073	IF HOLD=0 THEN RETURN
  2074	L.OFFALT
  2075	[PTR;PFRAG] _ CP(FN) DIVMOD EBUFSZ(FN); INC PTR  !BLK NO & ELMT DISPL
  2076	
  2077	DO ORGIND(FN) OF ORGINDLIM
  2078	
  2079	1:       !CHARACTER! &
  2080	  IF PFRAG MOD CPW THEN DO    !CP NOT AT WORD BOUNDARY
  2081	    PUTCH(CNT)
  2082	  END ELSE DO    !CP AT WORD BOUNDARY
  2083	    IF MODE(FN)=SEQUEN THEN DO       !SEQUEN CHARACTER
  2084		CHPT(PTR,PFRAG) _ EPTR(FN); INC PTR
  2085		SZAP
  2086		ECNT(FN) -_ CNT
  2087		[CNT;CFRAG] _ CNT DIVMOD CPW
  2088		IF CNT#0 THEN MOVE CNT FROM ADR TO PTR
  2089		EPTR(FN) _ CHPT(PTR+CNT,-1); PTR _ CHPT(ADR+CNT,-1)
  2090		REPEAT CFRAG NCHV EPTR(FN) _ NCHV PTR
  2091	    END ELSE DO       !DIRECT CHARACTER
  2092		IF PFRAG THEN DO       !CP NOT AT BLOCK BOUNDARY
  2093		  PUTCH(I_CNT MIN BUFSZ*CPW-PFRAG); CNT -_ I
  2094		  CHPT(ADR,PFRAG) _ TEMP     !PFRAG IS A DUMMY
  2095		  INC ADR
  2096		  INC PTR
  2097		END
  2098		DZAP; PUTCH(CFRAG)
  2099	    END
  2100	  END
  2101	
  2102	0:       !WORD! &
  2103	  IF MODE(FN)=SEQUEN THEN DO          !SEQUEN WORD
  2104		PTR _ 1+EPTR(FN)
  2105		SZAP
  2106		IF CNT#0 THEN DO
  2107		  MOVE CNT FROM ADR TO PTR; EPTR(FN) +_ CNT
  2108		  ECNT(FN) -_ CNT
  2109		END
  2110	  END ELSE DO          !DIRECT WORD
  2111		IF PFRAG THEN DO    !CP NOT AT BLOCK BOUNDARY
  2112		  PUTWD(I_CNT MIN BUFSZ-PFRAG); CNT -_ I
  2113		  INC PTR
  2114		END
  2115		DZAP; PUTWD(CFRAG)
  2116	  END
  2117	
  2118	2:       !PACK! &
  2119	IF SUBCNT(FN)>0 THEN DO    !CP NOT AT WORD BOUNDARY
  2120		PUTPK(HOLD)
  2121	END ELSE DO
  2122	  IF MODE(FN)=SEQUEN THEN DO    !SEQUEN PACK
  2123		PTR _ 2+EPTR(FN)
  2124		SZAP
  2125		[TEMP;CFRAG] _ CNT DIVMOD 9
  2126		IF TEMP#0 THEN DO
  2127		  MOVE TEMP*2 FROM ADR TO PTR
  2128		  EPTR(FN) +_ TEMP*2; ADR +_ TEMP*2
  2129		END
  2130		ECNT(FN) -_ CNT-CFRAG
  2131		PUTPK(CFRAG)
  2132	  END ELSE DO      !DIRECT PACK
  2133		IF PFRAG THEN DO    !NOT AT BLOCK BOUNDARY
  2134		  CNT -_ PUTPK(HOLD MIN EBUFSZ(FN)-PFRAG)
  2135		  INC PTR
  2136		END
  2137		DZAP; PUTPK(CFRAG)
  2138	  END
  2139	END
  2140	
  2141	END
  2142	L.ONALT
  2143	RETURN HOLD
  2144	
  2145	%PUTPK (C)
  2146	LOCAL PKA, PKB
  2147	
  2148		PKA _ ^ADR; PKB _ ^(ADR+1); I _ 9
  2149		REPEAT C DO
  2150		  [PKA;PKB] _ [PKA;PKB] DROTL 8
  2151		  W(FN,PKB BAND OCT 377)
  2152		  IF DEC I=0 THEN DO
  2153		    ADR +_ 2; PKA _ ^ADR; PKB _ ^(ADR+1); I _ 9
  2154		  END
  2155		END
  2156		RETURN C
  2157	END PUTPK
  2158	
  2159	%SZAP
  2160	! WRITE FULL WORDS FROM BUFFER AT ADR TO PTR UNTIL CNT<=ECNT(FN).
  2161	! UPDATE ADR AND CNT.
  2162	
  2163		WHILE CNT>ECNT(FN) THEN DO
  2164		  IF ECNT(FN)#0 THEN DO
  2165		    MOVE I_WPB(ECNT(FN)) FROM ADR TO PTR
  2166		    ADR +_ I; CNT -_ ECNT(FN) <==0
  2167		  END
  2168		  PTR _ S.WBLK(FN)
  2169		END
  2170		RETURN
  2171	END SZAP
  2172	
  2173	%DZAP
  2174	! WRITE BLOCKS DIRECTLY FROM BUFFER AT ADR TO FN
  2175	! STARTING AT BLOCK PTR.
  2176	! NO. OF BLOCKS: DETERMINE FROM REMAINING ELEMENT COUNT, CNT.
  2177	! SET CFRAG TO ELEMENT FRAGGLE BEYOND LAST BLOCK WRITTEN.
  2178	
  2179		  [CNT;CFRAG] _ CNT DIVMOD EBUFSZ(FN)
  2180		  IF CNT>0 THEN DO
  2181		    WBLK(FN,CNT*BUFSZ,ADR,PTR); ADR +_ CNT*BUFSZ
  2182		    MXACP(FN) _ MXACP(FN) MAX DSETCP(FN,DCP(FN)+CNT*EBUFSZ(FN))
  2183		    REPEAT CNT DO
  2184		      FOR I _ 0 TO NBUFS-1 DO
  2185		        IF FN.ID(I)=FN AND BLK.ID(I)=PTR THEN FN.ID(I)_-1
  2186		      END
  2187		      INC PTR
  2188		    END
  2189		  END
  2190		RETURN
  2191	END DZAP
  2192	
  2193	END WB
  2194	
  2195	
  2196	%GETCHK (FN)
  2197	
  2198	! CHECKS WHETHER BLOCK CONTAINING CP(FN) IS ALREADY IN A BUFFER.
  2199	! IF NOT, A BUFFER IS SELECTED INTO WHICH TO READ THE BLOCK (NXBUF
  2200	! INDICATES 1ST BUFFER TO EXAMINE); THE BLOCK IS READ & THE BUFFER
  2201	! SET CLEAN.  IN ANY CASE, GETCHK SETS THE ELEMENT POINTER & COUNT,
  2202	! (WHICH IS NO. OF ELEMENTS FROM CP TO END OF BLOCK)
  2203	! SETS CPBUF(FN) TO INDICATE BUFFER CONTAINING CP(FN), 
  2204	! RETURNS ADDRESS OF 1ST WORD OF BUFFER,
  2205	! AND RESETS NXBUF TO POINT TO 1ST BUFFER TO BE EXAMINED AT NEXT
  2206	! BUFFER SELECTION TIME.
  2207	
  2208	LOCAL %SETNXBUF
  2209	LOCAL DISPL, BLKNUM, HOLD
  2210	
  2211	         [BLKNUM;DISPL] _ DCP(FN) DIVMOD EBUFSZ(FN)
  2212	         INC BLKNUM          !FIRST BLOCK IS BLOCK NO. 1
  2213	         FOR I _ 0 TO NBUFS-1 &
  2214	          IF FN.ID(I)=FN AND BLK.ID(I)=BLKNUM THEN [NXBUF_I; GO GET1]
  2215	
  2216	!BLOCK NOT ALREADY IN BUFFER
  2217	         IF NOT RBLK(FN,1,BGNADR(SETNXBUF),BLKNUM) THEN DO
  2218	           MOVE BUFSZ FROM ALL 0 TO BGNADR(NXBUF)
  2219	         END
  2220	         FN.ID(NXBUF)_FN; BLK.ID(NXBUF)_BLKNUM; DIRTY(NXBUF) _ NO
  2221	GET1:    HOLD _ BGNADR(NXBUF)
  2222	         DO ORGIND(FN) OF ORGINDLIM
  2223	0:         EPTR(FN) _ HOLD+DISPL-1
  2224	1:         EPTR(FN) _ CHPT(HOLD,DISPL-1)
  2225	2:         [PKA;PKB] _ DISPL DIVMOD 9
  2226	           EPTR(FN) _ HOLD+2*PKA-2*[SUBCNT(FN)_(9-PKB) MOD 9=0]
  2227	         END
  2228	         ECNT(FN) _ EBUFSZ(FN)-DISPL
  2229	         CPBUF(FN) _ NXBUF <== (NXBUF+1) MOD NBUFS
  2230	         RETURN HOLD
  2231	
  2232	%SETNXBUF
  2233	! BEGINS EXAMINING BUFFERS AT NXBUF. RESETS NXBUF TO POINT
  2234	! TO BUFFER THAT FILE BLOCK IS TO BE READ INTO. RETURNS NXBUF.
  2235	! PRIORITY FOR SELECTION:
  2236	!  1) UNUSED BUFFER
  2237	!  2) CLEAN BUFFER NOT CPBUF FOR ITS FN.ID
  2238	!  3) DIRTY BUFFER NOT CPBUF FOR ITS FN.ID
  2239	!  4) CLEAN BUFFER (IS CPBUF)
  2240	!  5) NXBUF (IS DIRTY AND CPBUF)
  2241	! IF 3) OR 5), BLOCK CURRENTLY IN BUFFER IS WRITTEN OUT
  2242	! IF 4) OR 5), MUST RELINQUISH CPBUF WITH A DSETCP
  2243	
  2244	LOCAL LAB, CHK3:, CHK2:, CHK1:, CHK:
  2245	DEF IF.MORE AS IF INC I=NBUFS THEN I_0; WHILE I#NXBUF
  2246	DEF ACTIVE(I) AS I=CPBUF(FN.ID(I))
  2247	
  2248	         I _ NXBUF
  2249	         LOOP [IF FN.ID(I)<0 THEN GO OUT; IF.MORE]
  2250		LAB _ CHK3
  2251		LOOP DO
  2252		  GO ^LAB
  2253	CHK3:	  IF DIRTY(I) AND ACTIVE(I) THEN [HOLD _ I; LAB _ CHK2]
  2254	CHK2:	  IF NOT DIRTY(I) AND ACTIVE(I) THEN [HOLD _ I; LAB _ CHK1]
  2255	CHK1:	  IF DIRTY(I) AND NOT ACTIVE(I) THEN [HOLD _ I; LAB _ CHK]
  2256	CHK:	  IF NOT DIRTY(I) AND NOT ACTIVE(I) THEN [HOLD _ I; GO THRU]
  2257		  IF.MORE
  2258		END
  2259	THRU:	I _ HOLD
  2260		IF FN.ID(I)#FN THEN DSETCP(FN.ID(I),DCP(FN.ID(I)))
  2261		IF DIRTY(I) THEN CLEAN(I)
  2262	OUT:     RETURN NXBUF _ I
  2263	
  2264	END SETNXBUF
  2265	
  2266	END GETCHK
  2267	
  2268	
  2269	%RBLK (FN, NBLKS, ADR, BLKNO)
  2270	! MACHINE DEPENDENT.
  2271	! DIRECT BLOCK INPUT.
  2272	! READS NBLKS BLOCKS FROM BLKNO ON FN TO ADR.
  2273	! IF EOF HIT, RETURNS 0 ELSE RETURNS 1.
  2274	
  2275	LOCAL LIST(0:1)
  2276	LOCAL ERRCHK:,EOF:,OUTERR:
  2277	
  2278	         EXU(USICD, FN, BLKNO)   !POSITION AT BLKNUM
  2279	         LIST(0) _ [18,18] * [-BUFSZ*NBLKS, ADR-1]
  2280	         LIST(1) _ 0
  2281	         EXU(INCD, FN, LIST, ERRCHK); RETURN YES
  2282	ERRCHK:  EXU(STZCD, FN, OCT 740.000, EOF)
  2283	OUTERR:  ABNERR(FN)
  2284	
  2285	%%WBLK (FN, NWDS, ADR, BLKNO)
  2286	
  2287	! MACHINE DEPENDENT.  CALLED FROM %CLOSE, %SETNXBUF, %ERASE, %WB
  2288	! DIRECT BLOCK OUTPUT.
  2289	! WRITES OUT NWDS WORDS AT ADR ON FN AT BLKNO.
  2290	! IF BLKNO EXCEEDS FILE SIZE, INTERVENING BLOCKS ARE FILLED WITH
  2291	! ZEROES.
  2292	
  2293	         EXU(USOCD, FN, BLKNO)
  2294	         LIST(0) _ [18,18] * [-NWDS, ADR-1]
  2295	         LIST(1) _ 0
  2296	         EXU(OUTCD, FN, LIST, OUTERR)
  2297	EOF:     RETURN NO
  2298	
  2299	END RBLK
  2300	
  2301	
  2302	%S.RBLK (FN)
  2303	! MACHINE DEPENDENT.
  2304	! SEQUENTIAL BLOCK INPUT.
  2305	! ADVANCES TO NEXT BUFFER & READS IN NEXT BLOCK ON FN
  2306	! SETS EPTR(FN) & ECNT(FN) (LATTER APPROX. FOR NON-WORD FILES)
  2307	! INCREMENTS CP1(FN) BY ECNT(FN).
  2308	! RETURNS ADDRESS OF 1ST WD OF NEXT BUFFER.
  2309	
  2310	LOCAL ERRCHK:, EOF:, OUTERR:
  2311	
  2312	         L.OFFALT
  2313	         RH(CURBUF(FN)+1) _ BUFSZ
  2314	         EXU(INCD, FN, 0, ERRCHK)  !S.ECNT(FN) GETS CHAR CNT
  2315	         ECNT(FN) _ S.ECNT(FN)/CPW*EBUFSZ(FN)/BUFSZ
  2316	         GO BELOW
  2317	
  2318	ERRCHK:  EXU(STZCD, FN, OCT 740.000, EOF)
  2319	OUTERR:  ABNERR(FN)
  2320	EOF:     FNERR(EOFERR)
  2321	
  2322	%%S.WBLK (FN)
  2323	
  2324	! MACHINE DEPENDENT. CALLED FROM %CLOSE AND %W.
  2325	! SEQUENTIAL BLOCK OUTPUT.
  2326	! WRITES OUT BLOCK IN CURRENT BUFFER ON FN (NONE 1ST TIME THRU)
  2327	! & ADVANCES TO NEXT BUFFER, PREPARING IT FOR WRITING.
  2328	! SETS EPTR(FN) & ECNT(FN), INC'ING CP1(FN) BY THE LATTER.
  2329	! RETURNS ADDRESS OF 1ST WORD OF NEXT BUFFER.
  2330	
  2331	         L.OFFALT
  2332	         EXU(STSCD, FN, OCT 20)          !BIT 31 INDICATES WE HAVE
  2333	         RH(CURBUF(FN)+1) _ WPB(EBUFSZ(FN)-ECNT(FN))   !SET (EXACT) WORD COUNT
  2334	         EXU(OUTCD, FN, 0, OUTERR)
  2335	         ECNT(FN) _ EBUFSZ(FN)
  2336	BELOW:   DO ORGIND(FN) OF ORGINDLIM
  2337	0:         EPTR(FN) _ CURBUF(FN)+1
  2338	1:         EPTR(FN) _ S.EPTR(FN)
  2339	2:         EPTR(FN) _ CURBUF(FN); SUBCNT(FN) _ 0
  2340	         END
  2341	         CP1(FN) +_ ECNT(FN)
  2342	         L.ONALT
  2343	         RETURN CURBUF(FN)+2
  2344	
  2345	END S.RBLK
  2346	
  2347	
  2348	
  2349	%ERASE (FN, CPI, CPF)
  2350	
  2351	!  FN MAY NOT BE TEL OR A SEQUEN MODE OR INPUT TYPE FILE.
  2352	
  2353	! WRITES OUT ZEROES FROM POSITIONS CPI TO CPF ON FILE FN.
  2354	! PHYSICALLY TRUNCATES FILE IF POSSIBLE.
  2355	
  2356	! %W IS USED TO ERASE ANY PARTS OF (NOT ENTIRE) BLOCKS IN THE RANGE.
  2357	! TO ERASE THE 1ST ENTIRE BLOCK, IF ANY, A BUFFER IS SOUGHT
  2358	! (THRU %GETCHK), CLEARED & WRITTEN OUT (I.E., %W NOT USED).
  2359	! SUBSEQUENT ENTIRE BLOCKS ARE ERASED BY WRITING OUT THIS SAME CLEARED
  2360	! BUFFER.  TO ACHIEVE THIS, SUBSEQUENT CALLS TO %GETCHK ARE "FIXED"
  2361	! SO THAT IF THE BLOCK SOUGHT IS NOT ALREADY IN A BUFFER, THE BUFFER
  2362	! SELECTED IS THE ONE PREVIOUSLY CLEARED (ZBUF).  THE FIX IS TO MAKE
  2363	! ZBUF LOOK LIKE IT HOLDS THE BLOCK SOUGHT, BY INCREMENTING ITS 
  2364	! BLK.ID AND MAKING CERTAIN THAT NXBUF IS 1 PAST ZBUF, SO THAT
  2365	! ZBUF IS EXAMINED LAST AND CHOSEN IF THE BLOCK WASN'T IN ANOTHER
  2366	! BUFFER.
  2367	
  2368	! IF CPF EXCEEDS POSITION OF LAST ELEMENT (SIZE(FN)-1), IT IS SET
  2369	! TO THAT POSITION, AND ERASE LEAVES CURSOR AT CPI (NEW FILE END)
  2370	! & REDUCES MXACP AND OPNSZ TO CPI; ELSE
  2371	! CURSOR IS LEFT AT CPF+1.
  2372	
  2373	LOCAL CNT, DISPL, ZBUF, LAST, EVAL
  2374	LOCAL %TRUNCATE, CLR:
  2375	
  2376	         IF FTYP(FN)=INPUT THEN FNERR(FMDERR)
  2377	         IF CPF<0 THEN FNERR(ARGERR)
  2378	         SETCP(FN,CPI)     !ERROR IF SEQUEN OR <0
  2379	         IF CPF _ CPF MIN LAST _ (DSIZE(FN)-1)>=CPI THEN DO
  2380	
  2381		 EVAL _ IF ORG(FN)=WORD THEN 0 ELSE $ 
  2382	         IF DISPL _ CPI MOD EBUFSZ(FN) #0 THEN DO
  2383	           IF CNT _ EBUFSZ(FN)-(CPF-CPI+1+DISPL) >=0 THEN GO ZREST
  2384	
  2385	!CPI NOT AT BEGINNING & CPF PAST END
  2386	           LOOP[W(FN,EVAL); WHILE ECNT(FN)#0]
  2387	         END
  2388	
  2389	!CP(FN) AT BLOCK BEGINNING
  2390	         IF CNT _ EBUFSZ(FN)-(CPF-DCP(FN)+1) >0 THEN DO
  2391	
  2392	!CPI NOT AT BEGINNING OF BLOCK & CPF AT OR BEFORE END,
  2393	!OR CP(FN) AT BEGINNING & CPF BEFORE END.
  2394	!CNT IS NO. OF ELEMENTS PAST CPF
  2395	ZREST:     LOOP[W(FN,EVAL); WHILE ECNT(FN)#CNT]
  2396	         END ELSE DO
  2397	
  2398	!CP(FN) AT BEGINNING & CPF AT OR BEYOND END
  2399	           IF CPF=LAST THEN [TRUNCATE(DCP(FN)/EBUFSZ(FN),CLR); GO CHOP]
  2400	!SELECT BUFFER, CLEAR IT, WRITE IT OUT
  2401	CLR:       MOVE BUFSZ FROM ALL EVAL TO GETCHK(FN); ZBUF _ CPBUF(FN)
  2402	           LOOP DO
  2403	             WBUF(ZBUF); WHILE CNT#0
  2404	
  2405	!MORE TO GO. SET TO 1ST POSITION AFTER BLK JUST WRITTEN
  2406	             IF CNT _ EBUFSZ(FN)-(CPF-DSETCP(FN,BLK.ID(ZBUF)*EBUFSZ(FN))+1) >0 THEN GO ZREST
  2407	             INC BLK.ID(ZBUF); GETCHK(FN)
  2408	             IF CPBUF(FN)#ZBUF THEN !BLK ALREADY IN BUFFER! &
  2409	                    [FN.ID(CPBUF(FN))_-1; NXBUF _ (ZBUF+1) MOD NBUFS]
  2410	           END
  2411	         END
  2412	
  2413	         IF CPF<LAST THEN DO
  2414	           IF CNT=0 THEN DSETCP(FN,CPF+1)
  2415	         END ELSE DO
  2416	CHOP:      DSETCP(FN,CPI); MXACP(FN) _ OPNSZ(FN) _ SZFG(FN) _ CPI
  2417	         END
  2418	
  2419	         END
  2420	         RETURN
  2421	
  2422	%TRUNCATE (NBLKS, ERLAB:)
  2423	! MACHINE DEPENDENT
  2424	! TRUNCATE FILE FN TO NBLKS BLOCKS; GO TO ERLAB IF CAN'T
  2425	
  2426	LOCAL RNMOK:
  2427	
  2428	MOVE 4 FROM @MINFID(FN*4) TO @ARGCNT(FIDTBL)+1
  2429	ARGCNT(FIDTBL) _ 9; FIDTBL(LOCWPF+9) _ NBLKS
  2430	MOVE 4 FROM ALL 0 TO @ARGCNT(FIDTBL)+5
  2431	EXU(RNMCD, FN, FIDTBL+4, RNMOK ); GO ERLAB
  2432	RNMOK: ARGCNT(FIDTBL) _ MINARG
  2433	OPEN1
  2434	RETURN
  2435	
  2436	END TRUNCATE
  2437	
  2438	END ERASE
  2439	
  2440	
  2441	%TTYIO
  2442	
  2443	! REST OF TERMINAL AND TOUT I/O PROCEDURES
  2444	! IN THE SET OF PROCEDURES THAT PRINT CHARACTERS TO TEL ARE TWO GROUPS:
  2445	! ONE GROUP CONSISTS OF THE PRIMITIVE PROCEDURES THAT PRINT DIRECTLY TO THE
  2446	! TERMINAL (%MSG.TTY, %PRNTTC, %PRNTTY, %PUTTYC, %PUTTY, %PUTTYX);
  2447	! THE OTHERS PRINT TO A TOUT FILE IF IT EXISTS, ELSE TO THE
  2448	! TERMINAL (%MSG, %PRINTC, %PRINT, %PUTC, %PUT, %PUTX).
  2449	
  2450	LOCAL SPCNT              !NUMBER OF PENDING OUTPUT SPACES
  2451	LOCAL TEMP, TTY.P, TEMP1
  2452	
  2453	! INITIALIZATION
  2454	
  2455	SPCNT _ 0
  2456	EXTOUT(TEL)
  2457	EX.CFN(TEL)
  2458	TT.DEST(TO.TERM)
  2459	CF.ECHO(TO.NEITHER)
  2460	RETURN
  2461	
  2462	
  2463	%EXTOUT(FILNUM)
  2464	
  2465	! SETS TOUT OUTPUT TO FILE FILNUM. RETURNS CURRENT TOUT FILE NUMBER.
  2466	! (AN EXCHANGE)
  2467	
  2468	   RETURN TOUT.FILE <== FILNUM
  2469	
  2470	END EXTOUT
  2471	
  2472	
  2473	%EX.CFN(FILNUM)
  2474	
  2475	%%SET.CFN(FILNUM)   ! THE OLD NAME
  2476	
  2477	! SETS COMMAND INPUT FROM FILNUM. NO ERROR CHECKING IS DONE ON FILNUM TO SEE
  2478	! THAT IT IS OPEN. RETURNS CURRENT COMMANDS FILE NUMBER.
  2479	
  2480	   RETURN (CFN <== FILNUM)
  2481	
  2482	END EX.CFN
  2483	
  2484	
  2485	%TT.DEST(WHERE)
  2486	
  2487	! SETS DESTINATION OF TERMINAL OUTPUT. TO TERM, TOUT, BOTH, OR NEITHER.
  2488	! RETURNS OLD DESTINATION.
  2489	
  2490	   RETURN (TERM.DEST <== WHERE)
  2491	
  2492	END TT.DEST
  2493	
  2494	
  2495	%CF.ECHO(WHERE)
  2496	
  2497	! SETS DESTINATION OF COMMANDS FILE ECHO. TO TERM, TOUT, BOTH, OR NEITHER.
  2498	! RETURNS OLD DESTINATION.
  2499	
  2500	   RETURN (COM.ECHO.DEST <== WHERE)
  2501	
  2502	END CF.ECHO
  2503	
  2504	
  2505	%TT.ECHO(ON.P)
  2506	
  2507	! SETS ON/OFF STATE OF INPUT FROM TERMINAL ECHOING TO TOUT FILE.
  2508	! RETURNS OLD STATE VALUE.
  2509	
  2510	   RETURN (TERM.ECHO.P <== ON.P)
  2511	
  2512	END TT.ECHO
  2513	
  2514	
  2515	%CLIBUF
  2516	
  2517	! CLEAR INPUT BUFFER
  2518	
  2519	EXU(TTCD,OCT 11,0); RETURN
  2520	
  2521	END CLIBUF
  2522	
  2523	
  2524	%CLOBUF
  2525	
  2526	! CLEAR OUTPUT BUFFER
  2527	
  2528	EXU(TTCD,OCT 12,0); RETURN
  2529	
  2530	END CLOBUF
  2531	
  2532	
  2533	%TTYLEN
  2534	!  TERMINAL WIDTH
  2535	
  2536	^14_-1; EXU(CLICD,14,-OCT 16)   !GETTMC
  2537	RETURN (^14 BAND OCT 17740.000000) SHR 23
  2538	
  2539	END TTYLEN
  2540	
  2541	
  2542	%GET.BRK
  2543	
  2544	! READS A CHARACTER FROM THE TERMINAL & BREAKS ON IT,
  2545	
  2546	REPEAT SPCNT<==0 TTY_$ 
  2547	EXU(TTCD, 0, @I); GO GET1
  2548	
  2549	%%GET
  2550	
  2551	! READS A CHARACTER FROM THE TERMINAL & RETURNS IT.
  2552	! FIRST PRINTS ANY PENDING OUTPUT SPACES (SEE PUT & PUTX)
  2553	
  2554	         REPEAT SPCNT<==0 TTY_$ ; I _ TTY
  2555	GET1:    IF NOT(OCT 175# I #OCT 176) OR I=OCT 33 THEN GO ALT
  2556	         RETURN I
  2557	
  2558	END GET.BRK
  2559	
  2560	
  2561	%PUTTYX (CHAR)
  2562	
  2563	! PRINTS CHAR ON TERMINAL AND RETURNS CHAR.
  2564	! PRINTS SPACES ONLY IF PRINTING CHAR FOLLOWS.
  2565	! UNLIKE PUTTYX, PUTTY
  2566	!    PRINTS LF AFTER CR
  2567	!    PRINTS CR AFTER LF
  2568	
  2569	DEF INITPOS AS [PUT.CR; SPCNT_0]
  2570	
  2571	         EIF CHAR=CARRET THEN INITPOS
  2572	         ORIF CHAR=LNFEED THEN DO
  2573	           REPEAT SPCNT<==0 TTY _ $ ; PUT.LF
  2574	         END
  2575	         ELSE GO PUT1
  2576	         RETURN CHAR
  2577	
  2578	%%PUTTY (CHAR)
  2579	
  2580	         EIF ICTRL<=CHAR<=MCTRL THEN DO CHAR OF ICTRL:MCTRL
  2581	MCTRL:     INITPOS; PUT.LF
  2582	JCTRL:     PUT.LF; INITPOS
  2583	ICTRL: LCTRL:  TTY _ CHAR
  2584	KCTRL:     GO PUT2
  2585	         END
  2586	         ORIF CTRLCH(CHAR) THEN DO
  2587	PUT2:      TTY_$&; TTY_UNCTRL(CHAR)
  2588	         END
  2589	PUT1:    ORIF NOT PRCHAR(CHAR) THEN TTY_CHAR
  2590	         ELSE DO
  2591	           IF CHAR#$  THEN [WHILE DEC SPCNT>=0 THEN TTY_$ ; TTY_CHAR]
  2592	           INC SPCNT
  2593	         END
  2594	
  2595	         RETURN CHAR
  2596	
  2597	
  2598	END PUTTYX
  2599	
  2600	
  2601	%PUTX (CHAR)
  2602	
  2603	! PUTS CHAR, EXACTLY, TO TERM.DEST .
  2604	
  2605	   IF (TERM.DEST BAND TO.TERM) THEN PUTTYX(CHAR)
  2606	   IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN RETURN (WX(TOUT.FILE,CHAR))
  2607	   RETURN CHAR
  2608	
  2609	END PUTX
  2610	
  2611	
  2612	%PUT (CHAR)
  2613	
  2614	! PUTS TO TERM.DEST THE CHARACTER, PROPERLY TRANSLATED.
  2615	
  2616	   IF (TERM.DEST BAND TO.TERM) THEN PUTTY(CHAR)
  2617	   IF (TERM.DEST BAND TO.TOUT) AND TOUT.FILE THEN RETURN (W(TOUT.FILE,CHAR))
  2618	   RETURN CHAR
  2619	
  2620	END PUT
  2621	
  2622	
  2623	%PUTTYC (CHAR)
  2624	
  2625	! PRINTS CONTROL CHARACTERS (EXCEPT &I AND &L) AS '&''CHAR', TO TEL.
  2626	
  2627	   TTY.P _ YES
  2628	   GO PUTC.LOOP
  2629	
  2630	%%PUTC (CHAR)
  2631	
  2632	! PRINTS TO TERM.DEST.
  2633	
  2634	   TTY.P _ NO
  2635	
  2636	PUTC.LOOP:  IF ICTRL#CHAR#LCTRL THEN DO
  2637	                RETURN (IF TTY.P THEN PUTTY(CHAR) ELSE PUT(CHAR))
  2638	            END ELSE DO
  2639	                IF TTY.P THEN [PUTTY($&); RETURN (PUTTY(UNCTRL(CHAR)))]
  2640	                PUT($&); RETURN (PUT(UNCTRL(CHAR)))
  2641	            END
  2642	
  2643	END PUTTYC
  2644	
  2645	
  2646	
  2647	
  2648	%PRNTTY (ADR)
  2649	
  2650	! PRINTS STRING STARTING AT ADR TERMINATED BY EOLIT
  2651	
  2652	   LOCAL TEMP
  2653	
  2654	   TEMP _ TT.DEST(TEL)
  2655	   TT.DEST(TEMP <== F.P.PRINT(TEL,CHPT(ADR,-1)))
  2656	   RETURN TEMP
  2657	
  2658	%%PRINT (ADR)   ! PRINTS TO TERM.DEST
  2659	
  2660	   RETURN (F.P.PRINT(TEL,CHPT(ADR,-1)))
  2661	
  2662	
  2663	%F.P.PRINT(FILE,POINTER)  ! PRINT MESSAGE AT POINTER TO FILE
  2664	
  2665	   LOCAL CHAR
  2666	
  2667	   WHILE CHAR _ NCHV(POINTER) # EOLIT THEN W(FILE,CHAR)
  2668	   RETURN
  2669	
  2670	END F.P.PRINT
  2671	
  2672	
  2673	END PRNTTY
  2674	
  2675	
  2676	%PRNTTC (ADR)
  2677	
  2678	! PRINTS STRING AT ADR USING %PUTC
  2679	
  2680	   TTY.P _ YES
  2681	   GO PRNTC.LOOP
  2682	
  2683	%%PRINTC (ADR)
  2684	
  2685	! PRINTS TO TOUT
  2686	
  2687	   TTY.P _ NO
  2688	
  2689	PRNTC.LOOP:  &
  2690	TEMP _ CHPT(ADR,-1)
  2691	WHILE I_NCHV TEMP#EOLIT THEN [IF TTY.P THEN PUTTYC(I) ELSE PUTC(I)]
  2692	RETURN
  2693	
  2694	END PRNTTC
  2695	
  2696	
  2697	%MSG.TTY (ADR)
  2698	
  2699	! PRINTS STRING STARTING AT ADR TERMINATED BY EOLIT,
  2700	! IN WHICH $ DESIGNATES CR & \CHAR DESIGNATES CONTROL CHAR.
  2701	
  2702	   DEF CTRL(CHAR) AS (CHAR-$M+CARRET) ! MACHINE DEPENDENT BUT HANDLES IX AND X.
  2703	
  2704	
  2705	   TEMP _ TT.DEST(TEL); TT.DEST(TEMP <== F.P.MSG(TEL,CHPT(ADR,-1))); RETURN TEMP
  2706	
  2707	%%MSG (ADR)   ! PRINTS TO TERM.DEST
  2708	
  2709	   RETURN (F.P.MSG(TEL,CHPT(ADR,-1)))
  2710	
  2711	%F.P.MSG (FILE,POINTER)   ! PUT A MESSAGE TO A FILE GIVEN A POINTER.
  2712	                          ! CONVERTS '$' TO CARRET, '\X' TO CONTROL-X.
  2713	
  2714	   LOCAL C.P   ! PREDICATE FOR 'CONTROL CHARACTER IS SPECIFIED'.
  2715	   LOCAL C     ! THE CHARACTER.
  2716	
  2717	   C.P _ 0     ! CONTROL CHARACTER PREDICATE IS FALSE.
  2718	   WHILE C _ NCHV(POINTER)#EOLIT &
  2719	    THEN &
  2720	     DO
  2721	     IF C.P &
  2722	      THEN [WX(FILE, CTRL(C)); C.P _ 0] &
  2723	      ELSE &
  2724	       DO
  2725	       IF C=$\ &
  2726	        THEN C.P _ 1 &
  2727	        ELSE W(FILE, IF C=$$ THEN CARRET ELSE C)
  2728	       END
  2729	     END
  2730	   RETURN
  2731	
  2732	END F.P.MSG
  2733	
  2734	END MSG.TTY
  2735	
  2736	END TTYIO
  2737	
  2738	
  2739	!     *****  EXCEPTION HANDLING
  2740	
  2741	%ARTHOV(ADDR)
  2742	
  2743	! IF ADDR=0 , ALL ARITHMETIC OVERFLOW WILL BE IGNORED. OTHERWISE, IT WILL
  2744	! TRAP BY EXECUTING A JSR ADDR INSTRUCTION FROM THE MONITOR'S PROCESS TABLE.
  2745	
  2746	   LOCAL RETURN.ADDR:
  2747	
  2748	   ARTHOV.ADDR _ ADDR
  2749	
  2750	   IF ADDR = 0 THEN ^14 _ JFCL ELSE ^14 _ JSR + ADDR
  2751	   EXU(CLICD, 14, -OCT 40, RETURN.ADDR)   !SETTR1 CALLI
  2752	RETURN.ADDR:   RETURN
  2753	
  2754	END ARTHOV
  2755	
  2756	
  2757	%DDTOVR(STATE)
  2758	
  2759	! IF STATE IS TRUE, THEN EVEN IF LOADED WITH DDT, IOCS WILL ARM ESCAPES.
  2760	
  2761	   RETURN (DDTFLG <== STATE)
  2762	
  2763	END DDTOVR
  2764	
  2765	
  2766	%OFFALT
  2767	
  2768	IF INC ALTLEV > 1 THEN RETURN   ! ESCAPES ALREADY DISARMED.
  2769	! REALLY DISARM, FIRST TIME:
  2770	
  2771	TRPFG _ 0; SETALT(ALTNIL)
  2772	RETURN
  2773	
  2774	END OFFALT
  2775	
  2776	
  2777	%ONALT
  2778	
  2779	IF ALTLEV=0 OR DEC ALTLEV>0 THEN RETURN
  2780	SETALT(ALT); IF TRPFG>0 THEN GO ALT
  2781	RETURN
  2782	
  2783	END ONALT
  2784	
  2785	
  2786	%ONALT.C
  2787	
  2788	ALTLEV _ 1; ONALT; RETURN
  2789	
  2790	END ONALT.C
  2791	
  2792	
  2793	%SET.ARTHOV
  2794	
  2795	! CHECKS TO SEE IF ARITHMETIC OVERFLOW SHOULD BE TRAPPED.
  2796	
  2797	   IF ARTHOV.ADDR THEN DO
  2798	
  2799	      ^14 _ JSR + ARTHOV.ADDR
  2800	      EXU(CLICD, 14, -OCT 40)   !SETTR1 CALLI
  2801	
  2802	   END
  2803	   RETURN
  2804	
  2805	END SET.ARTHOV
  2806	
  2807	
  2808	%SETALT (LAB:)
  2809	%%RS.ALT        ! RESTORE ALT STATE.
  2810	
  2811	FIND ALT.NAME(".JBDDT",JOBDDT)
  2812	
  2813	IF JOBDDT AND NOT DDTFLG THEN JOBAPR _ ^14 _ 0 ELSE [JOBAPR _ LAB; ^14 _ TRPBITS]
  2814	EXU(CLICD,14,OCT 16); SET.ARTHOV; RETURN
  2815	
  2816	END SETALT
  2817	
  2818	
  2819	%L.OFFALT
  2820	
  2821	IF L.ALTLEV=0 THEN OFFALT; INC L.ALTLEV; RETURN
  2822	
  2823	END L.OFFALT
  2824	
  2825	
  2826	%L.ONALT
  2827	
  2828	IF DEC L.ALTLEV=0 THEN ONALT; RETURN
  2829	
  2830	END L.ONALT
  2831	
  2832	
  2833	%SETRWE (FN, LAB:)
  2834	
  2835	RETURN RWELAB(FN) <== LAB
  2836	
  2837	END SETRWE
  2838	
  2839	
  2840	%IOERR (FN, N)
  2841	
  2842	IF (L.ALTLEV<==0)>0 THEN ONALT
  2843	ERRNUM _ N; GO ^RWELAB(FN)
  2844	
  2845	END IOERR
  2846	
  2847	
  2848	%ABNERR(FN)
  2849	  MSG('$ABNORMAL ERROR ON FILE$')
  2850	  MOVE 4 FROM @MINFID(FN*4) TO @ARGCNT(FIDTBL)+1
  2851	  WFID(FIDTBL)
  2852	  MSG('$FILE STATUS WORD$')
  2853	  EXU(GTSCD,FN,@STS)
  2854	  REPEAT 12 DO
  2855	    STS_STS ROTL 3
  2856	    TTY_(STS BAND 7)+$0
  2857	    END
  2858	  EXIT
  2859	END ABNERR
  2860	
  2861	END IOCS

IOCS
SYMBOL CROSS REFERENCE

ABNERR	   256	   672	  1144	  2283	  2319	  2848#
ABORT	   661	   683	   723#	   835
ABORT1	   661	   688	   727#
ABORT2	   661	   697	   703	   731#
ABRT	   662#	   679	   683#
ACC	   488#	   488	   496	   508
ACTIVE	  2246#	  2253	  2254	  2255	  2256
ACTRL	   341#	  1719	  1764	  1778
ADDR	   488#	   488	   496	   508	  2741#	  2741	  2748	  2750
ADR	  1440#	  1440	  1463	  1470	  1471	  1475	  1476	  1477	  1480	  1489	  1494	  1497	  1509	  1510
	  1539	  1547	  1548	  1549	  1562	  1563	  1591	  2039#	  2039	  2048	  2061#	  2061	  2081	  2088
	  2089	  2093	  2094	  2095	  2098	  2107	  2112	  2115	  2127	  2128	  2148	  2153	  2165	  2166
	  2181	  2269#	  2269	  2279	  2285	  2294	  2648#	  2648	  2655	  2658	  2660	  2676#	  2676	  2683
	  2689	  2697#	  2697	  2705	  2707	  2709
AEFERR	   120#
AFG	  1637#	  1694	  1712	  1720	  1778	  1783
ALT	   429#	   481#	  2555#	  2555	  2780	  2780#
ALTBLK	   430#	   481	   482
ALTENT	     2#	     7	     8	     9	    10	    11	    12	    13	    14	    15	    16	    17	    18	    19
	    20	    21	    22	    23	    24	    25	    26	    27	    28	    29	    30	    31	    32	    33
	    34	    35	    36	    37	    38	    39	    40	    41	    42	    43	    44	    45	    46	    47
	    48	    49	    50	    51	    52	    53	    54	    55	    56	    57	    58	    59	    60	    61
	    62	    63	    64	    65	    66
ALTFX	  1638#	  1704	  1749#
ALTJUM	   435#	   483
ALTLEV	   430#	   442	  2768	  2779	  2788
ALTLOC	   200#	   471	   479	   679	   685	   725	  1693	  1704	  1733	  1756	  1759
ALTNAM	     1#	   147	   148	   149	   150	   151	   152	   153	   154	   155	   156	   157	   158	   159
	   160	   161	   162	   163	   164	   165	   166	   167	   168	   169	   170	   171	   172	   173
	   174	   175	   176	   177	   178	   179	   180	   181	   182	   183	   184	   185	   186	   187
	   188	   189	   190	   191	   192	   193	   194	   195	   196	   197	   198	   199	   200	   201
	   202	   203	   204	   205	   206	   207	   208	   210	   211	   212	   236	   238	   239	   241
	   242	   243	   245	   246	   247	   248	   249	   250	   396	  2811
ALTNIL	   429#	   483#	  2771
AOVTRP	   479	   479#	   481
ARGCNT	   219#	   677	   692	   696	   705	   709	   911	  1120	  2428	  2429	  2430	  2432	  2850
ARGERR	   126#	   768	  1245	  1453	  2072	  2377
ARTHOV	   212	   430#	   440	  2741#	  2748	  2797	  2799
BACKOB	  1647#	  1773
BBUFSZ	   271#	   781	   783	  1157
BCTRL	   342#	  1898
BELL	   368#	  1898
BELOW	   547	   555#	   903#	   903	   909#	  2316	  2336#
BGNADR	   296#	  1091	  1195	  1587	  2217	  2218	  2221	  2261	  2403
BIT10	   618#	   621
BIT14	   617#	   621
BIT17	   616#	   621
BIT18	   432#	   434
BIT25	   433#	   434
BIT26	   615#	   620
BIT28	   614#	   637
BIT29	   613#	   620
BIT4	   619#	   628
IOCS
SYMBOL CROSS REFERENCE

BLKID	   293#	   449	  1087	  1091	  1195	  1279	  1586	  1587	  2185	  2213	  2220	  2261	  2403	  2406
	  2407
BLKNO	  2269#	  2269	  2278	  2285	  2293
BLKNUM	  2209#	  2211	  2212	  2213	  2217	  2220
BPC	  1015#	  1017
BPE	   272#
BPW	   266#	   273	  1015	  1017
BUF	   280#	   445	   447	  1091	  1195	  1587	  2217	  2218	  2221	  2261	  2403
BUFDUM	   159	  1184#
BUFSZ	   270#	   273	   275	   296	   447	   700	   771	   773	  1091	  1195	  1475	  1494	  1587	  1591
	  2093	  2112	  2181	  2218	  2261	  2279	  2313	  2315	  2401	  2403
C	  1529#	  1529	  1535	  1551	  2145#	  2145	  2149	  2156	  2715#	  2718	  2721	  2725
CANCAL	   164	  1165#
CANCEL	   158	  1075#	  1169
CCTRL	   343#	  1812
CFECHO	   205	  2459	  2495#
CFN	   149#	   832	   835	  1663	  2480
CFRAG	  1447#	  1469	  1472	  1480	  1497	  1507	  1512	  1513	  1519	  1578	  1581	  2067#	  2087	  2090
	  2098	  2115	  2125	  2130	  2131	  2137	  2179
CGET	  1712	  1712#	  1728	  1807	  1903
CHAR	   812#	   812	   817	   818	   899#	   915	   916	   917	   919	   923	   928	   932	   934	   935
	   938	   941	   956	   963	   968	   977	   980	  1014#	  1021	  1022	  1637#	  1657	  1659	  1660
	  1679	  1684	  1685	  1686	  1713	  1714	  1715	  1718	  1719	  1721	  1722	  1725	  1726	  1727
	  1763	  1764	  1806	  1807	  1836	  1854	  1859	  1868	  1895	  1940#	  1940	  1945	  2561#	  2561
	  2571	  2572	  2576	  2578	  2580	  2583	  2586	  2587	  2589	  2591	  2595	  2601#	  2601	  2605
	  2606	  2607	  2612#	  2612	  2616	  2617	  2618	  2623#	  2623	  2630	  2636	  2637	  2639	  2640
	  2665#	  2667
CHARAC	    92#	   455	   558	   559	   568	   701
CHK	  2244#	  2255	  2256#
CHK1	  2244#	  2254	  2255#
CHK2	  2244#	  2253	  2254#
CHK3	  2244#	  2250	  2253#
CHKMSG	   662#	   677	   678#
CHMAC	  1393#	  1409	  1416
CHMTCH	  1839	  1842	  1845	  1853#
CHOP	  2399	  2416#
CLEAN	   254#	  1091	  1195	  1587	  2261
CLIBUF	   184	  1947	  2515#
CLICD	   390#	   437	   482	   623	   629	   633	   642	  1196	  1213	  2536	  2751	  2800	  2814
CLOBUF	   185	  2524#
CLOSE	   157	  1050#	  1179
CLOSE1	  1069	  1094	  1102	  1122	  1128#
CLOSEA	   163	   477	  1175#
CLR	  2374#	  2399	  2401#
CLSCD	   379#	   691	   729	  1141
CNFERR	   110#	   683	   688	   697	   703	   835
CNFTBL	   541#	   545
CNT	  1014#	  1019	  1021	  1024	  1025	  1026	  1037	  1440#	  1440	  1453	  1463	  1468	  1469	  1475
	  1480	  1488	  1489	  1490	  1494	  1497	  1507	  1512	  1513	  1524	  1526	  1527	  1540	  1544
	  1560	  1563	  1578	  1592	  2061#	  2061	  2072	  2081	  2086	  2087	  2088	  2089	  2093	  2106
	  2107	  2108	  2112	  2125	  2130	  2134	  2163	  2166	  2179	  2180	  2181	  2182	  2183	  2373#
	  2383	  2390	  2395	  2403	  2406	  2414
CODE	   488#	   488	   496	   508
IOCS
SYMBOL CROSS REFERENCE

COMECH	   415#	  1664	  1670	  2500
CONF	   663#	   675	   680	   681
CONFLB	   936	   941#
CONFTB	   545#	  1033	  1034	  1037
CONFWD	   228#	   675	   942
COPRNX	  1654#	  1812	  1816	  1862
CORERR	   129#
CP	   177	  1259#	  1301	  1455	  2047	  2075	  2714#	  2717	  2721	  2725
CP1	   310#	   999	  1250	  1275	  1279	  2341
CPBUF	   319#	  1087	  1088	  1249	  1250	  1279	  1306	  2029	  2229	  2253	  2254	  2255	  2256	  2401
	  2408
CPF	  2349#	  2349	  2377	  2379	  2383	  2390	  2399	  2406	  2413	  2414
CPI	  2349#	  2349	  2378	  2379	  2382	  2383	  2416
CPTOEO	  1400#	  1420	  1424	  1983#	  2017	  2020	  2025
CPW	   234#	   235	   273	  1015	  1017	  1019	  1024	  1324	  1461	  1469	  1475	  1738	  2047	  2050
	  2079	  2087	  2093	  2315
CSTOR	  1727	  1727#	  1892	  1895
CTREXU	  1726	  1763#
CTRL	  2702#	  2721
CTRLCH	   137#	  1726	  2586
CURBUF	   398#	   770	   773	  1156	  1215	  2313	  2333	  2337	  2339	  2343
DATE	  1111#	  1115	  1119
DCP	   255	  1249	  1277#	  1306	  1319	  1420	  1593	  2017	  2182	  2211	  2260	  2390	  2399
DCTRL	   344#	  1815
DDTFLG	   430#	  2761	  2813
DDTOVR	   211	  2757#
DEFTAB	  1348#	  1372
DEL	  1066#	  1102	  1136
DELETE	   182	  1097#
DELFG	  1638#	  1839	  1842	  1845	  1848	  1862
DEVNAM	   227#	   749	   939
DIRECT	    87#	   558	   751	  1082	  1094	  1102	  1114
DIRTY	   294#	   450	  1091	  1195	  1586	  1587	  2029	  2220	  2253	  2254	  2255	  2256	  2261
DISCAR	  1067#	  1077
DISP	  1202#	  1202	  1212	  1214	  1215	  1216	  1219
DISPL	  2209#	  2211	  2223	  2224	  2225	  2228	  2373#	  2382	  2383
DOERR	   402	   699	   713#	  1121	  1139
DOIT	  1073	  1079#
DONE	   945	   948#
DSA	   241	   444
DSETCP	   255	  1084	  1246#	  1327	  2020	  2182	  2260	  2406	  2414	  2416
DSIZE	   255	  1083	  1304#	  1420	  2017	  2379
DSKDEV	   747#	   749
DZAP	  1449	  1480	  1497	  1519	  1571#	  2068	  2098	  2115	  2137	  2173#
EBUFS	   273#	   700	  1085	  1279	  1455	  1516	  1562	  1578	  1581	  1592	  2075	  2134	  2165	  2179
	  2182	  2211	  2228	  2315	  2333	  2335	  2382	  2383	  2390	  2399	  2406
EBUFSZ	   274#	   275	   700	  1085	  1279	  1455	  1516	  1578	  1581	  1592	  2075	  2134	  2179	  2182
	  2211	  2228	  2315	  2333	  2335	  2382	  2383	  2390	  2399	  2406
ECHK	  1636	  1767	  1801	  1812	  1815	  1820	  1829	  1853	  1866	  1872	  1880	  1884	  1905#	  1947
ECNT	   308#	   999	  1275	  1279	  1325	  1404	  1406	  1409	  1411	  1413	  1416	  1419	  1424	  1468
	  1490	  1512	  1560	  1561	  1562	  1563	  2000	  2003	  2012	  2015	  2025	  2086	  2108	  2130
	  2163	  2164	  2165	  2166	  2228	  2315	  2333	  2335	  2341	  2386	  2395
ECTRL	   345#	  1767
IOCS
SYMBOL CROSS REFERENCE

ENDCNT	   322#	  1404	  1406	  1409	  1424
ENDRAD	   331#	   469	  1424
ENDRCH	   332#	   469	  1409#
ENDRPK	   333#	   469	  1406#
ENDRWD	   332#	   469	  1404#
ENTCD	   376#	   677	   705
ENTER	   677	   677#	   697
EOF	  2276#	  2282	  2297#	  2310#	  2318	  2320#
EOFERR	   122#	  1420	  1526	  2320
EOLITW	   144#	  1706
EON	  1637#	  1694	  1727	  1768	  1773	  1790	  1795	  1909	  1910
EPTR	   308#	  1214	  1321	  1322	  1404	  1406	  1409	  1411	  1413	  1416	  1466	  1471	  1472	  1486
	  1489	  1505	  1510	  2000	  2004	  2005	  2006	  2012	  2051	  2084	  2089	  2090	  2104	  2107
	  2123	  2128	  2223	  2224	  2226	  2337	  2338	  2339
ERASE	   175	  2349#
ERLAB	   520	   547	   549	   552	   557	   569	   574	   588	   768	   782	   870	   905	   950	  1097
	  1102	  1106	  1114	  2422	  2431
ERNUM	   723#	   723	   727	   731	   733
EROUT	   429#	   447	   448	   449	   450	   485#
ERR	   260#	   588	   768	   950
ERRCHK	  2276#	  2281	  2282#	  2310#	  2314	  2318#
ERRNUM	   201#	   588	   768	   950	  2843
ERROUT	   677	   699#	   705
EVAL	  2373#	  2381	  2386	  2395	  2401
EXCFG	  1638#	  1839	  1842	  1845	  1848	  1856	  1861
EXCFN	   203	  2457	  2473#
EXTARG	   222#	   664	   697	   718	   911	   920	   921	   978	   979
EXTDEF	   870#	   870	   905	   911
EXTOUT	   202	  2456	  2463#
EXTQ	   225#	   921
EXU	   150	   437	   482	   488#	   623	   625	   627	   629	   633	   642	   643	   670	   677	   691
	   692	   696	   705	   716	   729	   733	  1120	  1124	  1138	  1141	  1142	  1145	  1196	  1213
	  1579	  2278	  2281	  2282	  2293	  2296	  2314	  2318	  2332	  2334	  2431	  2519	  2528	  2536
	  2547	  2751	  2800	  2814	  2853
EXUF	   151	   496#
FBSERR	   119#
FCTRL	   346#	  1820
FDESCR	   520#	   520	   549	   597	   598	   599	   600
FID	   549#	   549	   552	  1097#	  1097	  1102
FIDP	   210#	   552	   674	   675	   677	   681	   688	   692	   696	   697	   700	   704	   705	   709
	   718	   749	   799	   853	   909	   911	   913	   920	   921	   924	   933	   934	   939	   942
	   948	   972#	   972	   976	   978	   979	  1115	  1116	  1119	  1120
FIDTBL	   300#	   547	   552	   870#	   870	   905	   909	  1117	  1137	  1138	  2428	  2429	  2430	  2431
	  2432	  2850	  2851
FILE	  2663#	  2663	  2667	  2711#	  2711	  2721	  2725
FILEP	   660	   679	   851#
FILNUM	  2463#	  2463	  2468	  2473#	  2473	  2475	  2480
FILSIZ	   224#	   700
FINI	   662#	   705	   709#
FIRSTP	  1207#	  1215	  1216
FISPEC	   533#	   670	   740	   749	   750	   752	   754	   755
FIXBUF	   181	  1202#
FMDERR	   106#	   565	  1244	  1429	  1451	  2036	  2070	  2376
IOCS
SYMBOL CROSS REFERENCE

FN	   532#	   557	   559	   564	   565	   567	   568	   569	   572	   574	   598	   599	   600	   670
	   672	   673	   676	   677	   678	   685	   687	   690	   691	   692	   696	   697	   699	   700
	   701	   702	   705	   707	   709	   713#	   713	   716	   717	   718	   729	   733	   751	   755
	   769	   770	   773	   999	  1000	  1001	  1050#	  1050	  1075	  1079	  1082	  1083	  1084	  1085
	  1086	  1087	  1088	  1091	  1093	  1094	  1102	  1114	  1120	  1121	  1122	  1124	  1125	  1138
	  1139	  1141	  1142	  1144	  1145	  1147	  1156	  1207#	  1209	  1211	  1214	  1215	  1228#	  1228
	  1242	  1244	  1245	  1246	  1249	  1250	  1251	  1252	  1259#	  1259	  1273	  1275	  1277	  1279
	  1284#	  1284	  1300	  1301	  1304	  1306	  1307	  1308	  1309	  1311#	  1311	  1318	  1319	  1320
	  1321	  1322	  1324	  1325	  1327	  1375#	  1375	  1402	  1404	  1406	  1409	  1411	  1413	  1416
	  1418	  1419	  1420	  1421	  1422	  1424	  1429	  1432	  1437	  1440#	  1440	  1451	  1452	  1453
	  1455	  1457	  1459	  1463	  1465	  1466	  1468	  1471	  1472	  1475	  1480	  1484	  1486	  1489
	  1490	  1494	  1497	  1500	  1504	  1505	  1510	  1512	  1516	  1525	  1526	  1533	  1536	  1552
	  1560	  1561	  1562	  1563	  1565	  1578	  1579	  1581	  1586	  1591	  1592	  1593	  1603#	  1603
	  1656	  1663	  1688	  1954	  1963#	  1963	  1985	  1988	  1992	  1996	  1998	  2000	  2003	  2004
	  2005	  2006	  2012	  2014	  2015	  2017	  2020	  2023	  2025	  2029	  2030	  2033	  2036	  2039#
	  2039	  2047	  2050	  2051	  2054	  2061#	  2061	  2070	  2071	  2072	  2075	  2077	  2081	  2083
	  2084	  2086	  2089	  2090	  2093	  2098	  2102	  2104	  2107	  2108	  2112	  2115	  2118	  2122
	  2123	  2128	  2130	  2134	  2151	  2163	  2164	  2165	  2166	  2168	  2179	  2181	  2182	  2185
	  2196#	  2196	  2211	  2213	  2217	  2220	  2222	  2223	  2224	  2226	  2228	  2229	  2260	  2269#
	  2269	  2278	  2281	  2282	  2283	  2285	  2293	  2296	  2302#	  2302	  2313	  2314	  2315	  2318
	  2319	  2320	  2322	  2332	  2333	  2334	  2335	  2336	  2337	  2338	  2339	  2341	  2343	  2349#
	  2349	  2376	  2377	  2378	  2379	  2381	  2382	  2383	  2386	  2390	  2395	  2399	  2401	  2406
	  2407	  2408	  2414	  2416	  2428	  2431	  2833#	  2833	  2835	  2840#	  2840	  2843	  2848#	  2848
	  2850	  2853
FNERR	   261#	   559	   565	   718	   733	  1122	  1244	  1245	  1273	  1300	  1420	  1429	  1451	  1452
	  1453	  1526	  1688	  2036	  2070	  2071	  2072	  2320	  2376	  2377
FNFERR	   116#	   718
FNID	   291#	   448	   451	  1088	  1091	  1195	  1586	  1587	  2185	  2213	  2220	  2249	  2253	  2254
	  2255	  2256	  2260	  2261	  2403	  2408
FNMAX	   100#	   306	   308	   310	   311	   313	   315	   319	   321	   322	   335	   336	   396	   403
	   463	   586	  1196
FNMIN	    99#	   101	   307	   396	   403	   463	   584	   586	  1196	  1209
FOO	   506#	   509	   512#
FORWOB	  1644#	  1727	  1795
FPMSG	   195	  1753	  2705	  2709	  2711#
FPPRIN	   196	  1667	  1743	  2655	  2660	  2663#
FREE	   236#	  1352	  1673	  1755
FTYP	   306#	   464	   565	   574	   600	   676	   678	   685	   687	   697	   702	   717	   755	  1000
	  1001	  1083	  1093	  1125	  1147	  1169	  1179	  1209	  1211	  1252	  1301	  2376
FWD	   543#
FWDCNT	   537#	   543	  1033	  1039
GCTRL	   347#	   368	  1892
GET	   187	  1427	  1713	  1714	  1721	  2549#
GET1	  2213	  2221#	  2547	  2555#
GETANS	   660	   680	   823#
GETBRK	   257	  1718	  1854	  1895	  2542#
GETBUF	   766	   770	   771	   776#
GETCH	  1442#	  1463	  1475	  1480
GETCHK	   252	  1086	  1320	  1421	  1437	  2023	  2196#	  2401	  2407
GETCON	   660	   942	  1007#
GETLIN	   172	   832	  1603#
GETMEM	   242	   447	   448	   449	   450	   781
GETNUM	   900	   933	   934	   952#
IOCS
SYMBOL CROSS REFERENCE

GETNXT	   867	   903	   967#
GETPK	  1445	  1502	  1513	  1516	  1519	  1529#
GETSZ	   662#	   696	   700#
GETTAB	  1636	  1793	  1802	  1914#
GETWD	  1444#	  1494	  1497
GLBCMX	   233#	   235
GLBSZ	   235#	   236	   238	  1706	  1755
GLCNT	   239#	  1657	  1658	  1737	  1738
GOCD	   505#	   509	   510
GTSCD	   388#	  2853
HCTA	  1833	  1833#	  1834
HCTRL	   348#	  1829
HEAD	   396#	   755	   769	   770	   773	  1156	  1214	  1215	  2313	  2315	  2333	  2337	  2338	  2339
	  2343
HERE	   532#	   564	   574#	  1240	  1250#	  1448#	  1457	  1525#	  1551#	  1551	  1552
HOLD	   899#	   911	   950	  1447#	  1453	  1454	  1463	  1475	  1494	  1502	  1516	  1526	  1527	  1637#
	  1697	  1700	  1701	  1737	  1738	  1832	  1855	  1856	  1858	  1859	  1861	  1862	  1873	  1874
	  1875	  1876	  1983#	  1992	  1993	  2019	  2021	  2067#	  2072	  2073	  2120	  2134	  2143	  2209#
	  2221	  2223	  2224	  2226	  2230	  2253	  2254	  2255	  2256	  2259
I	   263#	   463	   464	   584	   586	   587	   588	   799	   801	   913	   917	   920	   924	   927
	   954#	   955	   956	   957	  1069#	  1086	  1087	  1091	  1167#	  1169	  1178#	  1179	  1195	  1196
	  1316#	  1322	  1324	  1449#	  1534	  1538	  1540	  1543	  1544	  1545	  1546	  1547	  1562	  1563
	  1579	  1580	  1581	  1585	  1586	  1587	  1592	  1593	  1784	  1785	  1822	  1831	  1833	  1834
	  1886	  1918	  1919	  1920	  1932	  1933	  2045#	  2051	  2052	  2068#	  2093	  2112	  2148	  2152
	  2153	  2165	  2166	  2184	  2185	  2213	  2248	  2249	  2253	  2254	  2255	  2256	  2257	  2259
	  2260	  2261	  2262	  2547	  2554	  2555	  2556	  2691
ICTRL	   349#	  1793	  1807	  2054	  2580	  2583	  2636
IFDERR	   109#	   950	  1122
IFMORE	  2245#	  2249	  2257
IMAGE	   238#	  1353	  1354	  1355	  1706	  1738	  1755
INCD	   382#	  2281	  2314
INDEX	   492#	   494	   496	   508
INDIRE	   492#	   494	   496	   508
INITOK	   662#	   670	   673#
INITPO	  2569#	  2571	  2581	  2582
INITR	   252	   459	  1339#
INITRN	   660	   690	   707	   763#
INITSC	   531	   567	   991#
INPUT	    74#	   755	  1001	  1083	  1102	  1114	  1211	  1252	  2376
INWD	  1014#	  1019	  1033	  1034	  1037
IOCS	   152	   421#
IOERR	   256	   559	   565	   718	   733	  1122	  1244	  1245	  1273	  1300	  1420	  1429	  1451	  1452
	  1453	  1526	  1688	  2036	  2070	  2071	  2072	  2320	  2376	  2377	  2840#
IUSERR	   117#
J	   428#	   798	   799	  1584	  1586	  1637#	  2045#	  2051
JCTRL	   350#	  1892	  2582
JFCL	   393#	  2750
JOBAPR	   248#	  2813
JOBDDT	  2811#	  2813
JOBFF	   247#
JOBHCU	   245#	   584	   588	  1169	  1179	  1209
JOBJDA	   246#	   587
JOBREL	   250#
IOCS
SYMBOL CROSS REFERENCE

JOBTPC	   249#
JRSTCD	   374#
JSR	   392#	  2750	  2799
K	   428#
KCTRL	   351#	  1866	  2584
KFANY	   538#
KFEXST	   539#	   681
KFNEW	   540#	   541	   681
KFNO	   535#	   681
KFYES	   536#	   537	   541
LAB	  1007	  1024	  1037	  2244#	  2250	  2252	  2253	  2254	  2255	  2808	  2813	  2833	  2835
LALTLE	   259#	   442	  2821	  2828	  2842
LAST	  2373#	  2379	  2399	  2413
LCHBIT	   621#	   627
LCTRL	   352#	  1829	  1836	  2583	  2636
LESSTR	  1016#	  1034
LH	   404#	   445	   933	   978	  1211
LINK	  1154#	  1156	  1157
LIST	  2275#	  2279	  2280	  2281	  2294	  2295	  2296
LKPCD	   377#	   692	   696
LLEN	   232#	   233	  1354	  1658
LNGERR	   123#	  1688
LOCWPF	   213#	   216	   217	   219	   220	   221	   222	   223	   224	  2429
LOFFAL	   259	   442	   547	   551	   685	   725	  1080	  1101	  1113	  1194	  1240	  1248	  1319	  1421
	  1456	  1732	  1749	  2016	  2074	  2312	  2331	  2819#
LONALT	   259	   472	   485	   572	   679	  1094	  1103	  1125	  1197	  1253	  1327	  1423	  1525	  1736
	  1759	  2027	  2142	  2342	  2826#
LPTR	   663#	   832	   860
MAPTOU	   660	   812#	   833	   915	   928	  1021	  1027
MASK	  1017#	  1037
MAXARG	   214#	   217
MAXWPF	   217#	   300
MCTRL	   353#	  1892	  2580	  2581
MINARG	   215#	   216	   911	  2432
MINFID	   403#	   709	  2428	  2850
MKCTRL	   135#	   341	   342	   343	   344	   345	   346	   347	   348	   349	   350	   351	   352	   353
	   354	   355	   356	   357	   358	   359	   360	   361	   362	   363	   364	   365	   366
MODE	   306#	   455	   558	   559	   565	   567	   599	   690	   707	   738#	   738	   740	   751	  1082
	  1094	  1209	  1244	  1275	  1301	  1418	  1437	  1465	  1484	  1504	  2014	  2083	  2102	  2122
MSG	   193	   485	   671	  1143	  1947	  2707#	  2849	  2852
MSGTTY	   258	  2697#
MXACP	   321#	   567	  1249	  1306	  1307	  1309	  1593	  2182	  2416
N	  2840#	  2840	  2843
NAM	   913	   913#	   930	   939
NAMARG	   221#	   799	   913	   939	   948	   976
NBCHKB	  1640#	  1774	  1778	  1783	  1789
NBLKS	  2269#	  2269	  2279	  2422#	  2422	  2429
NBP	  1342#	  1697	  1737	  1769	  1774	  1778	  1779	  1783	  1784	  1785	  1789	  1832	  1876	  1931
	  1945	  1946
NBPB	  1631#	  1697	  1769	  1774	  1778	  1783	  1784	  1785	  1789	  1909
NBPE	  1343#	  1354	  1701	  1945
NBPI	  1341#	  1353	  1697	  1743	  1745	  1753	  1875	  1909	  1930
NBUFS	   421#	   421	   445	   446	   447	   448	   449	   450	   451	  1091	  1195	  1585	  2184	  2213
IOCS
SYMBOL CROSS REFERENCE

	  2229	  2249	  2257	  2408
NCTRL	   354#	  1773
NEW	    81#	   688	   703
NEWFID	  1106#	  1106	  1116	  1117
NEWMSG	   667#	   853
NLPOS	  1636	  1880	  1918	  1926#
NNCH	   520	   547	   870	   968
NO	   265#	   440	   807	  1091	  1195	  1587	  1694	  1712	  1720	  1778	  1783	  1839	  1842	  1848
	  1910	  2220	  2261	  2297	  2634	  2687
NOTERM	  1345#	  1346
NSBUFS	   520#	   520	   549	   768	   771
NULLP	   427	   460	   461	   474#
NWDS	  2285#	  2285	  2294
NXBLK	  1404	  1407	  1409	  1411	  1414	  1418#	  2001	  2010	  2014#
NXBUF	   282#	   453	  2213	  2218	  2220	  2221	  2229	  2248	  2249	  2257	  2262	  2408
NXCH	  1007	  1021	  1027	  1636	  1657	  1660	  1679	  1685	  1686	  1953#
NXCHAR	   660	   680	   858#	   865	   912	   926	   930	   939	   942	   943	   946	   948	   956
NXT	   823	   833
NXTFN	   531	   564	   577#
OBEND	  1641#	  1644	  1649	  1803	  1812	  1816	  1821	  1829	  1834	  1856	  1866	  1885
OBP	  1630#	  1657	  1659	  1662	  1682	  1696	  1727	  1769	  1773	  1789	  1795	  1803	  1804	  1806
	  1812	  1816	  1821	  1822	  1829	  1831	  1834	  1855	  1856	  1862	  1866	  1868	  1873	  1885
	  1886
OBPB	  1631#	  1696	  1769	  1773	  1789	  1909
OBPE	  1633#	  1696	  1700	  1703	  1727	  1773	  1795	  1803	  1804	  1812	  1816	  1821	  1829	  1834
	  1856	  1858	  1866	  1873	  1885
OBPI	  1341#	  1352	  1657	  1667	  1677	  1696	  1909
OBPLE	  1632#	  1703	  1773
OCTRL	   355#	  1839
OFF	  1362	  1364	  1918
OFFALT	   197	  2766#	  2821
OFFECH	   257	   636#	  1718	  1854	  1895
OLD	    82#	   688	   697
OLDFID	  1106#	  1106	  1114
OLDFIL	   664#	   681	   688	   853
OLDMSG	   666#	   853
OLDOFF	  1363#	  1364
OLDP	   663#	   679	   685	   725
OLDPRO	  1367#	  1368
OLDRLS	  1111#	  1117	  1122#
OLDTAB	  1371#	  1372
OLDTER	  1359#	  1360
ONALT	   198	  2777#	  2788	  2828	  2842
ONALTC	   199	  2786#
ONECHO	   257	   631#	  1718	  1855	  1895
ONP	  2505#	  2505	  2510
OPEN	   153	   549#	  1102	  1114
OPEN1	   427	   566	   649#	  2433
OPENP	   160	   520#
OPNCD	   375#	   670
OPNSZ	   311#	   673	   700	  1301	  1307	  1309	  1318	  1319	  1324	  2416
OPNSZX	  1298	  1308	  1311#
OPT	  1128#	  1128	  1136	  1141
IOCS
SYMBOL CROSS REFERENCE

OPTION	  1069#	  1071	  1077	  1094
OPWORD	   506#	   508	   509	   510	   511
ORG	   306#	   455	   558	   559	   568	   598	   700	   701	  1000	  1001	  1085	  1279	  1424	  1455
	  1459	  1516	  1562	  1578	  1581	  1592	  2017	  2025	  2030	  2075	  2077	  2134	  2165	  2179
	  2182	  2211	  2222	  2228	  2315	  2333	  2335	  2336	  2381	  2382	  2383	  2390	  2399	  2406
ORGIND	    94#	    95#	   272	   273	   274	   331	  1000	  1001	  1424	  1459	  2025	  2030	  2077	  2222
	  2336
OUT	   801	   805#	   927	   935	   942	   950#	  1111#	  1120	  1124#	  2249	  2262#
OUTCD	   383#	  2296	  2334
OUTERR	  2276#	  2283#	  2296	  2310#	  2319#	  2334
OUTMSG	    77#	   678
OUTPUT	    76#	   685	   687	  1000	  1093	  1301
P	   779#	   781	   782	   783	   784	  1207#	  1215	  1216
PACK	    93#
PCGET	  1706	  1706#	  1790
PCRXIT	  1730	  1730#	  1817	  1824
PCTRL	   356#	  1845
PFRAG	  1447#	  1455	  1461	  1466	  1474	  1475	  1476	  1493	  1494	  1515	  1516	  2067#	  2075	  2079
	  2084	  2092	  2093	  2094	  2111	  2112	  2133	  2134
PKA	   315#	  1531#	  1534	  1537	  1539	  1545	  1547	  2005	  2006	  2146#	  2148	  2150	  2153	  2225
	  2226
PKB	   315#	  1406	  1413	  1531#	  1534	  1537	  1539	  1545	  1548	  2005	  2006	  2146#	  2148	  2150
	  2151	  2153	  2225	  2226
PKEOF	  1531#	  1533	  1543#
PKMAC	  1394#	  1406	  1413
PLNCHK	   165	  1432#
PLNW	   166	  2039#
PNB	  1636	  1725	  1727	  1730	  1731	  1751	  1752	  1794	  1804	  1807	  1812	  1816	  1822	  1833
	  1862	  1886	  1888	  1889	  1940#
POINTE	  2663#	  2663	  2667	  2711#	  2711	  2718
POS	  1228#	  1228	  1242	  1245	  1246	  1250	  1254	  1637#	  1918	  1920	  1930	  1932	  1933	  1935
PPNARG	   220#	   674	   704	   924	   933	   934
PPNHLD	   663#	   674	   704
PRCHAR	   138#	  1933	  2589
PRINT	   191	   843	   853	  1673	  2658#
PRINTC	   192	  2683#
PRNTCL	  2681	  2689#
PRNTTC	   258	  2676#
PRNTTY	   258	  2648#
PROMPT	  1366	  1368	  1666	  1672	  1708	  1741
PRTERR	   118#
PRVARG	   223#	  1115	  1119
PTR	   532#	   552	   905#	   905	   911	   943	   948	   950	   963	  1014#	  1019	  1022	  1031	  1033
	  1034	  1037	  1039	  1111#	  1117	  1447#	  1455	  1466	  1470	  1471	  1472	  1478	  1486	  1489
	  1495	  1505	  1509	  1517	  1562	  1565	  1580	  1584	  1591	  2045#	  2048	  2050	  2067#	  2075
	  2084	  2088	  2089	  2090	  2096	  2104	  2107	  2113	  2123	  2127	  2135	  2165	  2168	  2181
	  2185	  2187
PTRNXT	   867	   907	   943	   948	   962#
PUT	   188	   977	   979	   980	  1720	  1730	  1768	  1774	  1778	  1783	  1789	  1790	  1794	  1804
	  1836	  1862	  1874	  1880	  1888	  1909	  2612#	  2637	  2640
PUT1	  2575	  2589#
PUT2	  2584	  2587#
PUTC	   190	  1779	  1784	  1785	  1807	  1812	  1816	  1822	  1862	  1868	  1873	  1876	  1886	  1895
IOCS
SYMBOL CROSS REFERENCE

	  2630#	  2691
PUTCH	  2063#	  2081	  2093	  2098
PUTCLO	  2628	  2636#
PUTCR	   139#	   141	   142	  2569
PUTCRL	   141#
PUTLF	   140#	   141	   142	  2573	  2581	  2582
PUTLFC	   142#
PUTPK	  2065	  2120	  2131	  2134	  2137	  2145#
PUTTY	   258	  1987	  2578#	  2616	  2637	  2639
PUTTYC	   258	  2623#	  2691
PUTTYX	   258	  2032	  2561#	  2605
PUTWD	  2064#	  2112	  2115
PUTX	   189	  1715	  1721	  1722	  1872	  1898	  2601#
QCTRL	   357#	  1789
QUIT	   429#	   471	   477#
R	   171	  1375#	  1463	  1475	  1480	  1494	  1497	  1536	  1954
RADR	   331#	   467	  1000	  1424	  2025
RB	   180	  1440#
RBLK	   252	  1591	  2217	  2269#
RCH	   332#	   467	  1416#
RCTA	  1873	  1873#	  1880
RCTB	  1836	  1876#
RCTRL	   358#	  1872
REASK	   662#
RELEAS	  1134#	  1138	  1142	  1145#
RENAME	   183	  1106#
RERR	   330#	  1000	  1429#	  1451
RETURN	  2746#	  2751	  2752#
RH	   405#	   446	   510	   584	   587	   588	   770	   773	   924	   934	  1156	  1157	  1169	  1179
	  1212	  1215	  1216	  1580	  2313	  2333	  2337	  2339	  2343
RING	  1763	  1773	  1774	  1778	  1783	  1789	  1812	  1829	  1831	  1856	  1858	  1866	  1898#	  1922#
	  1922
RINIT	   329#	  1251	  1420#	  2025
RLAB	   335#	   457	  1000	  1251	  1402	  1418	  1424	  1451	  2025
RLSCD	   380#	   716	   733	  1124	  1145
RLSMEM	   243	  1157
RLSRNG	  1069	  1094	  1151#
RNMCD	   378#	  1120	  1138	  2431
RNMOK	  2426#	  2431	  2432#
RPK	   333#	   467	  1413#
RSALT	   208	  2809#
RSBRK	   207	   626#
RSTRT	  1696	  1696#	  1889	  1948#	  1948
RTEL	   330#	   457	  1427#
RUBOUT	   143#	  1713	  1718
RWD	   332#	   467	  1411#
RWELAB	   336#	   557	   564	   569	  2835	  2843
SAVDES	  1638#	  1705	  1734	  1757
SAVE	  1065#	  1071	  1122
SAVLOC	   663#	   679	   685	   725	  1638#	  1693	  1733	  1756
SCTRL	   359#	  1866	  1868
SECNT	   400#	  2315
SEPTR	   399#	  1214	  2338
IOCS
SYMBOL CROSS REFERENCE

SEQUEN	    86#	   455	   559	   565	   567	   690	   707	  1209	  1244	  1275	  1301	  1418	  1437	  1465
	  1484	  1504	  2014	  2083	  2102	  2122
SET	   633	   633#	   637
SETALT	   256	  2771	  2780	  2808#
SETART	   256	   479	  2793#	  2814
SETCFN	   148	  2475#
SETCP	   176	  1242#	  1319	  1593	  2378
SETCPI	   252	   567	  1228#
SETCTR	   257	   606#	  1692
SETFID	   154	   552	   905#	  1117
SETFIP	   161	   547	   870#
SETFIS	   660	   669	   745#
SETMOD	   162	   458	   673	   738#
SETNXB	  2208	  2217	  2232#
SETNXC	   252	   865#	   903	   907
SETPRM	   169	   460	   679	   685	   725	   836	  1366#
SETRWE	   194	  1457	  1525	  1533	  1552	  2833#
SETTAB	   167	   461	  1370#
SETTER	   168	   460	  1358#
SIXBIT	   897#	   917	   928
SIXPTR	   899#	   913	   917	   920	   924	   928	   976	   977	   979	   980
SIZE	   178	  1284#
SKPLAB	   488#	   488	   496	   510
SPCNT	  2450#	  2455	  2546	  2554	  2571	  2573	  2581	  2582	  2591	  2592
SRBLK	   255	  1418	  1437	  1565	  2302#
STATE	  2757#	  2757	  2761
STDESC	   531	   557	   564	   594#
STPPN	   662#	   692	   704#
STS	   147#	  2853	  2855	  2856
STSBIT	   620#	   632	   637
STSCD	   387#	  2332
STZCD	   381#	  1142	  2282	  2318
SUBCNT	   315#	  1406	  1413	  1500	  2004	  2005	  2006	  2118	  2226	  2339
SVLCH	   612#	   625	   627	   643
SVTMC	   612#	   624	   628	   641
SWBLK	   255	  1093	  2014	  2168	  2322#
SXPT	   901#	   913	   920	   924	   976	   979
SZAP	  1449	  1467	  1487	  1506	  1556#	  2068	  2085	  2105	  2124	  2159#
SZFG	   313#	   673	   701	  1308	  2416
TAB	  1370#	  1370	  1372	  1919	  1920
TABOFF	   170	   461	  1362#
TCTRL	   360#	  1880
TEL	   101#	   305	   334	   455	   456	   457	   557	   558	   559	   835	  1079	  1273	  1300	  1452
	  1656	  2071	  2456	  2457	  2654	  2655	  2660	  2705	  2709
TELCHK	   155	   555	   791#
TELERR	   124#	   559	  1273	  1300	  1452	  2071
TELFID	   795#	   799
TEMP	   532#	   612#	   627	   770	   771	   773	   799	   801	   805	   833	   834	  1069#	  1083	  1084
	  1085	  1087	  1316#	  1319	  1327	  1447#	  1463	  1469	  1470	  1471	  1475	  1476	  1480	  1507
	  1508	  1509	  1510	  1536	  1537	  1546	  1548	  1578	  1580	  1581	  1583	  1584	  1591	  1592
	  1637#	  1660	  1665	  1668	  1671	  1674	  1685	  1740	  1742	  1930	  1931	  1932	  1954	  1983#
	  2017	  2020	  2067#	  2081	  2093	  2094	  2098	  2125	  2126	  2127	  2128	  2451#	  2652#	  2654
	  2655	  2656	  2689	  2691	  2705
IOCS
SYMBOL CROSS REFERENCE

TEMP1	  2451#
TERM	  1346#	  1654	  1725	  1806	  1822	  1831	  1834	  1886
TERMCH	  1358#	  1358	  1360	  1725	  1806	  1812	  1816	  1822	  1831	  1834	  1862	  1886
TERMDE	   414#	  1987	  1988	  2032	  2033	  2490	  2605	  2606	  2616	  2617
TERMEC	   416#	  1739	  1750	  2510
THRU	  2256	  2259#
TMFERR	   105#	   588
TOBOTH	   409#
TONEIT	   410#	  2459
TOTERM	   407#	  1670	  1671	  1705	  1987	  2032	  2458	  2605	  2616
TOTOUT	   408#	  1664	  1665	  1740	  1988	  2033	  2606	  2617
TOUTFI	   413#	  1664	  1667	  1739	  1743	  1750	  1753	  1988	  2033	  2468	  2606	  2617
TRPBIT	   434#	   481	  2813
TRPFG	   430#	   483	  2771	  2780
TRUNCA	  2374	  2399	  2422#
TTCD	   389#	   625	   627	   643	  2519	  2528	  2547
TTDEST	   204	  1665	  1668	  1671	  1674	  1705	  1734	  1740	  1742	  1757	  2458	  2485#	  2654	  2655
	  2705
TTECHO	   206	  2505#
TTYIO	   256	   471	  2441#
TTYLEN	   186	  2533#
TTYP	  2451#	  2627	  2634	  2637	  2639	  2680	  2687	  2691
TYPMOD	   533#	   597	   688	   697	   703
UCTRL	   361#	  1801
UGFCD	   384#	  1579
ULAB	  1448#	  1457	  1525
UNCTRL	   136#	  2587	  2639	  2640
UNSETC	   257	   639#	  1735	  1758
UPDATE	    75#	   565	   676	   697	   702
USEBIT	   397#	   769
USICD	   385#	  2278
USOCD	   386#	  2293
USRNAM	   226#	   924
VAL	  1963#	  1963	  1987	  1989	  1991	  1996	  2000	  2006	  2008	  2012	  2032	  2034
VCTRL	   362#	  1895
W	   173	  1963#	  2020	  2047	  2050	  2054	  2112	  2115	  2151	  2386	  2395	  2617	  2667	  2725
WADR	   331#	   468	  1001	  2030
WB	   179	  2061#
WBLK	   252	  1087	  1091	  1195	  1587	  2181	  2261	  2285#	  2403
WBUF	   253#	   254	  2403
WCH	   332#	   468	  2012#
WCNT	  2039#	  2039	  2049
WCTRL	   363#	  1719	  1783
WDMAC	  1392#	  1404	  1411
WERR	   330#	  1001	  1252	  1422	  2036#	  2070
WFID	   156	   972#	  2851
WHAT	   829	   836	   841#
WHERE	  2485#	  2485	  2490	  2495#	  2495	  2500
WINIT	   329#	  1252	  2016#
WLAB	   335#	   456	  1001	  1252	  1422	  1998	  2014	  2030	  2033	  2070
WORD	    91#	  2017	  2381
WPB	   275#	  1085	  1562	  2165	  2333
WPF	   216#	   909
IOCS
SYMBOL CROSS REFERENCE

WPK	   333#	   468	  2003#
WSET	   330#	  1422	  2029#
WTEL	   330#	   456	  2032#
WWD	   332#	   468	  2000#
WX	   174	  1992	  1996#	  2081	  2093	  2098	  2606	  2721
WXLAB	   329#	   568	  1998#
XCTRL	   364#	  1848
XIT	  1725	  1731#	  1812	  1816	  1822	  1862
Y1	  1886	  1889#
YCHAR	   330#	   568	  1991#
YCTRL	   365#	  1884
YES	   264#	   804	   805	   921	  1768	  1778	  1783	  1839	  1845	  1848	  2029	  2281	  2627	  2680
YLAB	   335#	   456	   568	  1985	  1988
YTEL	   330#	   456	  1987#
ZBUF	  2373#	  2401	  2403	  2406	  2407	  2408
ZCTRL	   366#	  1763	  1764	  1842
ZREST	  2383	  2395#	  2406  S /m