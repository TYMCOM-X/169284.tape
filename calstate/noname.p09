BASE 0

!PROCEDURES
GLOBAL %NONAME
FIND %INITTTY,%HASH,%QUERY,%GETNUM,%GETOCT,%GETTOKEN,%LISTABLE
FIND %CHR.OUT,%OCTWD.OUT,%OCTOUT,%OUT,%NUMOUT,%SIXOUT,%MAKE.SIXBIT
FIND %CHOOSE,%DATOUT,%SHORT.OUT,%SPOUT
LOCAL %CHK.IO.ERR,%CHECK.CHG,%HEADING
LOCAL %DUL.LOOK,%DUL.OVERFLOW
LOCAL %OPEN.DUL,%OPEN.LUD,%MAKE.ROOM,%KNOW.ACCT
LOCAL %LUD.LOOK,%LUD.SEQ,%LIST.RECORD,%LUD.OVERFLOW
LOCAL %CHANGEIT,%INITNONAME

DEF SIZE.BLK AS 128

!ID'S
FIND TOKEN(0)
GLOBAL OPRLIC
LOCAL THISPPN,THISACCT,THISDIST,THISLIC, THISNAM(2)
GLOBAL NUMBER,NAME.HASH,LOC.HASH,P,GETCMD:,CH.OUT
GLOBAL USER(2),LISTFLG,ALTTYP
LOCAL SAVORG(SIZE.BLK),OLDBLK,STATUS
LOCAL CH.LUD,CH.DUL,IO.ADR,CMD,LIST,MODE,ZONE
LOCAL D.INDEX,D.BLK(SIZE.BLK)
LOCAL L.INDEX,L.BLK(SIZE.BLK)
LOCAL LUD.SIZE,TEMP,CH.NUM



!COMMANDS
DEF CMD.LIST AS 1
DEF CMD.CHANGE AS 2
DEF CMD.NAMES AS 3
DEF CMD.LUD AS 4
DEF CMD.ENDIT AS 5
DEF CMD.HELP AS 6
DEF CMD.INSTR AS 7


!FLAGS IN LISTFLG
DEF USER.LST AS 1
DEF ACCT.LST AS 2
DEF CHANGE AS 4
DEF DIST.LST AS 3
DEF ALL.SET AS -1

!CHANGES TO BE MADE
DEF CH.LIC AS 4
DEF CH.MSG AS 5
DEF CH.INIT AS 6
DEF CH.ZONE AS 7
DEF CH.DET AS 8
DEF CH.MODE AS 9
DEF CH.STR AS 10
DEF CH.CORE AS 11

!FLAGS IN STATUS
DEF NO.CHG AS 0
DEF OLD.OUT AS 1	!OLD BLK WAS WRITTEN OUT...WITHOUT THIS USER

! SIZE OF TABLES
DEF N.CMDS AS 7	!NUMBER OF PRIMARY COMMANDS
DEF N.LISTS AS 3 !NUMBER OF LIST COMMANDS
DEF N.MODES AS 4	!NUMBER OF MODES
DEF N.ZONES AS 17 	!NUMBER OF TIME ZONES

!TABLES
GLOBAL TABLE CMDS(1:N.CMDS)&
	['LIST','CHANGE','NAMES','LUD','QUIT','HELP','INSTRUCTIONS']
GLOBAL TABLE LISTS(1:N.LISTS)['USER','ACCOUNT','DISTRICT']
GLOBAL TABLE MODES(1:N.MODES)['PDP10','TYMEX','TYMEXH','SUDS']
GLOBAL TABLE ZONES(1:N.ZONES)[7(-1),'PACIFIC','MOUNTAIN','CENTRAL',&
	'EASTERN',5(-1),'PARIS']

!MACRO'S
DEF ACTSUP.BIT AS BYT(LUD(3),1,13)
DEF BIG AS (LISTFLG = ACCT.LST OR LISTFLG = DIST.LST)
DEF LITTLE AS NOT(BIG)
DEF COLON AS CHR.OUT($:)
DEF CHECK.NO.MORE.IN(A) AS [IF TEMP_NCHV P=EOLIT OR TEMP=CARRET THEN A;&
	 PCHV P]
DEF CORE1.LUD AS BYT(LUD(3),7,0)
DEF CORE2.LUD AS BYT(LUD(3),7,18)
DEF LUD.TEMP(A) AS LUD(TEMP.INDEX+A)
DEF CR AS CHR.OUT(CARRET)
DEF DASH AS CHR.OUT($-)
DEF ENTER.NAME AS '$ENTER USER NAME: '
DEF FIXCP(A) AS (A-1)*SIZE.BLK	!COMPUTE CURSOR POS. FROM BLK. NO.
DEF LUD.READ AS [RB(CH.LUD,SIZE.BLK,L.BLK); L.INDEX_0]
DEF LUD.WRIT AS [KEEP.CP; WB(CH.LUD,SIZE.BLK,L.BLK)]
DEF DAYLIG.BIT AS BYT(LUD(3),1,33)
DEF DETACH.BIT AS BYT(LUD(3),1,15)
DEF DIST.BITS AS BYT(LUD(1),8,0)
DEF DISTOUT AS [SPOUT(DIST.BITS,6); NUMOUT(DIST.BITS)]
DEF DUL(A) AS D.BLK(D.INDEX+A)
DEF LUD(A) AS L.BLK(L.INDEX+A)
DEF DUL.READ AS [RB(CH.DUL,SIZE.BLK,D.BLK); D.INDEX_0]
DEF GETNAME(A) AS [CHECK.NO.MORE.IN(A);GETTOKEN(2);MAKE.SIXBIT(TOKEN,USER,12)]
DEF INIT.BIT AS BYT(LUD(2),1,8)
DEF INIT.LONG.LIST AS [HEADING; SETCP(CH.LUD,FIXCP(1)); LUD.SEQ]
DEF KEEP.CP AS [TEMP _ CP(CH.LUD); TEMP-_SIZE.BLK; SETCP(CH.LUD,TEMP)]
DEF LEGAL AS (OPRLIC # 0 OR (THISLIC = 1 AND SAMACCT) OR SAMUSR)
DEF MODE.BIT AS BYT(LUD(3),2,7)
DEF MOVE.DOWN AS [FOR TEMP _ 5 TO 7 LUD(TEMP+3) _ LUD(TEMP)]
DEF N.LUD.BLKS AS SIZE(CH.LUD)/SIZE.BLK
DEF NAMOUT AS SIXOUT(@DUL(1),12)
DEF NOT.VALID AS [MSG('$NOT A VALID USER.$');CLOSE.ALL;GO GETCMD]
DEF OUT.WHERE AS [MSG('$OUTPUT TO: '); GETTOKEN(0); &
	CH.OUT _ OPEN(TOKEN,SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)]
DEF OV.BLK AS HW(@LUD(0),1)
DEF PPN.OUT AS OCTWD.OUT(LUD(0))
DEF PROT.FAILURE AS [MSG('$NOT YOUR GLOBAL ACCOUNT$$');GO GETCMD]
DEF SAMACCT AS THISACCT = HW(@LUD(0),0)
DEF SAMUSR AS THISPPN = LUD(0)
DEF SIZE.INC AS SIZE.LUD.ENT _ SIZE.LUD.ENT + 3
DEF SIZE.DEC AS SIZE.LUD.ENT _ SIZE.LUD.ENT - 3
DEF SIZE.LUD.ENT AS BYT(LUD(2),7,0)
DEF SP AS CHR.OUT(SPACE)
DEF SPACE AS $ 
DEF SUPMSG.BIT AS BYT(LUD(2),1,34)
DEF TIM.OUT.BIT AS BYT(LUD(3),1,16)
DEF TYM.BIT AS BYT(LUD(3),1,14)
DEF TYPSPACE(A) AS [REPEAT A SP]
DEF USER.MISSING AS [PPN.OUT; OUT(' MISSING FROM DUL.$'); RETURN]
DEF VERSION AS 9
DEF WHAT AS [MSG('?$'); GO GETCMD]
DEF ZONE.BIT AS BYT(LUD(3),5,28)


!LABELS
LOCAL LUD.ERR:,CHK.ERR:
%NONAME
	!MAINLINE
LOCAL ENDLUD:
START: IOCS(2); INITNONAME
\\->START
GETCMD: STATUS _ NO.CHG; IO.ADR _ 0; CLOSE.ALL
	 CH.OUT _ OPEN('TEL',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
	CR; PUT($:); P _ GETLINE(TEL); GETTOKEN(0)
	IF CMD _ CHOOSE(N.CMDS,CMDS) = 0 THEN WHAT
	OPEN.LUD; OPEN.DUL

DO CMD OF 1:N.CMDS

CMD.LIST: CHECK.NO.MORE.IN([LISTABLE(N.LISTS,LISTS); COLON])
    GETTOKEN(0)
    WHILE LIST _ CHOOSE(N.LISTS,LISTS) = 0 THEN[CR;LISTABLE(N.LISTS,LISTS); COLON;&
	GETTOKEN(0)]
	IO.ADR _ ENDLUD
	DO LIST OF 1:N.LISTS

	USER.LST:  LISTFLG _ USER.LST; GETNAME(MSG(ENTER.NAME))
	   IF LUD.LOOK(USER) = 0 THEN NOT.VALID
	   IF LEGAL THEN LIST.RECORD(ALL.SET) ELSE PROT.FAILURE

	ACCT.LST: LISTFLG _ ACCT.LST
	    IF OPRLIC # 0 THEN DO
		IF KNOW.ACCT=1 THEN [CHECK.NO.MORE.IN(MSG('$ACCOUNT: '));&
			GETOCT]
	    END  ELSE NUMBER _ THISACCT
	   INIT.LONG.LIST
	      LOOP DO
		IF LEGAL AND NUMBER =HW(@LUD(0),0) THEN LIST.RECORD(ALL.SET)
		LUD.SEQ
	   END

	DIST.LST: LISTFLG _ DIST.LST
	   IF OPRLIC # 0 THEN [CHECK.NO.MORE.IN(MSG('$DISTRICT: '));&
		GETNUM] ELSE NUMBER _ THISDIST
	   INIT.LONG.LIST
	   LOOP DO
		IF LEGAL AND NUMBER=DIST.BITS THEN LIST.RECORD(ALL.SET)
		LUD.SEQ
	   END
	END

CMD.CHANGE: GETNAME(MSG(ENTER.NAME))
	IF LUD.LOOK(USER) = 0 THEN NOT.VALID
	IF NOT(LEGAL) THEN PROT.FAILURE
	LISTFLG _ CHANGE; LIST.RECORD(ALL.SET)
LOOP DO
	STATUS _ NO.CHG
	MOVE SIZE.BLK FROM @LBLK(0) TO @SAVORG(0)	!SAVE OLD ENTRY
	MSG('$CHANGE WHICH ITEM - TYPE NUMBER:  ')
	CH.NUM _ GETNUM; CR
	IF CHANGEIT(CH.NUM) = 1 THEN DO
	  IF CHECK.CHG(CH.NUM)=1 THEN [LUD.WRIT;MSG('$CHANGE COMPLETED.$')]
	  [IF QUERY('ANOTHER') = 0 THEN GO ENDLUD ELSE &
	  [CLOSE.ALL; OPEN.LUD; OPEN.DUL; LUD.LOOK(USER)]]
	END ELSE MSG('ILLEGAL NUMBER.$')
END

CMD.NAMES: IO.ADR _ ENDLUD; OUT.WHERE
   IF THISLIC # 0 THEN DO
	SETCP(CH.LUD,FIXCP(1)); LUD.SEQ
	LOOP DO
	   IF SAMACCT THEN DO
		IF DUL.LOOK(LUD(0)) = 0 THEN USER.MISSING ELSE &
		   [NAMOUT; CR]
	   END
	   LUD.SEQ
	END
   END ELSE [SIXOUT(THISNAM,12); CR]

CMD.LUD: IF OPRLIC = 0 THEN [MSG('YOU MUST HAVE OPER LICENSE TO ');&
	MSG('USE THIS COMMAND.'); GO GETCMD]
IO.ADR _ ENDLUD
CH.OUT _ OPEN('LUDLST',SEQUEN+OUTPUT+CHARACTER,CHK.ERR,2)
SETCP(CH.LUD,FIXCP(1)); LUD.SEQ
LOOP DO
   IF DUL.LOOK(LUD(0)) # 0 THEN DO
	NAMOUT
	DISTOUT; SP
	NUMOUT(BYT(LUD(3),1,14))
	CR
   END
   LUD.SEQ
END

CMD.ENDIT: CLOSE.ALL; MSG('$E.O.J.$'); EXIT

CMD.HELP: MSG('LEGAL COMMANDS ARE:$')
   LISTABLE(N.CMDS,CMDS); MSG('.$')

CMD.INSTR: MSG('$$$GENERAL INFORMATION$$')
MSG('	EACH TYMSHARE COMPUTER SYSTEM HAS A LOCAL USER DIRECTORY')
MSG('$CALLED THE LUD.  THIS USER DIRECTORY IS USED BY THE MONITOR')
MSG('$TO KEEP TRACK OF USERS ON THAT SYSTEM.')
MSG('$$	A USER MAY BE PROMPTED OR MAY TYPE AN ENTIRE COMMAND')
MSG('$WITH NO PROMPTING.  FOR EXAMPLE THE USER MAY TYPE:')
MSG('$		LIST USER ABCD')
MSG('$OR HE MAY TYPE 1 WORD AT A TIME AND THE PROGRAM WILL ASK FOR THE')
MSG('$NEXT.')
MSG('$$	NORMALLY THE PROGRAM WILL REPEAT A QUESTION IF AN INVALID')
MSG('$REPLY IS GIVEN.  AS IT IS POSSIBLE THE CALLER MAY BE FACED BY')
MSG('$A QUESTION HE DOES NOT KNOW THE ANSWER TO, HE CAN FORCE THE')
MSG('$PROGRAM BACK TO THE COMMAND DISPATCHER BY ENTERING A QUESTION')
MSG('$MARK AS A REPLY TO ANY YES OR NO QUESTION OR WHENEVER THE')
MSG('$PROGRAM IS REQUESTING A USER NAME.')
MSG('$$$HELP$$')
MSG('	THIS COMMAND OUTPUTS ALL VALID COMMANDS OF THE PROGRAM')
MSG('$TO THE TELETYPE.')
MSG('$$$INSTRUCTIONS$$')
MSG('	THIS COMMAND PROVIDES DETAILED INSTRUCTIONS FOR ALL COMMANDS.')
MSG('$$$LIST USER$$	THIS COMMAND IS USED TO OBTAIN INFORMATION')
MSG('$ABOUT A SPECIFIED USER.$A SAMPLE DIALOGUE:$$')
MSG(':LIST USER$$ENTER USER NAME: JONES')
MSG('$$1. USER NAME: JONES$2. DISTRICT: 63')
MSG('$3. GLOBAL ACCOUNT: 12345$UNIVERSAL USER NO.: 65432')
MSG('$4. LICENSE: ACT.SUP.$5. SUPRESS TYMSHARE MESSAGE AT LOGIN.')
MSG('$6. NO INIT FILE.$7. TIME ZONE NOT SET.')
MSG('$8. DETACH ON DISCONNECT.$9. TYMEX MODE.')
MSG('$10. STRUCTURE: DSKB$QUOTA IN: 10000$QUOTA OUT: 10000')
MSG('$11. AMOUNT OF CORE: SYSTEM DEFAULT')
MSG('$$$LIST ACCOUNT$	THIS COMMAND WILL MAKE A LISTING OF ALL ENTRIES')
MSG('$IN A GLOBAL ACCOUNT, EITHER TO THE TELETYPE OR A FILE.')
MSG('$A SAMPLE DIALOGUE:')
MSG('$$:LIST ACCOUNT$$OUTPUT TO: TEL')
MSG('$$7-22-72  14:32$$GLOBAL ACCOUNT: 1234')
MSG('$$USER           DIST   UUN      LICENSE         MSG INIT FILE')
MSG('$                   ZONE     DISC   MODE   STR    Q-IN   Q-OUT    CORE')
MSG('$$JONES             3   234567        ACT.SUP.   SUP')
MSG('$JONES            NOT SET    LOG    TYMEX  DSKB   10000   10000    DEF')
MSG('$SMITHY            5   112234                   TYP')
MSG('$SMITHY           PACIF-D    DET-T    PDP10  DSKB   30000   30000    DEF')
MSG('$JOHNSON           3   445675                   TYP (USERNAME    )FILE')
MSG('$JOHNSON          CENTR-S    DET    GE     DSKB   50000   50000     60')
MSG('$$SOME EXPLANATION:')
MSG('$LICENSE - ACT.SUP. = ACCOUNT SUPERVISOR')
MSG('$          TYM. = TYMSHARE')
MSG('$MSG - WHAT IS DONE WITH TYMSHARE MESSAGE AT LOGIN.')
MSG('$	SUP=SUPRESS MESSAGE$	TYP=TYPE MESSAGE')
MSG('$ZONE - TIME ZONE$	D=DAYLIGHT SAVINGS$	S=STANDARD')
MSG('$DISC - WHAT IS DONE IF THE TELEPHONE LINE DISCONNECTS.')
MSG('$	LOG=LOGOUT JOB$	DET=DETACH JOB$ DET-T=DETACH, 15 MIN. TIME OUT SET')
MSG('$CORE - MAXIMUM AMOUNT OF USER CORE')
MSG('$	DEF = SYSTEM DEFAULT')
MSG('$MODE - THE MODE THE USER RUNS UNDER$$$LIST DISTRICT')
MSG('$	THIS COMMAND WILL MAKE A LISTING OF ALL ENTRIES IN A GLOBAL')
MSG('$ACCOUNT IN A DISTRICT.')
MSG('$	THE OUTPUT IS SIMILAR TO THAT OF LIST ACCOUNT.')
MSG('$$$CHANGE USER$	THE COMMAND IS USED TO:')
MSG('$CHANGE WHAT IS DONE WITH THE TYMSHARE MESSAGE')
MSG('$AT LOGIN TIME, SET AN INIT FILE, CHANGE A USERS TIME ZONE,')
MSG('$CHANGE A USERS MODE, CHANGE WHAT IS DONE ON A DISCONNECT.')
MSG('$A SAMPLE DIALOGUE:')
MSG('$$:CHANGE JONES$$USER NAME: JONES')
MSG('$5. SUPRESS TYMSHARE MESSAGE AT LOGIN.')
MSG('$6. NO INIT FILE.$7. TIME ZONE NOT SET.')
MSG('$8. DETACH ON DISCONNECT.$9. MODE: PDP10')
MSG('$$CHANGE WHICH ITEM - TYPE NUMBER: 5')
MSG('$$SUPRESS TYMSHARE MESSAGE AT LOGIN? NO')
MSG('$$5. DO NOT SUPRESS TYMSHARE MESSAGE AT LOGIN.')
MSG('$$OKAY? YES$CHANGE COMPLETED.$ANOTHER? NO')
MSG('$$$NAMES$$')
MSG('$IF ACCOUNT SUPERVISOR LICENSE IS SET, THIS COMMAND WILL LIST')
MSG('$ALL USER NAMES (NAMES ONLY) IN YOUR ACCOUNT TO A FILE.  OTHERWISE')
MSG('$IT WILL JUST LIST YOUR NAME.')
MSG('$$$QUIT$$	THIS COMMAND IS USED TO EXIT ')
MSG('$FROM THE PROGRAM.  ALTMODES MAY BE USED TO RETURN TO COMMAND MODE.$$')

END
ENDLUD:  LISTFLG _ 0;  GO GETCMD

ALTTYP: IF STATUS = NO.CHG THEN [CLOSE.ALL; GO GETCMD]
	MOVE SIZE.BLK FROM @SAVORG(0) TO @LBLK(0)
	SETCP(CH.LUD,FIXCP(OLDBLK)); WB(CH.LUD,SIZE.BLK,L.BLK)
	CLOSE.ALL; GO GETCMD




%LUD.SEQ
	!READ NEXT SEQUENTIAL LUD ENTRY
LOOP DO
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)<0 THEN LUD.OVERFLOW
	WHILE LUD(0)=0 THEN LUD.READ
	IF LUD(4) # 0 THEN RETURN
END
END LUD.SEQ


%LUD.LOOK(ADR)
	!LOOK UP NAME IN ADR,ADR+1 IN LUD
HASH(^ADR,^(ADR+1))
OLDBLK _ LOC.HASH
SETCP(CH.LUD,FIXCP(LOC.HASH)); LUD.READ 
WHILE NAME.HASH # LUD(4) THEN DO	
	L.INDEX+_SIZE.LUD.ENT
	IF LUD(0)=0 THEN RETURN 0
	IF LUD(0)<0 THEN LUD.OVERFLOW
	END
RETURN 1
END LUD.LOOK


%DUL.LOOK(PPN)
	!LOOK UP PPN IN DUL
SETCP(CH.DUL,FIXCP((PPN MOD 101)+1)); DUL.READ
WHILE DUL(0)#PPN THEN DO
	D.INDEX+_3
	IF DUL(0)=0 THEN RETURN 0
	IF DUL(0)<0 THEN DUL.OVERFLOW
	END
RETURN 1
END DUL.LOOK


%CHK.IO.ERR
	!TAKE CARE OF ALL I/O ERRORS FROM IOCS...
CHK.ERR: IF ERRNUM=EOFERR AND IO.ADR # 0 THEN GO ^IO.ADR
 MSG('ERROR ON ');WFID(FIDP);MSG('...');CR
  DO ERRNUM OF TMFERR:CORERR
FNDERR: MSG('BAD FILE MODE OR TYPE')
IFDERR: MSG('ILLEGAL FILE IDENTIFIER')
FNFERR: MSG('FILE NOT FOUND')
IUSERR: MSG('INVALID USER NAME')
PRTERR: MSG('PROTECTION FAILURE')
EOFERR: MSG('END OF FILE')
 END
MSG('.$ERROR ');NUMOUT(ERRNUM);EXIT
END CHK.IO.ERR


%LUD.OVERFLOW
	!READ LUD OVERFLOW BLOCK
SETCP(CH.LUD,OV.BLK*SIZE.BLK); OLDBLK _ OV.BLK
LUD.READ
RETURN
END LUD.OVERFLOW


%DUL.OVERFLOW
	!READ DUL OVERFLOW BLOCK
SETCP(CH.DUL,HW(DUL(0),1)*SIZE.BLK)
DUL.READ
RETURN
END DUL.OVERFLOW


%INITNONAME
	!INIT PROGRAM
FIND %SETOPR
INITTTY(GETCMD)
CMD _ 0
MSG('$USER VALIDATION PROGRAM - VERSION '); NUMOUT(VERSION);MSG('$$$')
MOVE 72/CHARS.PER.WORD FROM ALL 0 TO TOKEN
THISPPN _ EXU(OCT 47,OCT 1,OCT 24); OPEN.DUL
THISACCT _ HW(@THISPPN,0)
IF DUL.LOOK(THISPPN) = 0 THEN [OCTWD.OUT(THISPPN); MSG(' NOT IN DUL');&
	EXIT]
THISNAM(0) _ DUL(1); THISNAM(1) _ DUL(2)
OPEN.LUD; LUD.SIZE _ N.LUD.BLKS
IF LUD.LOOK(@DUL(1)) = 0 THEN [SIXOUT(D.BLK+D.INDEX+1,12); MSG(' NOT IN LUD')&
	;EXIT]
THISDIST _ DIST.BITS
THISLIC _ ACTSUP.BIT
ALTLOC _ ALTTYP; OFFALT
SETOPR
 RETURN
END INITNONAME



%LIST.RECORD(LISTNUM)
	!LIST RECORD POINTED TO BY L.INDEX...LIST ONLY
	!ITEMS THAT CAN BE CHANGED IF USER WANTS TO CHANGE...LIST ONLY
	!SELECTIVE ITEMS IF ALL DIST OR ALL ACCT. REQUESTED
LOCAL TEMP.INDEX,FLG,I
IF LISTNUM=ALL.SET THEN [LISTNUM_1; FLG_1] ELSE FLG _ 0
TEMP.INDEX _ 0
IF DUL.LOOK(LUD(0)) = 0 THEN USER.MISSING
LOOP DO

	DO LISTNUM OF 1:11
1: IF LITTLE THEN DO
	CR
	IF LISTFLG#CHANGE THEN MSG('1. ')
	MSG('USER NAME: ')
END
NAMOUT

2: IF LISTFLG#CHANGE THEN DO
	IF LITTLE THEN MSG('$2. DISTRICT: ')
	IF BIG AND ((OPRLIC#0 AND LISTFLG=ACCT.LST) OR OPRLIC=0) THEN DO
			DISTOUT
			TYPSPACE(3)
	END ELSE IF LITTLE THEN DISTOUT
   END

3: IF LISTFLG#CHANGE THEN DO
	IF LITTLE THEN DO
	   MSG('$3. GLOBAL ACCOUNT: '); OCTOUT(HW(@LUD(0),0))
	   MSG('$UNIVERSAL USER NO.: '); OCTOUT(HW(@LUD(0),1))
	END ELSE DO
	   IF OPRLIC # 0 THEN DO
		IF LISTFLG = DISTLST THEN [OCTOUT(HW(@LUD(0),0));SP]
	   END
	   OCTOUT(HW(@LUD(0),1)); TYPSPACE(3)
	END
	 TYPSPACE(3)
END

4: IF LISTFLG # CHANGE OR OPRLIC # 0 THEN DO
 IF LITTLE THEN MSG('$4. LICENSE: ')
	IF TYM.BIT = 1 THEN OUT('TYM. ') ELSE OUT('     ')
	IF ACTSUP.BIT = 1 THEN OUT('ACT.SUP.') ELSE OUT('        ')
	IF BIG THEN TYPSPACE(3)
	END

5: IF LITTLE THEN DO
	MSG('$5. '); IF SUPMSG.BIT = 0 THEN MSG('DO NOT ')
	MSG('SUPRESS TYMSHARE MESSAGE AT LOGIN.')
END ELSE DO
	IF SUPMSG.BIT=0 THEN OUT('TYP') ELSE OUT('SUP')
	SP
	END

6: IF LITTLE THEN MSG('$6. ')
	IF INIT.BIT = 1 THEN DO
		IF LITTLE THEN MSG('INIT FILE: ')
		TEMP.INDEX_3
		IF LUD(6)#0 OR LUD(7)#0 THEN [CHR.OUT($();&
			 SIXOUT(@LUD(6),12); CHR.OUT($))]
		 SIXOUT(@LUD(5),6)
	END ELSE IF LITTLE THEN MSG('NO INIT FILE.')
   IF BIG THEN [CR; NAMOUT; TYPSPACE(5)]

7: IF LITTLE THEN DO
	MSG('$7. ')
	IF ZONE.BIT#0 THEN [MSG(ZONES(ZONE.BIT)); MSG(' TIME ZONE.')]&
		ELSE MSG('TIME ZONE NOT SET.')

	END  ELSE DO
		IF ZONES(ZONE.BIT)=-1 OR ZONE.BIT=0  THEN [OUT('NOT SET'); TYPSPACE(4); GO STRTAGN ]
		TEMP_CHPT(ZONES(ZONE.BIT),-1)
		SHORT.OUT(TEMP,5)
	END
	IF BIG THEN DASH
	IF DAYLIG.BIT = 1 THEN DO
		IF LITTLE THEN MSG('$SUBJECT TO DAYLIGHT SAVINGS.')
		IF BIG THEN CHR.OUT($D)
	END ELSE IF BIG THEN CHR.OUT($S)
	IF BIG THEN TYPSPACE(4)

8: IF LITTLE THEN DO
	MSG('$8. ')
	IF DETACH.BIT = 1 THEN MSG('DETACH') ELSE MSG('LOGOUT')
	MSG(' ON DISCONNECT.')
	IF TIM.OUT.BIT = 1 THEN MSG(' - TIME OUT SET')
END ELSE DO
	IF DETACH.BIT = 1 THEN OUT('DET') ELSE OUT('LOG')
	IF TIM.OUT.BIT = 1 THEN OUT('-T  ') ELSE TYPSPACE(4)
END

9: IF LITTLE THEN [MSG('$9. MODE: '); MSG(MODES(MODE.BIT+1))] ELSE &
	[TEMP_CHPT(MODES(MODE.BIT+1),-1); SHORT.OUT(TEMP,6); TYPSPACE(1)]

10: IF LISTFLG # CHANGE OR OPRLIC # 0 THEN DO
	IF LITTLE THEN MSG('$10. STRUCTURE: ')
	SIXOUT(@LUD.TEMP(5),4);SP
	IF LITTLE THEN MSG('$QUOTA IN: '); SPOUT(LUD.TEMP(6),6)
	 NUMOUT(LUD.TEMP(6));SP
	IF LITTLE THEN MSG('$QUOTA OUT: '); SPOUT(LUD.TEMP(7),6)

	NUMOUT(LUD.TEMP(7))
	END
	IF BIG THEN TYPSPACE(4)

11: IF LISTFLG # CHANGE OR OPRLIC#0 THEN DO
 IF LITTLE THEN MSG('$11. AMOUNT OF CORE: ')
	IF TEMP _ CORE1.LUD = 0 THEN DO
	    IF LITTLE THEN MSG('SYSTEM DEFAULT') ELSE OUT('DEF')
	END ELSE DO
		TEMP _ (TEMP+1) * 2
		IF BIG THEN SPOUT(TEMP,3)
		NUMOUT(TEMP)
	END
    END
END
STRTAGN: IF FLG = 0 THEN [CR; RETURN] ELSE [IF INC LISTNUM = 12 THEN [CR; RETURN]]
END
END LIST.RECORD



%CHANGEIT(WHICHONE)
	!CHANGE ITEM "WHICHONE" IN LUD
LOCAL TMP1,SAVNAM(2)
IF WHICHONE < CH.LIC OR WHICHONE > CH.CORE THEN RETURN 0
	DO WHICHONE OF CH.LIC:CH.CORE

CH.LIC:	IF OPRLIC = 0 THEN RETURN 0
	ACTSUP.BIT _ QUERY('ACCOUNT SUPERVISOR')
	TYM.BIT _ QUERY('TYMSHARE')

CH.MSG: SUPMSG.BIT _ QUERY('SUPRESS TYMSHARE MESSAGE AT LOGIN')

CH.INIT: IF QUERY('DO YOU WANT TO SET AN INIT FILE') = 1 THEN DO
    IF INIT.BIT # 1 THEN [INIT.BIT _ 1;MAKE.ROOM;MOVE.DOWN;SIZE.INC]
	MOVE 2 FROM USER TO SAVNAM
	   GETNAME(MSG('USER FILE BELONGS TO: ')); MOVE 2 FROM USER TO @LUD(6)
	MOVE 2 FROM SAVNAM TO USER; MSG('FILE NAME: ')
	    GETTOKEN(0); MAKE.SIXBIT(TOKEN,@LUD(5),6)
	END ELSE [IF INIT.BIT=1 THEN  [INIT.BIT _ 0;SIZE.DEC;&
		MOVE (SIZE.BLK-(L.INDEX+SIZE.LUD.ENT)) FROM @LUD(8) TO @LUD(5);&
	MOVE 3 FROM ALL 0 TO L.BLK(126)]]

CH.ZONE:  LOOP DO
	MSG('ENTER TIME ZONE: '); GETTOKEN(0)
	IF ZONE_CHOOSE(N.ZONES,ZONES)#0 THEN [ZONE.BIT_ZONE;REPEAT 0]&
	ELSE [MSG('$VALID TIME ZONES ARE '); LISTABLE(N.ZONES,ZONES); CR;CR]
END
	DAYLIG.BIT _ QUERY('$SUBJECT TO DAYLIGHT SAVING')

CH.DET: DETACH.BIT _ QUERY('DETACH ON DISCONNECT')
	TIM.OUT.BIT _ QUERY('SET 15 MIN. TIME OUT')

CH.MODE: LOOP DO
	MSG('MODE: '); GETTOKEN(0)
	IF MODE_CHOOSE(N.MODES,MODES)#0 THEN [MODE.BIT_MODE-1; RETURN 1]
	MSG('$VALID MODES ARE '); LISTABLE(N.MODES,MODES); CR;CR
END

CH.STR:	IF OPRLIC = 0 THEN RETURN 0
	MSG('QUOTA IN: '); LUD(6) _ GETNUM
	MSG('QUOTA OUT: '); LUD(7) _ GETNUM

CH.CORE: IF OPRLIC = 0 THEN RETURN 0
	MSG('$ENTER AMOUNT OF CORE: ')
	IF GETNUM > 256 THEN NUMBER _ 256
	TMP1 _ NUMBER/2
	IF TMP1 * 2 # NUMBER THEN DO
		NUMBER+_1
		MSG('$AMOUNT OF CORE MUST BE EVEN.')
	END
	IF NUMBER # 0 THEN NUMBER _ (NUMBER/2)-1
	CORE1.LUD _ NUMBER
	CORE2.LUD _ NUMBER
END
RETURN 1
END CHANGEIT



%MAKE.ROOM
	!MAKE ROOM FOR AN ADDITIONAL 3 WORD IN ENTRY...CREATE OVERFLOW
	!BLOCK IF NECESSARY
LOCAL TMP,I,SAVENT(20)
TMP _ SIZE.LU
MOVE TMP FROM @LUD(0) TO SAVENT
MOVE SIZE.BLK-L.INDEX-TMP FROM @LUD(TMP) TO @LUD(0)
WHILE LUD(0)#0 THEN L.INDEX+_SIZE.LUD.ENT
MOVE TMP FROM SAVENT TO @LUD(0)
IF L.INDEX+SIZE.LUD.ENT+3<SIZE.BLK THEN RETURN
HW(@LUD(0),0) _ -1; OV.BLK _ LUD.SIZE+ _ 1
STATUS _ OLD.OUT; LUD.WRIT; SETCP(CH.LUD,(LUD.SIZE+1)*SIZE.BLK)
L.INDEX _ 0
MOVE SIZE.BLK FROM ALL 0 TO LBLK
MOVE TMP FROM SAVENT TO @LUD(0)
RETURN
END MAKE.ROOM


%HEADING
OUT.WHERE
DATOUT
IF OPRLIC # 0 THEN DO
	IF LISTFLG = ACCT.LST THEN [OUT('$GLOBAL ACCOUNT: ');&
					OCTOUT(NUMBER)]
	IF LISTFLG = DIST.LST THEN [OUT('$DISTRICT: ');NUMOUT(NUMBER)]
END ELSE [OUT('$GLOBAL ACCOUNT: '); OCTOUT(THISACCT)]
OUT('$$USER         ')
IF OPRLIC = 0 OR LISTFLG=ACCT.LST  THEN OUT('  DIST   ')
IF OPRLIC # 0 AND LISTFLG=DIST.LST  THEN OUT('GAN    ')
OUT('UUN      LICENSE         MSG INIT FILE$')
OUT('                   ZONE     DISC    MODE   STR    Q-IN   Q-OUT    CORE$$')
RETURN
END HEADING


%KNOW.ACCT
	!SEE IF USER KNOWS ACCT. NO...OR ASK HIM NAME
IF QUERY('$DO YOU KNOW THE GLOBAL ACCOUNT NUMBER') = 1 THEN RETURN 1
MSG('$ENTER A USERS NAME FROM THE ACCOUNT: '); GETTOKEN(2)
MAKE.SIXBIT(TOKEN,USER,12)
IF LUD.LOOK(USER) = 0 THEN NOT.VALID ELSE NUMBER _ HW(@LUD(0),0)
RETURN 0
END KNOW.ACCT


%CHECK.CHG(NUMBER)
	!ASK IF USER IS SURE HE WANTS TO MAKE CHANGE
	!1=YES, 0=NO
LIST.RECORD(NUMBER)
TEMP _ QUERY('$OKAY'); RETURN TEMP
END CHECK.CHG


%OPEN.LUD
	!LOOK FOR LUD.SYS ON DSK
		IF CMD # CMD.CHANGE THEN &
	CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+INPUT+WORD,LUD.ERR)&
	ELSE CH.LUD_OPEN('(SYS)LUD.SYS',DIRECT+UPDATE+WORD,LUD.ERR)
	RETURN
LUD.ERR:CHK.IO.ERR
END OPEN.LUD


%OPEN.DUL
	!LOOK FOR DUL.SITE ON DSK
LOCAL DUL.ERR:
	CH.DUL_OPEN('(SYS)DUL.SYS',DIRECT+INPUT+WORD,DUL.ERR)
	RETURN
DUL.ERR:CHK.IO.ERR
END OPEN.DUL



END NONAME
 Cr)K